' $Id$

const ctCVSID$ := "$Id$";


'Include Files

#include "../util/ChannelUtilities.s2s"
#include "../util/UsreyUtil.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "UsreyFixationPoint.s2s"
#include "Joystick.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ConteTask script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' Overall script control vars
var Pause% := 0;
var anyScreenUp% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		
var XChannel%;
var YChannel%;
var JoyChannel%;  'does this need to be initiated?  Does not in CuedAtten, may be done in the joystick init stuff
var StimChannel%;
var FrameChannel%;
var ReadyChannel%;
var FixationPointChannel%;
var AdvanceChannel%;
var UtilityChannel%;

'var ChangeChannel%;
'var FrameSlaveChannel%;
'var ReadySlaveChannel%;
'var StimSlaveChannel%;
'var DigitalLaserChannel%;
'var StimulatorChannel%;
var TimingChannel%;  'only for useTwo1401s, which is not implemented for this code



' XY window stuff and display stuff
var XYWindow%;			' 
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iFixptChannel%;
var iFixptWindowChannel%;
var iCueWindowChannel%;
var iDisplayWindowGabor1%;
var iDisplayWindowGabor2%;
var iDisplayWindowFlanker1%;
var iDisplayWindowFlanker2%;
var iDisplayWindowFlanker3%;
var iDisplayWindowFlanker4%;
var CueWindowX[36],CueWindowY[36];	' points for displaying cue window in xy view
var Gabor1WindowX[36],Gabor1WindowY[36];
var Gabor2WindowX[36],Gabor2WindowY[36];
var Flanker1WindowX[36],Flanker1WindowY[36];
var Flanker2WindowX[36],Flanker2WindowY[36];
var Flanker3WindowX[36],Flanker3WindowY[36];
var Flanker4WindowX[36],Flanker4WindowY[36];
var BackgroundColor$ := "gray";  'for right now, let's not even allow changing this...



'for display in experimenter view of locations of stimuli
'var mainX;  'the main grating patch is expected to be the one located over the receptive field
'var mainY;
var mainW;
var mainH;
'var dist1X;  'there are also four possible distracters, these are set in config
'var dist1Y;
'var dist1W;
'var dist1H;


' Utility vars
var DialogOK%;      
var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastFixPtDisplayUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tRise, tFall;
var tReward;
var tAdvance;
var tLastAdvance;
var tLastFrameTrigger;
var tITIStart;
var FrameTriggersFound%;
var leverReleased%;
var drawFlankers%;   'for use with DrawMonitorScreen, uses plural to not step on local variable in DrawMonitorScreen
var drawGabors%;     'for use with DrawMonitorScreen, uses plural to not step on local variable in DrawMonitorScreen
var fixDrawn%;       'Keep track of whether each particular element is drawn, just so we don't ask to put up/take down when unnecessary
var cueDrawn%;
var gaborDrawn%;
var flankerDrawn%;
var TextForSample$;  'ummmm, gotta go with the funky name here
var TextForTest$;  'and match it I guess
var SequencerPeriodMS;
var HBCycle% := 1;
var allowGoDuringCuePatch% := 0;  'We will only allow a go during a cue patch if it is training step 3 and the cue rect is up during the cue patch
var ctRewardDurSec;
ctRewardDurSec := (GetJuiceRewardMS%()+20)/1000;  'Set reward duration up top.  Nowhere in the script can change this.
                                                  'I am paranoid and I'm adding another 20 ms following the reward.


' Constants for states

const stateVSGWait%:=0;		               'Wait for VSG to send ready signal, only used at beginning of experiment
const stateEnforceLeverInOrigin%:=1;        'Make sure lever is in origin before starting a trial
const stateWaitForLever%:=2;               'GNG, so we'll call lever/joystick "lever" - Lever is the very first action 
const stateStartTrial%:=3;                 'Start trial, request fixpt
const stateWaitForFixPtOn%:=4;             'Wait for fixpt up
const stateWaitForAcquisition%:=5;         'Wait for acquisition of fixaiton point
const stateWaitStimOnsetDelay%:=6;         'Wait through any stimulus onset delay
const stateRequestStimulus%:=7;            'Request stimulus
const stateMonitorFrameChannel%:=8;        'Ensure each cue/sample/target frame appears
const stateResponseWindow%:=9;             'Response window, will be used for ctTrainingOptions% 2 and higher
const stateTrialCompleted%:=10;            'Trial is done
const stateReward%:=11;                    'Deliver reward
const stateRewardWait%:=12;                'Wait through reward delivery
const stateCheckAdvance%:=13;              'Make sure advance has happened (has been requested prior to reward delivery, if any)
const stateITI%:=14;                       'Wait through ITI
const stateAbort%:=15;                     'Wait through abort
const stateWaitForBlank%:=16;              'Wait through blank - this state should only be approached via WaitForBlankTo()


var iState% := stateVSGWait%;	'Always start in stateVSGWait%
var nextState%;                 'For WaitForBlankTo(), allows waiting for blank then moving to next state 
var stateBegin% := 1;           'Keep track of whether it is the first time through a state, for logging purposes


var nTrials%;
var nTrialsStarted%;
var nTrialsCompleted%;
var nTrialsAborted%;
var Hits%;
var Misses%;
var FAs%;
var CRs%;


const ctMaxTrials% := 5000;

var ctTrialOrder%[ctMaxTrials%];   'Will be shuffled indices, to randomize trial order 
var cueDotPct[ctMaxTrials%];       'Percentage of cue dots on each trial
'var samp1Ori[ctMaxTrials%];        'Sample orientation on each trial, etc.  These are not needed for the contrast version of the task
'var samp2Ori[ctMaxTrials%];        'Commented out to ensure all references are removed for successful compile
'var test1Ori[ctMaxTrials%];
'var test2Ori[ctMaxTrials%];
var validity%[ctMaxTrials%];       'Validity on each trial, -1 = no change, 0 = invalid, 1 = valid (what if cueDotPct is 50?)
var whichLocChange%[ctMaxTrials%]; '0 = no change, 1 = location 1 changes, 2 = location 2 changes
var flankerIsH%;                   '-2 = no flanker, vertical box; -1 = no flanker, horizontal box; 0 = flanker vertical; 1 = flanker horizontal; cue box shrinks if flankers are off

var samp1Contrast%[ctMaxTrials%];
var samp2Contrast%[ctMaxTrials%];
var test1Contrast%[ctMaxTrials%];
var test2Contrast%[ctMaxTrials%];
var samp1FlankerContrast%[ctMaxTrials%];
var samp2FlankerContrast%[ctMaxTrials%];
var test1FlankerContrast%[ctMaxTrials%];
var test2FlankerContrast%[ctMaxTrials%];
var samp1CueRectContrast%[ctMaxTrials%];
var samp2CueRectContrast%[ctMaxTrials%];
var test1CueRectContrast%[ctMaxTrials%];
var test2CueRectContrast%[ctMaxTrials%];
var ctTargetDuration[ctMaxTrials%];

var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
var pulseFound%;
var tempAnswer%;

' Wavemarks and continuous ports
var ctNWavemarks% := 0;
var ctWavemarkPorts%[64];
var ctNContinuous% := 0;
var ctContinuousPorts%[64];


' Dialog box variables
var ctAlwaysPressing% := 1; 'If set joystick ignored - subject presumed to be pressing joystick always. TESTING ONLY.
var ctAlwaysLooking% := 0;  'I don't think we'll actually ever want to set this to 1, but we can
var ctCheckLooking%;        'OK, so AlwaysLooking is going to override CheckLooking; CheckLooking will be set based on RequireFixation
var ctAdditionalWindowRadius;
var ctTrainingOptions%;
var ctRequireFixation%; 
var nTrialsPerDataPoint%;
var ctCountUncued%;    'per data point
var ctCountNoChange%;  'per data point 
var ctCountCued%;    'per data point
var ctFixationOn%;
var ctFixCrossWidthPixels := 1;   'Note that this is NOT an integer, due to the way that the dialog is created, would be too much trouble to convert to integer
var ctFixCrossWidthPixels%;  'So here's the integer version, we'll just convert directly
var ctPatchOnsetDelay;
var ctPatchToSampleDelay;
var ctSampleToTargetDelay;  'Target is the "orientation change" if any
var ctSampleDuration;
var ctTargetDurationGo;
var ctTargetDurationNoGo;
var ctITI;
var ctThisITI;  'Allows us to change ITI for miss/FA penalties (abort penalty done differently)
var ctFAPenalty;
var ctMissPenalty;
var ctDotRadiusDeg;
var ctDotColor1R%;     'I think it may not be easy to put vectors in the registry, so use scalars?
var ctDotColor1G%;
var ctDotColor1B%; 
var ctDotColor2R%;
var ctDotColor2G%;
var ctDotColor2B%;
var ctDotsPerPF%;      'using PF to abbreviate "patch frame"; a patch consists of N patch frames
var ctPatchRadiusDeg;
var ctRefreshPerPF%;   'How many monitor refreshes per frame
var ctPFsPerPatch%;
var ctResponseTime;
var ctGaborXLoc;   'This will be the location of the "primary" (typically: "receptive field") gabor
var ctGaborYLoc;
var ctGabor2XLoc;  'This will be the location of the counterpart gabor
var ctGabor2YLoc;
var ctGaborHDeg;
var ctGaborWDeg;
var ctGaborSF;
var ctGaborPhase;
var ctGaborOriTemp;  'this is only for display
var ctGaborDivisor;
var ctPanelIsHoriz%;
var ctPanelLinePixels%;
var ctStimValsFromConfig%;
'var ctOrientationMatches%;
var ctContrastMatches%;
var ctNDistractorOn%;
var ctNDistractorOff%;
var ctDotPctString$;
'var ctSampleOriString$;
'var ctOriChangeString$;
var ctSampleContString$;
var ctContChangeString$;
var ctPatchDur;            'this is calculated
var ctAbortPenalty;
var ctFixAcqTime;
var ctGaborCuedCont%;
var ctGaborUncuedCont%;
var ctFlankerCuedCont%;
var ctFlankerUncuedCont%;
var ctCueRectCuedCont%;
var ctCueRectUncuedCont%;
var ctShowCueRectDuringCue%;

'Variables that allow us to build the allowed tunable values from strings
var ctDotPct[100];  '100 possible values is way too many
var ctGaborOri[100];
var ctGaborOriChange[100];
var ctNDotPct%;
var ctNSampleOri%;
var ctNOriChange%;


var ctMaxTrialPerDataPoint% := 1000;
var ctResponseTimeText$ := "Response time (s)";
var ctHoldTimeText$ := "Add'l hold time (s)";
var ctPatchRadiusText$ := "Cue patch radius (deg)";
var ctFixRadiusText$ := "Fixation radius (deg)";

'Dialog Box Position Variables - will make things easier if we decide to rearrange
var ctDlgnTrialsPerDataPoint% := 1;
var ctDlgTrainingOptions% := 2;
var ctDlgCountUncued% := 3;    
var ctDlgCountNoChange% := 4;  
var ctDlgCountCued% := 5; 
var ctDlgRequireFixation% := 6; 
var ctDlgFixationOn% := 7;
var ctDlgAdditionalWindowRadius% := 8;
var ctDlgFixCrossWidthPixels% := 9; 
var ctDlgPatchOnsetDelay% := 10;
var ctDlgPatchToSampleDelay% := 11;
var ctDlgSampleToTargetDelay% := 12; 
var ctDlgSampleDuration% := 13; 
var ctDlgTargetDurationGo% := 14;
var ctDlgTargetDurationNoGo% := 15;
var ctDlgITI% := 16;
var ctDlgDotRadiusDeg% := 17;
var ctDlgDotColor1R% := 18; 
var ctDlgDotColor1G% := 19;
var ctDlgDotColor1B% := 20; 
var ctDlgDotColor2R% := 21;
var ctDlgDotColor2G% := 22;
var ctDlgDotColor2B% := 23;
var ctDlgDotsPerPF% := 24;   
var ctDlgPatchRadiusDeg% := 25;
var ctDlgRefreshPerPF% := 26; 
var ctDlgPFsPerPatch% := 27;
var ctDlgResponseTime% := 28;
var ctDlgGaborXLoc% := 29;
var ctDlgGaborYLoc% := 30;
var ctDlgGaborHDeg% := 31;
var ctDlgGaborWDeg% := 32;
var ctDlgGaborSF% := 33;
var ctDlgGaborPhase% := 34;
var ctDlgGaborDivisor% := 35;
var ctDlgPanelIsHoriz% := 36;
var ctDlgPanelLinePixels% := 37;
var ctDlgStimValsFromConfig% := 38;
var ctDlgAlwaysPressing% := 39;
'var ctDlgOrientationMatches% := 40;
var ctDlgContrastMatches% := 40;
var ctDlgNDistractorOn% := 41;
var ctDlgNDistractorOff% := 42;
var ctDlgDotPctString% := 43;
'var ctDlgSampleOriString% := 44;
'var ctDlgOriChangeString% := 45;
var ctDlgSampleContString% := 44;
var ctDlgContChangeString% := 45;
var ctDlgAbort% := 46;
var ctDlgFixAcqTime% := 47;
var ctDlgFAPenalty% := 48;
var ctDlgMissPenalty% := 49;
var ctDlgGaborCuedCont% := 50;
var ctDlgGaborUncuedCont% := 51;
var ctDlgFlankerCuedCont% := 52;
var ctDlgFlankerUncuedCont% := 53;
var ctDlgCueRectCuedCont% := 54;
var ctDlgCueRectUncuedCont% := 55;
var ctDlgCueRectWithCue% := 56;


var ctDlgTotalTrials%;  'This just holds a pointer to the total trials text so we can update the text value
var ctTotalTrialsText$;
'var ctGaborOriText$;
var ctGaborContText$;
var ctPatchDurText$;

'Dialog Box Text Variables - will make things easier if we decide to rearrange
'Value will be returned by DlgText when setting up the text box
'Won't create a text value if we're never going to turn off the dialog entry, don't need it.
var ctTxtCountUncued%;    
var ctTxtCountNoChange%;  
var ctTxtCountCued%; 
var ctTxtRequireFixation%; 
var ctTxtFixationOn%;
var ctTxtAdditionalWindowRadius%;
var ctTxtFixCrossWidthPixels%; 
var ctTxtPatchOnsetDelay%;
var ctTxtPatchToSampleDelay%;
var ctTxtSampleToTargetDelay%; 
var ctTxtSampleDuration%; 
var ctTxtTargetDurationGo%;
var ctTxtTargetDurationNoGo%; 
var ctTxtDotRadiusDeg%;
var ctTxtDotColor1%;  
var ctTxtDotColor2%;
var ctTxtDotsPerPF%;   
var ctTxtPatchRadiusDeg%;
var ctTxtRefreshPerPF%; 
var ctTxtPFsPerPatch%;
var ctTxtResponseTime%;
var ctTxtGaborXLoc%;
var ctTxtGaborYLoc%;
var ctTxtGaborHDeg%;
var ctTxtGaborWDeg%;
var ctTxtGaborSF%;
var ctTxtGaborPhase%;
'var ctTxtGaborOri%;
var ctTxtGaborCont%;
var ctTxtGaborDivisor%;
var ctTxtPanelLinePixels%;
var ctTxtOrientationMatches%;
var ctTxtNDistractorOn%;
var ctTxtNDistractorOff%;
var ctTxtDotPctString%;
'var ctTxtSampleOriString%;
'var ctTxtOriChangeString%;
var ctTxtSampleContString%;
var ctTxtContChangeString%;
var ctTxtPatchDur%;
var ctTxtAbort%;
var ctTxtFAPenalty%;
var ctTxtMissPenalty%;
var ctTxtFixAcqTime%;
var ctTxtGaborCuedCont%;
var ctTxtGaborUncuedCont%;
var ctTxtFlankerCuedCont%;
var ctTxtFlankerUncuedCont%;
var ctTxtCueRectCuedCont%;
var ctTxtCueRectUncuedCont%;


var screenXDeg := 12.5;  'Manually setting screen degrees - we might want to calculate this based on manual screen cm or have degrees/cm in main dialog, but for now...
var screenYDeg := 9.5;   'Note that these are only used for placement of the "monitor box" in the Spike2 Eye Position XY view.  TODO - get actual degree values from config.




'Done with variables

GetConteTaskParameters();  'We will just get these right off the bat, this supports the pre-dialog box
                           'that warns about AlwaysLooking - though this pre-dialog is currently disabled

' Check if always looking flag is set. If so, issue a warning.
' I'm thinking that this is kind of a pain in the butt, we can possibly just put it in the dialog box
' and forget it.  If we want it back as a warning up front, it's an easy uncomment.
'if AlwaysLooking% = 1 then
'    if Query("Always looking is SET. Unset?") = 1 then
'        AlwaysLooking% := 0;
'    endif
'endif

' Init logging
LogInit(1);

UseTwo1401s% := DoWeUseTwo1401s%();

if UseTwo1401s% = 1 then
    'Two 1401s disabled because the port carrying the "change" trigger from the VSG has been stolen from one
    'of the slave ports, we need to fix that (physically and code-wise) to allow Two 1401s to work.
    message("Using two 1401s has been disabled for the Conte Task!  Talk to Dan/Jeff!  Quitting!");
    halt;
endif

GetPortsAndNumWMsWFs%(ctNWavemarks%,ctNContinuous%,ctWavemarkPorts%[],ctContinuousPorts%[]);


'Run the main dialog
DialogOK% := ConteTaskDialog%();

if DialogOK% = 1 then
    LogInfo("Proceed with DAQ.");
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 25;
YChannel% := 26;
JoyChannel% := 27;

TimingChannel% := 38;
UtilityChannel% := 39;
ReadyChannel% := 40;
FrameChannel% := 41;
StimChannel% := 42;
AdvanceChannel% := 43;
FixationPointChannel% := 44;
'ReadySlaveChannel% := 45;
'StimulatorChannel% := 46;
'ChangeChannel% := 47;
'DigitalLaserChannel% := 48;  'is 32 on Acute tuning, but let's not shove it in the midst of other stuff


ExcludedChans%[0] := 25;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 44;  'FixationPointChannel% is highest non-electrode channel used by this function  




'If we are not linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the dual-1401 setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401/SLAVE 1401 (the second, non-dominant instance of Spike2) FIRST and on the 
'MICRO 1401/MASTER 1401 (the first,  dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run 
'the VSG program (Fixstim) which gives the sampling trigger and sets the experiment in motion.
if UseTwo1401s% = 0 then
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();
    
    tic := View(DataWindow%).BinSize(ReadyChannel%);
    
    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ConteTask script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'From here on out, it's just various necessary functions


proc GetConteTaskParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\ConteTask";
    
    ctAdditionalWindowRadius := GetFloatRegistryValue(key$, "AdditionalWindowRadius", ctAdditionalWindowRadius);
    ctTrainingOptions% := GetIntRegistryValue%(key$, "TrainingOptions", ctTrainingOptions%);
    ctRequireFixation% := GetIntRegistryValue%(key$, "RequireFixation", ctRequireFixation%);
    nTrialsPerDataPoint% := GetIntRegistryValue%(key$, "nTrialsPerDataPoint", nTrialsPerDataPoint%);
    ctCountUncued% := GetIntRegistryValue%(key$, "CountInvalid", ctCountUncued%);  'changed variable name, keeping old key value
    ctCountNoChange% := GetIntRegistryValue%(key$, "CountCatch", ctCountNoChange%);  'changed variable name, keeping old key value
    ctCountCued% := GetIntRegistryValue%(key$, "CountValid", ctCountCued%);  'changed variable name, keeping old key value
    ctFixationOn% := GetIntRegistryValue%(key$, "FixationOn", ctFixationOn%);
    ctFixCrossWidthPixels := GetFloatRegistryValue(key$, "FixCrossWidthPixels", ctFixCrossWidthPixels);
    ctPatchOnsetDelay := GetFloatRegistryValue(key$, "PatchOnsetDelay", ctPatchOnsetDelay);
    ctPatchToSampleDelay := GetFloatRegistryValue(key$, "PatchToSampleDelay", ctPatchToSampleDelay);
    ctSampleToTargetDelay := GetFloatRegistryValue(key$, "SampleToTargetDelay", ctSampleToTargetDelay);
    ctSampleDuration := GetFloatRegistryValue(key$, "SampleDuration", ctSampleDuration);
    ctTargetDurationGo := GetFloatRegistryValue(key$, "TargetDuration", ctTargetDurationGo);  'changed variable name, keeping old key value
    ctTargetDurationNoGo := GetFloatRegistryValue(key$, "TargetDurationNoGo", ctTargetDurationNoGo);
    ctITI := GetFloatRegistryValue(key$, "ITI", ctITI);
    ctFAPenalty := GetFloatRegistryValue(key$, "FAPenalty", ctFAPenalty);
    ctMissPenalty := GetFloatRegistryValue(key$, "MissPenalty", ctMissPenalty);
    ctDotRadiusDeg := GetFloatRegistryValue(key$, "DotRadiusDeg", ctDotRadiusDeg);
    ctDotColor1R% := GetIntRegistryValue%(key$, "DotColor1R", ctDotColor1R%);
    ctDotColor1G% := GetIntRegistryValue%(key$, "DotColor1G", ctDotColor1G%);
    ctDotColor1B% := GetIntRegistryValue%(key$, "DotColor1B", ctDotColor1B%);
    ctDotColor2R% := GetIntRegistryValue%(key$, "DotColor2R", ctDotColor2R%);
    ctDotColor2G% := GetIntRegistryValue%(key$, "DotColor2G", ctDotColor2G%);
    ctDotColor2B% := GetIntRegistryValue%(key$, "DotColor2B", ctDotColor2B%);
    ctDotsPerPF% := GetIntRegistryValue%(key$, "DotsPerPF", ctDotsPerPF%);
    ctPatchRadiusDeg := GetFloatRegistryValue(key$, "PatchRadiusDeg", ctPatchRadiusDeg);
    ctRefreshPerPF% := GetIntRegistryValue%(key$, "RefreshPerPF", ctRefreshPerPF%);
    ctPFsPerPatch% := GetIntRegistryValue%(key$, "PFsPerPatch", ctPFsPerPatch%);
    ctResponseTime := GetFloatRegistryValue(key$, "ResponseTime", ctResponseTime);
    ctGaborDivisor := GetFloatRegistryValue(key$, "GaborDivisor", ctGaborDivisor);
    ctPanelIsHoriz% := GetIntRegistryValue%(key$, "PanelIsHoriz", ctPanelIsHoriz%);
    ctPanelLinePixels% := GetIntRegistryValue%(key$, "PanelLinePixels", ctPanelLinePixels%);
    ctStimValsFromConfig% := GetIntRegistryValue%(key$, "StimValsFromConfig", ctStimValsFromConfig%);
    ctAlwaysPressing% := GetIntRegistryValue%(key$, "AlwaysPressing", ctAlwaysPressing%);
    'ctOrientationMatches% := GetIntRegistryValue%(key$, "OrientationMatches", ctOrientationMatches%);
    ctContrastMatches% := GetIntRegistryValue%(key$, "ContrastMatches", ctContrastMatches%);
    ctNDistractorOn% := GetIntRegistryValue%(key$, "NDistractorOn", ctNDistractorOn%);
    ctNDistractorOff% := GetIntRegistryValue%(key$, "NDistractorOff", ctNDistractorOff%);
    ctDotPctString$ := GetStringRegistryValue$(key$, "DotPctString", ctDotPctString$);
    'ctSampleOriString$ := GetStringRegistryValue$(key$, "SampleOriString", ctSampleOriString$);
    'ctOriChangeString$ := GetStringRegistryValue$(key$, "OriChangeString", ctOriChangeString$);
    ctSampleContString$ := GetStringRegistryValue$(key$, "SampleContString", ctSampleContString$);
    ctContChangeString$ := GetStringRegistryValue$(key$, "ContChangeString", ctContChangeString$);
    ctAbortPenalty := GetFloatRegistryValue(key$, "AbortPenalty", ctAbortPenalty);
    ctFixAcqTime := GetFloatRegistryValue(key$, "FixAcqTime", ctFixAcqTime);
    ctGaborCuedCont% := GetIntRegistryValue%(key$, "GaborVC", ctGaborCuedCont%);  'changed variable name, keeping old key value
    ctGaborUncuedCont% := GetIntRegistryValue%(key$, "GaborInvC", ctGaborUncuedCont%);  'changed variable name, keeping old key value
    ctFlankerCuedCont% := GetIntRegistryValue%(key$, "FlankerVC", ctFlankerCuedCont%);  'changed variable name, keeping old key value
    ctFlankerUncuedCont% := GetIntRegistryValue%(key$, "FlankerInvC", ctFlankerUncuedCont%);  'changed variable name, keeping old key value
    ctCueRectCuedCont% := GetIntRegistryValue%(key$, "CueRectVC", ctCueRectCuedCont%);  'changed variable name, keeping old key value
    ctCueRectUncuedCont% := GetIntRegistryValue%(key$, "CueRectInvC", ctCueRectUncuedCont%);  'changed variable name, keeping old key value
    ctShowCueRectDuringCue% := GetIntRegistryValue%(key$, "ShowCueRectDuringCue", ctShowCueRectDuringCue%);
    

    
end;

proc SaveConteTaskParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\ConteTask";
    
    SetFloatRegistryValue(key$, "AdditionalWindowRadius", ctAdditionalWindowRadius);
    SetIntRegistryValue(key$, "TrainingOptions", ctTrainingOptions%);
    SetIntRegistryValue(key$, "RequireFixation", ctRequireFixation%);
    SetIntRegistryValue(key$, "nTrialsPerDataPoint", nTrialsPerDataPoint%);
    SetIntRegistryValue(key$, "CountInvalid", ctCountUncued%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "CountCatch", ctCountNoChange%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "CountValid", ctCountCued%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "FixationOn", ctFixationOn%);
    SetFloatRegistryValue(key$, "FixCrossWidthPixels", ctFixCrossWidthPixels);
    SetFloatRegistryValue(key$, "PatchOnsetDelay", ctPatchOnsetDelay);
    SetFloatRegistryValue(key$, "PatchToSampleDelay", ctPatchToSampleDelay);
    SetFloatRegistryValue(key$, "SampleToTargetDelay", ctSampleToTargetDelay);
    SetFloatRegistryValue(key$, "SampleDuration", ctSampleDuration);
    SetFloatRegistryValue(key$, "TargetDuration", ctTargetDurationGo);  'changed variable name, keeping old key value
    SetFloatRegistryValue(key$, "TargetDurationNoGo", ctTargetDurationNoGo);
    SetFloatRegistryValue(key$, "ITI", ctITI);
    SetFloatRegistryValue(key$, "FAPenalty", ctFAPenalty);
    SetFloatRegistryValue(key$, "MissPenalty", ctMissPenalty);
    SetFloatRegistryValue(key$, "DotRadiusDeg", ctDotRadiusDeg);
    SetIntRegistryValue(key$, "DotColor1R", ctDotColor1R%);
    SetIntRegistryValue(key$, "DotColor1G", ctDotColor1G%);
    SetIntRegistryValue(key$, "DotColor1B", ctDotColor1B%);
    SetIntRegistryValue(key$, "DotColor2R", ctDotColor2R%);
    SetIntRegistryValue(key$, "DotColor2G", ctDotColor2G%);
    SetIntRegistryValue(key$, "DotColor2B", ctDotColor2B%);
    SetIntRegistryValue(key$, "DotsPerPF", ctDotsPerPF%);
    SetFloatRegistryValue(key$, "PatchRadiusDeg", ctPatchRadiusDeg);
    SetIntRegistryValue(key$, "RefreshPerPF", ctRefreshPerPF%);
    SetIntRegistryValue(key$, "PFsPerPatch", ctPFsPerPatch%);
    SetFloatRegistryValue(key$, "ResponseTime", ctResponseTime);
    SetFloatRegistryValue(key$, "GaborDivisor", ctGaborDivisor);
    SetIntRegistryValue(key$, "PanelIsHoriz", ctPanelIsHoriz%);
    SetIntRegistryValue(key$, "PanelLinePixels", ctPanelLinePixels%);
    SetIntRegistryValue(key$, "StimValsFromConfig", ctStimValsFromConfig%);
    SetIntRegistryValue(key$, "AlwaysPressing", ctAlwaysPressing%);
    'SetIntRegistryValue(key$, "OrientationMatches", ctOrientationMatches%);
    SetIntRegistryValue(key$, "ContrastMatches", ctContrastMatches%);
    SetIntRegistryValue(key$, "NDistractorOn", ctNDistractorOn%);
    SetIntRegistryValue(key$, "NDistractorOff", ctNDistractorOff%);
    SetStringRegistryValue(key$, "DotPctString", ctDotPctString$);
    'SetStringRegistryValue(key$, "SampleOriString", ctSampleOriString$);
    'SetStringRegistryValue(key$, "OriChangeString", ctOriChangeString$);
    SetStringRegistryValue(key$, "SampleContString", ctSampleContString$);
    SetStringRegistryValue(key$, "ContChangeString", ctContChangeString$);
    SetFloatRegistryValue(key$, "AbortPenalty", ctAbortPenalty);
    SetFloatRegistryValue(key$, "FixAcqTime", ctFixAcqTime);
    SetIntRegistryValue(key$, "GaborVC", ctGaborCuedCont%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "GaborInvC", ctGaborUncuedCont%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "FlankerVC", ctFlankerCuedCont%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "FlankerInvC", ctFlankerUncuedCont%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "CueRectVC", ctCueRectCuedCont%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "CueRectInvC", ctCueRectUncuedCont%);  'changed variable name, keeping old key value
    SetIntRegistryValue(key$, "ShowCueRectDuringCue", ctShowCueRectDuringCue%);
    
end;



func ConteTaskDialog%()
    var i%;
    const nTOpts% := 7;
    var trainingOptionsList$[nTOpts%];
    const nFOpts% := 3;  'was 4, but it seems we will never require a saccade response
    var fixationOptionsList$[nFOpts%];
    var gr$;  'to grab the grating parameters for parsing
    var iw, ih, tf, ctf;  'will hold "unused" grating parameters from the parse
    var cv$, pat$, ap$;   'etc.
    var con%;             'etc.
    var tempXY;  'for color randomization
    
    var nineFloats[9]; 
    var sevenFloats[7];    
    var sixPlusOneInts%[7];  'This was nicer when it was just the RGB variables, but alas!
    var sevenInts%[7];  'OK, fine, this isn't exactly the greatest organization!  The dialog has evolved so much!
    var threeStrings$[3];
    var fourFloats[4];
    var sixInts%[7];  'LOL sixInts%[] has 7 because we already have "sevenInts%[]"  Eep

    trainingOptionsList$[0] := "0 - Reward for lever";    '"Press Lever - Instant Reward - Release - Wait ITI"
    trainingOptionsList$[1] := "1 - Reward for hold & release lever";   '"Hold Lever - Release (when fixpt down) - Reward - Wait ITI"
    trainingOptionsList$[2] := "2 - Reward for hold lever through cue then release";    '"Hold Lever - Patch - Release (when fixpt down) - Reward - Wait ITI"
    trainingOptionsList$[3] := "3 - Present single empty cue rectangle";    '"Hold Lever - Patch - One Cue Box - Hold on Cued/Release on Uncued - Reward of correct - Wait ITI" ("catch" + "valid" trials)
    trainingOptionsList$[4] := "4 - Present single cue rectangle plus stimulus (Go = 0-->X)";    '"Hold Lever - Patch - One Cue Box + Gabor - Hold on Cued/Release on Uncued - Reward if correct - Wait ITI" ("catch" + "valid" trials)
    trainingOptionsList$[5] := "5 - Fade in opposite cue rectangle (Go = X-->X+dX)";    '"Hold Lever - Patch - One Cue Box + Gabor - Hold on Cued/Release on Uncued - Reward if correct - Wait ITI" ("catch" + "valid" trials)
    trainingOptionsList$[6] := "6 - Full task (add uncued trials)";    '"Hold Lever - Patch & Sample & Test - Release (early for any change, hold for no change) - Reward if correct - Wait ITI" ("catch" + "valid" + "invalid" trials)
    
    fixationOptionsList$[0] := "Fixation:  None - No Eye Channels"; 
    fixationOptionsList$[1] := "Fixation:  Display Eye Position Only"; 'will create eye channels but not enforce fixation
    fixationOptionsList$[2] := "Fixation:  Require Fixation"; 
    'fixationOptionsList$[3] := "Fixation:  Require Saccade Response";  'we won't use this!
    
    
    GetConteTaskParameters();
    
    'Calculate total trials for initial display 
    nTrials% := CalcNumTrials%(ctTrainingOptions%,nTrialsPerDataPoint%,ctCountCued%,ctCountUncued%,ctCountNoChange%,
                ctDotPctString$,ctSampleContString$,ctContChangeString$,ctNDistractorOn%,ctNDistractorOff%);
    ctTotalTrialsText$ := "Total number of trials: " + Str$(nTrials%);
    
    
    'Get values for gabor properties from the main stimulus
    gr$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(gr$, ctGaborXLoc, ctGaborYLoc, ctGaborWDeg, ctGaborHDeg, iw, ih, con%, ctGaborSF, tf, ctGaborOriTemp, ctGaborPhase, cv$, pat$, ap$, ctf);
    
    'Make gabor orientation string, no longer allowing edit in the stimulus options portion of the dialog
    'ctGaborOriText$ := "RF Orientation (deg) = " + Str$(ctGaborOriTemp);
    
    'Make gabor contrast string, no longer allowing edit in the stimulus options portion of the dialog
    ctGaborContText$ := "RF Contrast = " + Str$(con%);
    
    'Convert to fixation-based coordinates (almost certainly fixation will be at 0,0, but we have to allow for other locations)
    'This conversion of the "primary" gabor location is only for the dialog box
    ctGaborXLoc := ctGaborXLoc - FixationX;  
    ctGaborYLoc := ctGaborYLoc - FixationY;
    
    
    'Calculate initial duration of cue patch, in text
    ctPatchDurText$ := "Patch duration (s) = " + Str$(ctRefreshPerPF%*ctPFsPerPatch%/dataScreenHz,4,-3);  'in seconds, three decimal places
    
    
    'Pack sixFloats[], sixPlusOneInts%[], sevenFloats[], sevenInts%[], threeStrings$[], sixInts%[]
    nineFloats[0] := ctFixCrossWidthPixels;
    nineFloats[1] := ctPatchOnsetDelay;
    nineFloats[2] := ctPatchToSampleDelay;
    nineFloats[3] := ctSampleToTargetDelay;
    nineFloats[4] := ctSampleDuration;
    nineFloats[5] := ctTargetDurationGo;
    nineFloats[6] := ctTargetDurationNoGo;
    nineFloats[7] := ctITI;
    nineFloats[8] := ctDotRadiusDeg;
    
    sixPlusOneInts%[0] := ctDotColor1R%;
    sixPlusOneInts%[1] := ctDotColor1G%;
    sixPlusOneInts%[2] := ctDotColor1B%;
    sixPlusOneInts%[3] := ctDotColor2R%;
    sixPlusOneInts%[4] := ctDotColor2G%;
    sixPlusOneInts%[5] := ctDotColor2B%;
    sixPlusOneInts%[6] := ctDotsPerPF%;
    
    sevenFloats[0] := ctGaborXLoc;
    sevenFloats[1] := ctGaborYLoc;
    sevenFloats[2] := ctGaborHDeg;
    sevenFloats[3] := ctGaborWDeg;
    sevenFloats[4] := ctGaborSF;
    sevenFloats[5] := ctGaborPhase;
    sevenFloats[6] := ctGaborDivisor;    
    
    sevenInts%[0] := ctPanelIsHoriz%;
    sevenInts%[1] := ctPanelLinePixels%;
    sevenInts%[2] := ctStimValsFromConfig%;
    sevenInts%[3] := ctAlwaysPressing%;
    'sevenInts%[4] := ctOrientationMatches%;
    sevenInts%[4] := ctContrastMatches%;
    sevenInts%[5] := ctNDistractorOn%;
    sevenInts%[6] := ctNDistractorOff%;
    
    threeStrings$[0] := ctDotPctString$;
    'threeStrings$[1] := ctSampleOriString$;
    'threeStrings$[2] := ctOriChangeString$;
    threeStrings$[1] := ctSampleContString$;
    threeStrings$[2] := ctContChangeString$;
    
    fourFloats[0] := ctAbortPenalty;
    fourFloats[1] := ctFixAcqTime;
    fourFloats[2] := ctFAPenalty;
    fourFloats[3] := ctMissPenalty;
    
    sixInts%[0] :=  ctGaborCuedCont%;  'sixInts%[] has seven!
    sixInts%[1] :=  ctGaborUncuedCont%;
    sixInts%[2] :=  ctFlankerCuedCont%;
    sixInts%[3] :=  ctFlankerUncuedCont%;
    sixInts%[4] :=  ctCueRectCuedCont%;
    sixInts%[5] :=  ctCueRectUncuedCont%;
    sixInts%[6] :=  ctShowCueRectDuringCue%;
    
    'Create variables for dialog layout
    var wDlg% := 111;  '108+3
    var c1% := 2;      'first column starts
    var c22% := 56;    'second column starts, 2-col, 54+2
    var c23% := 38;    'second column starts, 3-col, 36+2
    var c33% := 74;    'third column starts, 3-col, 72+2
    var hTrExpOpt% := 2; 'height of training/experimental options group
    var hTrSpec% := 7;   'height of trial specification group
    var hFix% := 3;      'height of fixation options group
    var hTime% := 5;     'height of timing options group
    var hCue% := 4;      'height of cue patch/cue dots options group
    var hStim% := 5;     'height of stimulus options group
    var hStimCont% := 3; 'height of stimulus contrast options group
    var sTrSpec% := hTrExpOpt% + 1;   'start line of trial specification group
    var sFix% := sTrSpec% + hTrSpec%; 'start line of fixation options group
    var sTime% := sFix% + hFix%;      'start line of timing options group, use sTime% to avoid potential future conflict with "stim%"
    var sCue% := sTime% + hTime%;     'start line of cue patch.cue dots options group
    var sStim% := sCue% + hCue%;      'start line of stimulus options group
    var sStimCont% := sStim% + hStim%; 'start line of stimulus contrast options group
    var hDlg% := sStim% + hStim% + hStimCont% + 2; 'height of entire dialog, add a line for the joystick dialog
    var wNum% := 6;  'width of a numeric dialog entry box
    
    
	DlgCreate("Conte Task Parameters",0,0,wDlg%,hDlg%);
    DlgGroup("Training/Full Experiment Options",1,1,wDlg%-2,hTrExpOpt%);
    DlgList(ctDlgTrainingOptions%,50,trainingOptionsList$[],nTOpts%,c1%+1,2);
    DlgCheck(ctDlgCueRectWithCue%,"Cue rect on with cue",c33%,2);
    
    
    DlgGroup("Trial Specification",1,sTrSpec%,wDlg%-2,hTrSpec%);
    ctDlgTotalTrials% := DlgText(ctTotalTrialsText$,c1%,sTrSpec%+1,50);
    DlgInteger(ctDlgnTrialsPerDataPoint%,wNum%,1,ctMaxTrialPerDataPoint%,c33%+1,sTrSpec%+1);  DlgText("Number of Repeats",c33%+wNum%+2,sTrSpec%+1);  'no variable to hold output of DlgText if we won't ever turn the field off
    DlgInteger(ctDlgCountCued%,wNum%,0,ctMaxTrialPerDataPoint%,c1%+1,sTrSpec%+2);  ctTxtCountCued% := DlgText("Cued trials/repeat (Go)",c1%+wNum%+2,sTrSpec%+2);
    DlgInteger(ctDlgCountUncued%,wNum%,0,ctMaxTrialPerDataPoint%,c23%+1,sTrSpec%+2);  ctTxtCountUncued% := DlgText("Uncued trials/repeat (Go)",c23%+wNum%+2,sTrSpec%+2);
    DlgInteger(ctDlgCountNoChange%,wNum%,-ctMaxTrialPerDataPoint%,ctMaxTrialPerDataPoint%,c33%+1,sTrSpec%+2);  ctTxtCountNoChange% := DlgText("No-Change trials/repeat (No-Go)",c33%+wNum%+2,sTrSpec%+2);
    DlgString(ctDlgDotPctString%,60,400,"-0-9 .",c1%+1,sTrSpec%+3);  ctTxtDotPctString% := DlgText("Dot pct Color 1 values (0-100, space-separated)",c1%+60+2,sTrSpec%+3);
    'DlgString(ctDlgSampleOriString%,60,400,"-0-9 .",c1%+1,sTrSpec%+4);  ctTxtSampleOriString% := DlgText("Sample Orientation values (+/- deg, space-separated)",c1%+60+2,sTrSpec%+4);
    'DlgString(ctDlgOriChangeString%,60,400,"-0-9 .",c1%+1,sTrSpec%+5);  ctTxtOriChangeString% := DlgText("Orientation Change values (+/- deg, space-separated)",c1%+60+2,sTrSpec%+5);
    DlgString(ctDlgSampleContString%,60,400,"-0-9 .",c1%+1,sTrSpec%+4);  ctTxtSampleContString% := DlgText("Sample Contrast values (0-100, space-separated)",c1%+60+2,sTrSpec%+4);
    DlgString(ctDlgContChangeString%,60,400,"-0-9 .",c1%+1,sTrSpec%+5);  ctTxtContChangeString% := DlgText("Contrast Change values (+/- 0-100, space-separated)",c1%+60+2,sTrSpec%+5);
    DlgInteger(ctDlgNDistractorOn%,wNum%,0,100,c1%+1,sTrSpec%+6);  ctTxtNDistractorOn% := DlgText("Distractor trials/data point (0=off)",c1%+wNum%+2,sTrSpec%+6);
    DlgInteger(ctDlgNDistractorOff%,wNum%,0,100,c23%+1,sTrSpec%+6);  ctTxtNDistractorOff% := DlgText("No-Distractor trials/data point",c23%+wNum%+2,sTrSpec%+6);
    'DlgCheck(ctDlgOrientationMatches%, "L/R Sample Orientations match",c33%,sTrSpec%+6);
    DlgCheck(ctDlgContrastMatches%, "L/R Sample Contrasts match",c33%,sTrSpec%+6);
    
    
    'This template is useful for "text left, box right", which after contemplation is my disfavored version
    'DlgInteger(ctDlgnTrialsPerDataPoint%,6,1,ctMaxTrialPerDataPoint%,c22%-7,3);  DlgText("Num Trials",c1%,3);  'no variable to hold output of DlgText if we won't ever turn the field off
    'DlgInteger(ctDlgCountCued%,6,0,100,wDlg%-2-7,3);  ctTxtCountCued% := DlgText("Count Trials Valid",c22%,3);
    'DlgInteger(ctDlgCountUncued%,6,0,100,c22%-7,4);  ctTxtCountUncued% := DlgText("Base Contrast",c1%,4);
    'DlgInteger(ctDlgCountNoChange%,6,0,100,wDlg%-2-7,4);  ctTxtCountNoChange% := DlgText("Change Contrast",c22%,4);
    
    
    DlgGroup("Fixation Options",1,sFix%,wDlg%-2,hFix%);
    DlgList(ctDlgRequireFixation%, 50, fixationOptionsList$[],nFOpts%,c1%+1,sFix%+1);
    DlgReal(ctDlgFixAcqTime%,wNum%,0.1,100,c33%+1,sFix%+1);  ctTxtFixAcqTime% := DlgText("Fixation acquisition time (s)",c33%+wNum%+2,sFix%+1);
    DlgCheck(ctDlgFixationOn%, "Fixation cross On",c1%,sFix%+2);
    DlgReal(ctDlgFixCrossWidthPixels%,wNum%,1,50,c23%+1,sFix%+2);  ctTxtFixCrossWidthPixels% := DlgText("Fixation cross width (pixels)",c23%+wNum%+2,sFix%+2);
    DlgReal(ctDlgAdditionalWindowRadius%,wNum%,-5,10,c33%+1,sFix%+2);  ctTxtAdditionalWindowRadius% := DlgText("Add'l fix window radius (deg)",c33%+wNum%+2,sFix%+2);
    

    
    DlgGroup("Timing Options",1,sTime%,wDlg%-2,hTime%);
    DlgReal(ctDlgITI%,wNum%,0.01,100,c1%+1,sTime%+1);  DlgText("Intertrial interval (s)",c1%+wNum%+2,sTime%+1);
    DlgReal(ctDlgPatchOnsetDelay%,wNum%,0.01,100,c23%+1,sTime%+1);  ctTxtPatchOnsetDelay% := DlgText("Cue patch onset delay (s)",c23%+wNum%+2,sTime%+1);
    DlgReal(ctDlgPatchToSampleDelay%,wNum%,0,100,c33%+1,sTime%+1);  ctTxtPatchToSampleDelay% := DlgText("Cue patch to sample gap (s)",c33%+wNum%+2,sTime%+1);
    DlgReal(ctDlgSampleDuration%,wNum%,0.01,100,c1%+1,sTime%+2);  ctTxtSampleDuration% := DlgText("Sample duration (s)",c1%+wNum%+2,sTime%+2);
    DlgReal(ctDlgSampleToTargetDelay%,wNum%,0,100,c23%+1,sTime%+2);  ctTxtSampleToTargetDelay% := DlgText("Sample to Test gap (s)",c23%+wNum%+2,sTime%+2);
    DlgReal(ctDlgTargetDurationGo%,wNum%,0.01,100,c33%+1,sTime%+2);  ctTxtTargetDurationGo% := DlgText("Test duration, Go (s)",c33%+wNum%+2,sTime%+2);
    DlgReal(ctDlgTargetDurationNoGo%,wNum%,0.01,100,c1%+1,sTime%+3);  ctTxtTargetDurationNoGo% := DlgText("Test duration No-go (s)",c1%+wNum%+2,sTime%+3);
    DlgReal(ctDlgResponseTime%,wNum%,0.01,100,c23%+1,sTime%+3);  ctTxtResponseTime% := DlgText(ctResponseTimeText$,c23%+wNum%+2,sTime%+3);
    'DlgReal(ctDlgAbort%,wNum%,0,100,c33%+1,sTime%+3);  ctTxtAbort% := DlgText("Add'l abort penalty (s)",c33%+wNum%+2,sTime%+3);
    DlgReal(ctDlgAbort%,wNum%,0,100,c1%+1,sTime%+4);  ctTxtAbort% := DlgText("Abort penalty (s)",c1%+wNum%+2,sTime%+4);
    DlgReal(ctDlgFAPenalty%,wNum%,0,100,c23%+1,sTime%+4);  ctTxtFAPenalty% := DlgText("False Alarm penalty (s)",c23%+wNum%+2,sTime%+4);
    DlgReal(ctDlgMissPenalty%,wNum%,0,100,c33%+1,sTime%+4);  ctTxtMissPenalty% := DlgText("Miss penalty (s)",c33%+wNum%+2,sTime%+4);

    
    
    DlgGroup("Cue Dot And Cue Patch Options",1,sCue%,wDlg%-2,hCue%);
    DlgReal(ctDlgPatchRadiusDeg%,wNum%,0,10,c1%+1,sCue%+1);  ctTxtPatchRadiusDeg% := DlgText(ctPatchRadiusText$,c1%+wNum%+2,sCue%+1);
    DlgReal(ctDlgDotRadiusDeg%,wNum%,0,5,c23%+1,sCue%+1);  ctTxtDotRadiusDeg% := DlgText("Dot radius (deg)",c23%+wNum%+2,sCue%+1);
    DlgInteger(ctDlgDotsPerPF%,wNum%,0,500,c33%+1,sCue%+1);  ctTxtDotsPerPF% := DlgText("Dots per patch frame",c33%+wNum%+2,sCue%+1);
    DlgInteger(ctDlgPFsPerPatch%,wNum%,0,100,c1%+1,sCue%+2);  ctTxtPFsPerPatch% := DlgText("Patch frames per cue patch",c1%+wNum%+2,sCue%+2);
    DlgInteger(ctDlgRefreshPerPF%,wNum%,0,100,c23%+1,sCue%+2);  ctTxtRefreshPerPF% := DlgText("Screen refreshes per patch frame",c23%+wNum%+2,sCue%+2);
    ctTxtPatchDur% := DlgText(ctPatchDurText$,c33%,sCue%+2);
    DlgInteger(ctDlgDotColor1R%,4,0,255,c1%+1,sCue%+3); DlgInteger(ctDlgDotColor1G%,4,0,255,c1%+6,sCue%+3); DlgInteger(ctDlgDotColor1B%,4,0,255,c1%+11,sCue%+3); ctTxtDotColor1% := DlgText("Cue dot Color 1 (R/G/B)",c1%+16,sCue%+3);
    DlgInteger(ctDlgDotColor2R%,4,0,255,c23%+1,sCue%+3); DlgInteger(ctDlgDotColor2G%,4,0,255,c23%+6,sCue%+3); DlgInteger(ctDlgDotColor2B%,4,0,255,c23%+11,sCue%+3); ctTxtDotColor2% := DlgText("Cue dot Color 2 (R/G/B)",c23%+16,sCue%+3);
    
    
    
    DlgGroup("Stimulus Options",1,sStim%,wDlg%-2,hStim%);
    DlgCheck(ctDlgStimValsFromConfig%,"Get vals from config",c1%,sStim%+1);
    ctTxtGaborCont% := DlgText(ctGaborContText$,c23%,sStim%+1);  'We literally do nothing with this
    DlgReal(ctDlgGaborXLoc%,wNum%,0,40,c1%+1,sStim%+2);  ctTxtGaborXLoc% := DlgText("Gabor 1 X Loc (deg right of fix)",c1%+wNum%+2,sStim%+2);
    DlgReal(ctDlgGaborYLoc%,wNum%,-40,40,c23%+1,sStim%+2);  ctTxtGaborYLoc% := DlgText("Gabor 1 Y Loc (deg above fix)",c23%+wNum%+2,sStim%+2);
    DlgReal(ctDlgGaborSF%,wNum%,0,100,c33%+1,sStim%+2);  ctTxtGaborSF% := DlgText("Gabor Spatial Freq (cyc/deg)",c33%+wNum%+2,sStim%+2);
    DlgReal(ctDlgGaborWDeg%,wNum%,0.1,20,c1%+1,sStim%+3);  ctTxtGaborWDeg% := DlgText("Gabor Width (diameter, deg)",c1%+wNum%+2,sStim%+3);
    DlgReal(ctDlgGaborHDeg%,wNum%,0.1,20,c23%+1,sStim%+3);  ctTxtGaborHDeg% := DlgText("Gabor Height (diameter, deg)",c23%+wNum%+2,sStim%+3);
    DlgReal(ctDlgGaborPhase%,wNum%,-360,360,c33%+1,sStim%+3);  ctTxtGaborPhase% := DlgText("Gabor Phase (deg)",c33%+wNum%+2,sStim%+3);
    DlgReal(ctDlgGaborDivisor%,wNum%,0.1,20,c1%+1,sStim%+4);  ctTxtGaborDivisor% := DlgText("Gaussian mask factor",c1%+wNum%+2,sStim%+4);
    DlgInteger(ctDlgPanelLinePixels%,wNum%,1,100,c23%+1,sStim%+4);  ctTxtPanelLinePixels% := DlgText("Cue rect border width (pixels)",c23%+wNum%+2,sStim%+4);
    DlgCheck(ctDlgPanelIsHoriz%,"Panel orientation horizontal",c33%+1,sStim%+4);
    
    DlgGroup("Stimulus Contrasts",1,sStimCont%,wDlg%-2,hStimCont%);
    DlgInteger(ctDlgGaborCuedCont%,wNum%,0,100,c1%+1,sStimCont%+1);  ctTxtGaborCuedCont% := DlgText("Cued Gabor Contrast (0-100)",c1%+wNum%+2,sStimCont%+1);
    DlgInteger(ctDlgFlankerCuedCont%,wNum%,0,100,c23%+1,sStimCont%+1);  ctTxtFlankerCuedCont% := DlgText("Cued Flanker Contrast (0-100)",c23%+wNum%+2,sStimCont%+1);
    DlgInteger(ctDlgCueRectCuedCont%,wNum%,0,100,c33%+1,sStimCont%+1);  ctTxtCueRectCuedCont% := DlgText("Cued Cue Rect Contrast (0-100)",c33%+wNum%+2,sStimCont%+1);
    DlgInteger(ctDlgGaborUncuedCont%,wNum%,0,100,c1%+1,sStimCont%+2);  ctTxtGaborUncuedCont% := DlgText("Uncued Gabor Contrast (0-100)",c1%+wNum%+2,sStimCont%+2);
    DlgInteger(ctDlgFlankerUncuedCont%,wNum%,0,100,c23%+1,sStimCont%+2);  ctTxtFlankerUncuedCont% := DlgText("Uncued Flanker Contrast (0-100)",c23%+wNum%+2,sStimCont%+2);
    DlgInteger(ctDlgCueRectUncuedCont%,wNum%,0,100,c33%+1,sStimCont%+2);  ctTxtCueRectUncuedCont% := DlgText("Uncued Cue Rect Contrast (0-100)",c33%+wNum%+2,sStimCont%+2);  
    
    
    DlgCheck(ctDlgAlwaysPressing%,"Always Pressing?",c1%,hDlg%-2);
    
    DlgButton(51, "Joystick Dialog", CallJoystickConfigDialogUD%,2,hDlg%-1);

    DlgAllow(0, 0, ConteTaskDialogChanged%);
    
    i% := DlgShow(nTrialsPerDataPoint%,ctTrainingOptions%,ctCountUncued%,ctCountNoChange%,ctCountCued%,ctRequireFixation%,
                  ctFixationOn%,ctAdditionalWindowRadius,nineFloats[],sixPlusOneInts%[],ctPatchRadiusDeg,
                  ctRefreshPerPF%,ctPFsPerPatch%,ctResponseTime,sevenFloats[],sevenInts%[],threeStrings$[],
                  fourFloats[],sixInts%[]);  'Now at 20!
    
    
    if i% = 1 then        
        
        'Unpack eightFloats[], sevenFloats[], sixPlusOneInts%[], sevenInts%[], threeStrings$[], sixInts%[]
        ctFixCrossWidthPixels := nineFloats[0];
        ctPatchOnsetDelay := nineFloats[1];
        ctPatchToSampleDelay := nineFloats[2];
        ctSampleToTargetDelay := nineFloats[3];
        ctSampleDuration := nineFloats[4];
        ctTargetDurationGo := nineFloats[5];
        ctTargetDurationNoGo := nineFloats[6];
        ctITI := nineFloats[7];
        ctDotRadiusDeg := nineFloats[8];
    
        ctDotColor1R% := sixPlusOneInts%[0];
        ctDotColor1G% := sixPlusOneInts%[1];
        ctDotColor1B% := sixPlusOneInts%[2];
        ctDotColor2R% := sixPlusOneInts%[3];
        ctDotColor2G% := sixPlusOneInts%[4];
        ctDotColor2B% := sixPlusOneInts%[5];
        ctDotsPerPF% := sixPlusOneInts%[6];
        
        ctGaborXLoc := sevenFloats[0];
        ctGaborYLoc := sevenFloats[1];
        ctGaborHDeg := sevenFloats[2];
        ctGaborWDeg := sevenFloats[3];
        ctGaborSF := sevenFloats[4];
        ctGaborPhase := sevenFloats[5];
        ctGaborDivisor := sevenFloats[6]; 
        
        ctPanelIsHoriz% := sevenInts%[0];
        ctPanelLinePixels% := sevenInts%[1];
        ctStimValsFromConfig% := sevenInts%[2];
        ctAlwaysPressing% := sevenInts%[3];
        'ctOrientationMatches% := sevenInts%[4];
        ctContrastMatches% := sevenInts%[4];
        ctNDistractorOn% := sevenInts%[5];
        ctNDistractorOff% := sevenInts%[6];
        
        ctDotPctString$ := threeStrings$[0];
        'ctSampleOriString$ := threeStrings$[1];
        'ctOriChangeString$ := threeStrings$[2];
        ctSampleContString$ := threeStrings$[1];
        ctContChangeString$ := threeStrings$[2];
        
        ctAbortPenalty := fourFloats[0];
        ctFixAcqTime := fourFloats[1];
        ctFAPenalty := fourFloats[2];
        ctMissPenalty := fourFloats[3];
        
        ctGaborCuedCont% := sixInts%[0];  'sixInts%[] has seven!
        ctGaborUncuedCont% := sixInts%[1];
        ctFlankerCuedCont% := sixInts%[2];
        ctFlankerUncuedCont% := sixInts%[3];
        ctCueRectCuedCont% := sixInts%[4];
        ctCueRectUncuedCont% := sixInts%[5];
        ctShowCueRectDuringCue% := sixInts%[6];
        
        'Once everything is unpacked, save parameters, we will manipulate some of them below
        SaveConteTaskParameters();
        
        
        'Set flanker and gabor contrasts to 0 for training mode 3
        if ctTrainingOptions% = 3 then
            ctGaborCuedCont% := 0;
            ctGaborUncuedCont% := 0;
            ctFlankerCuedCont% := 0;
            ctFlankerUncuedCont% := 0;
        endif
        
        'Disable showing cue rect during training mode < 3 regardless of checkbox
        docase
        case ctTrainingOptions% < 3 then
            ctShowCueRectDuringCue% := 0;
        case ctShowCueRectDuringCue% = 1 and ctTrainingOptions% = 3 then
            allowGoDuringCuePatch% := 1;
        endcase
        
        
        'Convert float pixel width to integer (due to "eightFloats[]", was too difficult to convert to integer for dialog)
        ctFixCrossWidthPixels% := ctFixCrossWidthPixels;
        
        'Get "secondary" gabor location based on requested orientation
        if ctPanelIsHoriz% = 0 then
            ctGabor2XLoc := -ctGaborXLoc;  'place vertical panels on opposite L/R side of fixation, coordinates relative to fixation
            ctGabor2YLoc := ctGaborYLoc;  'If panel is vertical, Y is same for both
        else
            ctGabor2XLoc := ctGaborXLoc;  'If panel is horizontal, X is same for both
            ctGabor2YLoc := -ctGaborYLoc;  'place horizontal panels on opposite U/D side of fixation, coordinates relative to fixation
        endif
        'Convert gabor locations back to literal coordinates
        ctGaborXLoc := ctGaborXLoc + FixationX;  
        ctGaborYLoc := ctGaborYLoc + FixationY;
        ctGabor2XLoc := ctGabor2XLoc + FixationX;  
        ctGabor2YLoc := ctGabor2YLoc + FixationY;
        
        'Randomize color/location assignment
        'The idea here is to make everything as easy as possible down the road.  Color 1 is the "receptive field"
        'color, color 2 is the other color.  But to make sure that color 1 is not always "on the right" or "on top"
        'or whatever, we will simply randomly swap right/left (up/down) half the experiments.  The program will continue 
        'as always, as if the experimenter was randomly swapping them, but this takes the burden off the experimenter.
        'We make sure to do this after saving the parameters so things don't get swapped in the dialog.
        'The initial thought here was to swap the COLOR of colors 1/2, but that doesn't play right with valid/invalid.
        'Just swap the whole shebang by changing XY.
        if Rand(1,0) > 0.5 then
            tempXY := ctGaborXLoc;
            ctGaborXLoc := ctGabor2XLoc;
            ctGabor2XLoc := tempXY;
            
            tempXY := ctGaborYLoc;
            ctGaborYLoc := ctGabor2YLoc;
            ctGabor2YLoc := tempXY;
        endif
        
        
        'Change value of ctRequireFixation to -1 if it is 1 (monitor eye position only), because that's what the code expects.
        'This is not strictly necessary but allows commonplace conditionals (full fixation if ctRequireFixation = 1, fixation is at least monitored if ctRequireFixation <> 0)
        docase 
        case ctRequireFixation% = 1 then
            ctRequireFixation% := -1;
        case ctRequireFixation% = 2 then
            ctRequireFixation% := 1;
        endcase
        
        'Set ctCheckLooking%, this will be used by Looking%(), will be easier than asking for "and ctRequireFixation% = 1" for every check
        docase
        case ctAlwaysLooking% = 1 then
            ctCheckLooking% := 0;
        case ctRequireFixation% = 1 then
            ctCheckLooking% := 1;
        else
            ctCheckLooking% := 0;
        endcase
        
        
        'ctAdditionalWindowRadius will apply to the fixation window around the cue patch - we can have this be NEGATIVE
        'so that it is smaller than the cue patch, since we may want to have the animal fixate the cross tightly but
        'still have a larger cue patch.  This calculation was originally predicated on monitoring fixation, but since a 
        '"fixation" window will be displayed in any event that there is a cue patch on screen we should just always check
        'Important note - the size of the FIXATION window will be dictated by this value in all cases, even if there is
        'no cue
        if ctPatchRadiusDeg + ctAdditionalWindowRadius < 0.1 then  '0.1 is obviously too tight of a window
            message("The requested fixation window is too small (" + Str$(ctPatchRadiusDeg + ctAdditionalWindowRadius) + " deg)!  Quitting!");
            halt;
        else
            'Overwrite the fixation parameters window radius
            WindowRadius := ctPatchRadiusDeg + ctAdditionalWindowRadius;
        endif      
        
        
        'Get final value of patch duration - this value is only used once in the idle loop??
        ctPatchDur := ctRefreshPerPF%*ctPFsPerPatch%/dataScreenHz;  'in seconds, three decimal places
        
        
        
        return 1;
    else   
        Printlog("Main Dialog was cancelled!\n");
        return 0;
    endif;
    
    
end


func ConteTaskDialogChanged%(item%)
    var status% := 1;
    
    'At least for the time being, this dialog entry will be unused, and forced to 100%.
    'This means that in all instances where a gabor appears in the cued location at all,
    'its contrast will be completely specified by the sample contrast value (plus change,
    'when applicable) set at the top of the dialog.  Any "fade-in" can be done up top.
    'However, we will allow independent fade-in of the gabor at the uncued location using
    'a 0-100 multiplicative percentage factor in cases where there is no change at this
    'uncued location.  If there is a change, the rounding established by a fade-in could
    'make the change invisible, so it is not allowed.
    'Yes, this is kind of silly, and it's largely a vestigial artifact of the orientation
    'version of the task, when independently changing the gabor constrast made sense.  BUT
    'it can still make sense to allow an independent fade-in at the uncued location, because
    'this is expected to happen in a "separate" later stage from the fade-in of the cued
    'location.  Could this value be eliminated?  From a practical standpoint, yes, but then
    'you know that the experimenters will decide they want to start "fade-in" with the uncued
    'location and follow with the cued location...and so while I'm at it I'll just do all the
    'math so if such a change is requested, I only have to play with enables on the dialog.
    DlgEnable(0,ctDlgGaborCuedCont%,ctTxtGaborCuedCont%);
    DlgValue(ctDlgGaborCuedCont%,100);
    
    
    'Force value of ctDlgNDistractorOff% if ctDlgNDistractorOn% is 0
    if DlgValue(ctDlgNDistractorOn%) = 0 then
        DlgValue(ctDlgNDistractorOff%,1);
    endif
    
    'Calculate total trials for display
    'nTrials% := CalcNumTrials%(DlgValue(ctDlgTrainingOptions%),DlgValue(ctDlgnTrialsPerDataPoint%),DlgValue(ctDlgCountCued%),DlgValue(ctDlgCountUncued%),DlgValue(ctDlgCountNoChange%),
    '            DlgValue$(ctDlgDotPctString%),DlgValue$(ctDlgSampleOriString%),DlgValue$(ctDlgOriChangeString%),DlgValue(ctDlgNDistractorOn%),DlgValue(ctDlgNDistractorOff%));
    nTrials% := CalcNumTrials%(DlgValue(ctDlgTrainingOptions%),DlgValue(ctDlgnTrialsPerDataPoint%),DlgValue(ctDlgCountCued%),DlgValue(ctDlgCountUncued%),DlgValue(ctDlgCountNoChange%),
                DlgValue$(ctDlgDotPctString%),DlgValue$(ctDlgSampleContString%),DlgValue$(ctDlgContChangeString%),DlgValue(ctDlgNDistractorOn%),DlgValue(ctDlgNDistractorOff%));
    
    docase
    case nTrials% > ctMaxTrials% then
        ctTotalTrialsText$ := "TOO MANY TRIALS (5000 max): " + Str$(nTrials%);
        DlgEnable(0,-1);  'disable "OK"
    case nTrials% < 1 then
        ctTotalTrialsText$ := "NO TRIALS SPECIFIED, CHECK FOR EMPTY DIALOG VALUE";
        DlgEnable(0,-1);  'disable "OK"
    else
        ctTotalTrialsText$ := "Total number of trials: " + Str$(nTrials%);
        DlgEnable(1,-1);  'Otherwise enable "OK"
    endcase  
    DlgValue$(ctDlgTotalTrials%,ctTotalTrialsText$);
    
    
    
    'Update value of patch duration, just do this every time since the dialog takes forever to refresh anyways
    'Calculate initial duration of cue patch
    ctPatchDurText$ := "Patch duration (s) = " + Str$(DlgValue(ctDlgRefreshPerPF%)*DlgValue(ctDlgPFsPerPatch%)/dataScreenHz,4,-3);  'in seconds, three decimal places
    DlgValue$(ctTxtPatchDur%,ctPatchDurText$);
    
    
    
    
    'Massive enable/disable based on training step
    
    'For Step 1 or greater, the "response" time and abort time come on ("response" time is hold time, label updated below)
    'and fixation options come on
    if DlgValue(ctDlgTrainingOptions%) >= 1 then
        DlgEnable(1,ctDlgResponseTime%,ctTxtResponseTime%);
        DlgEnable(1,ctDlgAbort%,ctTxtAbort%);
        DlgEnable(1,ctDlgRequireFixation%);  'enable fixation options
        

        'Force fixation cross to ON if fixation is required, because otherwise what do you fixate?
        'Disable Additional Window Radius if we are not requiring/checking fixation
        docase
        case DlgValue(ctDlgRequireFixation%) >= 2 then  'Note this is DlgValue, where monitor fixation is 2 (ctRequireFixation% variable is adjusted later)  
            DlgValue(ctDlgFixationOn%,1);  'set value to 1
            DlgEnable(0,ctDlgFixationOn%);  'and disable fixation checkbox
            DlgEnable(1,ctDlgAdditionalWindowRadius%,ctTxtAdditionalWindowRadius%);  'enable additional window radius
            DlgEnable(1,ctDlgPatchRadiusDeg%,ctTxtPatchRadiusDeg%);
            DlgEnable(1,ctDlgFixAcqTime%,ctTxtFixAcqTime%);  'enable fixation acquisition time
        case DlgValue(ctDlgRequireFixation%) = 1 then  
            DlgEnable(1,ctDlgFixationOn%);  'enable fixation checkbox, do not update value
            DlgEnable(1,ctDlgAdditionalWindowRadius%,ctTxtAdditionalWindowRadius%);  'enable additional window radius - this allows us to see whether the animal is near the window even if we aren't enforcing it
            DlgEnable(1,ctDlgPatchRadiusDeg%,ctTxtPatchRadiusDeg%);
            DlgEnable(0,ctDlgFixAcqTime%,ctTxtFixAcqTime%);  'disable fixation acquisition time
        else  'RequireFixation is 0
            DlgEnable(1,ctDlgFixationOn%);  'enable fixation checkbox, do not update value
            DlgEnable(0,ctDlgAdditionalWindowRadius%,ctTxtAdditionalWindowRadius%);  'disable additional window radius
            DlgEnable(0,ctDlgFixAcqTime%,ctTxtFixAcqTime%);  'disable fixation acquisition time
            if DlgValue(ctDlgTrainingOptions%) >= 2 then
                DlgEnable(1,ctDlgPatchRadiusDeg%,ctTxtPatchRadiusDeg%);
            else
                DlgEnable(0,ctDlgPatchRadiusDeg%,ctTxtPatchRadiusDeg%);
            endif
        endcase
        
        'Disable Fixation Cross size if fixation is not being displayed
        if DlgValue(ctDlgFixationOn%) = 0 then
            DlgEnable(0,ctDlgFixCrossWidthPixels%,ctTxtFixCrossWidthPixels%);
        else
            DlgEnable(1,ctDlgFixCrossWidthPixels%,ctTxtFixCrossWidthPixels%);
        endif
        
    else 'if we are on step 0, disable the following
        DlgEnable(0,ctDlgResponseTime%,ctTxtResponseTime%);
        DlgEnable(0,ctDlgAbort%,ctTxtAbort%);
        'For training option 0, do not allow fixation point or eye monitoring, this is purely press-lever-get-reward
        DlgValue(ctDlgFixationOn%,0);  'set fixation value to off
        DlgEnable(0,ctDlgFixationOn%);  'and disable fixation checkbox
        DlgValue(ctDlgRequireFixation%,0);  'and set fixation options value to 0
        DlgEnable(0,ctDlgRequireFixation%);  'and disable fixation options
        DlgEnable(0,ctDlgFixCrossWidthPixels%,ctTxtFixCrossWidthPixels%);  'disable fixation cross width
        DlgEnable(0,ctDlgAdditionalWindowRadius%,ctTxtAdditionalWindowRadius%);  'disable additional window radius
        DlgEnable(0,ctDlgPatchRadiusDeg%,ctTxtPatchRadiusDeg%);
    endif
    
    'For Step 2 and greater, values related to the cue patch come on
    if DlgValue(ctDlgTrainingOptions%) >= 2 then
        DlgEnable(1,ctDlgPatchOnsetDelay%,ctTxtPatchOnsetDelay%);
        DlgEnable(1,ctDlgDotRadiusDeg%,ctTxtDotRadiusDeg%);
        DlgEnable(1,ctDlgDotColor1R%);
        DlgEnable(1,ctDlgDotColor1G%);
        DlgEnable(1,ctDlgDotColor1B%);
        DlgEnable(1,ctTxtDotColor1%);
        DlgEnable(1,ctDlgDotColor2R%);
        DlgEnable(1,ctDlgDotColor2G%);
        DlgEnable(1,ctDlgDotColor2B%);
        DlgEnable(1,ctTxtDotColor2%);
        DlgEnable(1,ctDlgDotsPerPF%,ctTxtDotsPerPF%);
        DlgEnable(1,ctDlgRefreshPerPF%,ctTxtRefreshPerPF%);
        DlgEnable(1,ctDlgPFsPerPatch%,ctTxtPFsPerPatch%);
        DlgEnable(1,ctDlgDotPctString%,ctTxtDotPctString%);
        DlgEnable(1,ctTxtPatchDur%);
        DlgValue$(ctTxtPatchRadiusDeg%,ctPatchRadiusText$);
    'if we are on step 1 or below, disable values related to the cue patch   
    else
        DlgEnable(0,ctDlgPatchOnsetDelay%,ctTxtPatchOnsetDelay%);
        DlgEnable(0,ctDlgDotRadiusDeg%,ctTxtDotRadiusDeg%);
        DlgEnable(0,ctDlgDotColor1R%);
        DlgEnable(0,ctDlgDotColor1G%);
        DlgEnable(0,ctDlgDotColor1B%);
        DlgEnable(0,ctTxtDotColor1%);
        DlgEnable(0,ctDlgDotColor2R%);
        DlgEnable(0,ctDlgDotColor2G%);
        DlgEnable(0,ctDlgDotColor2B%);
        DlgEnable(0,ctTxtDotColor2%);
        DlgEnable(0,ctDlgDotsPerPF%,ctTxtDotsPerPF%);
        DlgEnable(0,ctDlgRefreshPerPF%,ctTxtRefreshPerPF%);
        DlgEnable(0,ctDlgPFsPerPatch%,ctTxtPFsPerPatch%);
        DlgEnable(0,ctDlgDotPctString%,ctTxtDotPctString%);
        DlgEnable(0,ctTxtPatchDur%);
        DlgValue$(ctTxtPatchRadiusDeg%,ctFixRadiusText$);  'Note that we will use the "fixation" text for step 0, where this is disabled
    endif
    
    
    'For Step 3 and greater, remaining timing values come on, cued trial count and no-change trial count come on,
    'cue panel orientation and cue rect border come on, cue rect contrasts come on
    if DlgValue(ctDlgTrainingOptions%) >= 3 then
        DlgEnable(1,ctDlgCueRectWithCue%); 
        DlgEnable(1,ctDlgCountNoChange%,ctTxtCountNoChange%);
        DlgEnable(1,ctDlgCountCued%,ctTxtCountCued%);
        DlgEnable(1,ctDlgCueRectCuedCont%,ctTxtCueRectCuedCont%);
        DlgEnable(1,ctDlgCueRectUncuedCont%,ctTxtCueRectUncuedCont%);
        DlgEnable(1,ctDlgPanelIsHoriz%);
        DlgEnable(1,ctDlgPanelLinePixels%,ctTxtPanelLinePixels%);
        DlgEnable(1,ctDlgPatchToSampleDelay%,ctTxtPatchToSampleDelay%);
        DlgEnable(1,ctDlgSampleDuration%,ctTxtSampleDuration%);
        DlgEnable(1,ctDlgSampleToTargetDelay%,ctTxtSampleToTargetDelay%);
        DlgEnable(1,ctDlgTargetDurationGo%,ctTxtTargetDurationGo%);
        DlgEnable(1,ctDlgTargetDurationNoGo%,ctTxtTargetDurationNoGo%);
        DlgEnable(1,ctDlgFAPenalty%,ctTxtFAPenalty%);
        DlgEnable(1,ctDlgMissPenalty%,ctTxtMissPenalty%);
        DlgValue$(ctTxtResponseTime%,ctResponseTimeText$);
    'if we are on Step 2 or below, values changed above remain disabled
    else
        DlgEnable(0,ctDlgCueRectWithCue%); 
        DlgEnable(0,ctDlgCountNoChange%,ctTxtCountNoChange%);
        DlgEnable(0,ctDlgCountCued%,ctTxtCountCued%);
        DlgEnable(0,ctDlgCueRectCuedCont%,ctTxtCueRectCuedCont%);
        DlgEnable(0,ctDlgCueRectUncuedCont%,ctTxtCueRectUncuedCont%);
        DlgEnable(0,ctDlgPanelIsHoriz%);
        DlgEnable(0,ctDlgPanelLinePixels%,ctTxtPanelLinePixels%);
        DlgEnable(0,ctDlgPatchToSampleDelay%,ctTxtPatchToSampleDelay%);
        DlgEnable(0,ctDlgSampleDuration%,ctTxtSampleDuration%);
        DlgEnable(0,ctDlgSampleToTargetDelay%,ctTxtSampleToTargetDelay%);
        DlgEnable(0,ctDlgTargetDurationGo%,ctTxtTargetDurationGo%);
        DlgEnable(0,ctDlgTargetDurationNoGo%,ctTxtTargetDurationNoGo%);
        DlgEnable(0,ctDlgFAPenalty%,ctTxtFAPenalty%);
        DlgEnable(0,ctDlgMissPenalty%,ctTxtMissPenalty%);
        DlgValue$(ctTxtResponseTime%,ctHoldTimeText$);
    endif
    
    
    
    
    'For Step 4 and greater, all values related to the stim (except response time) come on
    if DlgValue(ctDlgTrainingOptions%) >= 4 then
        DlgEnable(1,ctDlgGaborDivisor%,ctTxtGaborDivisor%);
        DlgEnable(1,ctDlgStimValsFromConfig%);
        DlgEnable(1,ctDlgNDistractorOn%,ctTxtNDistractorOn%);
        DlgEnable(1,ctDlgNDistractorOff%,ctTxtNDistractorOff%);
        'DlgEnable(1,ctDlgSampleOriString%,ctTxtSampleOriString%);
        DlgEnable(1,ctDlgSampleContString%,ctTxtSampleContString%);
        'DlgEnable(1,ctDlgGaborCuedCont%,ctTxtGaborCuedCont%);  'Actually, we will never turn this on, always 100%
        DlgEnable(1,ctDlgGaborUncuedCont%,ctTxtGaborUncuedCont%);
        DlgEnable(1,ctDlgFlankerCuedCont%,ctTxtFlankerCuedCont%);
        DlgEnable(1,ctDlgFlankerUncuedCont%,ctTxtFlankerUncuedCont%);
        
        'But do not bother enabling Gabor properties, as these will be enabled/disbled based on ctStimValuesFromConfig% below
    else
        DlgEnable(0,ctDlgGaborDivisor%,ctTxtGaborDivisor%);
        DlgEnable(0,ctDlgStimValsFromConfig%);
        DlgEnable(0,ctDlgNDistractorOn%,ctTxtNDistractorOn%);
        DlgEnable(0,ctDlgNDistractorOff%,ctTxtNDistractorOff%);
        'DlgEnable(0,ctDlgSampleOriString%,ctTxtSampleOriString%);
        DlgEnable(0,ctDlgSampleContString%,ctTxtSampleContString%);
        'Also disable the values for the Gabor properties
        DlgEnable(0,ctDlgGaborXLoc%,ctTxtGaborXLoc%);
        DlgEnable(0,ctDlgGaborYLoc%,ctTxtGaborYLoc%);
        DlgEnable(0,ctDlgGaborHDeg%,ctTxtGaborHDeg%);
        DlgEnable(0,ctDlgGaborWDeg%,ctTxtGaborWDeg%);
        DlgEnable(0,ctDlgGaborSF%,ctTxtGaborSF%);
        DlgEnable(0,ctDlgGaborPhase%,ctTxtGaborPhase%);
        'DlgEnable(0,ctDlgGaborCuedCont%,ctTxtGaborCuedCont%);  'Actually, we will never turn this on, always 100%
        DlgEnable(0,ctDlgGaborUncuedCont%,ctTxtGaborUncuedCont%);
        DlgEnable(0,ctDlgFlankerCuedCont%,ctTxtFlankerCuedCont%);
        DlgEnable(0,ctDlgFlankerUncuedCont%,ctTxtFlankerUncuedCont%);
        
    endif
    
    'For Step 5 and greater, add contrast match option, contrast changes
    if DlgValue(ctDlgTrainingOptions%) >= 5 then
       'DlgEnable(1,ctDlgOrientationMatches%);
        DlgEnable(1,ctDlgContrastMatches%);
        'DlgEnable(1,ctDlgOriChangeString%,ctTxtOriChangeString%);
        DlgEnable(1,ctDlgContChangeString%,ctTxtContChangeString%);
        
    else
        'DlgEnable(0,ctDlgOrientationMatches%);
        DlgEnable(0,ctDlgContrastMatches%);
        'DlgEnable(0,ctDlgOriChangeString%,ctTxtOriChangeString%);
        DlgEnable(0,ctDlgContChangeString%,ctTxtContChangeString%);
        
    endif

    'For Step 6, add uncued trials
    if DlgValue(ctDlgTrainingOptions%) >= 6 then
        DlgEnable(1,ctDlgCountUncued%,ctTxtCountUncued%);
        DlgEnable(0,ctDlgGaborUncuedCont%,ctTxtGaborUncuedCont%);  'Here at Step 6, there can be a contrast change at
        DlgValue(ctDlgGaborUncuedCont%,100);  'the uncued location, so we can't play around with scaling it.
    else
        DlgEnable(0,ctDlgCountUncued%,ctTxtCountUncued%);
    endif
    
    
    
    'Further disable and "tie" contrast values that are not used or must be identical
    docase
        'for Step 3, disable and tie the uncued cue rect
    case DlgValue(ctDlgTrainingOptions%) = 3 then
        DlgEnable(0,ctDlgCueRectUncuedCont%,ctTxtCueRectUncuedCont%);  'disable the uncued rect contrast
        DlgValue(ctDlgCueRectUncuedCont%,DlgValue(ctDlgCueRectCuedCont%));  'set the uncued rect contrast value to the cued value
        'for Step 5, if there is NO no-change trial, ENABLE all uncued contrasts
    case DlgValue(ctDlgTrainingOptions%) = 5 and DlgValue(ctDlgCountNoChange%) = 0 then  
        DlgEnable(1,ctDlgCueRectUncuedCont%,ctTxtCueRectUncuedCont%); 'enable the uncued rect contrast
        DlgEnable(1,ctDlgGaborUncuedCont%,ctTxtGaborUncuedCont%);   'enable the uncued gabor contrast
        DlgEnable(1,ctDlgFlankerUncuedCont%,ctTxtFlankerUncuedCont%);   'enable the uncued flanker contrast    
    'Otherwise, from Step 4 forward, disable and tie all uncued contrasts    
    case DlgValue(ctDlgTrainingOptions%) >= 4 then  
        DlgEnable(0,ctDlgCueRectUncuedCont%,ctTxtCueRectUncuedCont%); 'disable the uncued rect contrast
        DlgEnable(0,ctDlgGaborUncuedCont%,ctTxtGaborUncuedCont%);   'disable the uncued gabor contrast
        DlgEnable(0,ctDlgFlankerUncuedCont%,ctTxtFlankerUncuedCont%);   'disable the uncued flanker contrast
        DlgValue(ctDlgCueRectUncuedCont%,DlgValue(ctDlgCueRectCuedCont%));  'set the uncued rect contrast value to the cued value
        DlgValue(ctDlgGaborUncuedCont%,DlgValue(ctDlgGaborCuedCont%));  'set the uncued gabor contrast value to the cued value
        DlgValue(ctDlgFlankerUncuedCont%,DlgValue(ctDlgFlankerCuedCont%));  'set the uncued flanker contrast value to the cued value
    endcase
    
    
    
    'This code enables us to grab values for the gabor from the config (main stimulus)
    'but then to update them from there if desired.  Since only training step 3+ has a stimulus at all,
    'don't bother to do anything (everything is already disabled) for steps 0-2.
    docase
    case DlgValue(ctDlgStimValsFromConfig%) = 1 and DlgValue(ctDlgTrainingOptions%) > 2 then
        'Set values to those grabbed from main stimulus in config, and disable
        DlgValue(ctDlgGaborXLoc%,ctGaborXLoc);
        DlgValue(ctDlgGaborYLoc%,ctGaborYLoc);
        DlgValue(ctDlgGaborHDeg%,ctGaborHDeg);
        DlgValue(ctDlgGaborWDeg%,ctGaborWDeg);
        DlgValue(ctDlgGaborSF%,ctGaborSF);
        DlgValue(ctDlgGaborPhase%,ctGaborPhase);
        DlgEnable(0,ctDlgGaborXLoc%,ctTxtGaborXLoc%);
        DlgEnable(0,ctDlgGaborYLoc%,ctTxtGaborYLoc%);
        DlgEnable(0,ctDlgGaborHDeg%,ctTxtGaborHDeg%);
        DlgEnable(0,ctDlgGaborWDeg%,ctTxtGaborWDeg%);
        DlgEnable(0,ctDlgGaborSF%,ctTxtGaborSF%);
        DlgEnable(0,ctDlgGaborPhase%,ctTxtGaborPhase%);
    case DlgValue(ctDlgTrainingOptions%) > 2 then
        'Enable so values can be changed
        DlgEnable(1,ctDlgGaborXLoc%,ctTxtGaborXLoc%);  'Location will change location of gabor/cue rect
        DlgEnable(1,ctDlgGaborYLoc%,ctTxtGaborYLoc%);
        DlgEnable(1,ctDlgGaborHDeg%,ctTxtGaborHDeg%);  'Size will change size of gabor/cue rect
        DlgEnable(1,ctDlgGaborWDeg%,ctTxtGaborWDeg%);
        if DlgValue(ctDlgTrainingOptions%) > 3 then
            DlgEnable(1,ctDlgGaborSF%,ctTxtGaborSF%);  'Spatial frequency only makes sense if there is a gabor
            DlgEnable(1,ctDlgGaborPhase%,ctTxtGaborPhase%);  'Phase only makes sense if there is a gabor
        endif
    endcase

    return status%;
end



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func IdleProcessing%()
	var iStatus% := 1;
    var remainInIdleLoop% := 1;  'initialize to 1 to get INTO idle loop	

    while remainInIdleLoop% = 1 do  'do not cede time to OS in certain circumstances
                                    'the general rule is going to be: if the subsequent state 
                                    'does not involve waiting for something to happen/finish,
                                    'then go ahead and jump straight to it
        
        'Get current time
        tNow := View(DataWindow%).MaxTime();
        
        remainInIdleLoop% := 0;  'only run one idle cycle unless otherwise requested
        
        if ctRequireFixation% <> 0 then
            xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
            yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
            
            'Don't update display every time....
            if tNow-tLastFixPtDisplayUpdate > .005 then
                View(XYWindow%).XYAddData(1,xEye,yEye);
                tLastFixPtDisplayUpdate := tNow;
            endif
        endif
        
        
        
        docase 
        case iState% = stateVSGWait% then 
            'Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
            'Once VSG is ready, we start
            if stateBegin% = 1 then
                LogStatus("VSGWait", "Begin waiting for Ready Pulse from VSG at about " + str$(tNow));
                stateBegin% := 0;
            endif
            
            pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
            
            docase
            'case ctTrainingOptions% = 0 then
            '    LogStatus("VSGWait", "VSG does not run for training level 0, move to next state!");
            case pulseFound% = 1 then
                LogStatus("VSGWait", "Got Ready Pulse from VSG at exactly " + str$(tRise));
                Yield(1.0);
                tLastTrigger := tFall;
                ChangeStateTo(stateEnforceLeverInOrigin%, tFall);
                
                if RecordEyeTrackerOutputFile% = 1 then
                    'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                endif;
                
            case pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                    LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at exactly " + str$(tRise));
                    tLastTrigger := tFall;
            endcase;
            
            
            
        '---Here is where the repeated trial sequence begins---   
            
        case iState% = stateEnforceLeverInOrigin% then    
            ' Making sure lever is in origin to begin trial
            if stateBegin% = 1 then
                LogStatus("EnforceLeverInOrigin", "Checking for lever in origin at about " + str$(tNow));
                stateBegin% := 0;
            endif
            
            tempAnswer% := Answer%(JSCenter%); 'poll the joystick here, check result in case statement
                                               
            docase
            case tempAnswer% = JSCenter% or tempAnswer% = JSUp%  then  'If lever in origin (or up)
                LogStatus("EnforceLeverInOrigin", "Found lever in origin at about " + str$(tNow));
                ChangeStateTo(stateWaitForLever%, tNow);
            case tempAnswer% < 0 then  'If error indicated; only errors should be coding errors
                message("There has been a problem reading the lever device! Check log file! Quitting!");
                Stop%();  'Stop%() should do a clean quit
            else 
                'LogStatus("EnforceLeverInOrigin", "Lever is still down at about " + str$(tNow));
                'Just check again...but don't write it, this spams the log
            endcase
            
            
            
        case iState% = stateWaitForLever% then    
            'Waiting for lever press to begin trial
            if stateBegin% = 1 then
                LogStatus("WaitForLever", "Begin waiting for lever press from animal at about " + str$(tNow));
                stateBegin% := 0;
                jsUseExclusion% := 0;  'when we begin waiting for the lever, do not use the exclusion zone (if activated)
            endif
            
            if Answer%(JSDown%) = JSDown% then  'If lever is down (unlike above this is a single-poll, no need for tempAnswer%)
                LogStatus("WaitForLever", "Found lever press at about " + str$(tNow));
                jsUseExclusion% := 1;  'Once lever is down, now use the exclusion zone (if activated)
                if ctTrainingOptions% = 0 then
                    'If delivering reward for lever press only, go straight to reward
                    ChangeStateTo(stateReward%, tNow);
                    nTrialsStarted% += 1;  'Seems redundant with completed in this case but OK
                    nTrialsCompleted% += 1;
                    remainInIdleLoop% := 1;  'deliver reward immediately
                else
                    ChangeStateTo(stateStartTrial%, tNow);
                    remainInIdleLoop% := 1;  'start trial immediately
                endif
                
            endif
            
            
        case iState% = stateStartTrial% then
            'Begin trial
            
            nTrialsStarted% += 1;
            
            'Put timing marker in both eyetracker file, smr file
            if RecordEyeTrackerOutputFile% = 1 then
                docase
                case HBCycle% = 1 then
                    SafeSampleKey("1");
                case HBCycle% = 2 then
                    SafeSampleKey("2");
                case HBCycle% = 3 then
                    SafeSampleKey("3");
                case HBCycle% = 4 then
                    SafeSampleKey("4");
                case HBCycle% = 5 then
                    SafeSampleKey("5");
                case HBCycle% = 6 then
                    SafeSampleKey("6");
                case HBCycle% = 7 then
                    SafeSampleKey("7");
                endcase
                HBCycle% += 1;  'increment HBCycle%
                if HBCycle% = 8 then  'and cycle when necessary
                    HBCycle% := 1;
                endif
                yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
            endif;
            
            'Start trial. Put up fixation point if present, regardless of training step (except 0, which is already in reward state)
            if ctFixationOn% = 1 then
                LogStatus("StartTrial", "Request fixpt at about " + str$(tNow));
                SafeSampleKey("F");
                ChangeStateTo(stateWaitForFixPtOn%, tNow);   
            else
                LogStatus("StartTrial", "Start trial, no fixpt at about " + str$(tNow));
                ChangeStateTo(stateWaitStimOnsetDelay%, tNow);  
            endif        
            
            
        case iState% = stateWaitForFixPtOn% then
            'Waiting for fixation point onset
            if stateBegin% = 1 then
                LogStatus("WaitForFixPtOn", "Begin waiting for fixation point at about " + str$(tNow));
                stateBegin% := 0;
            endif
            
            'We are NOT going to check the lever here, because if it gets released we want to make sure the 
            'fixpt is UP before we request it to go back down to avoid any weirdness 
            if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 0 then
                'Fixation point is up
                LogStatus("WaitForFixPtOn", "Fixpt on at " + str$(tTrigger) + "\n");
                tLastTrigger := tTrigger;
                DrawMonitorScreen(1,0,0,0);	'Draws the location of the fixpt in the Spike2 fixation display window
                anyScreenUp% := 1;  'Note that we have successfully placed SOMETHING on the screen
                if ctRequireFixation% = 1 then
                    ChangeStateTo(stateWaitForAcquisition%, tTrigger);   
                else
                    ChangeStateTo(stateWaitStimOnsetDelay%, tNow);  
                endif            
            endif    
            
            
            
        case iState% = stateWaitForAcquisition% then    
            'Waiting for fixation point acquisition
            if stateBegin% = 1 then
                LogStatus("WaitForAcquisition", "Begin waiting for fixation acquisition at about " + str$(tNow));
                stateBegin% := 0;
            endif
            
            docase
            case Answer%(JSDown%) <> JSDown% then  'If lever in origin (or up, or undefined, or broken), go to abort penalty once fixation point is up
                LogStatus("WaitForAcquisition", "Lever released");
                SafeSampleKey("X");  'Drop fixation point
                WaitForBlankTo(stateAbort%, tNow); 
            case Looking%(xEye,yEye) = 1 then  'Note that Looking%() KNOWS if we're not monitoring fixation for any reason and returns 1
                LogStatus("WaitForAcquisition", "Fixation point acquired at about " + str$(tNow));
                ChangeStateTo(stateWaitStimOnsetDelay%, tNow);  
            case tNow > tStateStart + ctFixAcqTime then
                LogStatus("WaitForAcquisition", "Acquisition window over, abort");
                SafeSampleKey("X");  'Drop fixation point
                WaitForBlankTo(stateAbort%, tNow); 
            endcase
            
            
            
        case iState% = stateWaitStimOnsetDelay% then
            'Waiting through patch onset delay, unless we are in Training Step 1, in which case
            'we are waiting through the fixpt hold and rewarding
            if stateBegin% = 1 then
                if ctTrainingOptions% >= 2 then
                    LogStatus("WaitStimOnsetDelay", "Begin waiting through onset delay at about " + str$(tNow));
                else
                    LogStatus("WaitStimOnsetDelay", "Begin waiting through fixation point hold at about " + str$(tNow));
                endif
                stateBegin% := 0;
            endif
            
            docase
            case Answer%(JSDown%) <> JSDown% then  'If lever is released while waiting, go to abort penalty
                LogStatus("WaitStimOnsetDelay", "Lever released");
                SafeSampleKey("X");  'Drop fixation point
                WaitForBlankTo(stateAbort%, tNow); 
            case Looking%(xEye,yEye) = 0 then  'If fixation broken while waiting, go to abort penalty
                LogStatus("WaitStimOnsetDelay", "Fixation broken");
                SafeSampleKey("X");  'Drop fixation point
                WaitForBlankTo(stateAbort%, tNow);
            case ctTrainingOptions% = 1 and tNow >= tStateStart + ctResponseTime then 'For training option 1, success, reward
                LogStatus("WaitStimOnsetDelay", "Successful hold through delay");
                nTrialsCompleted% += 1;
                jsUseExclusion% := 0;  'remove exclusion zone (if activated)
                if ctFixationOn% = 1 then
                    SafeSampleKey("X");  'Drop fixation point
                    WaitForBlankTo(stateReward%, tNow);
                else
                    ChangeStateTo(stateReward%, tNow);
                endif
            case ctTrainingOptions% >= 2 and tNow >= tStateStart + ctPatchOnsetDelay then  'For all other conditions, request stimulus
                LogStatus("WaitStimOnsetDelay", "Successful hold through delay");
                ChangeStateTo(stateRequestStimulus%,tNow);
                remainInIdleLoop% := 1;  'request stimulus immediately
            endcase
            
            
            
            
        case iState% = stateRequestStimulus% then
            'Request stimulus
            LogStatus("RequestStimulus", "Stimulus requested at about " + str$(tNow));
            SafeSampleKey("S");  'Request stimulus (will be cue[+sample[+target]])
            ChangeStateTo(stateMonitorFrameChannel%,tNow);
            tLastFrameTrigger := tNow;
            remainInIdleLoop% := 1;  'monitor cue frames immediately
            anyScreenUp% := 1;  'Note that we have (presumably) successfully placed SOMETHING on the screen
            
            
        case iState% = stateMonitorFrameChannel% then  'TODO - make sure this makes sense, currently does not allow any
                                                       'response before response window, which is probably not valid in all cases now
            'Watching for the appearance of each cue frame
            
            'On the first time through this state we will do considerably more than we normally do (i.e. just logging)
            if stateBegin% = 1 then
                LogStatus("MonitorFrameChannel", "Begin monitoring frame channel at about " + str$(tNow));
                stateBegin% := 0;
                FrameTriggersFound% := 0;
                
                'Create strings for subsequent sampletexting - Cue sampletext is easy and created on the fly
                'Create string for "sample" sampletext; set drawFlankers% and drawGabors%
                if ctTrainingOptions% >= 3 then 'don't bother to make this if we won't get to the sample epoch
                    'TextForSample$ := "Sample; GaborOri " + Str$(samp1Ori[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(samp2Ori[ctTrialOrder%[nTrialsCompleted%]]) + "; ";
                    TextForSample$ := "Sample; GaborCont " + Str$(samp1Contrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(samp2Contrast%[ctTrialOrder%[nTrialsCompleted%]]) + "; ";
                    'Same for both below
                    TextForSample$ += "CueRectCont " + Str$(samp1CueRectContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(samp2CueRectContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "; ";
                    docase
                    'case flankerIsH% = -1 then
                    '    TextForSample$ += "NoFlankers";  'no flankers - note that this does NOT address contrast of flankers, this means square box (currently there is NO square box)
                    case flankerIsH% = 0 then
                        TextForSample$ += "VertFlankerCont " + Str$(samp1FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(samp2FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]);  'vertical flankers
                    case flankerIsH% = 1 then
                        TextForSample$ += "HorizFlankerCont " + Str$(samp1FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(samp2FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]);  'horizontal flankers
                    endcase

                    if flankerIsH% = -1 then
                        drawFlankers% := 0;
                    else
                        drawFlankers% := 1;
                    endif                
                    drawGabors% := whichLocChange%[ctTrialOrder%[nTrialsCompleted%]]+1;  'drawGabors% value designed to be whichLocChange% + 1
                    
                    'Note that under previous conceptions of the task, we were NOT using a test period during
                    'Training Step 3.  This required two separate IF statements here, one to make the "Sample"
                    'sampletext for Steps 3+, and a second to make the "Test" sampletext for Steps 4+.
                    'With the move to using an "identical" sample AND test period in Step 3, this can now be
                    'accomplished with a single IF (Steps 3+)...so the end of the first IF and the opening of
                    'the second IF can simply be removed.  They are below, for easy re-insertion.
                '
                'endif
                '
                'Create string for "test" sampletext
                'if ctTrainingOptions% >= 4 then 'don't bother to make this if the test epoch is not meaningful...even if it does happen (as in Step 3)
                    
                    
                    'TextForTest$ := "Test; GaborOri " + Str$(test1Ori[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(test2Ori[ctTrialOrder%[nTrialsCompleted%]]) + "; ";
                    TextForTest$ := "Target; GaborCont " + Str$(test1Contrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(test2Contrast%[ctTrialOrder%[nTrialsCompleted%]]) + "; ";
                    'Same for both below
                    TextForTest$ += "CueRectCont " + Str$(test1CueRectContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(test2CueRectContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "; ";
                    docase
                    case flankerIsH% = -1 then
                        TextForTest$ += "NoFlankers; ";  'no flankers - note that this does NOT address contrast of flankers, this means square box
                    case flankerIsH% = 0 then
                        TextForTest$ += "VertFlankerCont " + Str$(test1FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(test2FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "; ";  'vertical flankers
                    case flankerIsH% = 1 then
                        TextForTest$ += "HorizFlankerCont " + Str$(test1FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "," + Str$(test2FlankerContrast%[ctTrialOrder%[nTrialsCompleted%]]) + "; ";  'horizontal flankers
                    endcase

                    docase
                    case validity%[ctTrialOrder%[nTrialsCompleted%]] = -1 then
                        TextForTest$ += "NoChange,";
                    case validity%[ctTrialOrder%[nTrialsCompleted%]] = 0 then
                        TextForTest$ += "Invalid,";
                    case validity%[ctTrialOrder%[nTrialsCompleted%]] = 1 then
                        TextForTest$ += "Valid,";
                    endcase

                    docase
                    case whichLocChange%[ctTrialOrder%[nTrialsCompleted%]] = 0 then
                        TextForTest$ += "NoChange";
                    case whichLocChange%[ctTrialOrder%[nTrialsCompleted%]] = 1 then
                        TextForTest$ += "Loc1Change";
                    case whichLocChange%[ctTrialOrder%[nTrialsCompleted%]] = 2 then
                        TextForTest$ += "Loc2Change";
                    endcase
                endif
                
                
            endif
            'Done with first-time-through matter
            
            
            docase
            case Answer%(JSDown%) <> JSDown% and FrameTriggersFound% <= ctPFsPerPatch%+1 and allowGoDuringCuePatch% = 1 then
                LogStatus("MonitorFrameChannel", "Response during cue patch while cue rect is up, training step 3 only");
                SafeSampleKey("X");  'Drop fixation point
                leverReleased% := 1;
                WaitForBlankTo(stateTrialCompleted%, tNow);
            case Answer%(JSDown%) <> JSDown% and FrameTriggersFound% >= ctPFsPerPatch%+2 and ctTrainingOptions% = 3 then  'If lever is released during sample or later when training=3, this is a response, end trial, go to TrialCompleted
                LogStatus("MonitorFrameChannel", "Response during sample period");
                SafeSampleKey("X");  'Drop fixation point
                leverReleased% := 1;
                WaitForBlankTo(stateTrialCompleted%, tNow);
            case Answer%(JSDown%) <> JSDown% and FrameTriggersFound% >= ctPFsPerPatch%+4 and ctTrainingOptions% >= 4 then  'If lever is released during test or later when training=4, this is a response, end trial, go to TrialCompleted
                LogStatus("MonitorFrameChannel", "Response during test period");
                SafeSampleKey("X");  'Drop fixation point
                leverReleased% := 1;
                WaitForBlankTo(stateTrialCompleted%, tNow);
            case Answer%(JSDown%) <> JSDown% then  'If lever is released while stimulus is playing, go to abort penalty
                LogStatus("MonitorFrameChannel", "Lever released");
                SafeSampleKey("X");  'Drop fixation point
                WaitForBlankTo(stateAbort%, tNow);
            case Looking%(xEye,yEye) = 0 then  'If fixation broken while stimulus is playing, go to abort penalty
                LogStatus("MonitorFrameChannel", "Fixation broken");
                SafeSampleKey("X");  'Drop fixation point
                WaitForBlankTo(stateAbort%, tNow); 
            case View(DataWindow%).FindPulseUp%(FrameChannel%, tLastFrameTrigger+tic, tTrigger, tFall) = 1 then
                'Found a trigger, let's figure out what it is, by counting
                FrameTriggersFound% += 1;
                'printlog("Frame trigger #" + Str$(FrameTriggersFound%) + " found\n");
                docase
                case FrameTriggersFound% <= ctPFsPerPatch% then 'This pulse indicates a cue patch-frame up
                    LogStatus("MonitorFrameChannel", "Cue Frame #" + Str$(FrameTriggersFound%) + " of " + Str$(ctPFsPerPatch%) + " found at " + Str$(tTrigger));
                    if FrameTriggersFound% = 1 then
                        SampleText("Cue Frame #1, trial " + Str$(nTrialsCompleted%+1) + ", percent color 1 is " + Str$(cueDotPct[ctTrialOrder%[nTrialsCompleted%]]),tTrigger);  'on the first patch-frame, indicate dot percentage
                        DrawMonitorScreen(0,1,0,0);  'Draw cue on monitor screen
                    else
                        SampleText("Cue Frame #" + Str$(FrameTriggersFound%) + ", trial " + Str$(nTrialsCompleted%+1),tTrigger);  'let's sampletext every patch-frame in the cue
                    endif
                case FrameTriggersFound% = ctPFsPerPatch%+1 and ctPatchToSampleDelay = 0 and ctTrainingOptions% > 2 then  'This pulse indicates cue down AND sample up (if step 2, this is just the end of stimulus)
                    FrameTriggersFound% += 1;  'Increment frame triggers since there are not separate cue off and sample on
                    LogStatus("MonitorFrameChannel", "Cue off and sample on at " + Str$(tTrigger));
                    SampleText(TextForSample$,tTrigger);
                    DrawMonitorScreen(0,-1,1,drawFlankers%);  'Remove cue on monitor screen, draw others
                    if ctTrainingOptions% = 3 then 'cue is down, allow release on training option 3
                        jsUseExclusion% := 0;  'remove exclusion zone, response is allowed (if activated)
                    endif
                case FrameTriggersFound% = ctPFsPerPatch%+1 then 'This pulse indicates cue down; enter hold period for training option 2
                    LogStatus("MonitorFrameChannel", "Cue off at " + Str$(tTrigger));
                    SampleText("Cue Off, trial " + Str$(nTrialsCompleted%+1),tTrigger);
                    DrawMonitorScreen(0,-1,0,0);  'Remove cue on monitor screen
                    'Break out after cues for training option 2
                    if ctTrainingOptions% = 2 then 'cue is down, allow release on training option 2
                        ChangeStateTo(stateResponseWindow%,tTrigger);
                        jsUseExclusion% := 0;  'remove exclusion zone, response is allowed (if activated)
                    endif        
                case FrameTriggersFound% = ctPFsPerPatch%+2 then 'This pulse indicates sample on
                    LogStatus("MonitorFrameChannel", "Sample on at " + Str$(tTrigger));
                    SampleText(TextForSample$,tTrigger);
                    DrawMonitorScreen(0,0,1,drawFlankers%);
                    if ctTrainingOptions% = 3 then 'cue is down, allow release on training option 3
                        jsUseExclusion% := 0;  'remove exclusion zone, response is allowed (if activated)
                    endif
                case FrameTriggersFound% = ctPFsPerPatch%+3 and ctSampleToTargetDelay = 0 then  'This pulse indicates sample off AND target on
                    FrameTriggersFound% += 1;  'Increment frame triggers since there are not separate sample off and target on
                    LogStatus("MonitorFrameChannel", "Sample off and target on at " + Str$(tTrigger));
                    SampleText(TextForTest$,tTrigger);
                    DrawMonitorScreen(0,0,drawGabors%,drawFlankers%);
                    jsUseExclusion% := 0;  'remove exclusion zone, response is allowed (if activated)
                case FrameTriggersFound% = ctPFsPerPatch%+3 then 'This pulse indicates sample off; enter hold period for training option 3
                    LogStatus("MonitorFrameChannel", "Sample off at " + Str$(tTrigger));
                    SampleText("Sample Off, trial " + Str$(nTrialsCompleted%+1),tTrigger);
                    DrawMonitorScreen(0,0,-1,-1);
                    'Break out after sample for training option 3 - no, we actually need to wait through the target as well as the design has changed
                    'if ctTrainingOptions% = 3 then 'we need to wait through the delay period (if any) then wait for release
                    '    ChangeStateTo(stateResponseWindow%,tTrigger);
                    'endif 
                case FrameTriggersFound% = ctPFsPerPatch%+4 then 'This pulse indicates test on
                    LogStatus("MonitorFrameChannel", "Test on at " + Str$(tTrigger));
                    SampleText(TextForTest$,tTrigger);
                    DrawMonitorScreen(0,0,drawGabors%,drawFlankers%);
                    jsUseExclusion% := 0;  'remove exclusion zone, response is allowed (if activated)
                case FrameTriggersFound% = ctPFsPerPatch%+5 then 'This pulse indicates test off, enters response window for training option 4
                    LogStatus("MonitorFrameChannel", "Test off at " + Str$(tTrigger));
                    SampleText("Test Off, trial " + Str$(nTrialsCompleted%+1),tTrigger);
                    DrawMonitorScreen(0,0,-1,-1);  'remove gabors and flankers from monitor screen
                    ChangeStateTo(stateResponseWindow%,tTrigger);
                endcase
                tLastFrameTrigger := tFall;                    
            case tNow > tStateStart + ctPatchDur + ctPatchToSampleDelay + abs(ctSampleDuration) + ctSampleToTargetDelay + ctTargetDuration[ctTrialOrder%[nTrialsCompleted%]] + ctResponseTime + 1 then 
                'just in case things go all wrong, we should bail after one second too long
                'note that we should expect to NOT wait through the response window, so there's actually extra time, can't hurt
                'double note that ctSampleDuration is now -1 for training step 2, this causes addition problems so we ABS() it
                message("Waited for one second beyond end of stimuli, but did not find all expected triggers!  Quitting!");
                Stop%();
            endcase
            
            
            
            
        case iState% = stateResponseWindow% then
            'For training options 2 and higher, we have reached the response window
            'The fixation point is up during this window, and will be taken down at the end.
            'A response in this window is only appropriate if there has been a change 
            'in the target stimulus, otherwise response should be withheld (including
            'all training options with no target)
            if stateBegin% = 1 then
                LogStatus("ResponseWindow", "Entered response window at about " + str$(tNow));
                stateBegin% := 0;
                leverReleased% := 0;  'reset
                if jsUseExclusion% = 1 then
                    message("jsUseExclusion% is 1, should always be 0 in stateResponseWindow!  Tell Jeff!");
                    jsUseExclusion% := 0;   'what with the message, I don't think this would matter, but...obviously could just printlog the message but we'd never see it. Once all is tested this will be unnecessary.
                endif
            endif
            
            docase
            case Looking%(xEye,yEye) = 0 then  'If fixation broken during response window, go to abort penalty
                LogStatus("ResponseWindow", "Fixation broken");
                SafeSampleKey("X");  'Drop fixation point
                WaitForBlankTo(stateAbort%, tNow); 
            case Answer%(JSDown%) <> JSDown% then  'If lever is released during response window, end trial, go to TrialCompleted
                LogStatus("ResponseWindow", "Lever released");
                SafeSampleKey("X");  'Drop fixation point
                leverReleased% := 1;
                WaitForBlankTo(stateTrialCompleted%, tNow);
            case tNow >= tStateStart + ctResponseTime then  'If lever is held through entire window, end trial, go to TrialCompleted
                LogStatus("ResponseWindow", "Window closed");
                SafeSampleKey("X");  'Drop fixation point
                leverReleased% := 0;
                WaitForBlankTo(stateTrialCompleted%, tNow);
            endcase
            
         
            
        case iState% = stateTrialCompleted% then    
            'Trial is complete, advance and reward if appropriate
            nTrialsCompleted% += 1;
            LogStatus("TrialComplete", "Trial " + Str$(nTrialsCompleted%) + " complete at about " + Str$(tNow) + "\n");
            
            DrawMonitorScreen(-1,-1,-1,-1);  'remove everything from monitor screen
            
            'We can only get to this state if we are in ctTrainingOptions% >= 2, in all cases we need to advance
            LogStatus("TrialComplete", "Advancing stimulus at about " + str$(tNow) + "\n");
            SafeSampleKey("a");  'Advance stimulus
            tITIStart := tNow;  'Set start time of ITI now, "X" has already been called
            
            docase
            'Training Step 2 is a simple hold through cue patches
            case ctTrainingOptions% < 3 and leverReleased% = 0 then  'Held lever through cue training, correct
                LogStatus("TrialComplete", "Successful hold of lever (training)");
                ChangeStateTo(stateReward%,tNow);
                remainInIdleLoop% := 1;  'start reward immediately 
            case ctTrainingOptions% < 3 and leverReleased% = 1 then  'Released lever during cue training, incorrect
                LogStatus("TrialComplete", "Unsuccessful trial, released lever (training)");
                ChangeStateTo(stateCheckAdvance%,tNow);
            'Training Step 3 has a different reward structure (hold for "cue-matched" color), early response during cue patch, when allowed, will be dealt with seamlessly here
            case ctTrainingOptions% = 3 and leverReleased% = 0 and validity%[ctTrialOrder%[nTrialsCompleted%-1]] >= 0 then 'Hit - any non-negative validity requires a response
                LogStatus("TrialComplete", "Hit");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": Hit");
                Hits% += 1;
                ChangeStateTo(stateReward%,tNow);
                remainInIdleLoop% := 1;  'start reward immediately 
            case ctTrainingOptions% = 3 and leverReleased% = 1 and validity%[ctTrialOrder%[nTrialsCompleted%-1]] >= 0 then 'Miss
                LogStatus("TrialComplete", "Miss");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": Miss");
                Misses% += 1;
                ChangeStateTo(stateCheckAdvance%,tNow);
                ctThisITI := ctITI + ctMissPenalty;
            case ctTrainingOptions% = 3 and leverReleased% = 1 and validity%[ctTrialOrder%[nTrialsCompleted%-1]] = -1 then 'Correct Rejection
                LogStatus("TrialComplete", "Correct Rejection");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": Correct Rejection");
                CRs% += 1;
                ChangeStateTo(stateReward%,tNow);
                remainInIdleLoop% := 1;  'start reward immediately
            case ctTrainingOptions% = 3 and leverReleased% = 0 and validity%[ctTrialOrder%[nTrialsCompleted%-1]] = -1 then 'False Alarm
                LogStatus("TrialComplete", "False Alarm");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": False Alarm");
                FAs% += 1;
                ChangeStateTo(stateCheckAdvance%,tNow);
                ctThisITI := ctITI + ctFAPenalty;
            'Training Step 4 and beyond are go-on-any-change, hold-on-no-change
            case leverReleased% = 1 and whichLocChange%[ctTrialOrder%[nTrialsCompleted%-1]] > 0 then 'Hit
                LogStatus("TrialComplete", "Hit");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": Hit");
                Hits% += 1;
                ChangeStateTo(stateReward%,tNow);
                remainInIdleLoop% := 1;  'start reward immediately 
            case leverReleased% = 0 and whichLocChange%[ctTrialOrder%[nTrialsCompleted%-1]] > 0 then 'Miss
                LogStatus("TrialComplete", "Miss");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": Miss");
                Misses% += 1;
                ChangeStateTo(stateCheckAdvance%,tNow);
                ctThisITI := ctITI + ctMissPenalty;
            case leverReleased% = 0 and whichLocChange%[ctTrialOrder%[nTrialsCompleted%-1]] = 0 then 'Correct Rejection
                LogStatus("TrialComplete", "Correct Rejection");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": Correct Rejection");
                CRs% += 1;
                ChangeStateTo(stateReward%,tNow);
                remainInIdleLoop% := 1;  'start reward immediately
            case leverReleased% = 1 and whichLocChange%[ctTrialOrder%[nTrialsCompleted%-1]] = 0 then 'False Alarm 
                LogStatus("TrialComplete", "False Alarm");
                SampleText("Trial " + Str$(nTrialsCompleted%) + ": False Alarm");
                FAs% += 1;
                ChangeStateTo(stateCheckAdvance%,tNow);
                ctThisITI := ctITI + ctFAPenalty;
            endcase         
            
            
            
        case iState% = stateReward% then
            'For now being simple - if we get into the reward state, deliver a reward and move on!
            'There's no maintain fixation option, because the animal has to press, I guess I KNOW Henry is going to request "maintain" but it ain't happening to start
            'Important to assume that 'X' has already been given; some training steps don't use the VSG so can't 'X' here
            LogStatus("Reward", "Reward delivered at about " + str$(tNow) + "\n");
            DefaultReward();
            tReward := View(DataWindow%).MaxTime();  'use tReward so the reward wait is as precise as possible
            tITIStart := tReward;  'include reward wait in ITI, slightly updating to account for any delay in reward delivery
            TotalRewards% += 1;
            ChangeStateTo(stateRewardWait%,tReward);
            
            
            
        case iState% = stateRewardWait% then
            'Waiting for reward delivery to end
            if stateBegin% = 1 then
                LogStatus("RewardWait", "Begin waiting for reward delivery to complete at " + str$(tReward));
                stateBegin% := 0;
            endif
            
            if tNow > tReward + ctRewardDurSec then
                LogStatus("RewardWait", "Reward delivery completed at about " + str$(tNow) + "\n");
                if ctTrainingOptions% >= 2 then
                    ChangeStateTo(stateCheckAdvance%,tNow);
                else
                    ChangeStateTo(stateITI%,tNow);  'there is no advance for early training stages, just repeated reward delivery
                endif;
            endif
            
            
               
        case iState% = stateCheckAdvance% then
            'Checking that previously-requested advance has occurred
            if stateBegin% = 1 then
                LogStatus("CheckAdvance", "Checking that advance has occured at about " + str$(tNow));
                stateBegin% := 0;
            endif
            
            'The Advance channel will toggle, we don't care whether the edge is up or down
            if FindEdge%(AdvanceChannel%, tLastAdvance+tic, tAdvance) > -1 then
                LogStatus("CheckAdvance", "Advance occured at " + str$(tAdvance));
                ChangeStateTo(stateITI%,tNow);
                tLastAdvance := tAdvance;
            endif
            
            
            
        case iState% = stateITI% then
            'Waiting through intertrial interval
            if stateBegin% = 1 then
                LogStatus("ITI", "Began waiting through ITI at about " + str$(tNow));
                stateBegin% := 0;
            endif
        
            'Here is a good place to check and see if we are done!
            if nTrialsCompleted% >= nTrials% then
                LogStatus("ITI", "All Trials Completed!");
                Stop%();
            endif
        
            if tNow > tITIStart + ctThisITI then
                LogStatus("ITI", "ITI complete at about " + str$(tNow));
                ChangeStateTo(stateEnforceLeverInOrigin%,tNow);
                ctThisITI := ctITI;  'Reset ITI to standard
            endif
            
            
            
        case iState% = stateAbort% then  
            'Trial aborted, do not reward or advance          
            LogStatus("Abort", "Abort at about " + str$(tNow)); 
            
            DrawMonitorScreen(-1,-1,-1,-1);  'remove everything from monitor screen
            
            nTrialsAborted% += 1;
            
            'Wait through abort time, if any, then go to stateITI%
            if tNow >= tStateStart + ctAbortPenalty then
                LogStatus("Abort", "Abort wait complete at about " + str$(tNow)); 
                tITIStart := tNow;
                ChangeStateTo(stateITI%,tNow);
            endif
            
            
            
        'Special case - can only get here using WaitForBlankTo(), which specifies the next state to go to
        case iState% = stateWaitForBlank% then  
            'Waiting for screen blank
            if stateBegin% = 1 then
                LogStatus("WaitForBlank", "Began waiting for blank screen at about " + str$(tNow));
                stateBegin% := 0;
            endif
            
            docase
            case anyScreenUp% = 0 then
                'There's no screen to come down
                LogStatus("WaitForBlank", "No screen to blank, moving forward at about " + str$(tNow));
                DrawMonitorScreen(-1,-1,-1,-1);	'remove everything from spike 2 monitor screen
                ChangeStateTo(nextState%,tNow);
            case View(DataWindow%).FindFallingEdge%(StimChannel%, tStateStart, tTrigger) = 1 or View(DataWindow%).FindFallingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 1 then
                'Fixation point is off
                tLastTrigger := tTrigger;
                LogStatus("WaitForBlank", "Blank screen at " + str$(tTrigger));
                DrawMonitorScreen(-1,-1,-1,-1);	'remove everything from spike 2 monitor screen
                anyScreenUp% := 0;  'Reset anyScreenUp%
                ChangeStateTo(nextState%,tNow);
            endcase
            
            
        endcase
        
    wend 'end while RemainInIdleLoop% = 1
    
    
    return iStatus%;
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
    if iState% = stateWaitForBlank% then  'this is not allowed and is a coding error, must use WaitForBlankTo()
        message("Coding error - disallowed ChangeStateTo(stateWaitForBlank%,...)!  Quitting!");
        halt;  'Coding error, this won't happen live, we'll catch it in testing if we accidentally do it 
    endif
    stateBegin% := 1;  'Reset for next state
	if tStart > 0 then 
        tStateStart := tStart; 
    endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'WaitForBlankTo() - this is essentially the same as ChangeStateTo(), except it goes to an intermediate
'state which waits for a screen blank and THEN goes to the specified state.  stateWaitForBlank is an unusual
'state in that it can be called in a lot of contexts, which justifies an easier way of keeping track of
'which state we want to go to next
proc WaitForBlankTo(stateTo%, tStart)
	nextState% := stateTo%;
    stateBegin% := 1;  'Reset for next state
    iState% := stateWaitForBlank%;
	if tStart > 0 then 
        tStateStart := tStart; 
    endif;
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
    var key$;
    var primaryTxt$;
    var secondaryTxt$;
    
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
    
	SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    DoSampleAutoName(key$,"ct","ct",primaryTxt$,secondaryTxt$);   
    SampleAutoFile(1);  'Enable automatic file naming
    
    ' Text marks make extraction easier
    SampleTextMark(200);  'Channel 30 is textmark channel
    

	'----Event Channel recording definitions----
    'Just make these channels even in the event we don't need them, messing with success and all that
    SampleEvent(FrameChannel%, 0, 2, 3600);
    SampleComment$(FrameChannel%,"Frame");
    SampleTitle$(FrameChannel%,"Frame");
    
    SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
    SampleComment$(ReadyChannel%,"Ready");
    SampleTitle$(ReadyChannel%,"Ready");
    
    SampleEvent(FixationPointChannel%, 2, 2, 3600); 'Trigger channel, level
    SampleComment$(FixationPointChannel%,"Fixpt");
    SampleTitle$(FixationPointChannel%,"Fixpt");
    
    
    
    if UseTwo1401s% = 1 then  'currently disabled above, can't get there so just leaving the code intact
        
        '            SampleEvent(FrameSlaveChannel%, 4, 2, 3600);
        '            SampleComment$(FrameSlaveChannel%,"Frame-Slave");
        '            SampleTitle$(FrameSlaveChannel%,"Frame-Slave");
        '            
        '            SampleEvent(ReadySlaveChannel%, 5, 2, 3600); 'Trigger channel, level
        '            SampleComment$(ReadySlaveChannel%,"Ready-Slave");
        '            SampleTitle$(ReadySlaveChannel%,"Ready-Slave");
        '            
        '            SampleEvent(StimSlaveChannel%, 7, 2,3600); 'Trigger channel, level
        '            SampleComment$(StimSlaveChannel%,"Stim-Slave");
        '            SampleTitle$(StimSlaveChannel%,"Stim-Slave");
        
    endif
 
    
    'Create a stim channel
    SampleEvent(StimChannel%, 3, 2, 3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
    'Create an advance channel - we currently believe it is on port 4, have to confirm
    SampleEvent(AdvanceChannel%, 4, 2, 3600); 'Trigger channel, level
	SampleComment$(AdvanceChannel%,"Advance");
	SampleTitle$(AdvanceChannel%,"Advance");
    
    'Create joystick channel, ALL scenarios will use the joystick 
    printlog("Joy channel is %d and joystick port is %d\n", JoyChannel%, GetJoystickPort%());
    var ok%;
    ok%:=SampleWaveform(JoyChannel%, GetJoystickPort%(), 1000);
    SampleTitle$(JoyChannel%, JoystickPortLabel$);
    if ok% < 0 then
        printlog("Error opening joystick channel: %s\n",Error$(ok%));
    endif;
    
    
    'Possible digital marker channels.  Opto/INTAN have been removed as they seem super unlikely here, can be added back in from Freeviewer, etc.
    docase
    case UseTwo1401s% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Timing");  'Digital marker is by definition channel 32
    case RecordEyeTrackerOutputFile% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"EyeFilePulse");  'Digital marker is by definition channel 32
    endcase
       
    if ctRequireFixation% <> 0 then  'don't set up eye channels unless we are looking at eye position
        'ctRequireFixation% of -1 means display fixation position but don't require LookingCue%()
        'Set up eye channels 
        SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
        SampleTitle$(XChannel%,EyeXPortLabel$);
        SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
        SampleTitle$(YChannel%,EyeYPortLabel$);
    endif
    
    
    if UtilityPort% > -1 then
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);       
        SampleTitle$(UtilityChannel%,UtilityPortLabel$);
    endif;

    
    if UseTwo1401s% = 1 then
        SampleEvent(TimingChannel%, 6, 2, 3600); 'Trigger channel, level
        SampleComment$(TimingChannel%,"Handshake");
        SampleTitle$(TimingChannel%,"Hndshk");
    endif;

    
    '----Set up "spiking" Electrode Channels----
    SetUpElectrodeConfiguration(ctNWavemarks%,ExcludedChans%[]);
    
    
	if UseTwo1401s% = 0 then
        SampleSequencer(script$ + "Tuning.pls");
    else
        SampleSequencer(script$ + "TuningSendTrigger.pls");
    endif;

	DoSampleOptimise();
	SampleMode(1); 'Continuous sampling
    
end;




proc InitializeWindows()
    
    var index%;
    var twopi;
    twopi := 2.0*4.0*ATan(1.0);
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);  'show spike shape setup dialog
    printlog("datawindow is %d\n",dataWindow%);
	Window(0,48,100,95);
	XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
    
    
    
    
    'Open an XY view to display on screen stimuli, eye position
    XYWindow% := FileNew(12);  'the XY view has a default channel - this will hold the location of the animal's gaze
    XRange(-30,30);
    YRange(-2,-30,30);
    XYDrawMode(0,5,0);
    WindowVisible(1);
    Window(0, 0, 100, 47);
    XYColour(1,16);  'red
    XYSize(1,-1);
    
    
    'Create a new channel in the XY view to show the monitor's location, plot this no matter what
    iMonitorChannel% := XYSetChan(0);
    XYColour(iMonitorChannel%,13);  'blue
    XYDrawMode(iMonitorChannel%,3,1);
    XYJoin(iMonitorChannel%,2);
    XYAddData(iMonitorChannel%,-screenXDeg,-screenYDeg);
    XYAddData(iMonitorChannel%,screenXDeg,-screenYDeg);
    XYAddData(iMonitorChannel%,screenXDeg,screenYDeg);
    XYAddData(iMonitorChannel%,-screenXDeg,screenYDeg);
    
    
    'Create a new channel in the XY view to display the fixation point, if fixation point is on
    if ctFixationOn% = 1 then
        iFixptChannel% := XYSetChan(0);
        XYColour(iFixptChannel%,16);  'red
        if ctRequireFixation% <> 0 then
            iFixptWindowChannel% := XYSetChan(0);
            XYColour(iFixptWindowChannel%,16);  'red, I guess
            XYDrawMode(iFixptWindowChannel%,2,0);  'Make points invisible
            XYDrawMode(iFixptWindowChannel%,3,1);  'Dotted line
            XYJoin(iFixptWindowChannel%,1);
        endif
    endif

    'Calcuate the "cue" window in any case because we use it for fixation display as well
    'WindowRadius is updated in the dialog code, and corresponds to the size of the cue patch, +/- a settable value
    for index% := 0 to 35 do
        CueWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
        CueWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
    next;
    

    'Create a new channel in the XY view to display the CueWindow if a cue patch is present
    if ctTrainingOptions% >= 2 then      
        
        'Create a new channel in the XY view to display the cue stimulus
        iCueWindowChannel% := XYSetChan(0);
        XYColour(iCueWindowChannel%,13);  'blue
        XYDrawMode(iCueWindowChannel%,2,1);
        XYJoin(iCueWindowChannel%,1);
        'Draw the cue window, no not yet
        'XYAddData(iCueWindowChannel%, CueWindowX[], CueWindowY[]);
    endif;
    
    
 
    'There are no saccade answer windows! Joystick response only! 
    
    
    'Create new channels in the XY view to display the gabor/flankers, if they are present
    if ctTrainingOptions% > 2 then
        'The width/height values that we use correspond to the W/H of the BOX around the gabor, but the 
        'mask will fade things out before that; to make the screen display look reasonable we need to
        'implement a divisive factor that will make the display in Spike2 look not silly
        var dispFac := 1.5;  'Trying 1.5 to start, we'll just have to adjust by eye if this isn't great
        
        var xOffset;  'These values will help us account for the positions of the flankers
        var yOffset;
        
        'Set the radii of the gabor/flanker patches
        mainW := ctGaborWDeg/(2*dispFac);
        mainH := ctGaborHDeg/(2*dispFac);
        
        'Set the X/Y offsets of the flanker patches
        if ctPanelIsHoriz% = 1 then
            'Horizontal panels will have X flanker offsets
            xOffset := ctGaborWDeg;
            yOffset := 0;
        else
            'Vertical panels will have Y flanker offsets
            xOffset := 0;
            yOffset := ctGaborHDeg;
        endif
        

        'Create new channels in the XY view to display the gabor/flanker windows
        'reuse FixationX, FixationY
        'Gabor 1 stimulus window, ctGaborXLoc etc. coordinates are now literal
        for index% := 0 to 35 do
            Gabor1WindowX[index%] := ctGaborXLoc + (mainW * Cos(index% * twopi/36.0));
            Gabor1WindowY[index%] := ctGaborYLoc + (mainH * Sin(index% * twopi/36.0));
        next;
        iDisplayWindowGabor1% := XYSetChan(0);
        XYColour(iDisplayWindowGabor1%,13);  'blue
        XYDrawMode(iDisplayWindowGabor1%,2,1);
        XYJoin(iDisplayWindowGabor1%,1);
        'Draw the gabor window, no not yet
        'XYAddData(iDisplayWindowGabor1%, Gabor1WindowX[], Gabor1WindowY[]);
        
        'Gabor 2 stimulus window
        for index% := 0 to 35 do
            Gabor2WindowX[index%] := ctGabor2XLoc + (mainW * Cos(index% * twopi/36.0));
            Gabor2WindowY[index%] := ctGabor2YLoc + (mainH * Sin(index% * twopi/36.0));
        next;
        iDisplayWindowGabor2% := XYSetChan(0);
        XYColour(iDisplayWindowGabor2%,13);  'blue
        XYDrawMode(iDisplayWindowGabor2%,2,1);
        XYJoin(iDisplayWindowGabor2%,1);
        'Draw the gabor window, no not yet
        'XYAddData(iDisplayWindowGabor2%, Gabor2WindowX[], Gabor2WindowY[]);
        
        
        'Flanker 1 stimulus window
        'Note that one of xOffset or yOffset will be 0 based on whether panel is horiz/vert, so we can just
        'add/subtract both, the zeroed one won't contribute.  Nice and easy!
        for index% := 0 to 35 do
            Flanker1WindowX[index%] := ctGaborXLoc + xOffset + (mainW * Cos(index% * twopi/36.0));
            Flanker1WindowY[index%] := ctGaborYLoc + yOffset + (mainH * Sin(index% * twopi/36.0));
        next;
        iDisplayWindowFlanker1% := XYSetChan(0);
        XYColour(iDisplayWindowFlanker1%,13);  'blue
        XYDrawMode(iDisplayWindowFlanker1%,2,1);
        XYJoin(iDisplayWindowFlanker1%,1);
        'Draw the flanker window, no not yet
        'XYAddData(iDisplayWindowFlanker1%, Flanker1WindowX[], Flanker1WindowY[]);
        
        'Flanker 2 stimulus window
        for index% := 0 to 35 do
            Flanker2WindowX[index%] := ctGaborXLoc - xOffset + (mainW * Cos(index% * twopi/36.0));
            Flanker2WindowY[index%] := ctGaborYLoc - yOffset + (mainH * Sin(index% * twopi/36.0));
        next;
        iDisplayWindowFlanker2% := XYSetChan(0);
        XYColour(iDisplayWindowFlanker2%,13);  'blue
        XYDrawMode(iDisplayWindowFlanker2%,2,1);
        XYJoin(iDisplayWindowFlanker2%,1);
        'Draw the flanker window, no not yet
        'XYAddData(iDisplayWindowFlanker2%, Flanker2WindowX[], Flanker2WindowY[]);
        
        'Flanker 3 stimulus window
        for index% := 0 to 35 do
            Flanker3WindowX[index%] := ctGabor2XLoc + xOffset + (mainW * Cos(index% * twopi/36.0));
            Flanker3WindowY[index%] := ctGabor2YLoc + yOffset + (mainH * Sin(index% * twopi/36.0));
        next;
        iDisplayWindowFlanker3% := XYSetChan(0);
        XYColour(iDisplayWindowFlanker3%,13);  'blue
        XYDrawMode(iDisplayWindowFlanker3%,2,1);
        XYJoin(iDisplayWindowFlanker3%,1);
        'Draw the flanker window, no not yet
        'XYAddData(iDisplayWindowFlanker3%, Flanker3WindowX[], Flanker3WindowY[]);
        
        'Flanker 4 stimulus window
        for index% := 0 to 35 do
            Flanker4WindowX[index%] := ctGabor2XLoc - xOffset + (mainW * Cos(index% * twopi/36.0));
            Flanker4WindowY[index%] := ctGabor2YLoc - yOffset + (mainH * Sin(index% * twopi/36.0));
        next;
        iDisplayWindowFlanker4% := XYSetChan(0);
        XYColour(iDisplayWindowFlanker4%,13);  'blue
        XYDrawMode(iDisplayWindowFlanker4%,2,1);
        XYJoin(iDisplayWindowFlanker4%,1);
        'Draw the flanker window, no not yet
        'XYAddData(iDisplayWindowFlanker4%, Flanker4WindowX[], Flanker4WindowY[]);
                
    endif;
    
    
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
    if UseTwo1401s% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    ToolbarSet(6,"Select Wavemarks",SelectWavemarkDialog%);   'this may be an older unused functionality??
    ToolbarSet(7,"Adjust Joystick",CallJoystickConfigDialogUD%);
	ToolbarSet(8,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    fp$ := SetPathToScriptDirectory$();
    
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();    
    
    StartSecondInstanceOfSpike2();
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work
    

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    var Opener$;
    var ProgName$;
    var RemoteArg$ := "";     'Extra arg needed if vsg is not on local machine...
    var BGColor$;
    var Dist2Screen$;
    var TriggerPort$;
    var FixationCrossArg$;
    var CueColorArg$;
    var CueRectArg$;
    var Verbose$ := " -v ";  'For now, verbose is always on 
    var i%, j%, k%, m%, n%, p%, q%;
    var startSecs := 5;
    var cmdLine$;
    var CSVFileName$;
    var CSVHandle%;
    var dotSupplyFileName$;
    var dotSupplyHandle%;
    var count%;
    var eof%;
    var dotPctFileLen%;
    var s;
    var xy[ctDotsPerPF%*ctPFsPerPatch%][2];
    var xyVector[ctDotsPerPF%*2];  'construct anew for each frame
    var color%[ctDotsPerPF%*ctPFsPerPatch%];  'This variable is actually unused, but is filled by GenerateConteCuePatchColors() and we may as well keep it
    var numColor%[ctPFsPerPatch%][2];
    var OK%;
    var myRand%;
    'var sampleContrast%;
    var sampleOri;
    
    'Variables used for doing the massive counterbalance
    'Count variables hold the number of (not necessarily different) states used for the counterbalance
    'For example, if we want 10% invalid trials, we would eventually set nCueType% to 10
    var nCueDotPct% := 1;   'Default 1 cue dot percentage
    'var nOri% := 1;   'Default 1 sample orientation value
    var nCont% := 1;  'Default 1 sample contrast value
    var nDist% := 1;  'Default 1 distractor condition
    var nCh% := 1;    'Default 1 change contrast value
    var nCueType% := 1; 'Default 1 validity condition (cued,uncued,no-change)
    
    'Value variables hold the actual distinct values...they will be unlikely to reach 100 values
    'For example, if we want 10% uncued trials, 10% no-change, and 80% cued, we would fill cueType%[] with [0 -1 1 1 1 1 1 1 1 1]
    var cueDotPctLocal[100];
    'var ori[100];
    'var oriCh[100];
    var cont%[100];
    var contCh%[100];
    var cueType%[100];
    var dist%[100];
    
    var contFact1%;  'these are used to hold the contrast factors from the main dialog, assigning these should simplify looping
    var contFact2%;
    
    
    
    
    
    'It only makes sense to create and write the CSV and DotSupply files if we will be using them, so only for training options of 2 or higher
    if ctTrainingOptions% >= 2 then

        'Create filenames of files we will eventually write
        CSVFileName$ := GetScriptDir$(0)+"..\\..\\ConteCSVFile.csv"; 'This is a comma separated value file which specifies most details of each trial
        dotSupplyFileName$ := GetScriptDir$(0)+"..\\..\\ConteDotsFile.bin";  'This is a binary file which holds dot locations for the cue
        
        'Create the big set of counterbalanced trials for this experimental session
        'Start by getting values to use for the counterbalance, based on which training step we are at
        n% := nTrialsPerDataPoint%; 
        
        'For all ctTrainingOptions = 2 or higher, determine number of cue dot percentages specified
        nCueDotPct% := String2FloatArray%(ctDotPctString$,cueDotPctLocal[]);
        printlog("Number of cue values found is %d\n",nCueDotPct%);
        printlog("Cue values found are %f\n",cueDotPctLocal[0:nCueDotPct%]);
        
        'For ctTrainingOptions = 3 (introduce single empty cue rect) and 4/5, set cue type WITHOUT uncued (invalid)
        if ctTrainingOptions% >= 3 and ctTrainingOptions% < 6 then
            nCueType% := ctCountCued% + ctCountNoChange%;  'there are no uncued (invalid) trials
            for i% := 0 to ctCountCued%-1 do
                cueType%[i%] := 1;
            next
            for i% := 0 to ctCountNoChange%-1 do
                cueType%[i%+ctCountCued%] := -1;
            next
        endif;
        
        'For ctTrainingOptions = 4 (introduce single filled cue rect) and 5/6, set contrast and distractors
        if ctTrainingOptions% >= 4 then
            'nOri% := String2FloatArray%(ctSampleOriString$,ori[]);
            nCont% := String2IntArray%(ctSampleContString$,cont%[]);
            nDist% := ctNDistractorOn% + ctNDistractorOff%;
            for i% := 0 to ctNDistractorOn%-1 do
                dist%[i%] := 1;
            next
            for i% := 0 to ctNDistractorOff%-1 do
                dist%[i%+ctNDistractorOn%] := 0;
            next;  
        endif;
        
        'For ctTrainingOptions = 5 (introduce second stimulus) and 6, set contrast changes
        if ctTrainingOptions% >= 5 then
            'nCh% := String2FloatArray%(ctOriChangeString$,oriCh[]);
            nCh% := String2IntArray%(ctContChangeString$,contCh%[]);
        endif
        
        
        'For ctTrainingOptions = 6 (full task, include invalid), set cue type WITH uncued (invalid)
        if ctTrainingOptions% = 6 then
            nCueType% := ctCountCued% + ctCountUncued% + ctCountNoChange%;
            for i% := 0 to ctCountCued%-1 do
                cueType%[i%] := 1;
            next
            for i% := 0 to ctCountUncued%-1 do
                cueType%[i%+ctCountCued%] := 0;
            next
            for i% := 0 to ctCountNoChange%-1 do
                cueType%[i%+ctCountCued%+ctCountUncued%] := -1;
            next
        endif
        
        
        'Adjust some timing variables based on experimental options
        docase
        case ctTrainingOptions% = 2 then 'hold through cue only
            ctPatchToSampleDelay := ctResponseTime;  'Response time will apply to patch-to-sample delay if there is no sample
            ctSampleDuration := -1;  'Turn off stimulus after patch-to-sample (i.e. response time) delay - this is the only instance where we turn the stimulus off early
            ctSampleToTargetDelay := 0;  'No sample to target delay
            arrconst(ctTargetDuration[],0); 'No target on any trial
        'As it stands right now, option 3+ is using BOTH sample and target periods even when there is no
        'actual stimulus, for simplicity.  Using a CASE here makes it easier to change that if necessary
        endcase
        
        
        
        'Set orientation/absence of distractors
        'The square rect condition is not currently used, all cue rectangles will be 3x1 or 1x3, 
        'there may exist no syntax to create a square cue rect on VSG 
        'if ctNDistractorOn% > 0 then 'if any distractors are on, use rectangular cue rect
        '    flankerIsH% := ctPanelIsHoriz%;  
        'else 'if all distractors are off, use square cue rect (nice oxymoron)
        '    flankerIsH% := -1; 'Note that value of -1 is NOT CURRENTLY SUPPORTED for a square box on VSG
        'endif
        
        'This is a much-simplified version to set orientation of distractors; absent distractors
        'still result in a 3x1 or 1x3 cue rectangle
        flankerIsH% := ctPanelIsHoriz%;
        'Note that although VSG will allow us to flip distractor orientation within-experiment,
        'this is not currently supported by the ConteTask.s2s code; FlankerIsH% would need to be an array.
        
        
        'Write out the variables that hold the counterbalance
        'Put random indices into ctTrialOrder%[], easy when you write a function to do it!
        ArrRandIndices(ctTrialOrder%[0:nTrials%]);
        
        'This is ridiculously long...it works, don't printlog it
        'printlog("Random indices are: %d\n",ctTrialOrder%[0:nTrials%]);
        
        'printlog("Performing counterbalance: nRepeats = %d, nCues = %d, nOri = %d, ",n%,nCueDotPct%,nOri%);
        'printlog("nOriChange = %d, nDistractor = %d, nValid = %d, total trials = %d\n",nCh%,nDist%,nCueType%,nTrials%);
        printlog("Performing counterbalance: nRepeats = %d, nCueDotPct = %d, nCont = %d, ",n%,nCueDotPct%,nCont%);
        printlog("nContChange = %d, nDistractor = %d, nCueType = %d, total trials = %d\n",nCh%,nDist%,nCueType%,nTrials%);

        'loop through n, CuePct, Cont, ContCh, Dist, Valid
        for i% := 1 to n% do  'i% is not used as an index, just for getting correct count of trials
            for j% := 0 to nCueDotPct%-1 do
                'for k% := 0 to nOri%-1 do
                for k% := 0 to nCont%-1 do
                    for m% := 0 to nCh%-1 do
                        for p% := 0 to nDist%-1 do
                            for q% := 0 to nCueType%-1 do
                                'Setting cue dot pct and validity is easy, set these at top and then use below for minor clarity
                                cueDotPct[count%] := cueDotPctLocal[j%];
                                validity%[count%] := cueType%[q%];  '-1 = no change ("catch"); 0 = uncued location changes ("invalid"); 1 = cued location changes ("valid")
                                                          
'For ori - there used to be a commented-out version of the ori code, but the code was massively overhauled
'at the time of switching to contrast, so it wouldn't be very helpful.  Other code to change to ori is
'simply comment/uncomment, but for this loop, a change to ori will require some manual labor                                
                                
                                
                                'This is contrast version
                                'Set which contrast changes
                                docase      
                                case validity%[count%] = -1 then 'This is a no change trial (will also catch if cue == 50)
                                    whichLocChange%[count%] := 0;  'no location changes
                                case cueDotPct[count%] > 50 and validity%[count%] = 1 then 'cue indicates location 1, valid
                                    whichLocChange%[count%] := 1;  'cued location changes
                                case cueDotPct[count%] > 50 and validity%[count%] = 0 then 'cue indicates location 1, invalid
                                    whichLocChange%[count%] := 2;  'uncued location changes
                                case cueDotPct[count%] < 50 and validity%[count%] = 1 then 'cue indicates location 2, valid
                                    whichLocChange%[count%] := 2;  'cued location changes
                                case cueDotPct[count%] < 50 and validity%[count%] = 0 then 'cue indicates location 2, invalid
                                    whichLocChange%[count%] := 1;  'uncued location changes
                                case cueDotPct[count%] = 50 then  'valid/invalid is meaningless (user should probably avoid this)
                                    'roll a die, that's fine, we ignore "valid/invalid", but SOMETHING changes (counterbalanced no-changes will be taken care of by validity=-1)
                                    whichLocChange%[count%] := round(rand(1,1));  'value will indicate location 1 or location 2 changes
                                endcase
                                
                                'Set contrast factors, takes into account which side is the cued/uncued side
                                if cueDotPct[count%] > 50 then  'if cue indicates side 1
                                    contFact1% := ctGaborCuedCont%;
                                    contFact2% := ctGaborUncuedCont%;
                                else  'if cue indicates side 2
                                    contFact1% := ctGaborUncuedCont%;
                                    contFact2% := ctGaborCuedCont%;
                                endif

                                'Set ctTargetDuration[], which is different on go and no-go trials, but only for training options 3+
                                'For training option 2 ctTargetDuration is set to 0 (above)
                                docase
                                case validity%[count%] = -1 and ctTrainingOptions% >= 3 then 'This is a no change trial
                                    ctTargetDuration[count%] := ctTargetDurationNoGo;
                                case ctTrainingOptions% >= 3 then
                                    ctTargetDuration[count%] := ctTargetDurationGo;
                                endcase
                                
                                
                                'Set contrasts of sample and test gabors, and cue rects and flankers
                                docase
                                case ctTrainingOptions% <= 3 then 'if no gabors exist due to training step, zero everything
                                    samp1Contrast%[count%] := 0;
                                    test1Contrast%[count%] := 0;
                                    samp2Contrast%[count%] := 0;
                                    test2Contrast%[count%] := 0;    
                                case ctTrainingOptions% = 4 then  'for this stage, there can be only 0-->Sample (cued) or Sample-->Sample (no-change, at uncued)
                                    docase
                                    case cueDotPct[count%] > 50 and validity%[count%] = 1 then 'cue indicates side 1, valid, side 1 is present, changes
                                        samp1Contrast%[count%] := 0;
                                        test1Contrast%[count%] := cont%[k%]*ctGaborCuedCont%/100;  'sample contrast value
                                        samp2Contrast%[count%] := 0;
                                        test2Contrast%[count%] := 0;
                                    case cueDotPct[count%] < 50 and validity%[count%] = 1 then 'cue indicates side 2, valid, side 2 is present, changes
                                        samp1Contrast%[count%] := 0;
                                        test1Contrast%[count%] := 0;
                                        samp2Contrast%[count%] := 0;
                                        test2Contrast%[count%] := cont%[k%]*ctGaborCuedCont%/100;  'sample contrast value
                                    case cueDotPct[count%] > 50 and validity%[count%] = -1 then 'cue indicates side 1, no change, side 2 is present, no change
                                        samp1Contrast%[count%] := 0;
                                        test1Contrast%[count%] := 0;
                                        samp2Contrast%[count%] := cont%[k%]*ctGaborUncuedCont%/100;  'sample contrast value scaled by uncued gabor contrast
                                        test2Contrast%[count%] := cont%[k%]*ctGaborUncuedCont%/100;  'sample contrast value scaled by uncued gabor contrast
                                    case cueDotPct[count%] < 50 and validity%[count%] = -1 then 'cue indicates side 2, no change, side 1 is present, no change
                                        samp1Contrast%[count%] := cont%[k%]*ctGaborUncuedCont%/100;  'sample contrast value scaled by uncued gabor contrast
                                        test1Contrast%[count%] := cont%[k%]*ctGaborUncuedCont%/100;  'sample contrast value scaled by uncued gabor contrast
                                        samp2Contrast%[count%] := 0;
                                        test2Contrast%[count%] := 0;
                                    case cueDotPct[count%] = 50 and whichLocChange%[count%] = 1 then 'cue makes no indication, choose side 1, arbitrarily say valid 
                                        samp1Contrast%[count%] := 0;
                                        test1Contrast%[count%] := cont%[k%]*ctGaborCuedCont%/100;  'sample contrast value
                                        samp2Contrast%[count%] := 0;
                                        test2Contrast%[count%] := 0;
                                    case cueDotPct[count%] = 50 and whichLocChange%[count%] = 2 then 'cue makes no indication, choose side 2, arbitrarily say valid    
                                        samp1Contrast%[count%] := 0;
                                        test1Contrast%[count%] := 0;
                                        samp2Contrast%[count%] := 0;
                                        test2Contrast%[count%] := cont%[k%]*ctGaborCuedCont%/100;  'sample contrast value
                                    endcase
                                case ctTrainingOptions% >= 5 then 'for these stages, the contrasts are sample-->sample and sample-->test (if not no-go)
                                'Next do step 5 (is 6 same?)  Should be, but invalid and no-change are now different
                                    docase
                                    case whichLocChange%[count%] = 1 then 'if stimulus 1 changes, stimulus 1 gets the chosen contrast
                                        samp1Contrast%[count%] := cont%[k%]*contFact1%/100;
                                        test1Contrast%[count%] := (cont%[k%]+contCh%[m%])*contFact1%/100;
                                        if test1Contrast%[count%] < 0 then  'do not allow negative contrasts
                                            Message("Negative contrast found for test stimulus! Quitting!");
                                            Halt;
                                        endif
                                        if ctContrastMatches% = 1 then  'if contrast matches, both samp2 and test2 match original contrast
                                            samp2Contrast%[count%] := cont%[k%]*contFact2%/100;
                                            test2Contrast%[count%] := cont%[k%]*contFact2%/100;
                                        else  'otherwise, select a random contrast for samp2
                                            samp2Contrast%[count%] := cont%[floor(rand(nCont%,0))]*contFact2%/100;  'Selects a random contrast
                                            test2Contrast%[count%] := samp2Contrast%[count%];  'and match
                                        endif
                                    case whichLocChange%[count%] = 2 then 'if stimulus 2 changes, stimulus 2 gets the chosen contrast
                                        samp2Contrast%[count%] := cont%[k%]*contFact2%/100;
                                        test2Contrast%[count%] := (cont%[k%]+contCh%[m%])*contFact2%/100;
                                        if test2Contrast%[count%] < 0 then  'do not allow negative contrasts
                                            Message("Negative contrast found for test stimulus! Quitting!");
                                            Halt;
                                        endif
                                        if ctContrastMatches% = 1 then  'if contrast matches, both samp1 and test1 match original contrast
                                            samp1Contrast%[count%] := cont%[k%]*contFact1%/100;
                                            test1Contrast%[count%] := cont%[k%]*contFact1%/100;
                                        else  'otherwise, select a random contrast for samp1
                                            samp1Contrast%[count%] := cont%[floor(rand(nCont%,0))]*contFact1%/100;  'Selects a random contrast
                                            test1Contrast%[count%] := samp1Contrast%[count%];  'and match
                                        endif
                                    else 'whichLocChange%[count%] = 0, randomize which side gets the designated contrast
                                        if ctContrastMatches% = 1 then 'unless the sides match, then Oprah is passing out the designated contrast
                                            samp1Contrast%[count%] := cont%[k%]*contFact1%/100;
                                            test1Contrast%[count%] := cont%[k%]*contFact1%/100;
                                            samp2Contrast%[count%] := cont%[k%]*contFact2%/100;
                                            test2Contrast%[count%] := cont%[k%]*contFact2%/100;
                                        else
                                            if round(rand(1,0)) = 1 then
                                                samp1Contrast%[count%] := cont%[k%]*contFact1%/100;
                                                samp2Contrast%[count%] := cont%[floor(rand(nCont%,0))]*contFact2%/100;  'Selects a random contrast
                                            else
                                                samp2Contrast%[count%] := cont%[k%]*contFact2%/100;
                                                samp1Contrast%[count%] := cont%[floor(rand(nCont%,0))]*contFact1%/100;  'Selects a random contrast
                                            endif
                                            test1Contrast%[count%] := samp1Contrast%[count%];  'and match
                                            test2Contrast%[count%] := samp2Contrast%[count%];  
                                        endif
                                    endcase
       
                                endcase
                               
                                
                                
                                
                                'Need to set cue rect and flanker contrast values, which will be based on various values
                                if ctTrainingOptions% >= 3 then
                                    docase
                                    case cueDotPct[count%] > 50 and validity%[count%] = 1 then 'cue indicates side 1, valid, side 1 is present at cued value
                                        samp1CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        samp1FlankerContrast%[count%] := ctFlankerCuedCont%;
                                        test1CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        test1FlankerContrast%[count%] := ctFlankerCuedCont%;
                                    case cueDotPct[count%] < 50 and validity%[count%] = 1 then 'cue indicates side 2, valid, side 2 is present at cued value
                                        samp2CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        samp2FlankerContrast%[count%] := ctFlankerCuedCont%;
                                        test2CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        test2FlankerContrast%[count%] := ctFlankerCuedCont%;
                                    case cueDotPct[count%] > 50 and validity%[count%] = -1 then 'cue indicates side 1, no-change trial, side 2 is present at uncued value
                                        samp2CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        samp2FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                        test2CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        test2FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                    case cueDotPct[count%] < 50 and validity%[count%] = -1 then 'cue indicates side 2, no-change trial, side 1 is present at uncued values
                                        samp1CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        samp1FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                        test1CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        test1FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                    case cueDotPct[count%] = 50 and whichLocChange%[count%] = 1 then 'cue makes no indication, choose side 1, arbitrarily say valid 
                                        samp1CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        samp1FlankerContrast%[count%] := ctFlankerCuedCont%;
                                        test1CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        test1FlankerContrast%[count%] := ctFlankerCuedCont%;
                                    case cueDotPct[count%] = 50 and whichLocChange%[count%] = 2 then 'cue makes no indication, choose side 2, arbitrarily say valid
                                        samp2CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        samp2FlankerContrast%[count%] := ctFlankerCuedCont%;
                                        test2CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        test2FlankerContrast%[count%] := ctFlankerCuedCont%;
                                    endcase
                                endif
                                
                                if ctTrainingOptions% >= 5 then
                                    if (cueDotPct[count%] > 50 and validity%[count%] = 1) or (cueDotPct[count%] <= 50 and validity%[count%] = -1) then
                                        samp1CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        samp1FlankerContrast%[count%] := ctFlankerCuedCont%;
                                        test1CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        test1FlankerContrast%[count%] := ctFlankerCuedCont%;
                                        samp2CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        samp2FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                        test2CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        test2FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                    else 
                                        samp1CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        samp1FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                        test1CueRectContrast%[count%] := ctCueRectUncuedCont%;
                                        test1FlankerContrast%[count%] := ctFlankerUncuedCont%;
                                        samp2CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        samp2FlankerContrast%[count%] := ctFlankerCuedCont%;
                                        test2CueRectContrast%[count%] := ctCueRectCuedCont%;
                                        test2FlankerContrast%[count%] := ctFlankerCuedCont%;
                                    endif
                                endif
                                
                                
                                'After setting above, force all flanker contrasts to 0 if flankers are off
                                'Currently flankerIsH% will never be -1, but dist%[p%] should cover it
                                if flankerIsH% = -1 or dist%[p%] = 0 then
                                    samp1FlankerContrast%[count%] := 0;
                                    samp2FlankerContrast%[count%] := 0;
                                    test1FlankerContrast%[count%] := 0;
                                    test2FlankerContrast%[count%] := 0;
                                endif;
                                
                                
                                

                                count% += 1;  'increment counter                                
                            next
                        next
                    next
                next
            next
        next
        
        'We have now filled the following variables, for use in creating the CSV/binary file and beyond
        '   ctTrialOrder%[];   'Will be shuffled indices, to randomize trial order 
        '   cueDotPct[];       'Percentage of cue dots on each trial
        '   samp1Ori[];        'Sample orientation on each trial, etc.
        '   samp2Ori[];
        '   test1Ori[];
        '   test2Ori[];
        '   validity%[];       'Validity on each trial, -1 = no change, 0 = invalid, 1 = valid (if cueDotPct is 50, validity value is not updated, but side 1/2 is randomly selected)
        '   whichOriChange%[]; '0 = no change, 1 = side 1 changes, 2 = side 2 changes
        '   flankerIsH%;     '0 = vertical flankers, 1 = horizontal flankers, -1 = no flankers
        
        'Also filled the following:
        '   samp1Contrast%[];
        '   samp2Contrast%[];
        '   test1Contrast%[];
        '   test2Contrast%[];
        '   samp1FlankerContrast%[];
        '   samp2FlankerContrast%[];
        '   test1FlankerContrast%[];
        '   test2FlankerContrast%[];
        '   samp1CueRectContrast%[];
        '   samp2CueRectContrast%[];
        '   test1CueRectContrast%[];
        '   test2CueRectContrast%[];

        
        'halt;  'testing
        
        
        'Write binary file holding dot percentages on each patch
        'Spec for binary file is now:
        'Int1 Int2 FloatX1 FloatY1 FloatX2 FloatY2 ... FloatX(Int1+Int2) FloatY(Int1+Int2) Int1 Int2 FloatX1...
        '
        'The idea here is that for each "Patch Set" (one trial) we will designate the number of color1 dots and
        'the number of color2 dots (color1 and color2 will be defined in the CSV file) and that the VSG will
        'perform the randomization.  The VSG performing the randomization will make the binary file smaller.
        'So the file read process will sum Int1 and Int2, know that it needs to read Int1+Int2 X,Y pairs per
        'patch, and know from the CSV file that it will have a certain number of patches per Patch Set.
        '
        'The X and Y values are to be scaled to a unit circle (-0.5 to 0.5) and Dan will expand to the requested
        'size.
        
        
        dotSupplyHandle% := FileOpen(dotSupplyFileName$,9,1);
        if dotSupplyHandle% < 0 then
            printlog("Opening binary file for writing failed with error %d\n",dotSupplyHandle%);
            halt;
        endif;
        
        s := Seconds();
        for i% := 0 to nTrials%-1 do  'loop through every trial
            'Calculate the number of dots of each color present in each patch on this trial
            GenerateConteCuePatchColors(ctDotsPerPF%,ctPFsPerPatch%,cueDotPct[ctTrialOrder%[i%]],color%[],numColor%[][]);
            'Create random XY positions for each dot on this trial - technically these are not separated by patch, and don't need to be
            GenerateConteCuePatchXY(ctDotsPerPF%,ctPFsPerPatch%,0.5,xy[][]);  'force to unit circle instead of patch size
            
            for j% := 0 to ctPFsPerPatch%-1 do 'loop through each patch frame on this trial
                'write both numColor values for this patch frame to binary file, 4 byte integer
                OK% := view(dotSupplyHandle%).BWrite(numColor%[j%][]); 
                'printlog("On Patch %d, num color 1 is %d and num color 2 is %d\n",j%+1,numColor%[j%][0],numColor%[j%][1]);                
                if OK% < 0 then
                    message("Problem with 'color' binary write on patch# " + Str$(i%+1) + " frame# " + Str$(j%+1) + "!");
                    FileClose(dotSupplyHandle%);
                endif;
                
                'construct xyVector for this patch frame
                for k% := 0 to ctDotsPerPF%-1 do
                    xyVector[k%*2] := xy[(j%*ctDotsPerPF%)+k%][0];
                    xyVector[(k%*2)+1] := xy[(j%*ctDotsPerPF%)+k%][1];
                next
                
                'write all X,Y pairs for this patch frame to binary file, double (8 bytes)
                OK% := view(dotSupplyHandle%).BWrite(xyVector);
                if OK% < 0 then
                    message("Problem with xy vector binary write on patch# " + Str$(i%+1) + " frame# " + Str$(j%+1) + "!");
                    FileClose(dotSupplyHandle%);
                endif;
            next
            ArrConst(numColor%[][],0);  'reset numColor values, as we use an increment scheme above    
        next
        
        FileClose(dotSupplyHandle%);
        printlog("A total of %d patches required %f seconds to create and write to binary file!\n",ctPFsPerPatch%*nTrials%,Seconds()-s);
        
        'Write CSV file
        
        CSVHandle% := FileOpen(CSVFileName$,8,1);
        if CSVHandle% < 0 then
            printlog("Opening CSV file for writing failed with error %d\n",CSVHandle%);
            halt;
        endif;
        
        
        s := Seconds();
        'ParseGratingParametersContrast%(GetGratingParameters$("Stimulus"), sampleContrast%);  'get the contrast from "Stimulus", use for sample/test/cuebox
        ParseGratingParametersOri%(GetGratingParameters$("Stimulus"), sampleOri);  'get the orientation from "Stimulus", use for sample/test
        for i% := 0 to nTrials%-1 do  'loop through every trial
            'Target orientation for left and right gabors has been calculated above in the counterbalance code
            
            'We are going to use the Is_H to also turn on/off the flankers - if it is -1, there will be no flankers
            'In order to end a trial early, we will use ctSampleDuration or ctTargetDuration, either being 0 will
            'cut the trial off at that point, but will allow us to have the fixation point up during the "delay"
            
            
            'The latest version of the CSV file (about 2/13/24) consists of the following:
            '7 values specifying the cue patch (same as before)
            '5 values specifying some timing parameters (same as before) - for these sections a positive value
            '  is interpreted as duration in ms; a value of 0 skips the section; a value of -1 ends presentation
            '  at that section (and of course does not display that section)
            '14 values each specifying the Sample A/Sample B/Test A/Test B stimuli 
            
            'Old Orientation version
            'Write to file
'            Print("%f,%f,%f,%f,%f,%d,%d,",FixationX,FixationY,ctPatchRadiusDeg*2,ctPatchRadiusDeg*2,ctDotRadiusDeg*2,ctRefreshPerPF%,ctPFsPerPatch%);  'cue patch params
'            Print("%f,%f,%f,%f,%f,",ctPatchToSampleDelay*1000,ctSampleDuration*1000,ctSampleToTargetDelay*1000,ctTargetDuration[i%]*1000,ctResponseTime*1000);  'timing params
'            Print("%f,%f,%f,%f,%f,%f,",ctGaborXLoc,ctGaborYLoc,ctGaborHDeg,ctGaborWDeg,samp1Ori[i%],ctGaborSF);  'Sample A (primary), part 1
'            Print("%f,%f,%d,%d,0,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Sample A (primary), part 2, color for A is color 0
'            Print("%f,%f,%f,",samp1Contrast%[i%],samp1FlankerContrast%[i%],samp1CueRectContrast%[i%]);  'Sample A (primary), part 3, contrasts
'            Print("%f,%f,%f,%f,%f,%f,",ctGabor2XLoc,ctGabor2YLoc,ctGaborHDeg,ctGaborWDeg,samp2Ori[i%],ctGaborSF);  'Sample B (secondary), part 1
'            Print("%f,%f,%d,%d,1,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Sample B (secondary), part 2, color for B is color 1
'            Print("%f,%f,%f,",samp2Contrast%[i%],samp2FlankerContrast%[i%],samp2CueRectContrast%[i%]);  'Sample B (secondary), part 3, contrasts
'            Print("%f,%f,%f,%f,%f,%f,",ctGaborXLoc,ctGaborYLoc,ctGaborHDeg,ctGaborWDeg,test1Ori[i%],ctGaborSF);  'Test A (primary), part 1
'            Print("%f,%f,%d,%d,0,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Test A (primary), part 2, color for A is color 0
'            Print("%f,%f,%f,",test1Contrast%[i%],test1FlankerContrast%[i%],test1CueRectContrast%[i%]);  'Test A (primary), part 3, contrasts
'            Print("%f,%f,%f,%f,%f,%f,",ctGabor2XLoc,ctGabor2YLoc,ctGaborHDeg,ctGaborWDeg,test2Ori[i%],ctGaborSF);  'Test B (secondary), part 1
'            Print("%f,%f,%d,%d,1,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Test B (secondary), part 2, color for B is color 1
'            Print("%f,%f,%f",test2Contrast%[i%],test2FlankerContrast%[i%],test2CueRectContrast%[i%]);   'Test B (secondary), part 3, contrasts
'            Print("\n");
            
            'Contrast version
            'Write to file  
            Print("%f,%f,%f,%f,%f,%d,%d,",FixationX,FixationY,ctPatchRadiusDeg*2,ctPatchRadiusDeg*2,ctDotRadiusDeg*2,ctRefreshPerPF%,ctPFsPerPatch%);  'cue patch params
            Print("%f,%f,%f,%f,%f,",ctPatchToSampleDelay*1000,ctSampleDuration*1000,ctSampleToTargetDelay*1000,ctTargetDuration[ctTrialOrder%[i%]]*1000,ctResponseTime*1000);  'timing params
            Print("%f,%f,%f,%f,%f,%f,",ctGaborXLoc,ctGaborYLoc,ctGaborHDeg,ctGaborWDeg,sampleOri,ctGaborSF);  'Sample A (primary), part 1
            Print("%f,%f,%d,%d,0,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Sample A (primary), part 2, color for A is color 0
            Print("%f,%f,%f,",samp1Contrast%[ctTrialOrder%[i%]],samp1FlankerContrast%[ctTrialOrder%[i%]],samp1CueRectContrast%[ctTrialOrder%[i%]]);  'Sample A (primary), part 3, contrasts
            Print("%f,%f,%f,%f,%f,%f,",ctGabor2XLoc,ctGabor2YLoc,ctGaborHDeg,ctGaborWDeg,sampleOri,ctGaborSF);  'Sample B (secondary), part 1
            Print("%f,%f,%d,%d,1,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Sample B (secondary), part 2, color for B is color 1
            Print("%f,%f,%f,",samp2Contrast%[ctTrialOrder%[i%]],samp2FlankerContrast%[ctTrialOrder%[i%]],samp2CueRectContrast%[ctTrialOrder%[i%]]);  'Sample B (secondary), part 3, contrasts
            Print("%f,%f,%f,%f,%f,%f,",ctGaborXLoc,ctGaborYLoc,ctGaborHDeg,ctGaborWDeg,sampleOri,ctGaborSF);  'Test A (primary), part 1
            Print("%f,%f,%d,%d,0,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Test A (primary), part 2, color for A is color 0
            Print("%f,%f,%f,",test1Contrast%[ctTrialOrder%[i%]],test1FlankerContrast%[ctTrialOrder%[i%]],test1CueRectContrast%[ctTrialOrder%[i%]]);  'Test A (primary), part 3, contrasts
            Print("%f,%f,%f,%f,%f,%f,",ctGabor2XLoc,ctGabor2YLoc,ctGaborHDeg,ctGaborWDeg,sampleOri,ctGaborSF);  'Test B (secondary), part 1
            Print("%f,%f,%d,%d,1,",ctGaborPhase,ctGaborDivisor,flankerIsH%,ctPanelLinePixels%);  'Test B (secondary), part 2, color for B is color 1
            Print("%f,%f,%f",test2Contrast%[ctTrialOrder%[i%]],test2FlankerContrast%[ctTrialOrder%[i%]],test2CueRectContrast%[ctTrialOrder%[i%]]);   'Test B (secondary), part 3, contrasts
            Print("\n");
            
            
        next
        
        FileClose(CSVHandle%);
        printlog("CSV file of %d trials required %f seconds to create and write!\n",nTrials%,Seconds()-s);
        
    endif
    
    
    'printlog("Got here OK\n");
    'halt;  'temporarily allowing dialog to stop here, TODO move it down as testing allows, or remove altogether

'    ' Open serial port for VSG comms re: stimulus jump-advance...let's not do this
'    'OpenSerialPortToVSG();
'    
	'start sampling
    if UseTwo1401s% = 1 then
        SampleStart(0);  'Set sampling to start immediately
        Yield(0.5);  'Wait half a second
        'Look for handshake, unless disabled
        while pulseFound% < 1 and startSecs > 0 and Dual1401IgnoreHandshake% = 0 do
            pulseFound% := View(DataWindow%).FindPulseUp%(TimingChannel%, 0, tRise, tFall);
            yield(0.1);
            startSecs := startSecs - 0.1;
        wend
        'Send timing pulse
        SampleSeqVar(11,20);  'set for 20 ms pulse (Was not specified!  Two 1401s has been inactive for years and "T" may have been accidentally co-opted?)
        SafeSampleKey("T");
    else
    	SampleStart(0); 'Start sampling now
    endif;
    
    if startSecs <= 0 then
        message("Handshake not found in 5 seconds!  Quitting!");
        halt
    endif
    
    
    'Set sequencer variable 5, this value is appropriate for no rivalry
    SampleSeqVar(5, 0);
    
    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    
    'Get the clock period of the sequencer, in MS, must do this after starting sampling
    SequencerPeriodMS := SampleSeqClock(1);  
    
    
    'Begin building the command line argument
    Opener$ := "cmd /k " + bin$;


    'Get remote args, program name...will use FIXSTIM for training steps 0,1 and CONTE for all higher training steps
    if ctTrainingOptions% >= 2 then
        ' Get remote args if needed
        if GetUseRemoteStimulus%() = 1 then
            RemoteArg$  := " " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " conte ";
        endif;
        
        if GetUseRemoteStimulus%() = 1 then
            ProgName$ := "\\remote.exe "; 'set program name for one VSG
        else
            ProgName$ := "\\conte.exe "; 'set program name for one VSG
        endif;
        
    else
        ' Get remote args if needed
        if GetUseRemoteStimulus%() = 1 then
            RemoteArg$  := " " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim ";
        endif;
        
        if GetUseRemoteStimulus%() = 1 then
            ProgName$ := "\\remote.exe "; 'set program name for one VSG
        else
            ProgName$ := "\\fixstim.exe "; 'set program name for one VSG
        endif;
    endif

    
    
    'Set background color
    BGColor$ := " -b " + BackgroundColor$;
    
    'Set distance to screen
    Dist2Screen$ := " -d " + GetDistanceToScreenMM$();
    
    'Set trigger port
    TriggerPort$ := " -p 2 ";  'This one's hard-coded for now
    
    'Turn on verbose
    Verbose$ := " -v ";
    
    'Set Cue Rect Arg
    if ctShowCueRectDuringCue% = 1 then
        CueRectArg$ := " --show-cue-rects ";
    else
        CueRectArg$ := "";
    endif
    
    'Update fixation cross argument
    FixationCrossArg$ := Mid$(FixationArg$,5);  'Start with 5th character (remove " -f ") so we can insert the "+"
    FixationCrossArg$ := " -f +," + FixationCrossArg$ + "," + Str$(ctFixCrossWidthPixels%);  'Can also place a cross "orientation" argument at end to rotate it, but leaving that out here for default 0
    
    'Build cue color argument
    CueColorArg$ := " -c (" + Str$(ctDotColor1R%) + "/" + Str$(ctDotColor1G%) + "/" + Str$(ctDotColor1B%) + ") -c (" + Str$(ctDotColor2R%) + "/" + Str$(ctDotColor2G%) + "/" + Str$(ctDotColor2B%) + ") ";

    'Build opener to command line
    cmdLine$ := Opener$ + ProgName$ + RemoteArg$ + Verbose$ + TriggerPort$ + BGColor$ + Dist2Screen$ + FixationCrossArg$;
    
    'If doing partial/full Conte task, point to spec file
    if ctTrainingOptions% >= 2 then
        cmdLine$ := cmdLine$ + CueRectArg$ + CueColorArg$ + "--dot-supply " + GetScriptDir$(0) + "..\\..\\ConteDotsFile.bin" + " --trials " + GetScriptDir$(0) + "..\\..\\ConteCSVFile.csv";
    else  'Otherwise, just put in a fake grating/tuning curve to make it happy
        cmdLine$ := cmdLine$ + " -s " + GetGratingParameters$("Stimulus") + " -O 90 ";
    endif 
    
    
    
  
    ' Initial text marks
    ' djs Always version 3. NO difference if maintainmode is used or not. 
    SampleText("ConteTask,3," + str$(Len(cmdLine$)));
    SampleText(ctCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next    
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n"); 
    
    StimHandle% := ProgRun(cmdLine$, 1);
    if StimHandle% <0 then 
        Message("Could not start stimulus."); 
        halt; 
    endif
    
    
    'Set values for the joystick
    GetJoystickParameters();  'get voltage values for thresholds, offset
    'Change offset of joystick channel
    View(DataWindow%).ChanOffset(JoyChannel%,joystickOffset);  'use value from registry
    InitJoystick2(JoyChannel%,GetJoystickPort%());  'initialize the joystick
    DisplayJoystickParametersUD();  'write values to log file
    
    'set YRange for JoyChannel...was [0 1] for some reason, that's not good
    View(DataWindow%).YRange(JoyChannel%,-1,1);  '[-5 5] ain't great, we can do [-1 1] because the voltage off this baby is not huge (more like [-0.5 0.6])

    
    
    'If we are asking the eyetracker to record an output file, open the file and start recording
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("I");  'Open the file (this is done by setting a DIGLOW bit), file name will be saved in a sampletext
        yield(0.5);
        SafeSampleKey("W");  'Begin recording the file
        yield(0.5);
    endif
    
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(7,0);
	ToolbarEnable(8,0);
	View(DataWindow%);
	Yield(5);
    return 1;
    
    
    
end




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif

    
    ' Tell stim app to shut down.
	SafeSampleKey("Q");
	SampleStop();
    
    
    ProgKill(StimHandle%);
    while ProgStatus(StimHandle%) > 0 do
        Yield();
    wend

    
    
	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then  TODO Put H/M/FA/CR into (sample)bar?
	TotalTrials% += nTrialsStarted%;
	SaveDailyTotals();

    halt
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()  'note that this function is only used for Toolbar-based juice delivery
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverReward();
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNumber();
        endif;
    endif;
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectWavemarkDialog%()
	var iReturn%:=1;
	var i%;
    var whichWaveMark% := 1;
	DlgCreate("Select Wavemark");
	DlgInteger(1, "Input Wavemark to view, -1 for all", -1, 256);  'max is based on highest possible wavemark value
    
	i% := DlgShow(whichWaveMark%);

	if i% = 1 then
		PrintLog("SelectWavemarkDialog - user hit OK\n");
        for i% := 0 to ctNWavemarks%-1 do  'for each wavemark channel
            View(DataWindow%).MarkMask(i%+1,0,0,-1);  'exclude all codes on layer 0
            View(DataWindow%).MarkMask(i%+1,0,1,whichWaveMark%);  'then include requested code (or all, if -1) on layer 0
        next;       
	endif;
	if i% = 0 then
		PrintLog("SelectWavemarkDialog - user hit Cancel\n");
	endif;
    'PrintLog("Return value is %d\n", iReturn%);  'always return 1, so don't bother reporting this
	return iReturn%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var i%, j%;
    


	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
    Print("Eye coil offset, V (X)     : %f\n", XVoltOffset);
    Print("Eye coil offset, V (Y)     : %f\n", YVoltOffset);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	Print("Background color           : %s\n", BackgroundColor$);
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

    Print("Always looking?                          : %d\n", ctAlwaysLooking%);
	Print("Always pressing?                         : %d\n", ctAlwaysPressing%);
    Print("Check looking?                           : %d\n", ctCheckLooking%);
    Print("Training option                          : %d\n", ctTrainingOptions%);
    Print("Number of trials                         : %d\n", nTrials%);
'    'Print("Reward Delay (s)                         : %f\n", mainRewardDelay);  'never enabled
	Print("Inter-trial interval                     : %f\n", ctITI);
    Print("Fixation cross on?                       : %d\n", ctFixationOn%);
    Print("Fixation cross width (pixels)            : %f\n", ctFixCrossWidthPixels%);
    Print("Require fixation?                        : %d\n", ctRequireFixation%);
    Print("Acquisition time (s)                     : %f\n", ctFixAcqTime);
    Print("Patch onset delay (s)                    : %f\n", ctPatchOnsetDelay);
    Print("Patch duration (s)                       : %f\n", ctPatchDur);
    Print("Dots per patch frame                     : %d\n", ctDotsPerPF%);
    Print("Dot color 1 R/G/B                        : %d %d %d\n", ctDotColor1R%,ctDotColor1G%,ctDotColor1B%);
    Print("Dot color 2 R/G/B                        : %d %d %d\n", ctDotColor2R%,ctDotColor2G%,ctDotColor2B%);
    Print("Dot radius (deg)                         : %f\n", ctDotRadiusDeg);
    Print("Monitor refreshes per patch frame        : %d\n", ctRefreshPerPF%);
    Print("Patch frames per patch                   : %d\n", ctPFsPerPatch%);
    Print("Patch radius (deg)                       : %f\n", ctPatchRadiusDeg);
    Print("Additional window radius (deg)           : %f\n", ctAdditionalWindowRadius);
    Print("Patch to sample delay (s)                : %f\n", ctPatchToSampleDelay);
    Print("Sample duration (s)                      : %f\n", ctSampleDuration);
    Print("Sample to target delay (s)               : %f\n", ctSampleToTargetDelay);
    Print("Target duration Go (s)                   : %f\n", ctTargetDurationGo);  
    Print("Target duration NoGo (s)                 : %f\n", ctTargetDurationNoGo); 
    Print("Response time (s)                        : %f\n", ctResponseTime);  
    Print("Abort penalty (s)                        : %f\n", ctAbortPenalty); 
    Print("Trials per data point                    : %d\n", nTrialsPerDataPoint%);
    Print("Uncued per data point                    : %d\n", ctCountUncued%);
    Print("Cued per data point                      : %d\n", ctCountCued%);
    Print("No-Change per data point                 : %d\n", ctCountNoChange%);
    Print("N distractor on per data point           : %d\n", ctNDistractorOn%);
    Print("N distractor off per data point          : %d\n", ctNDistractorOff%);
    'Print("Orientations match?                      : %d\n", ctOrientationMatches%);
    Print("Contrasts match?                         : %d\n", ctContrastMatches%);
    Print("Dot percentages                          : %s\n", ctDotPctString$);
    'Print("Sample orientations                      : %s\n", ctSampleOriString$);
    'Print("Orientation changes                      : %s\n", ctOriChangeString$);
    Print("Sample contrasts                         : %s\n", ctSampleContString$);
    Print("Contrast changes                         : %s\n", ctContChangeString$);
    Print("Show Cue Rect During Cue Patch?          : %d\n", ctShowCueRectDuringCue%);
    
    Print("\nStimulus parameters\n");
	Print("-------------------------\n\n");
    
    Print("Take stim values from config?            : %d\n", ctStimValsFromConfig%);
    Print("Gabor/flanker radius width (deg)         : %f\n", mainW);
    Print("Gabor/flanker radius height (deg)        : %f\n", mainH);
    Print("Gabor X location (deg)                   : %f\n", ctGaborXLoc);
    Print("Gabor Y location (deg)                   : %f\n", ctGaborYLoc);
    Print("Gabor2 X location (deg)                  : %f\n", ctGabor2XLoc);
    Print("Gabor2 Y location (deg)                  : %f\n", ctGabor2YLoc);
    Print("Panel height (deg)                       : %f\n", ctGaborHDeg);
    Print("Panel width (deg)                        : %f\n", ctGaborWDeg);
    Print("Panel is horizontal?                     : %d\n", ctPanelIsHoriz%);
    Print("Panel line width (pixels)                : %d\n", ctPanelLinePixels%);
    Print("Gabor spatial frequency (cyc/deg)        : %f\n", ctGaborSF);
    Print("Gabor phase (deg)                        : %f\n", ctGaborPhase);
    Print("Gabor spatial factor                     : %f\n", ctGaborDivisor);
    Print("Gabor cued contrast (0-100)              : %d\n", ctGaborCuedCont%);
    Print("Gabor uncued contrast (0-100)            : %d\n", ctGaborUncuedCont%);
    Print("Flanker cued contrast (0-100)            : %d\n", ctFlankerCuedCont%);
    Print("Flanker uncued contrast (0-100)          : %d\n", ctFlankerUncuedCont%);
    Print("Panel cued contrast (0-100)              : %d\n", ctCueRectCuedCont%);
    Print("Panel uncued contrast (0-100)            : %d\n", ctCueRectUncuedCont%);
    
    

    Print("\nResults\n");
	Print("-------------------------\n\n");
    Print("N trials started                         : %d\n", nTrialsStarted%);
    Print("N trials completed                       : %d\n", nTrialsCompleted%);
    Print("N trials aborted                         : %d\n", nTrialsAborted%);
    Print("Hits                                     : %d\n", Hits%);
    Print("Misses                                   : %d\n", Misses%);
    Print("False alarms                             : %d\n", FAs%);
    Print("Correct rejections                       : %d\n", CRs%);
    
    
	' close parfile
	FileClose(0);

end;



' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
	FileClose(-1,-1);
	return 0;
end;



func CallJoystickConfigDialogUD%()
    'This function was written simply to prevent "odd" autonaming of files when saving joystick calibration data
    'Unfortunately, there doesn't seem to be a way to *not* save the data as SampleStop automatically saves it, so
    'this is the next best thing.  Should work for either dialog-based or toolbar-based calls of Joystick config
    var key$;
    var primaryTxt$;
    var secondaryTxt$;
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
    
    'Set autoname to use a joystick-based name
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);

    
    DoSampleAutoName(key$,"joystick","joy",primaryTxt$,secondaryTxt$);    
    
    JoystickConfigDialogUD%();
    
    'Set autoname back to what it should be once we return
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);

    DoSampleAutoName(key$,"ct","ct",primaryTxt$,secondaryTxt$);
    
    return 1;
end






'proc GetTuningCurveDotPercentParameters()
'	var stmp$;
'	var key$;
'	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\ConteTask\\DotPercent";
'    
'    ctDotPercentNSteps% := GetIntRegistryValue%(key$, "NSteps", ctDotPercentNSteps%);
'    ctDotPercentNRepeats% := GetIntRegistryValue%(key$, "NRepeats", ctDotPercentNRepeats%);
'    ctDotPercentMinPercent := GetFloatRegistryValue(key$, "MinDotPercent", ctDotPercentMinPercent);
'    ctDotPercentMaxPercent := GetFloatRegistryValue(key$, "MaxDotPercent", ctDotPercentMaxPercent);
'    ctDotPercentProgression% := GetIntRegistryValue%(key$, "Progression", ctDotPercentProgression%);
'    ctDotPercentUseFile% := GetIntRegistryValue%(key$, "UseFile", ctDotPercentUseFile%);
'    ctDotPercentTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", ctDotPercentTuningFile$);
'end;

'proc SaveTuningCurveDotPercentParameters()
'	var key$;
'	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\ConteTask\\DotPercent";
'    
'    SetIntRegistryValue(key$, "NSteps", ctDotPercentNSteps%);
'    SetIntRegistryValue(key$, "NRepeats", ctDotPercentNRepeats%);
'    SetFloatRegistryValue(key$, "MinDotPercent", ctDotPercentMinPercent);
'    SetFloatRegistryValue(key$, "MaxDotPercent", ctDotPercentMaxPercent);
'    SetIntRegistryValue(key$, "Progression", ctDotPercentProgression%);
'    SetIntRegistryValue(key$, "UseFile", ctDotPercentUseFile%);
'    SetStringRegistryValue(key$, "TuningFile", ctDotPercentTuningFile$);
'end;





'func TuningCurveDotPercentDialog%()
'	var iReturn% := 0;
'	var i%;
'    var zero%;
'    
'    'We are removing nRepeats and allowing the number of repeats to effectively be set at the main dialog
'    
'    GetTuningCurveDotPercentParameters();    
'    
'	DlgCreate("Dot Percentage Tuning Curve Parameters");
'	DlgInteger(1, "Number of Steps", 1, 100);
'	'DlgInteger(2, "Number of Repeats", 1, 10);
'    DlgInteger(2, "Repeats done in main dialog", 1, 10);
'	DlgReal(3, "Min Dot Percentage, Symmetrical (%)", 0, 50);
'	DlgReal(4, "Max Dot Percentage, Symmetrical (%)", 0, 50);
'	DlgCheck(5, "Random Progression");
'    DlgCheck(6, "Use File For Tuning Values (one trial per pct ONLY)");
'    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
'    DlgButton(3, " Select Tuning File ", SelectTuningFile%, 2, 8);
'
'    DlgAllow(0xffff, 0, TuningCurveDotPercentDialogChanged%);
'
'	'i% := DlgShow(ctDotPercentNSteps%, ctDotPercentNRepeats%, ctDotPercentMinPercent, ctDotPercentMaxPercent, ctDotPercentProgression%, ctDotPercentUseFile%, ctDotPercentTuningFile$);
'    i% := DlgShow(ctDotPercentNSteps%, zero%, ctDotPercentMinPercent, ctDotPercentMaxPercent, ctDotPercentProgression%, ctDotPercentUseFile%, ctDotPercentTuningFile$);
'    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
'	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't. 
'	if i% = 1 then
'        
'		SaveTuningCurveDotPercentParameters();
'    
'        iReturn% := 1;
'        
'	endif;
'
'	return iReturn%;
'end;
'
'
'func TuningCurveDotPercentDialogChanged%(item%)
'    
'    DlgEnable(0,2);
'    
'    if DlgValue(6) = 0 then  'If we are not using a tuning file
'        DlgEnable(0,7);  'disable the string box with the text file name (button still works)
'        DlgEnable(1,1);  'enable nSteps, min, and max
'        DlgEnable(1,3);
'        DlgEnable(1,4);
'    endif;
'    if DlgValue(6) = 1 then
'        DlgEnable(1,7);  'enable the string box with the text file name
'        DlgEnable(0,1);  'disable nSteps, min, and max
'        DlgEnable(0,3);
'        DlgEnable(0,4);
'    endif;
'    return 1;
'end



func SelectTuningFile%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(7,direc$);  'Place filename into dialog item 7 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;



func GenerateConteCuePatchColors(nDots%,nFrames%,redProp,&color%[],&numColor%[][])
    var count%;
    var ii%;
    var jj%;
    var redPropAdj;  'We know people will do silly things like not know whether to use 55 or .55, so just fix it
                     '(And, to be fair, the main dialog asks for PERCENT, but this function uses PROPORTION so...)
                     'Look, it's just going to almost certainly always be percent and we'll just do the math here
    docase
    case redProp > 100 then  'Should not be a common error, but may as well check
        message("Percentage of red dots (" + Str$(redProp) + ") exceeds 100%!  Quitting!");
        halt;
    case redProp < 0 then  'Should not be a common error, but may as well check
        message("Percentage of red dots (" + Str$(redProp) + ") is negative!  Quitting!");
        halt;
    case redProp < 1 then  'This is clearly proportion as required by the function, keep it (1 is tricky)
        redPropAdj := redProp;
    else  'This is clearly percentage, make it a proportion
        redPropAdj := redProp/100;
    endcase
    
    count% := round(nDots%*nFrames%*redPropAdj);  'Total number of red dots in all frames, must explicitly round or will floor
    printlog("nDots is %d and nFrames is %d and redPropAdj is %f and count is %d and color is %d long\n",nDots%,nFrames%,redPropAdj,count%,Len(color%[]));
    ArrConst(color%[0:count%],1);  'Put in ones for "red"
    if count% < Len(color%[]) then
        ArrConst(color%[count%:],2);  'Put in twos for "green", if there are no green, would result in indexing error
    endif;
    ArrSort(color%[],-1);  'Shuffle them
    for ii% := 0 to nFrames%-1 do
        for jj% := 0 to nDots%-1 do
            if color%[(nDots%*ii%)+jj%] = 1 then
                numColor%[ii%][0] += 1;
            else
                numColor%[ii%][1] += 1;
            endif
        next
    next
end




func GenerateConteCuePatchXY(nDots%,nFrames%,patchRadius,&xy[][])
    var oversize% := round(nDots%*nFrames%*1.7);  'We are going to "overproduce" random dots in the square to ensure 
                                                  'there are enough dots falling in the circle.  There is a tradeoff
                                                  'between making too many dots (which is slower) and making too few
                                                  'dots (which means we have to try again).  Although 1.5x is enough
                                                  'to fill the circle on the first try most of the time, there are
                                                  'enough failures that things go faster with more dots made.  1.7x
                                                  'seems to be the sweet spot from my testing.
    var xyTemp[oversize%][2];  
    var nDotsInCircle% := 0;
    var uhoh%;  'Don't let WHILE loop get stuck
    var ii%;
    
    'Create dot locations until there are enough dots inside the circle
    'Note that we create all dots for all patch frames at once, and we
    'separate them out to individual frames outside of this function
    while nDotsInCircle% < nDots%*nFrames% and uhoh% < 100 do
        nDotsInCircle% := 0;  'reset nDotsInCircle%
        rand(xyTemp[][],patchRadius*2,-patchRadius);  'put random values into xyTemp, values will fall into the square patch bounding the circle
        'Boy, I love being able to do matrix math instead of looping!  But looping it is!
        for ii% := 0 to oversize%-1 do
            docase
            'Break out of the FOR loop rather than continuing to the end if we have enough dots; makes the entire code run about 5% faster
            case nDotsInCircle% >= nDots%*nFrames% then  
                break
            'If this dot is inside the circle, put it into XY
            case (((xyTemp[ii%][0]*xyTemp[ii%][0]) + (xyTemp[ii%][1]*xyTemp[ii%][1])) < (patchRadius*patchRadius)) and (nDotsInCircle% < nDots%*nFrames%) then
                xy[nDotsInCircle%][0] := xyTemp[ii%][0];
                xy[nDotsInCircle%][1] := xyTemp[ii%][1];
                nDotsInCircle% += 1;  'and increment
            endcase;
        next
        uhoh% += 1;  'keep track of how many times we have failed to find enough dots in the circle
        'If there were enough dots in the circle, the WHILE will not execute again
    wend
    
    'This should not happen (like probability WAY less than 1 in 2^100)
    if uhoh% >= 100 then
        message("Looks like the WHILE loop in GenerateConteCuePatchXY failed! You have basically hit the lottery!");
        halt;
    endif
end




func CalcNumTrials%(opt%,TrialsPP%,ValidPP%,InvalidPP%,CatchPP%,CuePct$,Vals$,ValChange$,DistOn%,DistOff%);
    'This function will calculate the total number of trials requested by the Conte task dialog
    'It will use the training options value to determine which input variables to consider
    'We will use "Val" here rather than Ori/Cont because it has changed (and who knows may change again)
    'and for the purposes of this funciton it actually doesn't matter.
    var n%;
    var uTrials% := 1;  'Start at 1, will multiply by various values
    var cueDotPctLocal[100];  'these just allow us to use String2FloatArray
    var vals[100];  'Val is reserved, of course
    var valCh[100];
    
    'Start by assigning number of trials per point
    'For training steps 0/1 (reward on lever/reward on hold) this will determine how many rewards before
    'the program stops, for other training steps this will be data points per counterbalanced trial
    n% := TrialsPP%; 
    
    'Determine independently for each training step how many unique trials there are
    docase
    'For training step 2 (hold through cue), only cue dot percentage determines unique trials
    case opt% = 2 then
        uTrials% := String2FloatArray%(CuePct$,cueDotPctLocal[]); 'cue dot percentages
    'For training step 3 (introduce single cue rect, go/no-go), there are also valid and catch trials
    case opt% = 3 then
        uTrials% := String2FloatArray%(CuePct$,cueDotPctLocal[]); 'cue dot percentages
        uTrials% := uTrials% * (ValidPP%+CatchPP%);  'valid and catch trials 
    'For training step 4 (fill single cue rect, go/no-go), there are also sample contrasts and distractors   
    case opt% = 4 then
        uTrials% := String2FloatArray%(CuePct$,cueDotPctLocal[]); 'cue dot percentages
        uTrials% := uTrials% * (ValidPP%+CatchPP%);  'valid and catch trials
        uTrials% := uTrials% * String2FloatArray%(Vals$,vals[]);  'sample contrasts
        uTrials% := uTrials% * (DistOn%+DistOff%);  'distractors present/absent
    'For training step 5 (present both cue rects, go/no-go), there are also test contrasts (as contrast changes)   
    case opt% = 5 then
        uTrials% := String2FloatArray%(CuePct$,cueDotPctLocal[]); 'cue dot percentages
        uTrials% := uTrials% * (ValidPP%+CatchPP%);  'valid and catch trials
        uTrials% := uTrials% * String2FloatArray%(Vals$,vals[]);  'sample contrasts
        uTrials% := uTrials% * String2FloatArray%(ValChange$,valCh[]);  'contrast changes
        uTrials% := uTrials% * (DistOn%+DistOff%);  'distractors present/absent
    'For training step 6 (full task, includes invalid), there are now invalid trials as well    
    case opt% = 6 then
        uTrials% := String2FloatArray%(CuePct$,cueDotPctLocal[]); 'cue dot percentages
        uTrials% := uTrials% * (ValidPP%+InvalidPP%+CatchPP%); 'valid, invalid, and catch trials
        uTrials% := uTrials% * String2FloatArray%(Vals$,vals[]);  'sample contrasts
        uTrials% := uTrials% * String2FloatArray%(ValChange$,valCh[]);  'contrast changes
        uTrials% := uTrials% * (DistOn%+DistOff%);  'distractors present/absent
    endcase;
    
    
    

    'Get total number of trials
    n% := n%*uTrials%;
    
    return n%;
end


proc DrawMonitorScreen(drawFix%,drawCue%,drawGabor%,drawFlanker%)
    'This function simply allows us to draw/erase the four main elements which
    'compose the Spike2 monitor screen (fixpt, cue patch, gabors, flankers)
    'Enter 1 to draw the element, -1 to erase, 0 to do nothing
    'For drawGabor%, we can also indicate an orientation change by turning the 
    'indicator red as:
    'drawGabor%    gabor1    gabor2
    '   -1          off       off
    '    0            no action       
    '    1          blue      blue
    '    2          red       blue      (orientation/contrast change on 1)
    '    3          blue      red       (orientation/contrast change on 2)
    
    'Note that it will probably be easier to ensure the existence of the
    'various plotting channels here than to try to check conditionally in
    'the idle loop every time we call this function; rather, when calling
    'this function, just indicate the items that *would* happen here if they
    'are active, and here we will make sure that they are active
    '
    'Moreover, we are going to check the state of each of the four drawn elements to
    'prevent redundant XYAddData/XYDelete calls
    
    if ctFixationOn% = 1 then
        docase
        case drawFix% = 1 and fixDrawn% = 0 then
            'Draw fixpt in xy window
            View(XYWindow%).XYAddData(iFixptChannel%, FixationX, FixationY);
            'Draw fixpt window in xy window
            if ctRequireFixation% <> 0 then
                View(XYWindow%).XYAddData(iFixptWindowChannel%, CueWindowX[], CueWindowY[]);  'fixpoint window is identical to cue window  
            endif
            fixDrawn% := 1;
        case drawFix% = -1 and fixDrawn% = 1 then 
            'Delete fixpt
            View(XYWindow%).XYDelete(iFixptChannel%);
            'Delete fixpt window
            if ctRequireFixation% <> 0 then
                View(XYWindow%).XYDelete(iFixptWindowChannel%);  
            endif
            fixDrawn% := 0;
        endcase
    endif
    
    if ctTrainingOptions% > 1 then
        docase
        case drawCue% = 1 and cueDrawn% = 0 then
            'Draw cue window in xy window
            View(XYWindow%).XYAddData(iCueWindowChannel%, CueWindowX[], CueWindowY[]);
            cueDrawn% := 1;
        case drawCue% = -1 and cueDrawn% = 1 then 
            'Delete cue window
            View(XYWindow%).XYDelete(iCueWindowChannel%);
            cueDrawn% := 0;
        endcase
    endif
    
    if ctTrainingOptions% > 2 then
        docase
        case drawGabor% = 1 and gaborDrawn% <> 1 then
            'Draw gabor windows in xy window
            View(XYWindow%).XYColour(iDisplayWindowGabor1%,13);  'blue
            View(XYWindow%).XYColour(iDisplayWindowGabor2%,13);  'blue
            View(XYWindow%).XYAddData(iDisplayWindowGabor1%, Gabor1WindowX[], Gabor1WindowY[]);
            View(XYWindow%).XYAddData(iDisplayWindowGabor2%, Gabor2WindowX[], Gabor2WindowY[]);
            gaborDrawn% := 1;
        case drawGabor% = 2 and gaborDrawn% <> 2 then
            'Draw gabor windows in xy window
            View(XYWindow%).XYColour(iDisplayWindowGabor1%,16);  'red
            View(XYWindow%).XYColour(iDisplayWindowGabor2%,13);  'blue
            View(XYWindow%).XYAddData(iDisplayWindowGabor1%, Gabor1WindowX[], Gabor1WindowY[]);
            View(XYWindow%).XYAddData(iDisplayWindowGabor2%, Gabor2WindowX[], Gabor2WindowY[]);
            gaborDrawn% := 2;
        case drawGabor% = 3 and gaborDrawn% <> 3 then
            'Draw gabor windows in xy window
            View(XYWindow%).XYColour(iDisplayWindowGabor1%,13);  'blue
            View(XYWindow%).XYColour(iDisplayWindowGabor2%,16);  'red
            View(XYWindow%).XYAddData(iDisplayWindowGabor1%, Gabor1WindowX[], Gabor1WindowY[]);
            View(XYWindow%).XYAddData(iDisplayWindowGabor2%, Gabor2WindowX[], Gabor2WindowY[]);
            gaborDrawn% := 3;
        case drawGabor% = -1  and gaborDrawn% > 0 then 
            'Delete gabor windows
            View(XYWindow%).XYDelete(iDisplayWindowGabor1%);
            View(XYWindow%).XYDelete(iDisplayWindowGabor2%);
            gaborDrawn% := 0;
        endcase
        
        docase
        case drawFlanker% = 1 and flankerDrawn% = 0 then
            'Draw flanker windows in xy window
            View(XYWindow%).XYAddData(iDisplayWindowFlanker1%, Flanker1WindowX[], Flanker1WindowY[]);
            View(XYWindow%).XYAddData(iDisplayWindowFlanker2%, Flanker2WindowX[], Flanker2WindowY[]);
            View(XYWindow%).XYAddData(iDisplayWindowFlanker3%, Flanker3WindowX[], Flanker3WindowY[]);
            View(XYWindow%).XYAddData(iDisplayWindowFlanker4%, Flanker4WindowX[], Flanker4WindowY[]);
            flankerDrawn% := 1;
        case drawFlanker% = -1 and flankerDrawn% = 1 then 
            'Delete flanker windows
            View(XYWindow%).XYDelete(iDisplayWindowFlanker1%);
            View(XYWindow%).XYDelete(iDisplayWindowFlanker2%);
            View(XYWindow%).XYDelete(iDisplayWindowFlanker3%);
            View(XYWindow%).XYDelete(iDisplayWindowFlanker4%);
            flankerDrawn% := 0;
        endcase
    endif
    

    
    
end




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Note that we only have ONE joystick channel defined, so only one axis - in this case
'we expect the up/down axis
'Used to accept a channel input, but since there's only one, what's the point?
'Used to accept a "now" input but it didn't DO anything because the functions that we
'call here just use maxtime().  That may not be ideal, but let's not mess with success for now.
'We need to specify a "go forward" value whenever we call this to ensure that the AlwaysPressing 
'feature will perform as expected
func Answer%(goForward%)
    var ans% := -1;
    var v;  'will fill with actual voltage
    
    if ctAlwaysPressing% = 1 then
        return goForward%;
    endif
    
    
    if ChanKind(JoyChannel%) > 0 then  'if the channel does not exist, return -2 (was 0, but 0 is now used as a meaningful output)
        ans% := GetJoystickPositionUD%(v);   
    else
        ans% := -2;
    endif;
        
    docase
    case ans% = JSError% then
        printlog("There has been an error in reading the joystick!  GetJoystickPosition% has returned -1!\n");
    case ans% = -2 then  'this is a bit silly as we are assigning this directly above, but OK
        printlog("Joystick Channel does not appear to exist!  GetJoystickPosition% has returned -2!\n");
    endcase    
    
	return ans%;
    
    'This function will return:
    'JSDown% if joystick is down
    'JSCenter% if joystick is in center
    'JSUp% if joystick is up 
    '0 if joystick is not down ("in origin" - note that "up" is also "in origin")
    '-1 or -2 on error
     
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
    
    'We seem unlikely to use ctAlwaysLooking% here, because we have the ability to turn off eye
    'position monitoring, and we have ctAlwaysPressing% to simulate the joystick.  For testing we
    'will likely use ctAlwaysPressing%, and if we test monitoring eye position the point will be
    'to use the mouse to simulate looking/not looking.  ctAlwaysPressing% is the true test mode.
    'Instead, use ctCheckLooking% (which ctAlwaysLooking% will override at time of setting) to
    'return 1 in cases where we are not monitoring fixation for whatever reason
    if ctCheckLooking% = 0 then 
        return 1; 
    endif;
 
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then 
        return 1; 
    else 
        return 0; 
    endif
end;