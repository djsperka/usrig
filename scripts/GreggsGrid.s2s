' $Id$

const ggCVSID$ := "$Id$";


'Include Files

#include "../util/ChannelUtilities.s2s"
#include "../util/UsreyUtil.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "UsreyFixationPoint.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' GreggsGrid script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Overall script control vars
var Pause% := 0;
const nMaxTrials% := 2000;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		
var XChannel%;
var YChannel%;
'var iStimChannel%;
var iStimChannel%[25];

var FrameChannel%;
var FrameSlaveChannel%;
var StimChannel%;
var ChangeChannel%;
var ReadyChannel%;
var ReadySlaveChannel%;
var StimSlaveChannel%;
var DigitalLaserChannel%;
var SequencerPeriodMS;
var StimulatorChannel%;
var UtilityChannel%;
var TimingChannel%;
var FixationPointChannel%;


' XY window stuff
var XYWindow%;			' 
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iStimWindowChannel%;

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];
var BackgroundColor$ := "gray";  'for right now, let's not even allow changing this...
var stimWindowX[25][36];   'stimulus windows (for fixation) for each stimulus
var stimWindowY[25][36];
var stimXPos[25];          'position of center-of-stimulus; 0-8 are the 9 central stimuli, 9-24 are the peripheral stimuli
var stimYPos[25];          'this order may seem weird but it has two benefits.  1) It allows us to easily use 9 or 25 stimuli
                           'without the location of stimulus "5" being adjusted.  2) Since only central stimuli will be changed
                           'in orientation, these will be 0-8 for either case
                           'Stimulus position grid:
                           '  9  10  11  12  13
                           ' 14   0   1   2  15
                           ' 16   3   4   5  17
                           ' 18   6   7   8  19
                           ' 20  21  22  23  24
var stimInRF%[25];   'Index this with the index of interest (0-24).  The value is the index (0-24) of the stimulus in the receptive field if the animal is fixating the stimulus of interest
                     'If there is NO STIM in the RF, we use nStim% (one greater than last stimulus)

var stimOrientation[26][nMaxTrials%];  'This is 26 instead of 25 because we need to be able to represent "no stimulus in RF" in stimInRF%[], indexing with nStim% will work
var fixptPresent%[25][nMaxTrials%];   'Parallel to stimOrientation[][], but we can have locations that hold gratings that DO NOT hold fixation points
                                     'Note that fixptPresent%[][] == 0 will match stimOrientation[][] == -1000 if putFixptOverGratings% is 0, so they can be interchangable in that case,
                                     '(but not in the non-existent 26th stimulus slot, which is not needed here)
var gratingPresent%[26][nMaxTrials%];  'Similar to fixptPresent%[][], used as a replacement for stimOrientation[][] = -1000, allows us to remove a grating without specifying that weird orientation 
var changeFromOrientation[nMaxTrials%];   'change-to orientation will always be preferredOri
var changeLoc%[nMaxTrials%];


' dummy vars
var iScript%;


var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastFixPtDisplayUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before image is presented)
var tRise, tFall;
var tKludge := 0.06;    ' Add to Fixation time to account for stim sequence. Ugly hack, admittedly, but one does what one must. 
var FixationWasBroken% := 0;  'this allows us to monitor fixation through the individual image "periods"
var FixWaitState%;
var HBCycle% := 1;


' Constants for states

const stateVSGWait%:=0;		            ' Wait for VSG to send ready signal, only used at beginning of experiment
const stateStartTrial%:=1;              ' Start trial, request grid
const stateWaitForGrid%:=2;             ' Wait for VSG signal that grid is up
const stateWaitAcqAnyGrating%:=3;       ' Wait for animal to acquire any grating
const stateHoldIntermediateGrating%:=4; ' Require animal to hold grating, orientation change not imminent, give intermediate reward on success
const stateHoldPreChangeGrating%:=5;    ' Require animal to hold grating, orientation change during this hold
const stateChangeGratingOrientation%:=6;' Request grating orientation change
const stateWaitGratingChange%:=7;       ' Wait for VSG to signal grating change
const stateWaitAcqChangedGrating%:=8;   ' Wait for acquisition of changed grating
const stateHoldChangedGrating%:=9;      ' Require animal to hold grating for reward
const stateWaitForBlank%:=10;           ' Wait for VSG indication of blank screen, first step upon any blank
const stateReward%:=11;                 ' Give full reward
const stateTrialSuccess%:=12;           ' Advance stimulus, increment stimulus counter, check for end of trials
const stateTO%:=13;                     ' Give time out on failure
const stateITI%:=14;                    ' Intertrial interval

var iState% := stateVSGWait%;	' present state
var stateBegin% := 1;  'For fun, in this script let's keep track of whether it is the first time through a state, for logging purposes

var currTrial%:=1;  'Not an index
var illegalGrating%:=-1;  'No grating is illegal
var currentGrating%:=0;  'Grating being looked at
var numFixationsRemaining%;
var reduceFixations%;    'On some repeats we will reduce the number of fixations required
var tStartFindAnyGrating;
var tGratingChange;
var tGratingFlicker;
var flickerLetter$;
var tBlank;
var tReward;
var trialSuccess%;
var changeInRF%;
var JuiceRewardMSorig%;
var pRewardOrig;
var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;	

var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
var pulseFound%;
'var pulseFoundSlave%;
var tOpt;


' Wavemarks and continuous ports
var ggNWavemarks% := 0;
var ggWavemarkPorts%[64];
var ggNContinuous% := 0;
var ggContinuousPorts%[64];



' Dialog box variables
var AlwaysLooking% := 1; ' If set eye signals ignored - subject presumed to be looking always. TESTING ONLY.
var nStimIndex% := 1;
var nStim%;
var actualNStim%;  'with the addition of "lines" there is a chance some stimuli will not be made, for most purposes we want nStim% but in a few cases we need to know the actual number
var nOrientations% := 4;
var minDeltaOri := 30;
var nTrials% := 100;
var minFixations% := 3;
var varFixations% := 2;
var fixAcqTime := 2;
var fixHoldTime := 0.5;
var gratingChangeTime := 0.25;
var fixAcqTimeout := 0;
var ITI := 1.5; 
var rewardDelay := 0; 
var intRewardMS% := 70;
var intRewardProb := 0.5;
var addFixRad;
var putFixptOverGratings%;
var noFixptIfNoGratingInRF%;
var flickerSec;





var preferredOri;  'what is preferred orientation?
var screenXDeg := 12.5;  'Manually setting screen degrees - we might want to calculate this based on manual screen cm or have degrees/cm in main dialog, but for now...
var screenYDeg := 9.5;
var ggWindowRadius;
var doChange%;

GetGreggsGridScriptParameters();  'We will just get these right off the bat, this supports the pre-dialog box
'that warns about AlwaysLooking - though this pre-dialog is currently disabled



' Init logging
LogInit(1);

UseTwo1401s% := DoWeUseTwo1401s%();

if UseTwo1401s% = 1 then
    'Two 1401s disabled because the port carrying the "change" trigger from the VSG has been stolen from one
    'of the slave ports, we need to fix that (physically and code-wise) to allow Two 1401s to work.
    message("Using two 1401s has been disabled for the GreggsGrid script!  Talk to Dan/Jeff!  Quitting!");
    halt;
endif

GetPortsAndNumWMsWFs%(ggNWavemarks%,ggNContinuous%,ggWavemarkPorts%[],ggContinuousPorts%[]);



' Check if always looking flag is set. If so, issue a warning.
' I'm thinking that this is kind of a pain in the butt, we can possibly just put it in the dialog box
' and forget it.  If Henry wants it back as a warning up front, it's an easy uncomment.
'if AlwaysLooking% = 1 then
'    if Query("Always looking is SET. Unset?") = 1 then
'        AlwaysLooking% := 0;
'    endif
'endif


iScript% := GreggsGridScriptDialog%();

if iScript% = 1 then
    LogInfo("Proceed with DAQ.");
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 25;
YChannel% := 26;
ReadyChannel% := 40;
FrameChannel% := 41;
StimChannel% := 43;
ReadySlaveChannel% := 44;
StimulatorChannel% := 46;
ChangeChannel% := 47;
DigitalLaserChannel% := 48;  'is 32 on Acute tuning, but let's not shove it in the midst of other stuff
UtilityChannel% := 39;
TimingChannel% := 38;
FixationPointChannel% := 45;



ExcludedChans%[0] := 25;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 49;  'OptoCopyChannel% is highest non-electrode channel used by this function  


'If we are not linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the dual-1401 setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401/SLAVE 1401 (the second, non-dominant instance of Spike2) FIRST and on the 
'MICRO 1401/MASTER 1401 (the first,  dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run 
'the VSG program (Fixstim) which gives the sampling trigger and sets the experiment in motion.
if UseTwo1401s% = 0 then
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();
    
    tic := View(DataWindow%).BinSize(ReadyChannel%);
    
    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' GreggsGrid script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




'From here on out, it's just various necessary functions


' GreggsGridScriptDialog

func GreggsGridScriptDialog%()
	var i%;
	var iReturn%;
    var rfX,rfY,rfW,rfH;
    var numStim$[10];
    numStim$[0] := "1 (no grating change)";
    numStim$[1] := "2 (no grating change)";
    numStim$[2] := "4 (no grating change)";
    numStim$[3] := "4";
    numStim$[4] := "9 (no grating change)";
    numStim$[5] := "9";
    numStim$[6] := "25 (no grating change)";
    numStim$[7] := "25";
    numStim$[8] := "Lines (no grating change)";
    numStim$[9] := "Lines";

    GetGreggsGridScriptParameters();
    
    'These variables are available
    'printlog("fix diam is %f and fixation color is %s\n",FixationDiameter,FixationColor$);
    
    'Get preferred orientation
    ParseGratingParametersOri%(GetGratingParameters$("Stimulus"), preferredOri);
    if preferredOri >= 180 then
        preferredOri -= 180;  'if the value has been entered between 180-360, give it a u-turn (there is no drift, tf=0, so it's the same)
    endif
    
        
    DlgCreate("GreggsGrid Parameters", 0, 0, 0, 0, -1, 1, 1);  'center dialog relative to screen and not to application window to eliminate cutting off the bottom of the dialog!
    DlgGroup("Stimuli", 1, 1, 50, 7);
    DlgList(1, "Number of Stimuli: ", numStim$, 10, 32, 2);
    DlgInteger(2, "Number of orientations (0-180 deg)", 1, 1000, 0, 3);
    DlgReal(3, "Minimum dOri for change, deg", 0, 90, 0, 4);
    DlgInteger(4, "Number of trials", 1, nMaxTrials%, 0, 5);
    DlgCheck(5,"Put Fixpt over gratings",0,6);
    DlgCheck(6,"But no fixpt if no grating in RF",5,7);
    
    DlgGroup("Fixation", 1, 8, 50, 4);
    DlgInteger(7, "Minimum fixations", 0, 100, 0, 9);
    DlgInteger(8, "Variable fixations", 0, 100, 0, 10);
    DlgReal(9, "Additional fix radius (deg)", 0, 10, 0, 11);
    DlgCheck(10,"Always Looking",0,12);
    
    DlgGroup("Timing", 1, 13, 50, 7);
    DlgReal(11, "Fixation Acquisition Time (s)", 0, 1000, 0, 14);
    DlgReal(12, "Fixation Hold Time (s)", 0, 10, 0, 15);
    DlgReal(13, "Grating Change Time (s)", 0, 10, 0, 16);
    Dlgreal(14, "Grating Flicker Period (0 for off) (s)", 0, 10, 0, 17);
    DlgReal(15, "Fixation/Acq Timeout (s)", 0, 100, 0, 18);
    DlgReal(16, "Intertrial Interval (s)", 0, 10, 0, 19);
    
    DlgGroup("Reward", 1, 20, 50, 4);
    DlgReal(17, "Main Reward delay (s)", 0, 3, 0, 21);
    DlgInteger(18, "Intermediate Reward dur (ms)", 0, 1000, 0, 22);
    DlgReal(19, "Intermediate Reward prob (0-1)", 0, 1, 0, 23);
    
    'Right now we don't seem to need a callback, it's ready directly below if we do 
    DlgAllow(0xffff, 0, GreggsGridScriptDialogChanged%);

    i%:=DlgShow(nStimIndex%, nOrientations%, minDeltaOri, nTrials%, putFixptOverGratings%, noFixptIfNoGratingInRF%, minFixations%, varFixations%, addFixRad, 
                AlwaysLooking%, fixAcqTime, fixHoldTime, gratingChangeTime, flickerSec, fixAcqTimeout, ITI, rewardDelay, intRewardMS%, intRewardProb);
    
    if i% = 1 then

		SaveGreggsGridScriptParameters();
        
        'Fill nStim%, doChange% (currently doChange% is tethered to nStim%, but it could be untethered if appropriate)
        docase
        case nStimIndex% = 0 then
            nStim% := 1;  'Training, no grating change
            doChange% := 0;
        case nStimIndex% = 1 then
            nStim% := 2;  'Training, no grating change
            doChange% := 0;
        case nStimIndex% = 2 then
            nStim% := 4;  'Training, no grating change
            doChange% := 0;
        case nStimIndex% = 3 then
            nStim% := 4;  'Training, introduce grating change
            doChange% := 1;
        case nStimIndex% = 4 then
            nStim% := 9;  'Training, no grating change
            doChange% := 0;
        case nStimIndex% = 5 then
            nStim% := 9;  'Introduce grating change
            doChange% := 1;
        case nStimIndex% = 6 then
            nStim% := 25;  'Training, no grating change
            doChange% := 0;
        case nStimIndex% = 7 then
            nStim% := 25;  'Introduce grating change
            doChange% := 1;
        case nStimIndex% = 8 then
            nStim% := -1;  'Use -1, we will determine how many gratings will fit on the screen; Training, no grating change
            doChange% := 0;
        case nStimIndex% = 9 then
            nStim% := -1;  'Use -1, we will determine how many gratings will fit on the screen; Introduce grating change
            doChange% := 1;
        endcase
        
        
        'Check to ensure there will not be overlapping stimuli, and that the stimuli will not go off screen
        'Do this after the dialog because we need to know which nStim% was selected, this is totally inappropriate for < 9 stims
        ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"),rfX,rfY,rfW,rfH);
        docase
        'Make sure the outer edge of "9" stimuli will not be off screen, if so, quit
        case (abs(rfX) + (rfW/2)) > screenXDeg and nStim% = 9 then
            message("X requires " + str$(abs(rfX) + (rfW/2)) +  " degrees for 9 stimuli, screen is " + str$(screenXDeg) + " degrees, quitting!"); 
            halt;
        case (abs(rfY) + (rfH/2)) > screenYDeg and nStim% = 9 then
            message("Y requires " + str$(abs(rfY) + (rfH/2)) +  " degrees for 9 stimuli, screen is " + str$(screenYDeg) + " degrees, quitting!"); 
            halt; 
        'Make sure the outer edge of "25" stimuli will not be off screen, if so, restrict to 9 stimuli??
        case ((2*abs(rfX)) + (rfW/2)) > screenXDeg and nStim% = 25 then
            message("X requires " + str$((2*abs(rfX)) + (rfW/2)) +  " degrees for 25 stimuli, screen is " + str$(screenXDeg) + " degrees"); 
            nStim% := 9;
        case ((2*abs(rfY)) + (rfH/2)) > screenYDeg and nStim% = 25 then
            message("Y requires " + str$((2*abs(rfY)) + (rfH/2)) +  " degrees for 25 stimuli, screen is " + str$(screenYDeg) + " degrees"); 
            nStim% := 9;
        'Make sure stimuli will not overlap in X, Y   
'        case rfW >= abs(rfX) and nStim% > 4 then
'            message("X position is " + str$(rfX) + ", X width is " + str$(rfw) + ", stimuli will overlap, quitting!");
'            halt;
'        case rfH >= abs(rfY) and nStim% > 4  then
'            message("Y position is " + str$(rfY) + ", Y width is " + str$(rfh) + ", stimuli will overlap, quitting!");
'            halt;
        'Trying new strategy for overlapping stimuli
        case abs(rfX) < 1.5*rfW and abs(rfY) < 1.5*rfH and nStim% > 4 then
            message("Both X and Y RF positions are within 1.5 diameters of the stimulus.  Cannot use this RF location without reducing the size of the stimulus!");
            halt;
        case abs(rfX) < 2*rfW and abs(rfY) < 2*rfH and nStim% > 4 then
            'Here we do nothing - with both X/Y positions kinda uncomfortably small, do requested grid, grin and bear it
        case abs(rfX) < 2*rfW and nStim% > 4 then
            nStim% := -1;  'doChange does not change
            message("The X RF position is too close for grid-style, will switch to line-style");
        case abs(rfY) < 2*rfH and nStim% > 4 then
            nStim% := -1;  'doChange does not change
            message("The Y RF position is too close for grid-style, will switch to line-style");
        endcase
        actualNStim% := nStim%;  'initial setting, will have to be changed in the "lines" version
        
        
        
        'Build locations of stimuli and trials
        docase
        case nStim% > 4 then 'Use full version for 9/25 stimuli, this is "the real deal"
            'Build locations of stimuli
            BuildStimLocations%(rfX,rfY,rfW,rfH);
        
            'Build list of trials (stimOrientation[][], fixptPresent%[][], changeLoc%[], changeFromOrientation[])
            BuildOrientations();
        case nStim% < 0 then 'Use lines version, used typically when one RF position is too close to the center for the grid to correctly offset in both directions
            'Build locations of stimuli
            BuildStimLocationsLines%(rfX,rfY,rfW,rfH);  'not yet written, this is a placeholder
        
            'Build list of trials (stimOrientation[][], fixptPresent%[][], changeLoc%[], changeFromOrientation[])
            'BuildOrientationsLines();  'not yet written, this is a placeholder
            BuildOrientations();  'Actually, this *should* work here.
        else  'Use lite version for 1/2/4 stimuli, this is training
            'Build locations of stimuli
            BuildStimLocationsLite%(rfW,rfH);  'We will ignore the position of the RF, but use the width/height of the RF
        
            'Build list of trials (stimOrientation[][], fixptPresent%[][], changeLoc%[], changeFromOrientation[])
            BuildOrientationsLite();

        endcase;
        
        
        
'        stimOrientation[25][nMaxTrials%];  
'        changeFromOrientation[nMaxTrials%];
'        changeLoc%[nMaxTrials%];
        
        
        iReturn% := 1;  'set return value to success, otherwise we'll just quit.
        
	endif;
    
	return iReturn%;
    
    
end;

func GreggsGridScriptDialogChanged%(item%) 
    
    'DlgEnable(0,16);  'Disable reward delay
    
    'If there are no fixpts, do not allow reduced fixpts
    if DlgValue(5) = 0 then
        DlgValue(6,0);
    endif;
    DlgEnable(DlgValue(5),6);  'Only enable reduced number of fixpts if fixpts are present
    
    
    
    return 1;
end



proc GetGreggsGridScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\GreggsGrid";
    
    nStimIndex% := GetIntRegistryValue%(key$, "nStimIndex", nStimIndex%);
    nOrientations% := GetIntRegistryValue%(key$, "nOrientations", nOrientations%);
    minDeltaOri := GetFloatRegistryValue(key$, "minDeltaOri", minDeltaOri);
    nTrials% := GetIntRegistryValue%(key$, "nTrials", nTrials%);
    minFixations% := GetIntRegistryValue%(key$, "minFixations", minFixations%);
    varFixations% := GetIntRegistryValue%(key$, "varFixations", varFixations%);
    AlwaysLooking% := GetIntRegistryValue%(key$, "AlwaysLooking", AlwaysLooking%);
    fixAcqTime := GetFloatRegistryValue(key$, "fixAcqTime", fixAcqTime);
    fixHoldTime := GetFloatRegistryValue(key$, "fixHoldTime", fixHoldTime);
    gratingChangeTime := GetFloatRegistryValue(key$, "gratingChangeTime", gratingChangeTime);
    fixAcqTimeout := GetFloatRegistryValue(key$, "fixAcqTimeout", fixAcqTimeout);
    ITI := GetFloatRegistryValue(key$, "ITI", ITI);
    rewardDelay := GetFloatRegistryValue(key$, "rewardDelay", rewardDelay);
    intRewardMS% := GetIntRegistryValue%(key$, "intRewardMS", intRewardMS%);
    intRewardProb := GetFloatRegistryValue(key$, "intRewardProb", intRewardProb);
    addFixRad := GetFloatRegistryValue(key$, "addFixRad", addFixRad);
    putFixptOverGratings% := GetIntRegistryValue%(key$, "putFixptOverGratings", putFixptOverGratings%);
    noFixptIfNoGratingInRF% := GetIntRegistryValue%(key$, "noFixptIfNoGratingInRF", noFixptIfNoGratingInRF%);
    flickerSec := GetFloatRegistryValue(key$, "flickerSec", flickerSec);

end;

proc SaveGreggsGridScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\GreggsGrid";
    
    SetIntRegistryValue(key$, "nStimIndex", nStimIndex%);
    SetIntRegistryValue(key$, "nOrientations", nOrientations%);
    SetFloatRegistryValue(key$, "minDeltaOri", minDeltaOri);
    SetIntRegistryValue(key$, "nTrials", nTrials%);
    SetIntRegistryValue(key$, "minFixations", minFixations%);
    SetIntRegistryValue(key$, "varFixations", varFixations%);
    SetIntRegistryValue(key$, "AlwaysLooking", AlwaysLooking%);
    SetFloatRegistryValue(key$, "fixAcqTime", fixAcqTime);
    SetFloatRegistryValue(key$, "fixHoldTime", fixHoldTime);
    SetFloatRegistryValue(key$, "gratingChangeTime", gratingChangeTime);
    SetFloatRegistryValue(key$, "fixAcqTimeout", fixAcqTimeout);
    SetFloatRegistryValue(key$, "ITI", ITI);
    SetFloatRegistryValue(key$, "rewardDelay", rewardDelay);
    SetIntRegistryValue(key$, "intRewardMS", intRewardMS%);
    SetFloatRegistryValue(key$, "intRewardProb", intRewardProb);
    SetFloatRegistryValue(key$, "addFixRad", addFixRad);
    SetIntRegistryValue(key$, "putFixptOverGratings", putFixptOverGratings%);
    SetIntRegistryValue(key$, "noFixptIfNoGratingInRF", noFixptIfNoGratingInRF%);
    SetFloatRegistryValue(key$, "flickerSec", flickerSec);
    
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func IdleProcessing%()
	var iStatus% := 1;	
    
    'Get current time
    tNow := View(DataWindow%).MaxTime();
    
    xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
    yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
    
    ' Don't update display every time....
    if tNow-tLastFixPtDisplayUpdate > .005 then
        View(XYWindow%).XYAddData(1,xEye,yEye);
        tLastFixPtDisplayUpdate := tNow;
    endif
    
    
    docase 
    case iState% = stateVSGWait% then 
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        ' Once VSG is ready, we start
        if stateBegin% = 1 then
            LogStatus("VSGWait", "Begin waiting for Ready Pulse from VSG at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        
        if pulseFound% = 1 then
            LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
            Yield(1.0);
            tLastTrigger := tFall;
            ChangeStateTo(stateStartTrial%, tFall);
            
            if RecordEyeTrackerOutputFile% = 1 then
                'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
            endif;
            
        else
            if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                tLastTrigger := tFall;
            endif;
        endif;
        
        
    case iState% = stateStartTrial% then
        ' Request grid
        if stateBegin% = 1 then
            LogStatus("StartTrial", "Requested grid up from VSG at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        'Calculate number of fixations remaining
        docase
        case nStim% = 1 then
            numFixationsRemaining% := 1;  'Can't change fixation location if nStim% is 1
        case reduceFixations% = 0 then
            numFixationsRemaining% := rand(varFixations%+1,minFixations%);  'the math requires var+1
        else
            numFixationsRemaining% := rand(varFixations%+1,1);  'make minumum fixations 1 (for now keep same var?  this is quite off the cuff)
            reduceFixations% := 0;  'reset variable
        endcase
        
        'Note all gratings are legal before any acquisition
        illegalGrating% := -1;
        
        'Request stimulus up
        SafeSampleKey("S");
        
        'Sampletext the start of the trial
        SampleText("Trial " + str$(currTrial%),tNow);
        
        ChangeStateTo(stateWaitForGrid%, tNow);
        
 
        
    case iState% = stateWaitForGrid% then
        ' Wait for VSG to indicate grid up
        if stateBegin% = 1 then
            LogStatus("WaitForGrid", "Begin waiting for Grid Up Pulse from VSG at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if View(DataWindow%).FindRisingEdge%(StimChannel%, tStateStart, tTrigger) = 0 then
            ' Stimulus is up
            LogStatus("WaitForGrid", "Grid up at " + str$(tTrigger));
            tLastTrigger := tTrigger;
            tStartFindAnyGrating := tTrigger;
            
            
            'put timing marker in both eyetracker file, smr file
            if RecordEyeTrackerOutputFile% = 1 then
                docase
                case HBCycle% = 1 then
                    SafeSampleKey("1");
                case HBCycle% = 2 then
                    SafeSampleKey("2");
                case HBCycle% = 3 then
                    SafeSampleKey("3");
                case HBCycle% = 4 then
                    SafeSampleKey("4");
                case HBCycle% = 5 then
                    SafeSampleKey("5");
                case HBCycle% = 6 then
                    SafeSampleKey("6");
                case HBCycle% = 7 then
                    SafeSampleKey("7");
                endcase
                HBCycle% += 1;  'increment HBCycle%
                if HBCycle% = 8 then  'and cycle when necessary
                    HBCycle% := 1;
                endif
                'yield(0.01);   'May not be necessary in this code
            endif;
            
            ChangeStateTo(stateWaitAcqAnyGrating%, tTrigger);
            
        endif
        
        
        
        
        
    case iState% = stateWaitAcqAnyGrating% then
        ' Wait for animal to acquire a grating
        if stateBegin% = 1 then
            LogStatus("WaitAcqAnyGrating", "Begin waiting for animal to acquire any grating at " + str$(tNow));
            stateBegin% := 0;
        endif

        docase   
        case LookingGrid%(xEye,yEye,currentGrating%) = 1 then  'here, successful acquisition overrides the acquisition timeout if they happen simultaneously
            LogStatus("WaitAcqAnyGrating", "Grating " + str$(currentGrating%) + " acquired at " + str$(tNow));
            if stimOrientation[stimInRF%[currentGrating%]][currTrial%-1] = -1000 then
                SampleText("Acquired Grating (Voluntary), grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+", RFOri=NoStimInRF",tNow);
            else
                SampleText("Acquired Grating (Voluntary), grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+
                ", RFOri="+str$(stimOrientation[stimInRF%[currentGrating%]][currTrial%-1])+", RFStimNum="+str$(stimInRF%[currentGrating%]),tNow);
            endif
            docase
            case numFixationsRemaining% > 1 or (currentGrating% = changeLoc%[currTrial%-1] and AlwaysLooking% = 0 and doChange% = 1) then  'AlwaysLooking will loop forever if the change grating is 7 (AlwaysLooking aribtrary grating #)
                changeStateTo(stateHoldIntermediateGrating%,tNow);
            case doChange% = 0 then  'if this is the last fixation and we aren't changing a grating, skip to final hold
                changeStateTo(stateHoldChangedGrating%,tNow);  'kind of a kludge as nothing has changed
            else
                changeStateTo(stateHoldPreChangeGrating%,tNow);
            endcase            
        case tNow - tStartFindAnyGrating > fixAcqTime then
            LogStatus("WaitAcqAnyGrating", "Acquisition window timed out at " + str$(tNow));
            'request grid down
            SafeSampleKey("X");
            trialSuccess% := 0;  'indicate to go to acquisition TO
            ChangeStateTo(stateWaitForBlank%,tNow);
        endcase
        
        
        
        
    case iState% = stateHoldIntermediateGrating% then
        ' Require animal to hold intermediate grating through hold time
        if stateBegin% = 1 then
            LogStatus("HoldIntermediateGrating", "Begin requiring animal to hold intermediate grating at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        docase
        case LookingGrating%(xEye,yEye,currentGrating%,currentGrating%) = 0 then
            tStartFindAnyGrating  := tNow;  'reset time for finding a grating
            SampleText("Fixation Broken",tNow);
            ChangeStateTo(stateWaitAcqAnyGrating%, tNow);
        case tNow - tStateStart > fixHoldTime then
            LogStatus("HoldIntermediateGrating", "Intermediate grating held at " + str$(tNow));
            if stimOrientation[stimInRF%[currentGrating%]][currTrial%-1] = -1000 then
                SampleText("Held Intermediate Grating, grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+", RFOri=NoStimInRF",tNow);
            else
                SampleText("Held Intermediate Grating, grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+
                ", RFOri="+str$(stimOrientation[stimInRF%[currentGrating%]][currTrial%-1])+", RFStimNum="+str$(stimInRF%[currentGrating%]),tNow);
            endif
            'give intermediate reward
            JuiceRewardMS% := intRewardMS%;  'set reward to intermediate value
            pReward := intRewardProb;  'set intermediate reward probability
            DefaultReward();  'give reward, pReward has been set to 1 above, so once we get in here it's not random
            TotalRewards% += 1;
            SampleText("Intermediate Reward");  'don't use tNow, so it is at "time of request"
            
            'Decrement number of fixations remaining
            numFixationsRemaining% -= 1;  
            if numFixationsRemaining% < 1 then
                numFixationsRemaining% := 1;
            endif;
            
            'Do not allow next grating to be this one
            illegalGrating% := currentGrating%;  
            
            ChangeStateTo(stateWaitAcqAnyGrating%, tNow);
        endcase
        
        
    case iState% = stateHoldPreChangeGrating% then
        ' Require animal to hold pre-change grating through pre-change time
        if stateBegin% = 1 then
            LogStatus("HoldPreChangeGrating", "Begin requiring animal to hold pre-change grating at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        docase
        case LookingGrating%(xEye,yEye,currentGrating%,currentGrating%) = 0 then
            tStartFindAnyGrating  := tNow;  'reset time for finding a grating
            SampleText("Fixation Broken",tNow);
            ChangeStateTo(stateWaitAcqAnyGrating%, tNow);
        case tNow - tStateStart > gratingChangeTime then
            LogStatus("HoldPreChangeGrating", "Request grating change at " + str$(tNow));
            SafeSampleKey("U");  'Request grating change, is capital V
            if stimOrientation[stimInRF%[currentGrating%]][currTrial%-1] = -1000 then
                SampleText("Held Pre-Change Grating, grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+", RFOri=NoStimInRF",tNow);
            else   
                SampleText("Held Pre-Change Grating, grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+
                ", RFOri="+str$(stimOrientation[stimInRF%[currentGrating%]][currTrial%-1])+", RFStimNum="+str$(stimInRF%[currentGrating%]),tNow);
            endif       
            ChangeStateTo(stateWaitGratingChange%, tNow);
        endcase
        
'    case iState% = stateChangeGratingOrientation% then   ''seems unnecessary, just request the change above
'        ' Request grating orientation change from VSG
'        if stateBegin% = 1 then
'            LogStatus("ChangeGratingOrientation", "Request VSG to change grating orientation at " + str$(tNow));
'            stateBegin% := 0;
'        endif
        
        
        
    case iState% = stateWaitGratingChange% then
        ' Wait for VSG to confirm grating orientation change 
        if stateBegin% = 1 then
            LogStatus("WaitGratingChange", "Begin waiting for grating change pulse from VSG at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if View(DataWindow%).FindRisingEdge%(ChangeChannel%, tStateStart, tTrigger) = 0 then
            ' Grating change has happened
            LogStatus("WaitGratingChange", "Grating change at " + str$(tTrigger));
            tLastTrigger := tTrigger;
            tGratingChange := tTrigger;
            tGratingFlicker := tTrigger;  'if we are flickering the grating for salience, when did it happen?
            flickerLetter$ := "S";  'we just gave a "U", so the next will be an "S"
            'Was the grating that changed the one in the RF?
            if changeLoc%[currTrial%-1] = stimInRF%[currentGrating%] then
                changeInRF% := 1;
            else
                changeInRF% := 0;
            endif
            SampleText("Grating change, changedGrating="+str$(changeLoc%[currTrial%-1])+", oldOri="+str$(changeFromOrientation[currTrial%-1])+", newOri="+str$(preferredOri)+", changeInRF="+str$(changeInRF%),tGratingChange);
            
            ChangeStateTo(stateWaitAcqChangedGrating%,tGratingChange);
            
        endif;
        
        
        
    case iState% = stateWaitAcqChangedGrating% then
        ' Wait for animal to acquire changed grating
            LogStatus("WaitAcqChangedGrating", "Begin waiting for animal to acquire changed grating at " + str$(tNow));
        if stateBegin% = 1 then
            stateBegin% := 0;
        endif
        
        docase   
        case LookingGrating%(xEye,yEye,currentGrating%,changeLoc%[currTrial%-1]) = 1 then  'here, successful acquisition overrides the acquisition timeout if they happen simultaneously
            LogStatus("WaitAcqChangedGrating", "Grating " + str$(currentGrating%) + " acquired at " + str$(tNow));
            if stimOrientation[stimInRF%[currentGrating%]][currTrial%-1] = -1000 then
                SampleText("Acquired Grating (Directed), grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+", RFOri=NoStimInRF",tNow);
            else
                SampleText("Acquired Grating (Directed), grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+
                ", RFOri="+str$(stimOrientation[stimInRF%[currentGrating%]][currTrial%-1])+", RFStimNum="+str$(stimInRF%[currentGrating%]),tNow);
            endif    
            changeStateTo(stateHoldChangedGrating%,tNow);  
        case tNow - tGratingChange > fixAcqTime then
            LogStatus("WaitAcqChangedGrating", "Acquisition window timed out at " + str$(tNow));
            'request grid down
            SafeSampleKey("X");
            trialSuccess% := 0;  'indicate to go to acquisition TO
            reduceFixations% := 1;  'indicate to use reduced fixations next time
            ChangeStateTo(stateWaitForBlank%,tNow);
        case flickerSec > 0 and tNow - tGratingFlicker > flickerSec then  'for a start, we're not going to try timing this too precisely
            SafeSampleKey(flickerLetter$);  'switch to the opposite screen
            'Man, don't even look for the frame trigger, let's see how it goes
            tGratingFlicker := tNow;
            if flickerLetter$ = "U" then  'swap letters back and forth
                flickerLetter$ := "S";
            else 
                flickerLetter$ := "U";
            endif
        endcase
        
        
        
    case iState% = stateHoldChangedGrating% then
        ' Require animal to hold changed grating through hold time
        if stateBegin% = 1 then
            LogStatus("HoldChangedGrating", "Begin requiring animal to hold changed grating at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        docase
        case LookingGrating%(xEye,yEye,currentGrating%,currentGrating%) = 0 then
            'request grid down
            SafeSampleKey("X");
            trialSuccess% := 0;  'indicate to go to acquisition TO
            SampleText("Fixation Broken",tNow);
            reduceFixations% := 1;  'indicate to use reduced fixations next time (won't reduce fixations if there is no changed grating)
            ChangeStateTo(stateWaitForBlank%,tNow);
        case tNow - tStateStart > fixHoldTime then
            'request grid down
            SafeSampleKey("X");
            LogStatus("HoldChangedGrating", "Changed grating held at " + str$(tNow));
            if stimOrientation[stimInRF%[currentGrating%]][currTrial%-1] = -1000 then
                SampleText("Held Changed Grating, grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+", RFOri=NoStimInRF",tNow);
            else
                SampleText("Held Changed Grating, grating="+str$(currentGrating%)+", gazeOri="+str$(stimOrientation[currentGrating%][currTrial%-1])+
                ", RFOri="+str$(stimOrientation[stimInRF%[currentGrating%]][currTrial%-1])+", RFStimNum="+str$(stimInRF%[currentGrating%]),tNow);
            endif    
            trialSuccess% := 1;         
            ChangeStateTo(stateWaitForBlank%, tNow);
        endcase
        
        
        
    case iState% = stateWaitForBlank% then
        ' Wait for VSG to indicate blank screen
        if stateBegin% = 1 then
            LogStatus("WaitForBlank", "Begin waiting for VSG to send blank screen pulse at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if View(DataWindow%).FindFallingEdge%(StimChannel%, tStateStart, tTrigger) = 1 or View(DataWindow%).FindFallingEdge%(ChangeChannel%, tStateStart, tTrigger) = 1 then
            ' Grid is off
            tLastTrigger := tTrigger;
            tBlank := tTrigger;
            'TODO: this, erase stimuli?  'DrawFix(0);	' actually this draws the location of the fixpt.
            if trialSuccess% = 0 then
                ChangeStateTo(stateTO%, tBlank);
                'Sampletext the end of the trial
                SampleText("Trial " + str$(currTrial%) + " failure",tNow)
            else
                ChangeStateTo(stateReward%, tBlank);
                'Sampletext the end of the trial
                SampleText("Trial " + str$(currTrial%) + " success",tNow)
            endif
        endif 
        
        
        
    case iState% = stateReward% then
        ' Deliver reward
        if stateBegin% = 1 then
            LogStatus("Reward", "Deliver reward at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if tNow - tStateStart > rewardDelay then  'reward delay currently disabled and 0, but maybe this is wanted?  Screen will be off, so...I hope not
            
            'give full reward
            JuiceRewardMS% := JuiceRewardMSorig%;  'set reward to original full value
            pReward := pRewardOrig;  'also probability of reward
            tReward := tNow;
            DefaultReward();  'give reward
            TotalRewards% += 1;
            SampleText("Full Reward");  'don't use tNow, so it is at "time of request"
            
            ChangeStateTo(stateTrialSuccess%,tNow);
            
        endif;
        
        
    case iState% = stateTrialSuccess% then
        ' Do trial success bookkeeping and advance
        if stateBegin% = 1 then
            LogStatus("TrialSuccess", "Do trial success bookkeeping and advance at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        var tempFloat;
        tempFloat := JuiceRewardMSorig%;
        
        'Advance Stimulus
        SafeSampleKey("a");
        
        'Increment trial counter
        currTrial% += 1;
        
        if currTrial% > nTrials% then
            SampleText("All Trials Complete!");
            Stop%();
            iStatus% := 0;
        else
            ChangeStateTo(stateITI%,tReward+(tempFloat/1000));  'Use time of end of reward for the ITI
        endif

        
        
    case iState% = stateTO% then
        ' Wait through time out period
        if stateBegin% = 1 then
            LogStatus("TO", "Begin waiting through timeout period at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if tNow - tStateStart > fixAcqTimeout then
            ChangeStateTo(stateITI%,tNow);
        endif;
        
        
        
    case iState% = stateITI% then
        ' Wait through intertrial interval
        if stateBegin% = 1 then
            LogStatus("ITI", "Begin waiting through intertrial interval at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if tNow - tStateStart > ITI then
            ChangeStateTo(stateStartTrial%,tNow);
        endif;
            
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        
        'If the eyetracker is recording an output file, stop recording and close the file
        if RecordEyeTrackerOutputFile% = 1 then
            SafeSampleKey("w");  'Stop recording
            yield(0.1);
            SafeSampleKey("i");  'Close the file
            SafeSampleKey("Z");  'zero the DIGLOWs
        endif
        
        halt;
        
    endcase
    
    
    
    
    return iStatus%;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
    stateBegin% := 1;  'Reset for next state - this line is unique (so far) to FreeViewer.s2s and is intended to allow us to do a bit more specific logging
	if tStart > 0 then 
        tStateStart := tStart; 
    endif;
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
    var key$;
    var primaryTxt$;
    var secondaryTxt$;
    
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
    
	SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    
    DoSampleAutoName(key$,"gg","gg",primaryTxt$,secondaryTxt$);
       
    SampleAutoFile(1);  'Enable automatic file naming
    
    ' Text marks make extraction easier
    SampleTextMark(200);  'Channel 30 is textmark channel
    

	'----Event Channel recording definitions----
    
   	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");

	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"Ready");
	SampleTitle$(ReadyChannel%,"Ready");
    
    SampleEvent(FixationPointChannel%, 2, 2, 3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixpt");
	SampleTitle$(FixationPointChannel%,"Fixpt");
	
	SampleEvent(StimChannel%, 3, 2, 3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
    'Channel for change is using port 7 for now, this will compromise UseTwo1401s...
    'In the future we may fix this in one way or another, for now we will disable
    'UseTwo1401s for GreggsGrid.
    SampleEvent(ChangeChannel%, 7, 2, 3600); 'Trigger channel, level
	SampleComment$(ChangeChannel%,"Change");
	SampleTitle$(ChangeChannel%,"Change");
    
    if UseTwo1401s% = 1 then
    
        SampleEvent(FrameSlaveChannel%, 4, 2, 3600);
        SampleComment$(FrameSlaveChannel%,"Frame-Slave");
        SampleTitle$(FrameSlaveChannel%,"Frame-Slave");
    
        SampleEvent(ReadySlaveChannel%, 5, 2, 3600); 'Trigger channel, level
        SampleComment$(ReadySlaveChannel%,"Ready-Slave");
        SampleTitle$(ReadySlaveChannel%,"Ready-Slave");
	
        SampleEvent(StimSlaveChannel%, 7, 2,3600); 'Trigger channel, level
        SampleComment$(StimSlaveChannel%,"Stim-Slave");
        SampleTitle$(StimSlaveChannel%,"Stim-Slave");
        
    endif
    

    
    'Possible digital marker channels.  Opto/INTAN have been removed as they seem super unlikely here, can be added back in from Freeviewer, etc.
    docase
    case UseTwo1401s% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Timing");  'Digital marker is by definition channel 32
    case RecordEyeTrackerOutputFile% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"EyeFilePulse");  'Digital marker is by definition channel 32
    endcase
       
    
    SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
	SampleTitle$(XChannel%,EyeXPortLabel$);
	SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
	SampleTitle$(YChannel%,EyeYPortLabel$);
    
    if UtilityPort% > -1 then
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);       
        SampleTitle$(UtilityChannel%,UtilityPortLabel$);
    endif;

    
    if UseTwo1401s% = 1 then
        SampleEvent(TimingChannel%, 6, 2, 3600); 'Trigger channel, level
        SampleComment$(TimingChannel%,"Handshake");
        SampleTitle$(TimingChannel%,"Hndshk");
    endif;

    
    
    '----Set up "spiking" Electrode Channels----
    SetUpElectrodeConfiguration(ggNWavemarks%,ExcludedChans%[]);
    
        
	
    
	if UseTwo1401s% = 0 then
        SampleSequencer(script$ + "Tuning.pls");
    else
        SampleSequencer(script$ + "TuningSendTrigger.pls");
    endif;

	DoSampleOptimise();
	SampleMode(1); 'Continuous sampling
    
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeWindows()
    var i%;
    var tempNStim%;
    
    ' Make spike2 use all of monitor 1 - I hate this...but...
    View(App()).Window(0, 0, 100, 100, 1);
    
	'Open the data sampling window
    DataWindow% := FileNew(0,4);
    if DataWindow% < 0 then
        PrintLog("FileNew Error: %s\n", Error$(DataWindow%));
    endif

	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
            

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);  'Red for fixation point - note that XYColour is deprecated, but works fine so we're sticking with it
	XYSize(1,-1);


	'Stimulus windows are calculated in the dialog box
	'Create a new channel in the XY view to display the stimulus windows
    'So if I understand channels on XY views correctly, we actually have to create a NEW channel for each stimulus
    if nStim% > 2 then
        tempNStim% := nStim%;
    else
        tempNStim% := 4;  'make sure we draw boxes for even invisible gratings in the training mode
    endif;
    for i% := 0 to tempNStim%-1 do
        iStimChannel%[i%] := XYSetChan(0);
        XYColour(iStimChannel%[i%],13);  'Blue for stimuli
        XYDrawMode(iStimChannel%[i%],2,1);  'Set line size to 1 point
        XYJoin(iStimChannel%[i%],2);  'form closed loop
        'Draw the stimulus window
        if gratingPresent%[i%][1] then  'only draw windows that are present
            XYAddData(iStimChannel%[i%], StimWindowX[i%][], StimWindowY[i%][]);
        endif
    next
    


	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);  'Blue for monitor location
	XYDrawMode(iMonitorChannel%,3,1);  'set line style to dotted (really?  I missed this)
	XYJoin(iMonitorChannel%,2);  'form closed loop (rectangle here)
    XYAddData(iMonitorChannel%,-screenXDeg,-screenYDeg);  'for now this is manually set above, could calculate
	XYAddData(iMonitorChannel%,screenXDeg,-screenYDeg);
	XYAddData(iMonitorChannel%,screenXDeg,screenYDeg);
	XYAddData(iMonitorChannel%,-screenXDeg,screenYDeg);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
    if UseTwo1401s% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    ToolbarSet(6,"Select Wavemarks",SelectWavemarkDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    fp$ := SetPathToScriptDirectory$();
    
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();    
    
    StartSecondInstanceOfSpike2();
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work
    

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    var Opener$;
    var ProgName$;
    var RemoteArg$ := "";     'Extra arg needed if vsg is not on local machine...
    var BGColor$;
    var Dist2Screen$;
    var TriggerPort$;
    var ImageArg$;
    var GammaArg$ := "";
    var Verbose$ := " -v ";  'For now, verbose is always on 
    var i%;
    var j%;
    var Grid1$;
    var Grid2$;
    var Dots$;
    'var fh%;
    var startSecs := 5;
    var cmdLine$;
    var specFileName$;
    var specHandle%;
    var tempNStim%;
    var count%;
    
    specFileName$ := GetScriptDir$(0)+"..\\..\\GGSpecFile.txt";
    
    JuiceRewardMSorig% := JuiceRewardMS%;  'we are going to use smaller intermediate rewards, so hold the original
    pRewardOrig := pReward;                'Also probability (these values both come from the DAQ dialog)

        'GetRepeatedParameterProgression%(fvFileLen%, fvNRepeats%, dummyResult[], fvImageOrder%[], 1, 2, 0, fvRandomProgression%);  'We will ignore dummyResult, which holds values between (1) and (2) that are not logspaced (0)

    ' Open serial port for VSG comms re: stimulus jump-advance
    OpenSerialPortToVSG();
    
	'start sampling
    if UseTwo1401s% = 1 then
        SampleStart(0);  'Set sampling to start immediately
        Yield(0.5);  'Wait half a second
        'Look for handshake, unless disabled
        while pulseFound% < 1 and startSecs > 0 and Dual1401IgnoreHandshake% = 0 do
            pulseFound% := View(DataWindow%).FindPulseUp%(TimingChannel%, 0, tRise, tFall);
            yield(0.1);
            startSecs := startSecs - 0.1;
        wend
        'Send timing pulse
        SafeSampleKey("T");
    else
    	SampleStart(0); 'Start sampling now
    endif;
    
    if startSecs <= 0 then
        message("Handshake not found in 5 seconds!  Quitting!");
        halt
    endif
    
    
    'Set sequencer variable 5, this value is appropriate for no rivalry
    SampleSeqVar(5, 0);
    
    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
    
    
    'Begin building the command line argument
    Opener$ := "cmd /k " + bin$;
    
    ' Get remote args if needed
    if GetUseRemoteStimulus%() = 1 then
        RemoteArg$  := " " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim ";
    endif;
    
    if GetUseRemoteStimulus%() = 1 then
        ProgName$ := "\\remote.exe "; 'set program name for one VSG
    else
        ProgName$ := "\\fixstim.exe "; 'set program name for one VSG
    endif;
    
    
    'Set background color
    BGColor$ := " -b " + BackgroundColor$;
    
    'Set distance to screen
    Dist2Screen$ := " -d " + GetDistanceToScreenMM$();
    
    'Set trigger port
    TriggerPort$ := " -p 2 ";  'This one's hard-coded for now
    
    'Turn on verbose
    Verbose$ := " -v ";
    
    'For now, explicitly no fixation point, no gamma argument
    FixationArg$ := "";
    GammaArg$ := ""; 
    
    
    
    'Build simple command line, point to spec file
    cmdLine$ := Opener$ + ProgName$ + RemoteArg$ + " -F " + specFileName$;
    
    
    'Fill tempNStim% variable with greater of 4 and number of stims
    if nStim% > 2 then
        tempNStim% := nStim%;
    else
        tempNStim% := 4;
    endif
    
    'Build the spec file, and write the trial-by-trial specs for the VSG
    specHandle% := FileOpen(specFileName$, 8, 1);  'open spec file
    'print more standard arguments to spec file
    Print("%s",FixationArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + Verbose$ + SerialArg$ + GammaArg$);  
    'print number of stim pages argument, but don't put this in if we are not changing a grating
    if doChange% = 1 then
        Print("%s"," --num-stim-pages=2 ");
    endif
    'print "stimulus" parameters
    Print("%s"," -s " + GetGratingParameters$("Stimulus")); 
    'print "fixpt" parameters (as dots) if necessary
    if putFixptOverGratings% = 1 then
        Dots$ := " -D ";  'make one -D total
        for j% := 0 to nTrials% - 1 do  'make one entry for each trial
            for i% := 0 to tempNStim%-1 do  
                if fixptPresent%[i%][j%] = 1 then  
                    'All "dots" on all trials are actually the same
                    Dots$ := Dots$+str$(stimXPos[i%])+","+str$(stimYPos[i%])+","+str$(FixationDiameter)+","+FixationColor$+";";  'put a semicolon to separate all dots
                'else  'put in 0 diameter if fixpt is not present on this trial, this appears to be no longer necessary
                    'Dots$ := Dots$+str$(stimXPos[i%])+","+str$(stimYPos[i%])+",0,"+FixationColor$;
                endif
            next
            'After all dots on each trial, get rid of final semicolon - not as easy to do above as not all dots show up, and we don't keep track of how many to expect
            Dots$ := Left$(Dots$,Len(Dots$)-1);
            if j% < (nTrials% - 1) then
                Dots$ := Dots$+"!";  'separate trials by exclamation point!
            endif
        next
    endif
    Print("%s", Dots$);
    'print multiple orientation indicator
    Print("%s"," --multi-ori ");
    'Loop through trials, then stimuli
    for i% := 0 to nTrials%-1 do
        Grid1$ := "";  'reset Grid$ variables
        Grid2$ := "";
        count% := 0;
        for j% := 0 to tempNStim%-1 do
            'Build Grid1$ and Grid2$ for this trial
            'if stimOrientation[j%][i%] <> -1000 then  'do not build if "no stim" indicator (-1000) is present (note i%/j% reversed from above) (old version)
            if gratingPresent%[j%][i%] = 1 then  'do not build if grating is not present (note i%/j% reversed from above)
                'Grid1$ is easy, same every time
                Grid1$ := Grid1$+str$(stimXPos[j%])+","+str$(stimYPos[j%])+","+str$(stimOrientation[j%][i%]);
                'Grid2$ varies depending on whether this grid changes orientation
                if j% = changeLoc%[i%] then
                    Grid2$ := Grid2$+str$(stimXPos[j%])+","+str$(stimYPos[j%])+","+str$(preferredOri);  'change orientation is preferred orientation
                else
                    Grid2$ := Grid2$+str$(stimXPos[j%])+","+str$(stimYPos[j%])+","+str$(stimOrientation[j%][i%]);  'no-change orientation is same orientation as above
                endif
                'Put a closing comma after every stimulus but the final one
                if count% < actualNStim%-1 then  'here we need to know the actual count to know the last stimulus
                    Grid1$ := Grid1$+",";
                    Grid2$ := Grid2$+",";
                endif
                count% += 1;
            endif
        next
        'Put Grid1$ (and Grid2$) for this trial into file, use trial separator (!) if Grid2$ present
        if doChange% = 1 then
            Print("%s", Grid1$ + "!" + Grid2$);
        else
            Print("%s", Grid1$);
        endif
        'Put in trial separator between trials, but not on final trial
        if i% < nTrials%-1 then
            Print("%s","!"); 
        endif
    next
    
    FileClose(0);  'close spec file
    
    
    ' Initial text marks
    ' djs Always version 3. NO difference if maintainmode is used or not. 
    SampleText("GreggsGrid,3," + str$(Len(cmdLine$)));
    SampleText(ggCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next    
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n"); 
    
    StimHandle% := ProgRun(cmdLine$, 1);
    if StimHandle% <0 then 
        Message("Could not start stimulus."); 
        halt; 
    endif
    
    
    'If we are asking the eyetracker to record an output file, open the file and start recording
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("I");  'Open the file (this is done by setting a DIGLOW bit), file name will be saved in a sampletext
        yield(0.5);
        SafeSampleKey("W");  'Begin recording the file
        yield(0.5);
    endif
    
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(5);
    return 1;
    
    
    
end



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif

    
    ' Tell stim app to shut down.
	SafeSampleKey("Q");
	SampleStop();
    
    
    ProgKill(StimHandle%);
    while ProgStatus(StimHandle%) > 0 do
        Yield();
    wend

    
    
	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	SaveDailyTotals();
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()  'note that this function is only used for Toolbar-based juice delivery
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverReward();
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNumber();
        endif;
    endif;
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectWavemarkDialog%()
	var iReturn%:=1;
	var i%;
    var whichWaveMark% := 1;
	DlgCreate("Select Wavemark");
	DlgInteger(1, "Input Wavemark to view, -1 for all", -1, 256);  'max is based on highest possible wavemark value
    
	i% := DlgShow(whichWaveMark%);

	if i% = 1 then
		PrintLog("SelectWavemarkDialog - user hit OK\n");
        for i% := 0 to ggNWavemarks%-1 do  'for each wavemark channel
            View(DataWindow%).MarkMask(i%+1,0,0,-1);  'exclude all codes on layer 0
            View(DataWindow%).MarkMask(i%+1,0,1,whichWaveMark%);  'then include requested code (or all, if -1) on layer 0
        next;       
	endif;
	if i% = 0 then
		PrintLog("SelectWavemarkDialog - user hit Cancel\n");
	endif;
    'PrintLog("Return value is %d\n", iReturn%);  'always return 1, so don't bother reporting this
	return iReturn%;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var i%, j%;
    var tempNStim%;


	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
    Print("Eye coil offset, V (X)     : %f\n", XVoltOffset);
    Print("Eye coil offset, V (Y)     : %f\n", YVoltOffset);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	Print("Background color           : %s\n", BackgroundColor$);
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

    Print("Always Looking?                          : %d\n", AlwaysLooking%);
    Print("Stim Window Radius                       : %f\n", ggWindowRadius);
	Print("Number of trials                         : %d\n", nTrials%);
    Print("Number of stimuli                        : %d\n", actualNStim%);
    Print("Number of orientations                   : %d\n", nOrientations%);
    Print("Min delta orientation for change         : %f\n", minDeltaOri);
    Print("Minimum fixations                        : %d\n", minFixations%);
    Print("Variable fixations                       : %d\n", varFixations%);
    Print("Reward Delay (s)                         : %f\n", rewardDelay);
    Print("Intermediate reward probability          : %f\n", intRewardProb);
    Print("Intermediate reward (ms)                 : %d\n", intRewardMS%);
	Print("Inter-trial interval                     : %f\n", ITI);
    Print("Acquisition time (s)                     : %f\n", fixAcqTime);
    Print("Fixation hold time (s)                   : %f\n", fixHoldTime);
    Print("Grating change time (s)                  : %f\n", gratingChangeTime);
    Print("Acquisition time out (s)                 : %f\n", fixAcqTimeout);
    
    
    
    Print("\nStimulus Locations\n");
	Print("-------------------------\n\n");
    
    'Fill tempNStim% variable with greater of 4 and number of stims
    if nStim% > 2 then
        tempNStim% := nStim%;
    else
        tempNStim% := 4;
    endif
    
    for j% := 0 to tempNStim%-1 do
        if gratingPresent%[j%][0] then
            Print("Grating %d,  x = %f,  y = %f\n",j%,stimXPos[j%],stimYPos[j%]);
        endif;
    next
    
    
    Print("\nTrial-By-Trial Orientations\n");
	Print("-------------------------\n\n");
    
    for i% := 0 to nTrials%-1 do
        Print("Trial %d\n",i%+1);
        for j% := 0 to tempNStim%-1 do
            if gratingPresent%[j%][i%] = 1 then  'do not build if grating is not present (note i%/j% reversed from above)
                Print("Grating: %d, Orientation: %f\n",j%,stimOrientation[j%][i%]);
            endif
        next
        if doChange% = 1 then
            print("Change Grating: %d, Change-To Orientation: %f\n",changeLoc%[i%],preferredOri);
        else
            print("No Change Grating\n");
        endif
        Print("\n\n");  'put in a spacer
    next
    
    
    
    
	' close parfile
	FileClose(0);

end;





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func BuildStimLocations%(rfX,rfY,rfW,rfH)
    'This function will fill stimXPos[],stimYPos[],stimWindowX[][],stimWindowY[][],stimInRF%[]
    'using the position of the receptive field.
    
    'Position of center-of-stimulus: 0-8 are the 9 central stimuli, 9-24 are the peripheral stimuli.
    'This order may seem weird but it has two benefits.  1) It allows us to easily use 9 or 25 stimuli
    'without the location of stimulus "x" being adjusted.  2) Since only central stimuli will be changed
    'in orientation, these will be 0-8 for either case.
    'Stimulus position grid:
    '  9  10  11  12  13
    ' 14   0   1   2  15
    ' 16   3   4   5  17
    ' 18   6   7   8  19
    ' 20  21  22  23  24    
    
    'This function assumes the existence of various variables as global:
    'nStim%,stimXPos[],stimYPos[],stimWindowX[][],stimWindowY[][],stimInRF%[]
    'Obviously could pass in and out, but I just don't see this ever being used in another
    'script, so I've just made sure all these variables exist as globals and we're good to go.
    
    var success% := 1;  'not sure how this can fail...it's just math
    var X;
    var Y;
    var xFac[25];  'multiplicative factor on X for each position, is integer, but use float for math purposes
    var yFac[25];  'multiplicative factor on Y for each position, is integer, but use float for math purposes
    var q%[25];     'Which stimulus is in the RF, differs based on quadrant of RF
    var i%;
    
    arrconst(gratingPresent%[][],1);  'fill gratingPresent with ones, we will later remove any that do not exist

    'Build Xfac%, Yfac%, which will help us in building the position of the grid
    xFac[0]:=-1; xFac[1]:=0; xFac[2]:=1; xFac[3]:=-1; xFac[4]:=0; xFac[5]:=1; xFac[6]:=-1; 
    xFac[7]:=0; xFac[8]:=1; xFac[9]:=-2; xFac[10]:=-1; xFac[11]:=0; xFac[12]:=1;  
    xFac[13]:=2; xFac[14]:=-2; xFac[15]:=2; xFac[16]:=-2; xFac[17]:=2; xFac[18]:=-2;  
    xFac[19]:=2; xFac[20]:=-2; xFac[21]:=-1; xFac[22]:=0; xFac[23]:=1; xFac[24]:=2; 
    
    yFac[0]:=1; yFac[1]:=1; yFac[2]:=1; yFac[3]:=0; yFac[4]:=0; yFac[5]:=0; yFac[6]:=-1; 
    yFac[7]:=-1; yFac[8]:=-1; yFac[9]:=2; yFac[10]:=2; yFac[11]:=2; yFac[12]:=2;  
    yFac[13]:=2; yFac[14]:=1; yFac[15]:=1; yFac[16]:=0; yFac[17]:=0; yFac[18]:=-1;  
    yFac[19]:=-1; yFac[20]:=-2; yFac[21]:=-2; yFac[22]:=-2; yFac[23]:=-2; yFac[24]:=-2; 
    
    'Get absolute position of RF, grid **locations** will be identical regardless of RF quadrant
    X := abs(rfX);
    Y := abs(rfY);
    
    'Now, building X and Y stimulus positions is easy!
    for i% := 0 to 24 do
        stimXPos[i%] := X*xFac[i%];
        stimYPos[i%] := Y*YFac[i%];
    next
    
    'Calcuating the fixation window mirrors the process done for a single fixation window in the
    'standard InitializeWindows() function
	var j%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
    
    ggWindowRadius := max(rfW,rfH)/2;  'rfW, rfH are diameters, get max radius, make it a circle
    ggWindowRadius := ggWindowRadius + addFixRad;
    
	for i% := 0 to 24 do
        for j% := 0 to 35 do
            stimWindowX[i%][j%] := stimXPos[i%] + ggWindowRadius * Cos(j% * twopi/36.0);
            stimWindowY[i%][j%] := stimYPos[i%] + ggWindowRadius * Sin(j% * twopi/36.0);
        next;
	next;
    
    
    'Stimulus position grid:
    '  9  10  11  12  13
    ' 14   0   1   2  15
    ' 16   3   4   5  17
    ' 18   6   7   8  19
    ' 20  21  22  23  24 
    'Build q%[], should be nStim% if no stimulus is in the RF (based on 25 stimuli)
    'q%[] is the quadrant-based stimulus index of the stimulus in the RF
    docase
    case rfX > 0 and rfY > 0 then  'Quadrant 1
        q%[0]:=11; q%[1]:=12; q%[2]:=13; q%[3]:=1; q%[4]:=2; q%[5]:=15; q%[6]:=4; 
        q%[7]:=5; q%[8]:=17; q%[9]:=nStim%; q%[10]:=nStim%; q%[11]:=nStim%; q%[12]:=nStim%;  
        q%[13]:=nStim%; q%[14]:=10; q%[15]:=nStim%; q%[16]:=0; q%[17]:=nStim%; q%[18]:=3;  
        q%[19]:=nStim%; q%[20]:=6; q%[21]:=7; q%[22]:=8; q%[23]:=19; q%[24]:=nStim%;
    case rfX < 0 and rfY > 0 then  'Quadrant 2
        q%[0]:=9; q%[1]:=10; q%[2]:=11; q%[3]:=14; q%[4]:=0; q%[5]:=1; q%[6]:=16; 
        q%[7]:=3; q%[8]:=4; q%[9]:=nStim%; q%[10]:=nStim%; q%[11]:=nStim%; q%[12]:=nStim%;  
        q%[13]:=nStim%; q%[14]:=nStim%; q%[15]:=12; q%[16]:=nStim%; q%[17]:=2; q%[18]:=nStim%;  
        q%[19]:=5; q%[20]:=nStim%; q%[21]:=18; q%[22]:=6; q%[23]:=7; q%[24]:=8;
    case rfX < 0 and rfY < 0 then  'Quadrant 3
        q%[0]:=16; q%[1]:=3; q%[2]:=4; q%[3]:=18; q%[4]:=6; q%[5]:=7; q%[6]:=20; 
        q%[7]:=21; q%[8]:=22; q%[9]:=nStim%; q%[10]:=14; q%[11]:=0; q%[12]:=1;  
        q%[13]:=2; q%[14]:=nStim%; q%[15]:=5; q%[16]:=nStim%; q%[17]:=8; q%[18]:=nStim%;  
        q%[19]:=23; q%[20]:=nStim%; q%[21]:=nStim%; q%[22]:=nStim%; q%[23]:=nStim%; q%[24]:=nStim%;
    case rfX > 0 and rfY < 0 then  'Quadrant 4
        q%[0]:=4; q%[1]:=5; q%[2]:=17; q%[3]:=7; q%[4]:=8; q%[5]:=19; q%[6]:=22; 
        q%[7]:=23; q%[8]:=24; q%[9]:=0; q%[10]:=1; q%[11]:=2; q%[12]:=15;  
        q%[13]:=nStim%; q%[14]:=3; q%[15]:=nStim%; q%[16]:=6; q%[17]:=nStim%; q%[18]:=21;  
        q%[19]:=nStim%; q%[20]:=nStim%; q%[21]:=nStim%; q%[22]:=nStim%; q%[23]:=nStim%; q%[24]:=nStim%;
    else  'rfX or rfY is 0
        'Do nothing, as we should already have halted in the dialog box
        'OK, fine.
        Message("rfX or rfY is zero!  Should have halted in the dialog box!  This message should never come up!  Quitting!");
        halt;
        'Happy?
    endcase
    
    
    
    'Build stimInRF%, is copied from q%[], but use nStim% to set any stimulus that does not exist to nStim%
    for i% := 0 to 24 do
        if q%[i%] < nStim% then  'check to see if the index of the stimulus in the RF when looking at stim i% exists
            stimInRF%[i%] := q%[i%];  'if so, put it in
        else  'if not, e.g. if nStim% = 9, stims at indices 9-24 do not exist
            stimInRF%[i%] := nStim%;  'when these non-existent stims are in the RF, then set it to nStim%
        endif;        
    next;
    
    
    return success%;
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func BuildStimLocationsLines%(rfX,rfY,rfW,rfH)
    'This function will fill stimXPos[],stimYPos[],stimWindowX[][],stimWindowY[][],stimInRF%[]
    'using the "lines" design, intended for cases where either the X or Y position of the RF is 
    'too close to the midline to do grid-style tiling without near-overlap.  "Too close to the
    'midline" has been defined as <2 RF diameters, which is the distance which leaves a spacing
    'of one RF diameter between grid elements (in the dimension in question, the other dimension
    'may have greater spacing).
    
    'For this case, the stimulus "lines" will be "basically" horizontal (if it is the Y location of
    'the RF that is near 0) or "basically" vertical (if it is the X location of the RF that is near 0)
    'In principle, the span of each line is going to be +/-2X or +/-2Y, and potentially much less. 
    'Since we ought not to have an RF with a diameter greater than 2 degrees, and we are going to 
    'create lines with <= 5 elements, the total span of a line in the dimension in question should
    'not exceed 8 degrees.  The screen (Chunky's Rig) is 25 x 19 degrees (+/-12.5 deg X, +/-9.5 deg Y)
    'so the "middle" line should always fit fully on the screen.  Lines will be spaced at 2 RF diameters
    'apart, which may result in other lines partially falling off the screen.
    
    'A schematic for when X is near 0 (XVersion% = 1) should look about like this:
    '09  10  11  12  13
    ' 14  00  01  02  15
    '  16  03  04  05  17
    '   18  06  07  08  19
    '    20  21  22  23  24
    '
    '09  10  -2X2Y  12  13
    ' 14  00  -X,1Y  02  15
    '  16  03  00,00  05  17
    '   18  06  1X,-Y  08  19
    '    20  21  2X-2Y  23  24
    '  -4RFW -2RFW  0 +2RFW +4RFW   And these are the X adjustments for each line, relative to the center line
    '
    'A schematic for when Y is near 0 (XVersion% = 0) should look about like this:
    '09
    '     10
    '14         11
    '     00          12    
    '16         01          13
    '     03          02
    '18         04          15
    '     06          05
    '20         07          17
    '     21          08
    '           22          19
    '                 23
    '                       24
    '
    '09
    '     10
    '14         11
    '     00          12    
    '-2X2Y      01          13     +4RFH  And these are the Y adjustments for each line, relative to the center line
    '     -X,1Y       02
    '18         00,00       15     +2RFH
    '     06          1X,-Y
    '20         07          2X-2Y  0
    '     21          08
    '           22          19     -2RFH
    '                 23
    '                       24     -4RFH
    
    
    'This function assumes the existence of various variables as global:
    'nStim%,stimXPos[],stimYPos[],stimWindowX[][],stimWindowY[][],stimInRF%[]
    'Obviously could pass in and out, but I just don't see this ever being used in another
    'script, so I've just made sure all these variables exist as globals and we're good to go.
    
    var success% := 1;  'not sure how this can fail...it's just math
    var X;
    var Y;
    var L;
    var xFac[25];  'multiplicative factor on X for each position, is integer, but use float for math purposes
    var yFac[25];  'multiplicative factor on Y for each position, is integer, but use float for math purposes
    var lFac[25];  'multiplicative factor for each line, is float because RFW/RFH are float
    var q%[25];     'Which stimulus is in the RF, differs based on quadrant of RF
    var i%, j%;
    var XVersion% := 0;
    
    'Get absolute position of RF
    X := abs(rfX);
    Y := abs(rfY);
    
    'We will only get here if one RF coordinate is close to 0 and the other is not.  Determine which
    'coordinate will control the remainder of the funciton
    if Y > X then
        XVersion% := 1;  
    endif
    
    if XVersion% = 1 then
        'Build Xfac%, Yfac%, which will help us in building the position of the grid
        xFac[0]:=-1; xFac[1]:=-1; xFac[2]:=-1; xFac[3]:=0; xFac[4]:=0; xFac[5]:=0; xFac[6]:=1; 
        xFac[7]:=1; xFac[8]:=1; xFac[9]:=-2; xFac[10]:=-2; xFac[11]:=-2; xFac[12]:=-2;  
        xFac[13]:=-2; xFac[14]:=-1; xFac[15]:=-1; xFac[16]:=0; xFac[17]:=0; xFac[18]:=1;  
        xFac[19]:=1; xFac[20]:=2; xFac[21]:=2; xFac[22]:=2; xFac[23]:=2; xFac[24]:=2; 
        
        yFac[0]:=1; yFac[1]:=1; yFac[2]:=1; yFac[3]:=0; yFac[4]:=0; yFac[5]:=0; yFac[6]:=-1; 
        yFac[7]:=-1; yFac[8]:=-1; yFac[9]:=2; yFac[10]:=2; yFac[11]:=2; yFac[12]:=2;  
        yFac[13]:=2; yFac[14]:=1; yFac[15]:=1; yFac[16]:=0; yFac[17]:=0; yFac[18]:=-1;  
        yFac[19]:=-1; yFac[20]:=-2; yFac[21]:=-2; yFac[22]:=-2; yFac[23]:=-2; yFac[24]:=-2; 
        
        lFac[0]:=-2; lFac[1]:=0; lFac[2]:=2; lFac[3]:=-2; lFac[4]:=0; lFac[5]:=2; lFac[6]:=-2; 
        lFac[7]:=0; lFac[8]:=2; lFac[9]:=-4; lFac[10]:=-2; lFac[11]:=0; lFac[12]:=2;  
        lFac[13]:=4; lFac[14]:=-4; lFac[15]:=4; lFac[16]:=-4; lFac[17]:=4; lFac[18]:=-4;  
        lFac[19]:=4; lFac[20]:=-4; lFac[21]:=-2; lFac[22]:=0; lFac[23]:=2; lFac[24]:=4; 
        
        L := rfW;
        
        'Now, building X and Y stimulus positions is easy!
        for i% := 0 to 24 do
            stimXPos[i%] := (X*xFac[i%]) + (L*lFac[i%]);
            stimYPos[i%] := Y*yFac[i%];
        next
        
    else
        'Build Xfac%, Yfac%, which will help us in building the position of the grid
        xFac[0]:=-1; xFac[1]:=0; xFac[2]:=1; xFac[3]:=-1; xFac[4]:=0; xFac[5]:=1; xFac[6]:=-1; 
        xFac[7]:=0; xFac[8]:=1; xFac[9]:=-2; xFac[10]:=-1; xFac[11]:=0; xFac[12]:=1;  
        xFac[13]:=2; xFac[14]:=-2; xFac[15]:=2; xFac[16]:=-2; xFac[17]:=2; xFac[18]:=-2;  
        xFac[19]:=2; xFac[20]:=-2; xFac[21]:=-1; xFac[22]:=0; xFac[23]:=1; xFac[24]:=2; 
        
        yFac[0]:=1; yFac[1]:=0; yFac[2]:=-1; yFac[3]:=1; yFac[4]:=0; yFac[5]:=-1; yFac[6]:=1; 
        yFac[7]:=0; yFac[8]:=-1; yFac[9]:=2; yFac[10]:=1; yFac[11]:=0; yFac[12]:=-1;  
        yFac[13]:=-2; yFac[14]:=2; yFac[15]:=-2; yFac[16]:=2; yFac[17]:=-2; yFac[18]:=2;  
        yFac[19]:=-2; yFac[20]:=2; yFac[21]:=1; yFac[22]:=0; yFac[23]:=-1; yFac[24]:=-2; 
        
        lFac[0]:=2; lFac[1]:=2; lFac[2]:=2; lFac[3]:=0; lFac[4]:=0; lFac[5]:=0; lFac[6]:=-2; 
        lFac[7]:=-2; lFac[8]:=-2; lFac[9]:=4; lFac[10]:=4; lFac[11]:=4; lFac[12]:=4;  
        lFac[13]:=4; lFac[14]:=2; lFac[15]:=2; lFac[16]:=0; lFac[17]:=0; lFac[18]:=-2;  
        lFac[19]:=-2; lFac[20]:=-4; lFac[21]:=-4; lFac[22]:=-4; lFac[23]:=-4; lFac[24]:=-4;
        
        L := rfH;   
        
        'Now, building X and Y stimulus positions is easy!
        for i% := 0 to 24 do
            stimXPos[i%] := X*xFac[i%];
            stimYPos[i%] := (Y*yFac[i%]) + (L*lFac[i%]);
            'printlog("xpos is %f and ypos is %f\n",stimXPos[i%],stimYPos[i%]);
        next        
        'halt;
    endif
    
    
    'Here we should remove any stimuli that fall outside of the screen, this is important for building q%[] and stimInRF%[]
    arrconst(gratingPresent%[][],1);  'fill gratingPresent with ones, we will remove any that do not exist
                                      'in the standard/lite tracks, this is done in BuildOrientations but
                                      'here we have to do it earlier so that we can build stimInRF%[]
    nStim% := 25;  'nStim starts as -1 in this function (from dialog box). Change to 25, keep this value regardless of how many fit on the screen
    actualNStim% := 25;  'Here, keep track of actual number on screen
    for i% := 0 to nStim%-1 do 
        'A grating is off the screen if the absolute value of the stimX/YPos + 0.5*rfW/H > screenX/YDeg
        if ((abs(stimXPos[i%]) + (rfW/2)) > screenXDeg) or ((abs(stimYPos[i%]) + (rfH/2)) > screenYDeg) then
            if i% < 9 then
                message("The grating spacing does not allow all central 9 stimuli\nto be on screen!  Quitting!");
                halt;
            endif
            for j% := 0 to nTrials%-1 do
                gratingPresent%[i%][j%] := 0;
                fixptPresent%[i%][j%] := 0;  'take off the fixation point, too!
            next
            actualNStim% -= 1;  'Decrement actual number of stims on the screen, if stim is not being presented
        endif
    next
    'fill an n+1th row with zeros for code below
    for j% := 0 to nTrials%-1 do
        gratingPresent%[nStim%][j%] := 0;
    next
    
    
    'Calcuating the fixation window mirrors the process done for a single fixation window in the
    'standard InitializeWindows() function
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
    
    ggWindowRadius := max(rfW,rfH)/2;  'rfW, rfH are diameters, get max radius, make it a circle
    ggWindowRadius := ggWindowRadius + addFixRad;
    
	for i% := 0 to 24 do  'here, we can make the windows for even gratings which don't exist, we simply won't DRAW those later
        for j% := 0 to 35 do
            stimWindowX[i%][j%] := stimXPos[i%] + ggWindowRadius * Cos(j% * twopi/36.0);
            stimWindowY[i%][j%] := stimYPos[i%] + ggWindowRadius * Sin(j% * twopi/36.0);
        next;
	next;
    
    
    'Build q%[], should be nStim% if no stimulus is in the RF (based on 25 stimuli)
    'q%[] is the quadrant-based stimulus index of the stimulus in the RF
    'XVersion grid
    '09  10  11  12  13
    ' 14  00  01  02  15
    '  16  03  04  05  17
    '   18  06  07  08  19
    '    20  21  22  23  24
    docase
    case rfY > 0 and XVersion% = 1 then  'Quadrant 1 OR Quadrant 2, XVersion
        q%[0]:=10; q%[1]:=11; q%[2]:=12; q%[3]:=0; q%[4]:=1; q%[5]:=2; q%[6]:=3; 
        q%[7]:=4; q%[8]:=5; q%[9]:=nStim%; q%[10]:=nStim%; q%[11]:=nStim%; q%[12]:=nStim%;  
        q%[13]:=nStim%; q%[14]:=9; q%[15]:=13; q%[16]:=14; q%[17]:=15; q%[18]:=16;  
        q%[19]:=17; q%[20]:=18; q%[21]:=6; q%[22]:=7; q%[23]:=8; q%[24]:=19;
    case rfY < 0 and XVersion% = 1 then  'Quadrant 3 OR Quadrant 4, XVersion
        q%[0]:=3; q%[1]:=4; q%[2]:=5; q%[3]:=6; q%[4]:=7; q%[5]:=8; q%[6]:=21; 
        q%[7]:=22; q%[8]:=23; q%[9]:=14; q%[10]:=0; q%[11]:=1; q%[12]:=2;  
        q%[13]:=15; q%[14]:=16; q%[15]:=17; q%[16]:=18; q%[17]:=19; q%[18]:=20;  
        q%[19]:=24; q%[20]:=nStim%; q%[21]:=nStim%; q%[22]:=nStim%; q%[23]:=nStim%; q%[24]:=nStim%;
    '09
    '     10
    '14         11
    '     00          12    
    '16         01          13
    '     03          02
    '18         04          15
    '     06          05
    '20         07          17
    '     21          08
    '           22          19
    '                 23
    '                       24    
    case rfX > 0 and XVersion% = 0 then  'Quadrant 1 OR Quadrant 4, YVersion
        q%[0]:=1; q%[1]:=2; q%[2]:=15; q%[3]:=4; q%[4]:=5; q%[5]:=17; q%[6]:=7; 
        q%[7]:=8; q%[8]:=19; q%[9]:=10; q%[10]:=11; q%[11]:=12; q%[12]:=13;  
        q%[13]:=nStim%; q%[14]:=0; q%[15]:=nStim%; q%[16]:=3; q%[17]:=nStim%; q%[18]:=6;  
        q%[19]:=nStim%; q%[20]:=21; q%[21]:=22; q%[22]:=23; q%[23]:=24; q%[24]:=nStim%;
    case rfX < 0 and XVersion% = 0 then  'Quadrant 2 OR Quadrant 3, YVersion
        q%[0]:=14; q%[1]:=0; q%[2]:=1; q%[3]:=16; q%[4]:=3; q%[5]:=4; q%[6]:=18; 
        q%[7]:=6; q%[8]:=7; q%[9]:=nStim%; q%[10]:=9; q%[11]:=10; q%[12]:=11;  
        q%[13]:=12; q%[14]:=nStim%; q%[15]:=2; q%[16]:=nStim%; q%[17]:=5; q%[18]:=nStim%;  
        q%[19]:=8; q%[20]:=nStim%; q%[21]:=20; q%[22]:=21; q%[23]:=22; q%[24]:=23;
    else  'rfX or rfY is 0
        'Do nothing, as we should already have halted in the dialog box
        'OK, fine.
        Message("rfX or rfY is zero!  Should have halted in the dialog box!  This message should never come up!  Quitting!");
        halt;
        'Happy?
    endcase
    
    
    
    'Build stimInRF%, is copied from q%[], but use nStim% to set any stimulus that does not exist to nStim%
    for i% := 0 to 24 do
        if q%[i%] < nStim% and gratingPresent%[q%[i%]][0] = 1 then  'check to see if the index of the stimulus in the RF when looking at stim i% exists
            stimInRF%[i%] := q%[i%];  'if so, put it in
        else  'if not, e.g. if nStim% = 9, stims at indices 9-24 do not exist
            stimInRF%[i%] := nStim%;  'when these non-existent stims are in the RF, then set it to nStim%
        endif;        
    next;
    
    
    return success%;
    
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func BuildStimLocationsLite%(rfW,rfH)
    'This function will fill stimXPos[],stimYPos[],stimWindowX[][],stimWindowY[][],stimInRF%[]
    'with values based on an arbitrary square grid of four, this is for training.  Note that
    'there will not necessarily be a stimulus in the RF - but since we are training we don't
    'expect to be recording anyway.  We will set stimInRF% to nStim%, which indicates no stimulus
    'in the RF and forget it
    
    'Position of center-of-stimulus: 0-4 are the 9 central stimuli, 9-24 are the peripheral stimuli.
    'This order may seem weird but it has two benefits.  1) It allows us to easily use 9 or 25 stimuli
    'without the location of stimulus "x" being adjusted.  2) Since only central stimuli will be changed
    'in orientation, these will be 0-8 for either case.
    'Stimulus position grid:
    '  0   1
    '  2   3
    
    'This function assumes the existence of various variables as global:
    'nStim%,stimXPos[],stimYPos[],stimWindowX[][],stimWindowY[][],stimInRF%[]
    'Obviously could pass in and out, but I just don't see this ever being used in another
    'script, so I've just made sure all these variables exist as globals and we're good to go.
    
    var success% := 1;  'not sure how this can fail...it's just math
    var i%;

    
    'Building X and Y stimulus positions is easy!
    stimXPos[0] := -4;
    stimYPos[0] := 4;
    stimXPos[1] := 4;
    stimYPos[1] := 4;
    stimXPos[2] := -4;
    stimYPos[2] := -4;
    stimXPos[3] := 4;
    stimYPos[3] := -4;
    
    'Calcuating the fixation window mirrors the process done for a single fixation window in the
    'standard InitializeWindows() function
	var j%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
    
    ggWindowRadius := max(rfW,rfH)/2;  'rfW, rfH are diameters, get max radius, make it a circle
    ggWindowRadius := ggWindowRadius + addFixRad;
    
	for i% := 0 to 3 do
        for j% := 0 to 35 do
            stimWindowX[i%][j%] := stimXPos[i%] + ggWindowRadius * Cos(j% * twopi/36.0);
            stimWindowY[i%][j%] := stimYPos[i%] + ggWindowRadius * Sin(j% * twopi/36.0);
        next;
	next;

    'Build stimInRF%, use nStim% to set any stimulus that does not exist to nStim% --- and (technically) no stimuli exist in the RF for the training version
    for i% := 0 to 3 do
        stimInRF%[i%] := nStim%;  'when these non-existent stims are in the RF, then set it to nStim%      
    next;
    
    
    return success%;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc BuildOrientations()
    'This function will fill stimOrientation[26][nMaxTrials%],fixptPresent%[25][nMaxTrials%],changeFromOrientation[nMaxTrials%],changeLoc%[nMaxTrials%]
    'using the values of nStim%, nOrientations%, minDeltaOri, nTrials%, preferred ori
    var i%;  'loop for stimulus position
    var j%;  'loop for trials
    var rndInt%[nStim%][nTrials%];  'set up a variable to hold a random integer
    var oriInc;  'The orientation increment
    var nOri;  'float for math
    var bailOut%;
    var tempLoc%;
    
    ''Fill stimOrientation[][]
    
    rand(rndInt%[][],nOrientations%);  'Get integer to multiply by orientation increment
    
    nOri := nOrientations%;  'float for math
    oriInc := 180/nOri;  'get orientation increment in degrees
    
    arrconst(stimOrientation[0:nStim%][0:nTrials%],rndInt%[][]);  'put in multiplier (i.e. number of ori increments)
    arrmul(stimOrientation[][],oriInc);  'multiply by ori increment to get actual orientation
    arradd(stimOrientation[][],preferredOri);  'add preferred orientation
    arrconst(fixptPresent%[][],1);  'fill fixptPresent with ones, we will later remove any that do not exist
    
    'Cannot fill gratingPresent%[][] here, because it will overwrite the calculated present gratings in the lines version, fill in BuildStimLocations functions
    'arrconst(gratingPresent%[][],1);  'fill gratingPresent with ones, we will later remove any that do not exist
    
    'Aaaaaaand set to be between 0-180, I don't think this can be done without looping
    for i% := 0 to nStim%-1 do
        for j% := 0 to nTrials%-1 do
            if stimOrientation[i%][j%] >= 180 then
                stimOrientation[i%][j%] := stimOrientation[i%][j%]-180;
            endif;
        next
    next
    'And fill the value for nStim% (one past last actually present stim) with a value that represents no stimulus in the RF
    for j% := 0 to nTrials%-1 do
        stimOrientation[nStim%][j%] := -1000;
        'fixptPresent%[nStim%][j%] := 0;  'Not necessary!  Now will cause indexing error!
    next
    
    ''If we have 9/25 stimuli, and requested, do not place fixpts on gratings that will never have a grating in their RF
    if putFixptOverGratings% = 1 and noFixptIfNoGratingInRF% = 1 then  'we can't do this if there are no fixpts
        for i% := 0 to nStim%-1 do
            if gratingPresent%[i%][0] = 1 then  'do not overlay a fixation point if there is no grating
                for j% := 0 to nTrials%-1 do
                    if stimInRF%[i%] = nStim% then  'stimIfRF%[] = nStim% is an indicator that there is no stim in the RF
                        fixptPresent%[i%][j%] := 0;
                    endif;
                next
            endif;
        next
    endif
    
    ''Fill changeLoc%[] and changeFromOrientation[]
    
    'This is probably best done in a loop given the tools present in Spike2
    for j% := 0 to nTrials%-1 do
        changeLoc%[j%] := -1;  'indicates we have not found a legal location to change yet
        bailOut% := 0;  'don't get stuck in the loop - 10000 is plenty safe, there are 9 possible change locations, if NONE work we'll know by 10000     
        while changeLoc%[j%] = -1 and bailOut% < 10000 do
            tempLoc% := rand(9,0);  'Use the first 9 locations for possible changes
            'printlog("temploc is %d and value is %f and mindelta is %f\n",tempLoc%,abs(preferredOri-stimOrientation[tempLoc%][j%]),minDeltaOri);
            if abs(preferredOri-stimOrientation[tempLoc%][j%]) > minDeltaOri and abs(180+preferredOri-stimOrientation[tempLoc%][j%]) > minDeltaOri then
                changeLoc%[j%] := tempLoc%;
                changeFromOrientation[j%] := stimOrientation[tempLoc%][j%];
            endif
            bailOut% += 1;  'increment bailOut%
        wend
        if bailOut% >= 10000 then  'there is an argument here for changing the original grating to fit, as below in the LITE version, but for now sticking with this
            message("Unable to find changeable grating at least " + str$(minDeltaOri) + " degrees of the preferred orientation.  Quitting!");
            halt;
        endif
    next
    
    'sanity check passed
    'printlog("preferred orientation is %f\n",preferredOri);
    'printlog("Values are\n%d\n",rndInt%[][]);
    'printlog("Orientations are\n%f\n",stimOrientation[0:nStim%][0:nTrials%]);
    'printlog("Change loc and change ori are\n%d\n%f\n",changeLoc%[],changeFromOrientation[]);
    
    
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc BuildOrientationsLite()
    'This function will fill stimOrientation[25][nMaxTrials%],fixptPresent%[26][nMaxTrials%],changeFromOrientation[nMaxTrials%],changeLoc%[nMaxTrials%]
    'using the values of nStim%, nOrientations%, minDeltaOri, nTrials%, preferred ori
    var i%;  'loop for stimulus position
    var j%;  'loop for trials
    var rndInt%[4][nTrials%];  'set up a variable to hold a random integer, we need 4 because there are 4 positions (even if there are <4 stimuli)
    var oriInc;  'The orientation increment
    var nOri;  'float for math
    var bailOut%;
    var tempLoc%;
    var randlist%[4];
    
    ''Fill stimOrientation[][]
    
    rand(rndInt%[][],nOrientations%);  'Get integer to multiply by orientation increment
    
    nOri := nOrientations%;  'float for math
    oriInc := 180/nOri;  'get orientation increment in degrees
    
    arrconst(stimOrientation[0:4][0:nTrials%],rndInt%[][]);  'put in multiplier (i.e. number of ori increments)
    arrmul(stimOrientation[][],oriInc);  'multiply by ori increment to get actual orientation
    arradd(stimOrientation[][],preferredOri);  'add preferred orientation
    arrconst(fixptPresent%[][],1);  'fill fixptPresent with ones, will remove any that do not exist
    arrconst(gratingPresent%[][],1);  'fill gratingPresent with ones, will remove any that do not exist
    'Aaaaaaand set to be between 0-180, I don't think this can be done without looping
    for i% := 0 to 3 do
        for j% := 0 to nTrials%-1 do
            if stimOrientation[i%][j%] >= 180 then
                stimOrientation[i%][j%] := stimOrientation[i%][j%]-180;
            endif;
        next
    next
    
    'And fill the value for nStim% (one past last actual stim) with a value that represents no stimulus in the RF, this isn't really necessary
    for j% := 0 to nTrials%-1 do
        stimOrientation[4][j%] := -1000;
        'fixptPresent%[4][j%] := 0;  'Not necessary!
    next
    
    docase
    ''Fill changeLoc%[] and changeFromOrientation[], but only bother if we are changing a location (i.e. there are 4 stimuli)
    case nStim% = 4 then
        'This is probably best done in a loop given the tools present in Spike2
        for j% := 0 to nTrials%-1 do
            changeLoc%[j%] := -1;  'indicates we have not found a legal location to change yet
            bailOut% := 0;  'don't get stuck in the loop - 100 is plenty safe, there are 4 possible change locations     
            while changeLoc%[j%] = -1 and bailOut% < 100 do
                tempLoc% := rand(4,0);  'Use all 4 locations for possible changes
                'printlog("temploc is %d and value is %f and mindelta is %f\n",tempLoc%,abs(preferredOri-stimOrientation[tempLoc%][j%]),minDeltaOri);
                if abs(preferredOri-stimOrientation[tempLoc%][j%]) > minDeltaOri and abs(180+preferredOri-stimOrientation[tempLoc%][j%]) > minDeltaOri then
                    changeLoc%[j%] := tempLoc%;
                    changeFromOrientation[j%] := stimOrientation[tempLoc%][j%];
                endif
                bailOut% += 1;  'increment bailOut%
            wend
            if bailOut% >= 100 then
                'just use tempLoc%, and change the orientation of the pre-change grating
                stimOrientation[tempLoc%][j%] := preferredOri + 90;  'this is not great as preferredOri+90 because that may not be a "standard" orientation
                'make sure value is between 0-180
                if stimOrientation[tempLoc%][j%] >= 180 then
                    stimOrientation[tempLoc%][j%] := stimOrientation[tempLoc%][j%]-180;
                endif;
                changeLoc%[j%] := tempLoc%;
                changeFromOrientation[j%] := stimOrientation[tempLoc%][j%];
            endif
        next
    ''If we have 1 or 2 stimuli, "blank out" 2 or 3 random stimuli    
    else
        for j% := 0 to nTrials%-1 do
            Shuffle%(4, randlist%[]);  'shuffle index values
            for i% := 0 to 3-nStim% do  'will do 3 if nStim% is 1, and 2 if nStim% is 2
                stimOrientation[randlist%[i%]][j%] := -1000;
                fixptPresent%[randlist%[i%]][j%] := 0;
                gratingPresent%[randlist%[i%]][j%] := 0;
            next
        next
    endcase 
    'sanity check passed
    'printlog("preferred orientation is %f\n",preferredOri);
    'printlog("Values are\n%d\n",rndInt%[][]);
    'printlog("Orientations are\n%f\n",stimOrientation[0:4][0:nTrials%]);
    'printlog("Change loc and change ori are\n%d\n%f\n",changeLoc%[],changeFromOrientation[]);
    
    
end



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func LookingGrid%(EyePosX,EyePosY,&whichGrating%)
	'Determine if the eye position is within any stimulus window, function is adapted from Looking%()
    'This function returns/updates two values - one value that indicates which grating is being
    'looked at (whichGrating%) and a separate value that indicates whether the animal is considered
    'to be "looking" (retValue%).  The reason there are two returns (that could possibly be covered
    'by one) is twofold.  The first is that the traditional return of "Looking%()" functions is a 1/0
    'return, but since 0 is a legal grating position due to zero-indexing, we would have to change
    'the traditional meaning of the output and use a -1 to indicate not looking.  Better to keep 
    'consistent conventions throughout.  The second is that while we may use an "always looking"
    'setting during training, we can still be interested in which grating, if any, the animal is 
    'fixating.  Thus, even if the animal is "automatically" looking, we can know if they actually are
    'looking and at which grating.  So...two outputs.
    'Updated before use to include illegal grating indicator (this would be the grating most recently
    'looked at).
    'Requires presence of global vars AlwaysLooking% and illegalGrating%
    var i%;
    var retValue% := 0;  'by default, not looking
    whichGrating% := -1;  'by default, set whichGrating% to -1 to indicate no grating being viewed
    var tempNStim%;
    if nStim% > 2 then
        tempNStim% := nStim%;
    else
        tempNStim% := 4;
    endif
    
    'determine which grating, if any, is being looked at
    for i% := 0 to tempNStim%-1 do
        'if stimOrientation[i%][currTrial%-1] <> -1000 then  'don't check gratings that don't exist
        if fixptPresent%[i%][currTrial%-1] = 1 then  'don't check locations that don't have fixation points - if putFixptOverGratings% = 0 , will be identical to stimOrientation[][] = -1000
            if (Pow(EyePosX-stimXPos[i%],2) + Pow(EyePosY-stimYPos[i%],2)) <= Pow(ggWindowRadius,2) then 
                whichGrating% := i%;  'indicate the grating number being viewed
                retValue% := 1;  'update looking!
                break  'and quit checking
            endif
        endif
    next
    
    'if looking at illegal grating, override return value
    if whichGrating% = illegalGrating% then  'if -1 == -1, retValue% is 0 anyway, so that's OK
        retValue% := 0;
    endif;
    
    'Always looking overrides everything
    if AlwaysLooking% = 1 then 
        retValue% := 1; 
        whichGrating% := 7;  'arbitrary value, if we use -1 AlwaysLooking breaks things that index with this
    endif;
    
    return retValue%;
    
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func LookingGrating%(EyePosX,EyePosY,&whichGrating%,thisGrating%)
	'Same as LookingGrid%(), will still report which grating, if any, the animal is looking at, 
    'but if the grating does NOT match the specified whichGrating%, then the return value will 
    'be 0 (unless AlwaysLooking% is on, in that case forced to 1 as normal for AlwaysLooking%) 
    'Please note that in many cases, you may want to ensure that the animal is looking at the
    'SAME grating that it was looking at when Looking was most recently determined.  In this
    'case the same variable can be passed in twice as both &whichGrating% and thisGrating%, 
    'it totally works fine even though it seems weird.
    var i%;
    var retValue% := 0;  'by default, not looking
    whichGrating% := -1;  'by default, set whichGrating% to -1 to indicate no grating being viewed
                          'before determining which grating is actually being viewed
    var tempNStim%;
    if nStim% > 2 then
        tempNStim% := nStim%;
    else
        tempNStim% := 4;
    endif
    
    'determine which grating, if any, is being looked at
    for i% := 0 to tempNStim%-1 do
        if fixptPresent%[i%][currTrial%-1] = 1 or i% = changeLoc%[currTrial%-1] then  'don't check locations that don't have fixation points - if putFixptOverGratings% = 0 , will be identical to stimOrientation[][] = -1000
            if (Pow(EyePosX-stimXPos[i%],2) + Pow(EyePosY-stimYPos[i%],2)) <= Pow(ggWindowRadius,2) then 
                whichGrating% := i%;  'indicate the grating number being viewed
                retValue% := 1;  'update looking!
                break  'and quit checking
            endif
        endif
    next
    
    'If the grating being looked at does not match the requested grating, do not consider this a success
    if whichGrating% <> thisGrating% then
        retValue% := 0;
    endif;
    
    'But consider anything a success if AlwaysLooking% is on
    if AlwaysLooking% = 1 then 
        retValue% := 1; 
        whichGrating% := rand(nStim%,0);  'arbitrary value, if we use -1 AlwaysLooking breaks things that index with this, must change grating number each time or it can get stuck
        'printlog("Current Grating is %d\n",whichGrating%);
    endif;
    
    return retValue%;
    
end;



' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
	FileClose(-1,-1);
	return 0;
end;
