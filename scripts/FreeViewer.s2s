' $Id$

const fvCVSID$ := "$Id$";


'Include Files

#include "../util/ChannelUtilities.s2s"
#include "../util/UsreyUtil.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "UsreyFixationPoint.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' FreeViewer script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Overall script control vars
var Pause% := 0;


' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		
var XChannel%;
var YChannel%;
var iStimChannel%;

var FrameChannel%;
var FrameSlaveChannel%;
var StimChannel%;
var ReadyChannel%;
var ReadySlaveChannel%;
var StimSlaveChannel%;
var DigitalLaserChannel%;
var OptoCopyChannel%;
var SequencerPeriodMS;
var StimulatorChannel%;
var UtilityChannel%;
var TimingChannel%;
var FixationPointChannel%;
var IntanMarkChannel%;
var IntanTrialChannel%;

' XY window stuff
var XYWindow%;			' 
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iStimWindowChannel%;

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];
var fvBackgroundColor$ := "gray";  'for right now, let's not even allow changing this...

' dummy vars
var iScript%;


var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastFixPtDisplayUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before image is presented)
var tRise, tFall;
var tKludge := 0.06;    ' Add to Fixation time to account for stim sequence. Ugly hack, admittedly, but one does what one must. 
var fvFixationWasBroken% := 0;  'this allows us to monitor fixation through the individual image "periods"
var fvFixWaitState%;
var fvBlankTime;        'Useful for delayed waitForBlank
var HBCycle% := 1;

' Constants for states

const stateVSGWait%:=0;		           ' Wait for VSG to send ready signal
const stateWaitForAcquisition%:=1;	   ' Waiting for subject to acquire fixation on screen
const stateAcquisitionTO%:=2;          ' Wait through acquisition timeout
const stateWaitForStimOn%:=3;		   ' Wait for stimulus return trigger (on)
const stateHoldImage%:=4;		       ' Holding fixation on screen while image is up
const stateWaitForStimOff%:=5;		   ' Wait for stimulus return trigger (off)
const stateInterTrialInterval%:=6;     ' Wait until it is time to present the next trial
const stateLookAwayTO%:=7;             ' Wait through timeout for breaking fixation
const stateTrialCompleted%:=8;		   ' trial has been completed successfully
const statePrepareOpto%:=9;            ' Set up opto on a trial-by-trial basis
const stateBeginImagePeriod%:=10;      ' Determine if we will do opto this period, branch
const stateOptoPeriod%:=11;
const stateOptoOff%:=12;
const stateNoOptoPeriod%:=13;
const stateRewardPeriod%:=14;
const stateWaitReward%:=15;
const stateFixptUp%:=16;
const stateWaitForFixptUp%:=17;
const stateWaitForBlank%:=18;
const stateWaitForImageOn%:=19;       ' "Image" is for image series, which are dealt with differently than single images
const stateWaitForImageOff%:=20;
const stateHoldAcquisition%:=21;
const stateLogTrialStart%:=22;
const stateIntanPreRecPause%:=23;
const stateIntanPostRecPause%:=24;

var iState% := stateVSGWait%;	' present state
var stateBegin% := 1;  'For fun, in this script let's keep track of whether it is the first time through a state, for logging purposes

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;	

var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
var pulseFound%;
'var pulseFoundSlave%;
var tOpt;

'variables for reading image files
var fvFileLen%; 
var fvdlgFileSelectButton% := 100;
var fvdlgFolderSelectButton% := 101;
var fvdlgImageSeriesSelectButton% := 102;
var fvdlgTextItem%;
var fvStimFolder$;
var fvStimFile$;
var fvUseFile%;  '1 if use file, 0 if use folder
var DPR$;
DPR$ := GetDataPathRoot$();
DPR$ := Left$(DPR$,1);  'get drive letter
var fvDefaultStimPath$ := DPR$ + ":\\Images\\";  'Set this folder for any computer with any main drive path!
var fvDefaultStimFile$ := "DefaultStimFile.txt";  'this file will be updated 
var fvDialogText$;
var fvImageList$[5000];  'allow up to 5000 unique images
var fvImageOrder%[5000];  'allow up to 5000 images to be presented total
var dummyResult[5000];  'This just lets me run GRPP to get the index order on fvImageOrder%[] instead of writing new code, just allows return of dummy values
var fvDoImageSeries%;
var success%;
var fvImagesPerTrial%[5000];  'for image series, allow up to 5000 trials
var fvTrialDurEstimate[5000];
var fvImageIndices%[5000][20];  '[trial][image-index] Xiaomo says max of 3 images per series, so 20 is plenty
var fvImageDur[5000];  'seconds
var fvImageDelay[5000];  'seconds
var fvImageXPos[5000];
var fvImageYPos[5000];
var fvImageHeightPix%[5000];
var fvImageWidthPix%[5000];
var fvCurrImageIndex%;


'Current Source Density
var fvDoCSD%;
var fvCSDWhiteFirst%;
var fvNumCSDFlashes%;
var fvCSDXPos;


' Wavemarks and continuous ports
var fvNWavemarks% := 0;
var fvWavemarkPorts%[64];
var fvNContinuous% := 0;
var fvContinuousPorts%[64];


' Reward variables
var fvProbRewardEachPeriod;
var fvProbDoubleRewardEachPeriod;
var rewardRand;     'we need to roll the dice once and check them twice!
var fvRewardDelaySec;   
var fvRewardDurSec;
fvRewardDurSec := (GetJuiceRewardMS%()+20)/1000;  'Set reward duration up top.  If we have any reason to think this will change through the experiment, then set it say each idle loop
                                                  'I am paranoid and I'm adding another 20 ms following the reward.
var fvJuiceRewardMSorig%;


' Optogenetics variables
var fvOptoVoltageOut;
var fvDoOpto%; 
var fvOptoState% := 0;      'might be useful to keep track of opto state?  Possibly not, as the sequencer is going to be doing the heavy lifting
var fvLaserDiode% := 0;     'Are we recording the output of the laser using a photodiode?
var fvOptoOrderThisTrial%;  'Set to 1 for opto first, and 2 for opto second
var fvPeriodCount%;         'How many periods we have completed
var fvLastPeriodStart;      'When did the last period start?

' Dialog box variables
var fvAlwaysLooking% := 1; ' If set eye signals ignored - subject presumed to be looking always. TESTING ONLY.
var fvRandomProgression%;
var fvNRepeats%;
var fvITI;   'The value between trials applies to the time between each "image series" if we are doing image series, and between each image in other cases
var fvISI;   'This value only applies to the time between images within an image series
var fvBlitzMode% := 0;  'If 1 (set if ITI is negative), try Blitz Mode, will aggressively pursue wait periods
var fvImageDuration;  'this value only applies to image series
var fvAcquisitionTime;
var fvAcquisitionTO;
var fvNumPeriods%;
var fvNumPeriodsPerBlock%;
var fvPeriodDuration;
var fvMinViewPeriodsForAdvance%;
var fvLookAwayTO;
var fvScreenMMX;  'we will assume that the 0,0 coordinate of fixation is at the center of the screen, and calculate the screen size from there
var fvScreenMMY;
var fvScreenXDeg;  'Defined as the distance from the center of the screen to the edge, for ease with creating the LookingAtScreenOrFixpt%() function
var fvScreenYDeg;
var fvGiveLookingTO%;
var fvGiveAcqTO%;
var fvAdvance%;
var fvNValues%;
var fvNAdvances%;
var fvXPos;
var fvYPos;
var fvUseStimLocation%;
var fvFixScreen%;
var fvHoldAcquisitionTime;
var fvSendINTANPulse%;
var fvDisableGamma%;
var fvMaintainFixation%;
var fvExptType%;

var cmdLine$;  'if we want to print this out, has to be global!



GetFreeViewerScriptParameters();  'We will just get these right off the bat, this supports the pre-dialog box
                                  'that warns about AlwaysLooking - though this pre-dialog is currently disabled


' Init logging
LogInit(1);

UseTwo1401s% := DoWeUseTwo1401s%();
GetPortsAndNumWMsWFs%(fvNWavemarks%,fvNContinuous%,fvWavemarkPorts%[],fvContinuousPorts%[]);


' Check if always looking flag is set. If so, issue a warning.
' I'm thinking that this is kind of a pain in the butt, we can possibly just put it in the dialog box
' and forget it.  If Henry wants it back as a warning up front, it's an easy uncomment.
'if fvAlwaysLooking% = 1 then
'    if Query("Always looking is SET. Unset?") = 1 then
'        fvAlwaysLooking% := 0;
'    endif
'endif


iScript% := FreeViewerScriptDialog%();


'halt;  'this is just so I can test out the dialog box but not go any farther... TODO - COMMENT THIS OUT, DUH
if iScript% = 1 then
    LogInfo("Proceed with DAQ.");
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 25;
YChannel% := 26;
ReadyChannel% := 40;
FrameChannel% := 41;
StimChannel% := 43;
ReadySlaveChannel% := 44;
'FrameSlaveChannel% := 45;  'replaced by fixation point channel
StimulatorChannel% := 46;
'StimSlaveChannel% := 47;
DigitalLaserChannel% := 48;  'is 32 on Acute tuning, but let's not shove it in the midst of other stuff
OptoCopyChannel% := 49;
UtilityChannel% := 39;
TimingChannel% := 38;
FixationPointChannel% := 45;
IntanMarkChannel% := 27;
IntanTrialChannel% := 28;

ExcludedChans%[0] := 25;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 49;  'OptoCopyChannel% is highest non-electrode channel used by this function  




'If we are not linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the dual-1401 setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401/SLAVE 1401 (the second, non-dominant instance of Spike2) FIRST and on the 
'MICRO 1401/MASTER 1401 (the first,  dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run 
'the VSG program (Fixstim) which gives the sampling trigger and sets the experiment in motion.
if UseTwo1401s% = 0 then
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();
    
    tic := View(DataWindow%).BinSize(ReadyChannel%);
    
    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' FreeViewer script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'From here on out, it's just various necessary functions


' FreeViewerScriptDialog

func FreeViewerScriptDialog%()
	var i%;
	var iReturn%;
    var screenMMPerDegree;
    var pi := 3.141592653589793;  'There is a pre-defined constant "_pi", but only on 8.03 and beyond, explicitly defining pi for back-compatibility
    var fixscreen$[2];
    fixscreen$[0] := "Use Fixation Point";
    fixscreen$[1] := "Use Screen";
    var exptype$[5];
    exptype$[0] := "Standard Image";
    exptype$[1] := "Opto (blocked)";
    exptype$[2] := "No Opto (blocked)";
    exptype$[3] := "Image Series";
    exptype$[4] := "CSD Flash";
    var sixReals[6];
    var fourReals[4];
    
    
    'Since the opto is incorporated into this dialog (for now) we don't have to do a separate parameter grab for opto
    GetFreeViewerScriptParameters();
    
    'Fill sixReals[]
    sixReals[0] := fvISI;
    sixReals[1] := fvITI;
    sixReals[2] := fvAcquisitionTime;
    sixReals[3] := fvHoldAcquisitionTime;
    sixReals[4] := fvAcquisitionTO;
    sixReals[5] := fvLookAwayTO;
    
    'Fill fourReals[]
    fourReals[0] := fvXPos;
    fourReals[1] := fvYPos; 
    fourReals[2] := fvScreenMMX;
    fourReals[3] := fvScreenMMY;
    
    
    if fvUseFile% = 0 then
        if Len(fvStimFolder$) > 0 then
            fvDialogText$ := "Use FOLDER: " + fvStimFolder$;
        else
            fvDialogText$ := "No File/Folder Selected";
        endif
    else
        if Len(fvStimFile$) > 0 then
            fvDialogText$ := "Use FILE: " + fvStimFile$;
        else
            fvDialogText$ := "No File/Folder Selected";
        endif
    endif
    
        
    DlgCreate("FreeViewer Parameters", 0, 0, 0, 0, -1, -1, 1);  'center dialog relative to screen and not to application window to eliminate cutting off the bottom of the dialog!
    DlgGroup("Stimulus and Fixation", 1, 1, 50, 19);
    DlgInteger(1, "Number of repeats", 1, 1000, 0, 2);
    DlgCheck(2, "Random Progression?", 0, 3);
    DlgList(3, "View/Opto Condition: ", exptype$, 5, 32, 4);
    DlgReal(4, "Period Duration, s", 0.05, 100, 0, 5);
    DlgInteger(5, "Number of periods per block", -10, 1000, 0, 6);
    DlgInteger(6, "Minimum Viewed Periods To Advance", 0, 1000, 0, 7);
    DlgReal(7, "Image Series Interimage Delay, s", 0, 100, 0, 8);
    DlgReal(8, "Intertrial Interval, s (-1 for Blitz Mode)", -1, 100, 0, 9);
    DlgReal(9, "Fixation Acquisition Time, s", 0.1, 100, 0, 10);
    DlgReal(10, "Fixation Hold Time, s", 0, 100, 0, 11);
    DlgReal(11, "Acquisition/Hold Time Out, s", 0, 100, 0, 12);
    DlgReal(12, "Look Away Time Out, s", 0, 100, 0, 13);
    DlgList(13, "Fixation: ", fixscreen$, 2, 32, 14);
    DlgCheck(14, "Always Looking?", 0, 15);
    DlgCheck(15, "Maintain Fixation?", 0, 16);
    DlgCheck(16, "Use Stimulus Location From Config?", 0, 17);
    DlgReal(17, "Image X Position (deg)", -20, 20, 0, 18);
    DlgReal(18, "Image Y Position (deg)", -20, 20, 0, 19);
    
    DlgGroup("Screen", 1, 20, 50, 3);
    DlgReal(19, "Screen Width, mm", 10, 3000, 0, 21);
    DlgReal(20, "Screen Height, mm", 10, 3000, 0, 22);
    
    DlgGroup("Reward", 1, 23, 50, 4);
    DlgReal(21, "Prob of reward each period", 0, 1, 0, 24);
    DlgReal(22, "Prob of double reward each period", 0, 1, 0, 25);
    DlgReal(23, "Reward delay (s)", 0, 3, 0, 26);
    
    DlgGroup("Optogenetics", 1, 27, 50, 2);
    DlgReal(24, "Opto Voltage Out (V)", 0.0002, 5, 0, 28); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    
    DlgGroup("Images", 1, 29, 50, 4);
    fvdlgTextItem% := DlgText(fvDialogText$, 3, 30, 40);
    DlgButton(fvdlgFolderSelectButton% , "Select Folder", SelectStimFolder%, 3, 31);
    DlgButton(fvdlgFileSelectButton% , "Select File", SelectStimFile%, 18, 31);  
    DlgButton(fvdlgImageSeriesSelectButton% , "Select Image Series", SelectStimFile%, 30, 31);
    DlgCheck(25,"Disable Gamma",0,32);
    
    DlgCheck(26, "Send digital pulse to INTAN", 0,33);
    
    'Right now we don't seem to need a callback, it's ready directly below if we do 
    DlgAllow(0xffff, 0, FreeViewerScriptDialogChanged%);

    i%:=DlgShow(fvNRepeats%, fvRandomProgression%, fvExptType%, fvPeriodDuration, fvNumPeriodsPerBlock%, fvMinViewPeriodsForAdvance%, 
    sixReals[], fvFixScreen%, fvAlwaysLooking%, fvMaintainFixation%, fvUseStimLocation%, fourReals[], 
    fvProbRewardEachPeriod, fvProbDoubleRewardEachPeriod, fvRewardDelaySec, fvOptoVoltageOut, fvDisableGamma%, fvSendINTANPulse%);
    
    if i% = 1 then
        'Unpack sixReals[]
        fvISI := sixReals[0];
        fvITI := sixReals[1];
        fvAcquisitionTime := sixReals[2];
        fvHoldAcquisitionTime := sixReals[3];
        fvAcquisitionTO := sixReals[4];
        fvLookAwayTO := sixReals[5];
        
        'Unpack fourReals[]
        fvXPos := fourReals[0];
        fvYPos := fourReals[1]; 
        fvScreenMMX := fourReals[2];
        fvScreenMMY := fourReals[3];
        
        if fvITI < 0 then
            fvBlitzMode% := 1;
        endif
        
		SaveFreeViewerScriptParameters();

        'Calculate screen values in degrees here
        screenMMPerDegree := Val(GetDistanceToScreenMM$())*pi/180;  
        fvScreenXDeg := (fvScreenMMX/2)/screenMMPerDegree;  'we are defining fvScreenX(Y)Deg as HALF the screen so it is the distance from fixation to the edge
        fvScreenYDeg := (fvScreenMMY/2)/screenMMPerDegree;
        
        
        
        'Just for code clarity
        docase
        case fvExptType% = 3 then
            fvDoImageSeries% := 1;
            fvImageDuration := fvPeriodDuration;
            fvRandomProgression% := 0;  'Explicitly do not allow randomization on image series
            'fvNumPeriodsPerBlock% := 1;  'Unused in image series logic
            'fvNumPeriods is set in the idle loop for image series
            fvDoOpto% := 0;  'hard code opto OFF
            fvNRepeats% := 1;  'technically this value is ignored, but good to note we don't allow repeats for Image Series, the file can have repeated trials if you want
            fvDoCSD% := 0;
        case fvExptType% = 4 then
            fvDoImageSeries% := 0;
            fvDoCSD% := 1;
            fvImageDuration := fvPeriodDuration;
            fvRandomProgression% := 0;  'Explicitly do not allow randomization on CSD
            fvISI := 0;
            docase
            case fvNumPeriodsPerBlock% > 10 then
                message("Maximum number of CSD images is 10, setting to 10!");
                fvNumCSDFlashes% := 10;
                fvCSDWhiteFirst% := 1;  'By default, we will have the white image first
            case fvNumPeriodsPerBlock% < 0 then
                fvCSDWhiteFirst% := 0;  'negative value indicates black first
                fvNumCSDFlashes% := -fvNumPeriodsPerBlock%;  'and make that positive
            case fvNumPeriodsPerBlock% = 0 then  'can't do this!
                message("Number of CSD images cannot be 0, quitting!");
                halt;
            else
                fvNumCSDFlashes% := fvNumPeriodsPerBlock%;  'default case
                fvCSDWhiteFirst% := 1;  'By default, we will have the white image first
            endcase
            
            '??? fvNumPeriods is set in the idle loop for image series
            fvDoOpto% := 0;  'hard code opto OFF   
        else
            fvDoImageSeries% := 0;
            fvImageDuration := 0;  'This is what had been set for the third argument in non-image-series presentations
            fvISI := 0;  'This is what had been set for the fourth argument in non-image-series presentations
            fvDoOpto% := fvExptType%;
            fvDoCSD% := 0;
            docase 'This is the consequence of having a "clever" dialog that requires you to "open up" the limits on a dialog entry
            case fvNumPeriodsPerBlock% < 1 then
                fvNumPeriodsPerBlock% := -fvNumPeriodsPerBlock%;
                message("Negative NumPeriodsPerBlock has been changed to positive!");
            case fvNumPeriodsPerBlock% = 0 then
                message("NumPeriodsPerBlock cannot be 0!  Quitting!");
                halt;
            endcase
        endcase
        
        
        'If we are doing the opto blocking (or pseudo-opto blocking) 
        if fvExptType% = 1 or fvExptType% = 2 then
            fvNumPeriods% := fvNumPeriodsPerBlock%*2;   'two "blocks" per image
        else  'for NOW, we are assuming that the image series must be viewed in full to advance, but that's a question to ask
            fvNumPeriods% := 1;  'only one period
            if fvMinViewPeriodsForAdvance% > 1 then 'don't allow this value to be too large
                fvMinViewPeriodsForAdvance% := 1;
            endif;
            fvMinViewPeriodsForAdvance% := 1-fvMinViewPeriodsForAdvance%;  'Invert this for standard image/image series, as dialog says "new image on fix break", 0 = no new image, means min view periods is 1
        endif;
        
        
        'Recode pReward (value from DAQ parameters dialog) because we are setting the per-period value here 
        '(It's weird, but we need to be able to get an "R" without actually giving a reward for the INTAN
        'experiments, so we set the "size" of the reward to Full/Zero and make sure that the "R" always comes.
        if fvSendINTANPulse% = 1 then
            pReward := 1;  'For INTAN, set pReward to 1, and use fvProbRewardEachPeriod below in state logic
                           'to set reward size to 0 for non-reward trials, always give "R"
        else            
            pReward := fvProbRewardEachPeriod;  'For other experiments, set pReward to value in local dialog box, will work as normal, but override value in DAQ dialog
        endif;
        
        iReturn% := 1;  'set return value to success, otherwise we'll just quit.
        
	endif;

	return iReturn%;
end;

func FreeViewerScriptDialogChanged%(item%) 
    var gr$;
    var x, y, w, h;
    
    'If always looking, turn off all fixation variables - this misses some values set later, don't want to mess with it for now, not important
'    if DlgValue(13) = 1 then
'        DlgEnable(0,9);
'        DlgEnable(0,10);
'        DlgEnable(0,11);
'        DlgEnable(0,12);
'        DlgEnable(0,13);
'    else
'        DlgEnable(1,9);
'        DlgEnable(1,10);
'        DlgEnable(1,11);
'        DlgEnable(1,12);
'        DlgEnable(1,13);
'    endif;
    
    'Grating parameters will be used to set stimulus location
    if DlgValue(16) = 1 then
        gr$ := GetGratingParameters$("Stimulus");
        ParseGratingParametersBrief%(gr$, x, y, w, h);  'w, h are diameters
    endif;
    
    'Enable/disable screen size entries based on using screen/fixation point for fixation
    if DlgValue(16) = 0 then  
        DlgEnable(1,17);
        DlgEnable(1,18);
    else
        DlgEnable(0,17);
        DlgEnable(0,18);
        DlgValue(17,x);
        DlgValue(18,y);
    endif;
    
    
    'Enable/disable screen size entries based on use of fixpt
    DlgEnable(DlgValue(13),19);
    DlgEnable(DlgValue(13),20);
    
    'Set fixation hold time to zero and disable if fixating screen
    if DlgValue(13) = 1 then
        DlgValue(10,0);  'Set hold time to zero
        DlgEnable(0,10);  'And disable
    else
        DlgEnable(1,10);  'Enable
        if item% = 13 then
            DlgValue(10,fvHoldAcquisitionTime);  'And set the value back to the most recent registry value - but ONLY if we just changed the list, otherwise change any value and it pops back!
        endif
    endif
    
    'Make sure double reward probability isn't greater than overall reward probability
    if DlgValue(22) > DlgValue(21) then
        DlgValue(22,0); 'Set double reward probability to zero
        message("Double reward probability cannot be greater than single (overall) reward probability");
    endif
    
    
    'Enable/disable opto voltage based on using opto
    if DlgValue(3) = 1 then
        DlgEnable(1,24);
    else
        DlgEnable(0,24);
    endif;
    
    'Change labeling/enable based on using opto-style vs, regular style vs. image series style
    docase
    case DlgValue(3) = 0 then 'regular style
        DlgEnable(1,1);  'enable repeats
        DlgEnable(1,2);  'enable randomization
        DlgValue$(1004,"Image Duration, s");  'label duration appropriately
        DlgEnable(0,5);  'disable number of periods
        DlgValue$(1005,"Number of periods per block");  'label periods appropriately
        DlgEnable(1,6);  'enable new image series
        DlgValue$(1006,"New Image On Fix Break? (0/1)");  'label appropriately
        DlgEnable(0,7);  'disable ISI
        DlgEnable(1,16);  'enable Use Stim Location
        DlgValue$(1017,"Image X Position (deg)");  'label X position appropriately
        DlgEnable(1,18);  'enable Y position
        DlgEnable(0,21);  'disable reward
        DlgEnable(0,22);  'disable double reward
        DlgEnable(1,-fvdlgFolderSelectButton%);  'enable folder select
        DlgEnable(1,-fvdlgFileSelectButton%);  'enable standard file select
        DlgEnable(0,-fvdlgImageSeriesSelectButton%);  'disable image series select
    case DlgValue(3) = 3 then 'image series style
        DlgEnable(0,1);  'disable repeats
        DlgEnable(0,2);  'disable randomization (changed from disable to enable back to disable)
        DlgValue$(1004,"Image Duration, s");  'label duration appropriately
        DlgEnable(0,5);  'disable number of periods
        DlgValue$(1005,"Number of periods per block");  'label periods appropriately
        DlgEnable(1,6);  'enable new image series
        DlgValue$(1006,"New Image Series On Fix Break? (0/1)");  'label appropriately
        DlgEnable(1,7);  'enable ISI
        DlgEnable(1,16);  'enable Use Stim Location
        DlgValue$(1017,"Image X Position (deg)");  'label X position appropriately
        DlgEnable(1,18);  'enable Y position
        DlgEnable(1,21);  'enable reward
        DlgEnable(1,22);  'enable double reward
        DlgEnable(0,-fvdlgFolderSelectButton%);  'disable folder select
        DlgEnable(0,-fvdlgFileSelectButton%);  'disable standard file select
        DlgEnable(1,-fvdlgImageSeriesSelectButton%);  'enable image series select
    case DlgValue(3) = 4 then 'CSD flash style
        DlgEnable(1,1);  'enable repeats
        DlgEnable(0,2);  'disable randomization
        DlgValue$(1004,"Flash Duration, s");  'label duration appropriately
        DlgEnable(1,5);  'enable number of flashes
        DlgValue$(1005,"#Flashes, neg = black 1st");  'label periods appropriately
        DlgEnable(0,6);  'disable new image series
        DlgValue$(1006,"Unused");  'label appropriately
        DlgEnable(0,7);  'disable ISI
        DlgEnable(0,16);  'disable Use Stim Location
        DlgValue$(1017,"CSD XCtr deg from fix");  'label X position appropriately
        DlgEnable(0,18);  'disable Y position
        DlgEnable(1,21);  'enable reward
        DlgEnable(0,22);  'disable double reward ???
        DlgEnable(0,-fvdlgFolderSelectButton%);  'disable folder select
        DlgEnable(0,-fvdlgFileSelectButton%);  'disable standard file select
        DlgEnable(0,-fvdlgImageSeriesSelectButton%);  'disable image series select
    else 'opto style
        DlgEnable(1,1);  'enable repeats
        DlgEnable(1,2);  'enable randomization
        DlgValue$(1004,"Period Duration, s");  'label duration appropriately
        DlgEnable(1,5);  'enable number of periods
        DlgValue$(1005,"Number of periods per block");  'label periods appropriately
        DlgEnable(1,6);  'enable minimum viewed periods to advance
        DlgValue$(1006,"Minimum Viewed Periods To Advance");  'label appropriately
        DlgEnable(0,7);  'disable ISI
        DlgEnable(1,16);  'enable Use Stim Location
        DlgValue$(1017,"Image X Position (deg)");  'label X position appropriately
        DlgEnable(1,18);  'enable Y position
        DlgEnable(1,21);  'enable reward
        DlgEnable(0,22);  'disable double reward
        DlgEnable(1,-fvdlgFolderSelectButton%);  'enable folder select
        DlgEnable(1,-fvdlgFileSelectButton%);  'enable standard file select
        DlgEnable(0,-fvdlgImageSeriesSelectButton%);  'disable image series select
    endcase;
    
    
    
    return 1;
end



proc GetFreeViewerScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\FreeViewer";
    
	
    fvAlwaysLooking% := GetIntRegistryValue%(key$, "AlwaysLooking", fvAlwaysLooking%);
    fvRandomProgression% := GetIntRegistryValue%(key$, "RandomProgression", fvRandomProgression%);
    fvNRepeats% := GetIntRegistryValue%(key$, "NRepeats", fvNRepeats%);
    fvITI := GetFloatRegistryValue(key$, "TrialISI", fvITI);
    fvISI := GetFloatRegistryValue(key$, "ISI", fvISI);
    fvAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", fvAcquisitionTime);
    fvAcquisitionTO := GetFloatRegistryValue(key$, "AcquisitionTO", fvAcquisitionTO);
    fvLookAwayTO := GetFloatRegistryValue(key$, "LookAwayTO", fvLookAwayTO);
    fvScreenMMX := GetFloatRegistryValue(key$, "ScreenMMX", fvScreenMMX);
    fvScreenMMY := GetFloatRegistryValue(key$, "ScreenMMY", fvScreenMMY);
    fvUseFile% := GetIntRegistryValue%(key$, "UseFile", fvUseFile%);
    fvStimFolder$ := GetStringRegistryValue$(key$, "StimFolder", fvStimFolder$);
    fvStimFile$ := GetStringRegistryValue$(key$, "StimFile", fvStimFile$);
    fvOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", fvOptoVoltageOut);
    fvExptType% := GetIntRegistryValue%(key$, "ExptType", fvExptType%);
    fvNumPeriodsPerBlock% := GetIntRegistryValue%(key$, "NumPeriodsPerBlock", fvNumPeriodsPerBlock%);
    fvMinViewPeriodsForAdvance% := GetIntRegistryValue%(key$, "MinViewPeriodsForAdvance", fvMinViewPeriodsForAdvance%);
    fvPeriodDuration := GetFloatRegistryValue(key$, "PeriodDuration", fvPeriodDuration);
    fvProbRewardEachPeriod := GetFloatRegistryValue(key$, "ProbRewardEachPeriod", fvProbRewardEachPeriod);
    fvRewardDelaySec := GetFloatRegistryValue(key$, "RewardDelaySec", fvRewardDelaySec);
    fvProbDoubleRewardEachPeriod := GetFloatRegistryValue(key$, "ProbDoubleRewardEachPeriod", fvProbDoubleRewardEachPeriod);
    fvUseStimLocation% := GetIntRegistryValue%(key$, "UseStimLocation", fvUseStimLocation%);
    fvXPos := GetFloatRegistryValue(key$, "XPos", fvXPos);
    fvYPos := GetFloatRegistryValue(key$, "YPos", fvYPos);
    fvFixScreen% := GetIntRegistryValue%(key$, "FixScreen", fvFixScreen%);
    fvHoldAcquisitionTime := GetFloatRegistryValue(key$, "HoldAcquisitionTime", fvHoldAcquisitionTime);
    fvSendINTANPulse% := GetIntRegistryValue%(key$, "SendINTANPulse", fvSendINTANPulse%);
    fvDisableGamma% := GetIntRegistryValue%(key$, "DisableGamma", fvDisableGamma%);
    fvMaintainFixation% := GetIntRegistryValue%(key$, "MaintainFixation", fvMaintainFixation%);
    fvSendINTANPulse% := GetIntRegistryValue%(key$, "SendINTANPulse", fvSendINTANPulse%);
    
  
end;

proc SaveFreeViewerScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\FreeViewer";
    
    SetIntRegistryValue(key$, "AlwaysLooking", fvAlwaysLooking%);
    SetIntRegistryValue(key$, "RandomProgression", fvRandomProgression%);
    SetIntRegistryValue(key$, "NRepeats", fvNRepeats%);
    SetFloatRegistryValue(key$, "TrialISI", fvITI);
    SetFloatRegistryValue(key$, "ISI", fvISI);
    SetFloatRegistryValue(key$, "AcquisitionTime", fvAcquisitionTime);
    SetFloatRegistryValue(key$, "AcquisitionTO", fvAcquisitionTO);
    SetFloatRegistryValue(key$, "LookAwayTO", fvLookAwayTO);
    SetFloatRegistryValue(key$, "ScreenMMX", fvScreenMMX);
    SetFloatRegistryValue(key$, "ScreenMMY", fvScreenMMY);
    SetIntRegistryValue(key$, "UseFile", fvUseFile%);
    SetStringRegistryValue(key$, "StimFolder", fvStimFolder$);
    SetStringRegistryValue(key$, "StimFile", fvStimFile$);
    SetFloatRegistryValue(key$, "OptoVoltageOut", fvOptoVoltageOut);
    SetIntRegistryValue(key$, "ExptType", fvExptType%);
    SetIntRegistryValue(key$, "NumPeriodsPerBlock", fvNumPeriodsPerBlock%);
    SetIntRegistryValue(key$, "MinViewPeriodsForAdvance", fvMinViewPeriodsForAdvance%);
    SetFloatRegistryValue(key$, "PeriodDuration", fvPeriodDuration);
    SetFloatRegistryValue(key$, "ProbRewardEachPeriod", fvProbRewardEachPeriod);
    SetFloatRegistryValue(key$, "ProbDoubleRewardEachPeriod", fvProbDoubleRewardEachPeriod);
    SetFloatRegistryValue(key$, "RewardDelaySec", fvRewardDelaySec);
    SetIntRegistryValue(key$, "UseStimLocation", fvUseStimLocation%);
    SetFloatRegistryValue(key$, "XPos", fvXPos);
    SetFloatRegistryValue(key$, "YPos", fvYPos);
    SetIntRegistryValue(key$, "FixScreen", fvFixScreen%);
    SetFloatRegistryValue(key$, "HoldAcquisitionTime", fvHoldAcquisitionTime);
    SetIntRegistryValue(key$, "SendINTANPulse", fvSendINTANPulse%);
    SetIntRegistryValue(key$, "DisableGamma", fvDisableGamma%);
    SetIntRegistryValue(key$, "MaintainFixation", fvMaintainFixation%);
    SetIntRegistryValue(key$, "SendINTANPulse", fvSendINTANPulse%);
    
end;







''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
    var temp1$;
    var temp2$;
    var od;
    var key$;
    var eof% := 1;
    
    var primaryTxt$;
    var secondaryTxt$;
    
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
    
	SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    
    DoSampleAutoName(key$,"imgs","img",primaryTxt$,secondaryTxt$);
       
    SampleAutoFile(1);  'Enable automatic file naming
    
    ' Text marks make extraction easier
    SampleTextMark(200);  'Channel 30 is textmark channel
    

	'----Event Channel recording definitions----
    
   	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");

	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"Ready");
	SampleTitle$(ReadyChannel%,"Ready");
    
    SampleEvent(FixationPointChannel%, 2, 2, 3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixpt");
	SampleTitle$(FixationPointChannel%,"Fixpt");
	
	SampleEvent(StimChannel%, 3, 2, 3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
    if UseTwo1401s% = 1 then
    
        SampleEvent(FrameSlaveChannel%, 4, 2, 3600);
        SampleComment$(FrameSlaveChannel%,"Frame-Slave");
        SampleTitle$(FrameSlaveChannel%,"Frame-Slave");
    
        SampleEvent(ReadySlaveChannel%, 5, 2, 3600); 'Trigger channel, level
        SampleComment$(ReadySlaveChannel%,"Ready-Slave");
        SampleTitle$(ReadySlaveChannel%,"Ready-Slave");
	
        SampleEvent(StimSlaveChannel%, 7, 2,3600); 'Trigger channel, level
        SampleComment$(StimSlaveChannel%,"Stim-Slave");
        SampleTitle$(StimSlaveChannel%,"Stim-Slave");
        
    endif
    
    if fvSendINTANPulse% = 1 then
        SampleEvent(IntanTrialChannel%, 5, 2, 3600); 'Trigger channel, level
        SampleComment$(IntanTrialChannel%,"INTAN-T");
        SampleTitle$(IntanTrialChannel%,"INTAN-T");
        
        'Under the new conception, we will not be receiving a pulse from the INTAN machine
'        SampleEvent(IntanMarkChannel%, 6, 2, 3600); 'Trigger channel, level
'        SampleComment$(IntanMarkChannel%,"INTAN-M");
'        SampleTitle$(IntanMarkChannel%,"INTAN-M");
    endif
    
    
    
    
    'Add a digital marker channel for pulsing optogenetics
    'Do it for every opto, easy enough to add this into the wraparound calls in the PLS
    'Will record a '1' for laser on and a '0' for laser off
    docase
    case fvDoOpto% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(DigitalLaserChannel%,"Laser On");
    case UseTwo1401s% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Timing");  'Digital marker is by definition channel 32
    case fvSendINTANPulse% = 1 then
        'will record '11' for reward onset and '55' for trial onset, these values are hardcoded as MARK 11/55 commands in the PLS file
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"INTAN");  'Digital marker is by definition channel 32
    case RecordEyeTrackerOutputFile% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"EyeFilePulse");  'Digital marker is by definition channel 32
    endcase
    
    
    '----Analog, non-spiking electrode recording conditions
    'Add a waveform channel for efference copy.  This can come from either the 1401 itself or
    'from the stimulator, it doesn't really matter.
    if fvDoOpto% = 1 and OptoEffCopyPort% > -1 then
        SampleWaveform(OptoCopyChannel%,OptoEffCopyPort%,5000);  'is 30000 Hz on Acute, but here was defined as 5000 Hz, could change...
        SampleTitle$(OptoCopyChannel%,OptoPortLabel$);
    endif;
       
    
    
    'if we are recording the laser output, turn off any electrode channels
    'this will not happen currently, as the laser diode collection has been disabled at the dialog box
    'If we re-implement this, test to see if it actually works as intended!
    docase
    case fvLaserDiode% = 1 and StimEffCopyPort% > -1 then
        SampleWaveform(StimulatorChannel%,StimEffCopyPort%,50000);  
        SampleTitle$(StimulatorChannel%,StimPortLabel$);

        fvNWavemarks% := 0;  'no wavemarks!
        fvNContinuous% := 0;  'no continuous!
        'SampleWaveform(1,0,50000);  'on waveform port 0
        'SampleTitle$(1,"Diode output (laser)");
    case fvLaserDiode% = 1 and StimEffCopyPort% = -1 then
        message("fvLaserDiode is set to 1 but no StimEffCopyPort is set!  Quitting!");
        halt
    endcase;
    
    SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
	SampleTitle$(XChannel%,EyeXPortLabel$);
	SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
	SampleTitle$(YChannel%,EyeYPortLabel$);
    
    if UtilityPort% > -1 then
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);       
        SampleTitle$(UtilityChannel%,UtilityPortLabel$);
    endif;

    
    if UseTwo1401s% = 1 then
        SampleEvent(TimingChannel%, 6, 2, 3600); 'Trigger channel, level
        SampleComment$(TimingChannel%,"Handshake");
        SampleTitle$(TimingChannel%,"Hndshk");
    endif;

    
    
    '----Set up "spiking" Electrode Channels----
    SetUpElectrodeConfiguration(fvNWavemarks%,ExcludedChans%[]);
    
        
	
    
	if UseTwo1401s% = 0 then
        SampleSequencer(script$ + "Tuning.pls");
    else
        SampleSequencer(script$ + "TuningSendTrigger.pls");
    endif;

	DoSampleOptimise();
	SampleMode(1); 'Continuous sampling
    
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeWindows()
    var i%;
    var WindowStep;
    
    ' Make spike2 use all of monitor 1
    'View(App()).Window(0, 0, 100, 100, 1);  'this just seems to fuck shit up
    
	'Open the data sampling window
    DataWindow% := FileNew(0,4);
    if DataWindow% < 0 then
        PrintLog("FileNew Error: %s\n", Error$(DataWindow%));
    endif

	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
            

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);
	XYSize(1,-1);


	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);


	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
'	XYAddData(4,-9,-7);  'this assumes an 18x14 degree monitor, could literally calculate it, and should
'	XYAddData(4,9,-7);
'	XYAddData(4,9,7);
'	XYAddData(4,-9,7);
    XYAddData(iMonitorChannel%,-fvScreenXDeg,-fvScreenYDeg);  'this calculates it instead
	XYAddData(iMonitorChannel%,fvScreenXDeg,-fvScreenYDeg);
	XYAddData(iMonitorChannel%,fvScreenXDeg,fvScreenYDeg);
	XYAddData(iMonitorChannel%,-fvScreenXDeg,fvScreenYDeg);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
    if UseTwo1401s% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    ToolbarSet(6,"Select Wavemarks",SelectWavemarkDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    fp$ := SetPathToScriptDirectory$();
    
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();    
    
    StartSecondInstanceOfSpike2();
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work
    

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    var Opener$;
    var ProgName$;
    var RemoteArg$ := "";     'Extra arg needed if vsg is not on local machine...
    var BGColor$;
    var Dist2Screen$;
    var TriggerPort$;
    var ImageFileLoc$;  'We can just set this outright
    ImageFileLoc$ := fvDefaultStimPath$ + fvDefaultStimFile$;
    'var FixationArg$;  'NO!  Do not define FixationArg$ here or it will step on the one defined in UsreyFixationPoint.s2s!!
    var ImageArg$;
    var GammaArg$ := "";
    var Verbose$ := " -v ";  'For now, verbose is always on 
    'vars for opto setup
    var voltageInteger%;
    var stimRemaining;
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;
    var i%;
    var j%;
    var k%;
    var returnToPath$;  'this is where we start, we'll move back here after reading the folder
    var fh%;
    var readInputFile% := 1;
    var readTemp$;
    var startSecs := 5;
    var bw%[10];
    var fixX,fixY,fixD,fixWR;
    
    
    'Grab current Juice Reward size if we are using the INTAN system, we will be manipulating the
    'reward size to 0 to turn off the reward but NOT turn off the pulse that comes with the reward.
    if fvSendINTANPulse% = 1 then
        fvJuiceRewardMSorig% := JuiceRewardMS%;
    endif
    
    
    'If we are loading an IMAGE SERIES file, the entire spec is in the file, for CSD we have to MAKE the file,
    'otherwise we take a folder or list of file names and re-create the file in a known location
    docase
    case fvDoImageSeries% = 1 then
        ImageFileLoc$ := fvStimFile$;  'directly assign the selected file
        'Note that this file is NOT randomized, we will be going in the order listed in the file
        'File format has two sections:
        '
        'E:\work\img\grapes-tc.bmp
        'E:\work\img\lettuce-tc.bmp,-8,-8
        'E:\work\img\potato-tc.bmp,-8,8,2,1
        'E:\work\img\radish-tc.bmp
        'E:\work\img\zuccini-tc.bmp,0,0,3
        'E:\work\img\potato-tc.bmp,-4,4,2,1
        '
        'Groups
        '0,2,4
        '1
        '2,3
        '3,4,5
        '
        'Where the first section is image definitions, and the second section is a list of trials, using
        'zero-based indexing to ID the N stimuli to present in any trial.  In the image definition section, 
        'the optional arguments are xpos,ypos,duration,delay_following.  Delay_following is ignored for the
        'final stimulus in a group ("image series", "trial").  Can give 0, 2, 3, or 4 args (x/y must come
        'together) with default values used if not specified.  Note that the same image may be defined more
        'than once with different arguments.
        
        'Parse image series file, we need to know how many trials, etc.
        success% := ParseImageSeriesFile%(fvStimFile$,fvNValues%,fvImagesPerTrial%[],fvTrialDurEstimate[],fvImageList$[],fvImageIndices%[][],fvImageDur[],fvImageDelay[],fvImageXPos[],fvImageYPos[]);
        if success% = 1 then
            printlog("Success in reading image series file %s, num trials is %d\n",fvStimFile$,fvNValues%);
        else
            printlog("Failure in reading image series file %s! \n",fvStimFile$);
            halt;  'no point in going on if the file is bad!
        endif;
        'Potentially randomize, use fvImageOrder%[] to hold randomized indices
        GetRepeatedParameterProgression%(fvNValues%, fvNRepeats%, dummyResult[], fvImageOrder%[], 1, 2, 0, fvRandomProgression%);  'We will ignore dummyResult, which holds values between (1) and (2) that are not logspaced (0)
    case fvDoCSD% = 1 then
        'Create a variable to hold the black/white order, I'm afraid there's no clever way to do this with Spike2 and it's only ten places, so screw it...
        if fvCSDWhiteFirst% = 1 then
            bw%[0]:=1; bw%[2]:=1; bw%[4]:=1; bw%[6]:=1; bw%[8]:=1; 'I hate it!
        else
            bw%[1]:=1; bw%[3]:=1; bw%[5]:=1; bw%[7]:=1; bw%[9]:=1; 'I hate it!
        endif    
        'We need to explicitly write out a file
        fh% := FileOpen(ImageFileLoc$,8,1);  'Open a new text file for writing, replace current (default) file
        printlog("result of opening text file is %d\n",fh%);
        view(fh%).Print("%sblack-512x768.bmp\n%swhite-512x768.bmp\n\nGroups",fvDefaultStimPath$,fvDefaultStimPath$);  'this part will be constant, the white image, the black image, the Groups section
        for j% := 0 to fvNRepeats%-1 do 'for each repeat of the stimulus
            view(fh%).Print("\n"); 'lead off by putting in a new line, trailing newline omitted from above "constant" view().Print
            for k% := 0 to fvNumCSDFlashes%-1 do 'for each flash
                view(fh%).Print("%d",bw%[k%]);
                if k% < fvNumCSDFlashes%-1 then
                    view(fh%).Print(",");  'comma after all but last value
                endif
            next
        next
        FileClose(fh%);  'Close the VSG image list file
        
        'Now we parse the file we just made, to fill variables...we know what's in it, just easier to fill variables by copying this code
        'Parse image series file, we need to know how many trials, etc.
        ImageFileLoc$ := fvDefaultStimPath$ + fvDefaultStimFile$;
        success% := ParseImageSeriesFile%(ImageFileLoc$,fvNValues%,fvImagesPerTrial%[],fvTrialDurEstimate[],fvImageList$[],fvImageIndices%[][],fvImageDur[],fvImageDelay[],fvImageXPos[],fvImageYPos[]);
        if success% = 1 then
            printlog("Success in reading image series file %s, num trials is %d\n",fvStimFile$,fvNValues%);
        else
            printlog("Failure in reading image series file %s! \n",fvStimFile$);
            halt;  'no point in going on if the file is bad!
        endif;
        'Potentially randomize, use fvImageOrder%[] to hold randomized indices
        GetRepeatedParameterProgression%(fvNValues%, fvNRepeats%, dummyResult[], fvImageOrder%[], 1, 2, 0, fvRandomProgression%);  'We will ignore dummyResult, which holds values between (1) and (2) that are not logspaced (0)
    else
        'Get list of images, either from folder or from file, and create a randomized order (via list of indices),
        'write entire randomized trial-by-trial image list to text file for passing to VSG
        if fvUseFile% = 0 then  'if using folder
            returnToPath$ := FilePath$();  'keep track of current directory
            FilePathSet(fvStimFolder$);  'move to selected folder
            fvFileLen% := FileList(fvImageList$[],-1,"*.bmp");  'return the list of all .bmps and the number in fvFileLen%
            FilePathSet(returnToPath$);  'return current directory to where it was
            'and finally, convert fvImageList$[] to full-path
            for i% := 0 to fvFileLen%-1 do
                fvImageList$[i%] := fvStimFolder$ + fvImageList$[i%];  'fvStimFolder$ will have the trailing slashie
            next
        else 'if using file
            'This file is simply a list of full paths of images, one per line
            fvFileLen% := 0;
            fh% := FileOpen(fvStimFile$,8,0);  'open file for reading only
            if fh% < 0 then
                message("File " + fvStimFile$ + " failed to open!!!  Quitting!");
                halt
            endif;
            while readInputFile% do
                j% := Read(readTemp$);
                if j% = 1 then
                    fvImageList$[fvFileLen%] := readTemp$;  'by expectation, these will have full paths
                    fvFileLen% += 1;
                else
                    readInputFile% := 0;
                endif;
            wend
            FileClose(fh%);
        endif;
        'Now, regardless of source, fvImageList$ contains a full path to a list of images and fvFileLen% contains the number of images
        'Use GRPP to get a list of indices determining presentation order - this is easier than writing new code, even if it does some extra stuff
        fvNValues% := fvFileLen%*fvNRepeats%;
        GetRepeatedParameterProgression%(fvFileLen%, fvNRepeats%, dummyResult[], fvImageOrder%[], 1, 2, 0, fvRandomProgression%);  'We will ignore dummyResult, which holds values between (1) and (2) that are not logspaced (0)
        'Create the file to send to the VSG, use order created in line above
        fh% := FileOpen(ImageFileLoc$,8,1);  'Open a new text file for writing, replace current (default) file
        printlog("result of opening text file is %d\n",fh%);
        for j% := 0 to fvNValues% -1 do
            view(fh%).Print("%s\n",fvImageList$[fvImageOrder%[j%]]);
        next
        FileClose(fh%);  'Close the VSG image list file
        
        'Load each image in turn to get height/width, currently disabled, but should work out of the box, will take about 25 ms per image, so for 1000 images, it's half a minute
        'for j% := 0 to fvFileLen%-1 do
        '    EditImageLoad(fvImageList$[j%]);
        '    EditPaste(1,fvImageWidthPix%[j%],fvImageHeightPix%[j%]);  'This will only work on a bitmap, but I believe that is the only type expected
        'next
        
        
    endcase;
    
    
    ' Open serial port for VSG comms re: stimulus jump-advance
    OpenSerialPortToVSG();
    
	'start sampling
    if UseTwo1401s% = 1 then
        SampleStart(0);  'Set sampling to start immediately
        Yield(0.5);  'Wait half a second
        'Look for handshake, unless disabled
        while pulseFound% < 1 and startSecs > 0 and Dual1401IgnoreHandshake% = 0 do
            pulseFound% := View(DataWindow%).FindPulseUp%(TimingChannel%, 0, tRise, tFall);
            yield(0.1);
            startSecs := startSecs - 0.1;
        wend
        'Send timing pulse
        SafeSampleKey("T");
    else
    	SampleStart(0); 'Start sampling now
    endif;
    
    if startSecs <= 0 then
        message("Handshake not found in 5 seconds!  Quitting!");
        halt
    endif

    
    'Set sequencer variable 5, this value is appropriate for no rivalry
    SampleSeqVar(5, 0);

    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
    

    if fvDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable. Use vdac32% to get the right value.
        voltageInteger% := vdac32%(fvOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
        printlog("Voltage integer is %d\n",voltageInteger%);        
    endif;
    
    if fvSendINTANPulse% =  1 then
        'set sequencer variable 11 to 15, the duration of the initial "FreeViewer" indicator pulse
        SampleSeqVar(11,15);
    endif
    
    

    'Begin building the command line argument
    Opener$ := "cmd /k " + bin$;
    
    ' Get remote args if needed
    if GetUseRemoteStimulus%() = 1 then
        RemoteArg$  := " " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim ";
    endif;
        
    if GetUseRemoteStimulus%() = 1 then
        ProgName$ := "\\remote.exe "; 'set program name for one VSG
    else
        ProgName$ := "\\fixstim.exe "; 'set program name for one VSG
    endif;
        
    
    'Set background color
    BGColor$ := " -b " + fvBackgroundColor$;
    
    'Set distance to screen
    Dist2Screen$ := " -d " + GetDistanceToScreenMM$();
    
    'Set trigger port
    TriggerPort$ := " -p 2 ";  'This one's hard-coded for now
    
    'Turn on verbose
    Verbose$ := " -v ";
    
    'For now, explicitly no fixation.  For no longer.  Optional fixation point has been requested.
    'FixationArg$ := "";  'Blank out fixation point, we won't do this, we just won't put it up if we aren't using it
    'FixationArg$ is automatically filled by #including UsreyFixationPoint.s2s
    'If we are using always looking, or if the animal is fixating the screen, do not show fixation point
    if fvFixScreen% = 1 then      'or fvAlwaysLooking% = 1 then
        FixationArg$ := "";
    endif
    
    'Set image arg - versions prior to adding Image Series had trailing "0,0" hardcoded, now fvImageDuration and
    'fvISI will be set to zeroes at the dialog unless it is an Image Series scenario
    if fvDoCSD% = 0 then
        ImageArg$ := " -i " + ImageFileLoc$ + "," + Str$(fvXPos) + "," + Str$(fvYPos) + "," + Str$(fvImageDuration) + "," + Str$(fvISI);
    else 'different build for CSD
        GetFixationPointParameterValues(fixX, fixY, fixD, fixWR);
        fvCSDXPos := fixX + fvXPos;  
        'if fixX >=0 then
        '    fvCSDXPos := fixX - 8; 'Half width of flashing box is ~7 degrees, set 1 degree interior from fixpt
        'else
        '    fvCSDXPos := fixX + 8; 'Same for other side of screen
        'endif
        ImageArg$ := " -i " + ImageFileLoc$ + "," + Str$(fvCSDXPos) + ",0," + Str$(fvImageDuration) + ",0"; 'yPos and ISI explicitly 0, xPos has to be calculated from location on screen
    endif
    
        
    'Set GammaArg$ - we may turn off the gamma table, particularly for Xiaomo's images
    if fvDisableGamma% = 1 then
        GammaArg$ := " --no-gamma ";  'GammaArg$ is empty otherwise
    endif
    
    
    
    'Build command line, any values that are unnecessary will be empty, so the build should work no matter what type of command line is required
    ' ------ Here is a sample command line ------
    'cmdLine$ := "remote.exe 127.0.0.1 7000 fixstim -v -d 500 -i c:/Users/location/stimulus-images.txt";  'This has no fixation point
    'cmdLine$ := "remote.exe 127.0.0.1 7000 fixstim -v -d 500 -f 0,0,1,red -i c:/Users/location/stimulus-images.txt";  'This has a fixation point
    ' ------ So that looks like this ------
    cmdLine$ := Opener$ + ProgName$ + RemoteArg$ + Verbose$ + FixationArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + ImageArg$ + SerialArg$ + GammaArg$;  'Not sure about the TriggerPort and BGColor but this might work.
    
    
    ' Initial text marks
    ' djs Always version 3. NO difference if maintainmode is used or not. 
    SampleText("FreeViewer,3," + str$(Len(cmdLine$)));
    SampleText(fvCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next

   
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",fvNAdvances%,fvNRepeats%);  

    StimHandle% := ProgRun(cmdLine$, 1);
    if StimHandle% <0 then 
        Message("Could not start stimulus."); 
        halt; 
    endif
    
    
    'If we are asking the eyetracker to record an output file, open the file and start recording
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("I");  'Open the file (this is done by setting a DIGLOW bit), file name will be saved in a sampletext
        yield(0.5);
        SafeSampleKey("W");  'Begin recording the file
        yield(0.5);
    endif
    
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(5);
return 1;
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if fvDoOpto% = 1 then
        SafeSampleKey("o");
    endif;
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
    'If we are sending INTAN pulses, send one last pulse before closing down
    if fvSendINTANPulse% = 1 then
        'set sequencer variable 11 to 10 to indicate the end-of-session pulse
        SampleSeqVar(11,10);
        SafeSampleKey("T");
        SampleText("End of session");
        yield(0.2); 'wait for the 10 ms pulse to be complete before stopping sampling
    endif
    
    ' Tell stim app to shut down.
	SafeSampleKey("Q");
	SampleStop();
    
    
    ProgKill(StimHandle%);
    while ProgStatus(StimHandle%) > 0 do
        Yield();
    wend

    
    
	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	SaveDailyTotals();
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectWavemarkDialog%()
	var iReturn%:=1;
	var i%;
    var whichWaveMark% := 1;
	DlgCreate("Select Wavemark");
	DlgInteger(1, "Input Wavemark to view, -1 for all", -1, 256);  'max is based on highest possible wavemark value
    
	i% := DlgShow(whichWaveMark%);

	if i% = 1 then
		PrintLog("SelectWavemarkDialog - user hit OK\n");
        for i% := 0 to fvNWavemarks%-1 do  'for each wavemark channel
            View(DataWindow%).MarkMask(i%+1,0,0,-1);  'exclude all codes on layer 0
            View(DataWindow%).MarkMask(i%+1,0,1,whichWaveMark%);  'then include requested code (or all, if -1) on layer 0
        next;       
	endif;
	if i% = 0 then
		PrintLog("SelectWavemarkDialog - user hit Cancel\n");
	endif;
    'PrintLog("Return value is %d\n", iReturn%);  'always return 1, so don't bother reporting this
	return iReturn%;
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var ii%;


	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
    Print("Eye coil offset, V (X)     : %f\n", XVoltOffset);
    Print("Eye coil offset, V (Y)     : %f\n", YVoltOffset);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	Print("Background color           : %s\n", fvBackgroundColor$);
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

    Print("Always Looking?                          : %d\n", fvAlwaysLooking%);
    Print("Fixate Screen?                           : %d\n", fvFixScreen%);
    if fvFixScreen% = 0 then
        Print("Fixation X                               : %f\n", FixationX);
        Print("Fixation Y                               : %f\n", FixationY);
    endif
    Print("Fixation Window Radius                   : %f\n", WindowRadius);
	Print("Random Progression?                      : %d\n", fvRandomProgression%);
	Print("Number of repeats                        : %d\n", fvNRepeats%);
    docase
    case fvDoImageSeries% = 1 then
        Print("Image duration                           : %f\n", fvImageDuration);
    case fvDoCSD% = 1 then
        Print("Flash duration                           : %f\n", fvImageDuration);
        Print("Number of flashes per stim               : %d\n", fvNumCSDFlashes%);
        Print("Is white flash first?                    : %d\n", fvCSDWhiteFirst%);
    else
        Print("Number of periods per block              : %d\n", fvNumPeriodsPerBlock%);
        Print("Min number of periods viewed for advance : %d\n", fvMinViewPeriodsForAdvance%);
        Print("Period duration (s)                      : %f\n", fvPeriodDuration);
    endcase
    Print("Probability of reward each period        : %f\n", fvProbRewardEachPeriod);
    if fvDoImageSeries% = 1 then
        Print("Probability of double reward each period        : %f\n", fvProbDoubleRewardEachPeriod);
    endif
    Print("Reward Delay (s)        : %f\n", fvRewardDelaySec);
	Print("Inter-trial interval                     : %f\n", fvITI);
    if fvDoImageSeries% = 1 then
        Print("Inter-stimulus interval                  : %f\n", fvISI);
    endif
    Print("Acquisition time (s)                     : %f\n", fvAcquisitionTime);
    Print("Fixpt hold time (s)                      : %f\n", fvHoldAcquisitionTime);
    Print("Acquisition time out (s)                 : %f\n", fvAcquisitionTO);
    Print("Look away time out (s)                   : %f\n", fvLookAwayTO);
    Print("Screen width (mm)                        : %f\n", fvScreenMMX);
    Print("Screen Height (mm)                       : %f\n", fvScreenMMY);
    Print("Send Pulse to INTAN?                     : %d\n", fvSendINTANPulse%);
    Print("Disable Gamma Table?                     : %d\n", fvDisableGamma%);
     
    
    
    if fvDoOpto% = 1 then
        Print("\nOptogenetics parameters\n");
        Print("-------------------------\n\n");
        if fvLaserDiode% = 1 then
            Print("Laser Diode recorded\n");
        endif;
        Print("Opto Voltage Out: %f\n", fvOptoVoltageOut);       
    endif;    
    
    
    if fvDoImageSeries% = 1 then  'write location of image series file
        Print("Image Series file                   : %s\n", fvStimFile$);
    else
        'Write out image list
        Print("\nImage List\n");
        for ii% := 0 to fvFileLen%-1 do 
            Print("Image %d: %s\n",ii%+1,fvImageList$[ii%]);
        next
    endif;
        
    Print("Command Line:    %s\n", cmdLine$);
    
	' close parfile
	FileClose(0);

end;




func IdleProcessing%()
	var iStatus% := 1;	
    var xval;
    var yval;
    var xind%;
    var yind%;
    var remainInIdleLoop% := 1;  'must initialize to 1 to get INTO idle loop, regardless of Blitz Mode setting
    var tBlitz;  'tNow when entering each state for blitz mode
    var blitzNow%;  'For Blitz Mode, will break blitz by time (tBlitz) or if event found
    var blitzTO%;  'If we don't find our pulses, we gotta quit
    
	tNow := View(DataWindow%).MaxTime();
    tBlitz := tNow;
    
    
    
    
    
    
    while remainInIdleLoop% = 1 and tBlitz+5 > tNow do  'run idle cycles for 5 seconds max if in blitz mode before ceding time to OS, if tBlitz is not updated
        
        if fvBlitzMode% = 0 then
            remainInIdleLoop% := 0;  'only run one idle cycle if not in blitz mode  
        endif    
        
        
        xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
        yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
        
        ' Don't update display every time....
        if tNow-tLastFixPtDisplayUpdate > .005 then
            View(XYWindow%).XYAddData(1,xEye,yEye);
            tLastFixPtDisplayUpdate := tNow;
        endif
        
        
        
        docase 
        case iState% = stateVSGWait% then  'no blitz mode for VSGWait, we haven't "started" yet
            ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
            if stateBegin% = 1 then
                LogStatus("VSGWait", "Begin waiting for Ready Pulse from VSG at " + str$(tNow));
                stateBegin% := 0;
                
            endif
            
            remainInIdleLoop% := 0;  'do not blitz stateVSGWait
            
            pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
            
            if pulseFound% = 1 then
                LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
                Yield(1.0);
                tLastTrigger := tFall;
                fvAdvance% := 0;  'Ensure value is 0 on first run
                'Advance/Jump Stimulus to correct value for first stimulus (using serial version)
                JumpOrAdvance%(fvImageOrder%[nTrialsCompleted%]);
                docase
                    'case fvSendINTANPulse% = 1 then  'pause to start INTAN recording, under the new conception we will not do this
                    '    ChangeStateTo(stateIntanPreRecPause%, tFall);
                case fvFixScreen% = 1 then
                    ChangeStateTo(statePrepareOpto%, tFall);
                else
                    ChangeStateTo(stateFixptUp%, tFall);
                endcase;
                
                if fvSendINTANPulse% = 1 then
                    'set sequencer variable 11 to 20 to indicate 20-ms session-start pulse
                    SampleSeqVar(11,20);
                    SafeSampleKey("T");  'Send a pulse
                endif;
                
                
                Yield(1.0);  'Note, this yield is useful for giving a delay following the INTAN pulse
                if RecordEyeTrackerOutputFile% = 1 then
                    'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                endif;
                
            else
                if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                    LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                    tLastTrigger := tFall;
                endif;
            endif;
            
            'Under the new conception we will not pause to start an INTAN recording
            '    case iState% = stateIntanPreRecPause% then
            '        LogStatus("IntanPreRecPause", "Pausing to start INTAN recording");
            '        message("Start INTAN recording!");
            '        if fvFixScreen% = 1 then
            '            ChangeStateTo(statePrepareOpto%, tFall);
            '        else
            '            ChangeStateTo(stateFixptUp%, tFall);
            '        endif;
            
        case iState% = stateFixptUp% then
            LogStatus("RequestFixpt", "Request fixpt");
            SafeSampleKey("F");
            fvPeriodCount% := 0; 'Also reset period count
            fvGiveLookingTO% := 0;  'Also reset looking TO
            ChangeStateTo(stateWaitForFixptUp%, tNow);
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1) 
            endif 
            
        case iState% = stateWaitForFixptUp% then
            if fvBlitzMode% = 1 then
                tBlitz := tNow;  'reset tBlitz
                blitzNow% := 1;
                while tBlitz+1 > tNow  and blitzNow% = 1 do  'give one second for the trigger before giving up
                    blitzTO% := 1;  'assume failure, if we succeed, fix this
                    if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 0 then
                        ' Fixation point is up
                        LogStatus("WaitForFixPtOn", "Fixpt on at " + str$(tTrigger) + "\n");
                        tLastTrigger := tTrigger;
                        if fvDoOpto% = 0 then
                            ChangeStateTo(stateLogTrialStart%, tTrigger);
                            DrawFix(1);	' this draws the location of the fixpt on the Spike2 window
                        else
                            ChangeStateTo(statePrepareOpto%, tTrigger);
                        endif;
                        blitzNow% := 0;  'end blitz
                        blitzTO% := 0;  'blitz succeeded
                    endif;
                wend
                if blitzTO% = 1 then
                    LogStatus("waitForFixptUp", "Failure during Blitz Mode!");
                    message("Failed to find fixation point trigger in Blitz Mode!  Press OK to quit.");
                    Stop%();  'Call a stop
                    iStatus% := 0;  
                endif;
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else 'not blitz mode, this is the original code
                if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 0 then
                    ' Fixation point is up
                    LogStatus("WaitForFixPtOn", "Fixpt on at " + str$(tTrigger) + "\n");
                    tLastTrigger := tTrigger;
                    if fvDoOpto% = 0 then
                        ChangeStateTo(stateLogTrialStart%, tTrigger);
                        DrawFix(1);	' this draws the location of the fixpt on the Spike2 window
                    else
                        ChangeStateTo(statePrepareOpto%, tTrigger);
                    endif; 
                endif
            endif
            
        case iState% = statePrepareOpto% then
            if fvDoOpto% = 1 then
                fvOptoOrderThisTrial% := round(rand(1,1));  'set this to 1 or 2 (1 = opto first, 2 = opto second)
                if fvOptoOrderThisTrial% = 1 then
                    LogStatus("PrepareOpto", "Opto order for trial " + Str$(nTrialsCompleted%+1) + "is opto first");
                else
                    LogStatus("PrepareOpto", "Opto order for trial " + Str$(nTrialsCompleted%+1) + "is opto second");
                endif;
            else
                LogStatus("PrepareOpto", "No opto in this experiment")
            endif;
            
            fvOptoState% := 0;  'This value will toggle, but we need to start at zero for each trial
            fvPeriodCount% := 0; 'Also reset period count
            ChangeStateTo(stateLogTrialStart%, tNow);
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)  
            endif 
            
            
        case iState% = stateLogTrialStart% then
            'put timing marker in both eyetracker file, smr file
            if RecordEyeTrackerOutputFile% = 1 then
                'SafeSampleKey("1");
                docase
                case HBCycle% = 1 then
                    SafeSampleKey("1");
                case HBCycle% = 2 then
                    SafeSampleKey("2");
                case HBCycle% = 3 then
                    SafeSampleKey("3");
                case HBCycle% = 4 then
                    SafeSampleKey("4");
                case HBCycle% = 5 then
                    SafeSampleKey("5");
                case HBCycle% = 6 then
                    SafeSampleKey("6");
                case HBCycle% = 7 then
                    SafeSampleKey("7");
                endcase
                HBCycle% += 1;  'increment HBCycle%
                if HBCycle% = 8 then  'and cycle when necessary
                    HBCycle% := 1;
                endif
                if fvBlitzMode% = 0 then  'for blitz mode, just let it blitz
                    yield(0.01);  'this will likely be positioned very close to the "T" below, so give a tiny bit of time, 10 ms should be enough
                endif
            endif;
            
            
            if fvSendINTANPulse% = 1 then
                'set sequencer variable 11 to 3 to indicate 3-ms trial-start pulse
                SampleSeqVar(11,3);
                SafeSampleKey("T");  'Send a pulse
                'Not sure how to read the time off of the digmark channel, help is not much help, just going to go with a non-timed Sampletext for now
                Sampletext("Image series " + Str$(nTrialsCompleted%+1) + " start");
            endif
            fvPeriodCount% := 0; 'Also reset period count
            fvGiveLookingTO% := 0;  'Also reset looking TO
            ChangeStateTo(stateWaitForAcquisition%, tNow);
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1) 
            endif 
            
        case iState% = stateWaitForAcquisition% then
            ' Wait for animal to acquire the screen
            ' If experiment is paused, this is where we should wait 
            if Pause% = 0 then
                if stateBegin% = 1 then
                    LogStatus("WaitForAcquisition", "Begin waiting for screen/fixpt acquisition at " + str$(tNow));
                    stateBegin% := 0;
                endif
                
                if fvBlitzMode% = 1 then
                    tBlitz := tNow;  'reset tBlitz
                    blitzNow% := 1;
                    while blitzNow% = 1 do  'This one has a built-in time out in the CASE statement
                        'have to update tNow and xEye/yEye if we are checking eye position in the Blitz
                        tNow := View(DataWindow%).MaxTime();
                        xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
                        yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
                        docase
                        case LookingAtScreenOrFixpt%(xEye,yEye) = 1 then  'here, successful acquisition overrides the acquisition timeout if they happen simultaneously
                            if fvHoldAcquisitionTime > 0 then
                                LogStatus("WaitForAcquisition", "Fixpt Acquired at " + str$(tNow));
                                ChangeStateTo(stateHoldAcquisition%, tNow);
                                remainInIdleLoop% := 0;  'if we are holding acquisition, take opportunity to give system idle time
                            else  'if we don't require holding acquisition, just start the stimulus now rather than waiting through a potential OS time slice
                                SafeSampleKey("S");  'request stimulus
                                'sampletext(fvImageList$[fvImageOrder%[nTrialsCompleted%]], tNow);
                                LogStatus("WaitForAcquisition", "Fixpt Acquired, Request stimulus at " + str$(tNow));
                                if fvDoImageSeries% = 1 or fvDoCSD% = 1 then
                                    ChangeStateTo(stateWaitForImageOn%, tNow);
                                    fvNumPeriods% := fvImagesPerTrial%[fvImageOrder%[nTrialsCompleted%]];
                                else
                                    ChangeStateTo(stateWaitForStimOn%, tNow);
                                endif
                                remainInIdleLoop% := 1;  'go straight to next state in blitz mode if stimulus requested (redundant, is already 1)
                            endif
                            blitzNow% := 0;  'end blitz
                        case tNow - tStateStart > fvAcquisitionTime then
                            LogStatus("WaitForAcquisition", "Acquisition window timed out at " + str$(tNow));
                            if fvFixScreen% = 1 then
                                ChangeStateTo(stateAcquisitionTO%, tNow);
                            else
                                'request fixpt down
                                SafeSampleKey("X");
                                fvFixWaitState% := 0;  'indicate to go to acquisition TO
                                ChangeStateTo(stateWaitForBlank%,tNow);
                            endif
                            remainInIdleLoop% := 0;   'cede time to operating system if animal breaks sequence 
                            blitzNow% := 0;  'end blitz
                        endcase
                    wend 
                else 'not blitz mode, this is the original code
                    docase
                    case LookingAtScreenOrFixpt%(xEye,yEye) = 1 then  'here, successful acquisition overrides the acquisition timeout if they happen simultaneously
                        if fvHoldAcquisitionTime > 0 then
                            LogStatus("WaitForAcquisition", "Fixpt Acquired at " + str$(tNow));
                            ChangeStateTo(stateHoldAcquisition%, tNow);
                        else  'if we don't require holding acquisition, just start the stimulus now rather than waiting through a potential OS time slice
                            SafeSampleKey("S");  'request stimulus
                            'sampletext(fvImageList$[fvImageOrder%[nTrialsCompleted%]], tNow);
                            LogStatus("WaitForAcquisition", "Fixpt Acquired, Request stimulus at " + str$(tNow));
                            if fvDoImageSeries% = 1 or fvDoCSD% = 1 then
                                ChangeStateTo(stateWaitForImageOn%, tNow);
                                fvNumPeriods% := fvImagesPerTrial%[fvImageOrder%[nTrialsCompleted%]];
                            else
                                ChangeStateTo(stateWaitForStimOn%, tNow);
                            endif
                        endif
                    case tNow - tStateStart > fvAcquisitionTime then
                        LogStatus("WaitForAcquisition", "Acquisition window timed out at " + str$(tNow));
                        if fvFixScreen% = 1 then
                            ChangeStateTo(stateAcquisitionTO%, tNow);
                        else
                            'request fixpt down
                            SafeSampleKey("X");
                            fvFixWaitState% := 0;  'indicate to go to acquisition TO
                            ChangeStateTo(stateWaitForBlank%,tNow);
                        endif
                    endcase
                endif;
            else 'if we are paused, reset tStateStart so that when pause comes off there is a full acquisition window
                tStateStart := tNow;
            endif
            
            
        case iState% = stateHoldAcquisition% then
            'Check for fixation break, if broken move out
            
            if fvBlitzMode% = 1 then
                tBlitz := tNow;  'reset tBlitz
                blitzNow% := 1;
                while blitzNow% = 1 do  'no timeout, will succeed on hold time or break fixation
                    'have to update tNow and xEye/yEye if we are checking eye position in the Blitz
                    tNow := View(DataWindow%).MaxTime();
                    xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
                    yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
                    if LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                        SafeSampleKey("X");  'turn off fixation point
                        ChangeStateTo(stateAcquisitionTO%, tNow);
                        blitzNow% := 0;  'end blitz
                    else
                        if tNow - tStateStart > fvHoldAcquisitionTime then
                            SafeSampleKey("S");  'request stimulus
                            LogStatus("HoldAcquisition", "Fixpt Held, Request stimulus at " + str$(tNow));
                            if fvDoImageSeries% = 1 or fvDoCSD% = 1 then
                                ChangeStateTo(stateWaitForImageOn%, tNow);
                                fvNumPeriods% := fvImagesPerTrial%[fvImageOrder%[nTrialsCompleted%]];
                            else
                                ChangeStateTo(stateWaitForStimOn%, tNow);
                            endif
                        endif
                        blitzNow% := 0;  'end blitz
                    endif;
                wend
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else 'not blitz mode, this is the original code
                if LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                    SafeSampleKey("X");  'turn off fixation point
                    ChangeStateTo(stateAcquisitionTO%, tNow);
                else
                    if tNow - tStateStart > fvHoldAcquisitionTime then
                        SafeSampleKey("S");  'request stimulus
                        LogStatus("HoldAcquisition", "Fixpt Held, Request stimulus at " + str$(tNow));
                        if fvDoImageSeries% = 1 or fvDoCSD% = 1 then
                            ChangeStateTo(stateWaitForImageOn%, tNow);
                            fvNumPeriods% := fvImagesPerTrial%[fvImageOrder%[nTrialsCompleted%]];
                        else
                            ChangeStateTo(stateWaitForStimOn%, tNow);
                        endif
                    endif
                endif
            endif
            
                                    
            
            
            
        case iState% = stateWaitForBlank% then
            'This state only happens when the animal breaks fixation
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 0;  'do not use blitz mode  
            endif
            
            if View(DataWindow%).FindFallingEdge%(StimChannel%, tStateStart, tTrigger) = 1 or View(DataWindow%).FindFallingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 1 then
                ' Fixation point is off
                tLastTrigger := tTrigger;
                DrawFix(0);	' actually this draws the location of the fixpt.
                docase
                case fvGiveAcqTO% = 1 then
                    ChangeStateTo(stateTrialCompleted%, tTrigger);  'this will go to stateAcquisitionTO%, but will advance stimulus first, given during fix break in maintain fixation during reward delivery.
                case fvFixWaitState% = 0 then
                    ChangeStateTo(stateAcquisitionTO%, tTrigger);
                case fvFixWaitState% = 1 then
                    if fvMinViewPeriodsForAdvance% = 0 then
                        ChangeStateTo(stateTrialCompleted%, tTrigger);
                    else
                        ChangeStateTo(stateLookAwayTO%, tTrigger);
                    endif;
                case fvFixWaitState% = 2 then
                    ChangeStateTo(stateWaitReward%, tTrigger);                
                endcase
                
            endif    
            
            
        case iState% = stateAcquisitionTO% then
            'If the animal fails to acquire, then administer timeout
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 0;  'do not use blitz mode  
            endif
            
            fvGiveAcqTO% := 0;  'reset
            
            if stateBegin% = 1 then
                LogStatus("AcquisitionTO", "Begin acquisition timeout at " + str$(tNow));
                stateBegin% := 0;
            endif
            
            if tNow - tStateStart > fvAcquisitionTO then
                LogStatus("AcquisitionTO", "End acquisition timeout at " + str$(tNow));
                if fvDoOpto% = 0 and fvFixScreen% = 0 then
                    ChangeStateTo(stateFixptUp%,tNow);
                else
                    ChangeStateTo(stateLogTrialStart%, tNow); 
                endif;
            endif
            
            
        case iState% = stateWaitForStimOn% then
            'Wait for the stimulus to come on
            if stateBegin% = 1 then
                LogStatus("WaitForStimOn", "Waiting for stimulus on at " + str$(tNow));
                stateBegin% := 0;
            endif
            
            if fvBlitzMode% = 1 then
                tBlitz := tNow;  'reset tBlitz
                blitzNow% := 1;
                while tBlitz+1 > tNow  and blitzNow% = 1 do  'if stimulus does not come on in 1 second, quit
                    blitzTO% := 1;  'assume failure, if we succeed, fix this
                    if View(DataWindow%).FindRisingEdge%(StimChannel%, tStateStart, tTrigger) = 0 then
                        ' Stimulus is up
                        LogStatus("WaitForStimOn", "Stimulus started at " + str$(tTrigger));
                        tLastTrigger := tTrigger;
                        sampletext(fvImageList$[fvImageOrder%[nTrialsCompleted%]], tTrigger);
                        ChangeStateTo(stateHoldImage%, tTrigger);
                        'SampleText("Stim On",tTrigger);  'TODO - see if Henry wants this sampletext
                        blitzNow% := 0;  'end blitz
                        blitzTO% := 0;  'blitz succeeded
                    endif
                wend
                if blitzTO% = 1 then
                    LogStatus("waitForStimOn", "Failure during Blitz Mode!");
                    message("Failed to find Stimulus Onset trigger in Blitz Mode!  Press OK to quit.");
                    Stop%();  'Call a stop
                    iStatus% := 0;  
                endif;
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else 'not blitz mode, this is the original code
                if View(DataWindow%).FindRisingEdge%(StimChannel%, tStateStart, tTrigger) = 0 then
                    ' Stimulus is up
                    LogStatus("WaitForStimOn", "Stimulus started at " + str$(tTrigger));
                    tLastTrigger := tTrigger;
                    sampletext(fvImageList$[fvImageOrder%[nTrialsCompleted%]], tTrigger);
                    ChangeStateTo(stateHoldImage%, tTrigger);
                    'SampleText("Stim On",tTrigger);  'TODO - see if Henry wants this sampletext
                endif
            endif
            
            
            
            
        case iState% = stateWaitForImageOn% then
            'Wait for the image to come on, do for each image in image series
            if stateBegin% = 1 then
                LogStatus("WaitForImageOn", "Waiting for image on at " + str$(tNow));
                stateBegin% := 0;
            endif
            
            
            if fvBlitzMode% = 1 then
                tBlitz := tNow;  'reset tBlitz
                blitzNow% := 1;
                while tBlitz+1 > tNow  and blitzNow% = 1 do
                    blitzTO% := 1;  'assume failure, if we succeed, fix this
                    'have to update tNow and xEye/yEye if we are checking eye position in the Blitz
                    tNow := View(DataWindow%).MaxTime();
                    xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
                    yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
                    'Check for fixation break, if broken move out
                    if LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                        fvFixationWasBroken% := 1;
                        ChangeStateTo(stateHoldImage%, tTrigger);
                        blitzNow% := 0;  'end blitz
                        blitzTO% := 0;  'blitz succeeded
                    else 'check for image on
                        if View(DataWindow%).FindRisingEdge%(FrameChannel%, tStateStart, tTrigger) = 0 then
                            ' Image is up
                            LogStatus("WaitForImageOn", "Image started at " + str$(tTrigger));
                            tLastTrigger := tTrigger;
                            fvCurrImageIndex% := fvImageIndices%[fvImageOrder%[nTrialsCompleted%]][fvPeriodCount%];
                            docase
                            case fvDoCSD% = 0 then
                                sampletext(fvImageList$[fvCurrImageIndex%] + "," + Str$(fvImageXPos[fvCurrImageIndex%]) + "," + Str$(fvImageYPos[fvCurrImageIndex%]), tTrigger);
                                'If we want to note the size of the image in the sampletext, uncomment below line(s) - too long for one line
                                'sampletext(fvImageList$[fvCurrImageIndex%] + "," + Str$(fvImageXPos[fvCurrImageIndex%]) + "," + Str$(fvImageYPos[fvCurrImageIndex%]) + "," 
                                '+ Str$(fvImageWidthPix%[fvCurrImageIndex%]) + "," + Str$(fvImageHeightPix%[fvCurrImageIndex%]), tTrigger);
                                ChangeStateTo(stateHoldImage%, tTrigger);
                                blitzNow% := 0;  'end blitz
                                blitzTO% := 0;  'blitz succeeded
                            case fvDoCSD% = 1 and fvPeriodCount% < fvNumPeriods% then
                                sampletext(fvImageList$[fvCurrImageIndex%] + "," + Str$(fvImageXPos[fvCurrImageIndex%]) + "," + Str$(fvImageYPos[fvCurrImageIndex%]), tTrigger);
                                'For CSD, there is no ISI, so there will not be an image offset trigger.  The next trigger
                                'will be an "image change" trigger.  So we need to count triggers and stay here until
                                'we have found enough (when fvPeriodCount% = fvNumPeriods%).
                                fvPeriodCount% += 1;
                                ChangeStateTo(stateWaitForImageOn%, tTrigger);  'change to same state to update tStateStart!
                            else 'i.e., fvDoCSD% = 1 and fvPeriodCount% = fvNumPeriods% 
                                sampletext("Stimulus off", tTrigger);
                                ChangeStateTo(stateHoldImage%, tTrigger);
                                blitzNow% := 0;  'end blitz
                                blitzTO% := 0;  'blitz succeeded
                            endcase
                        endif
                    endif
                wend
                if blitzTO% = 1 then
                    LogStatus("waitForImageOn", "Failure during Blitz Mode!");
                    message("Failed to find Image Onset trigger in Blitz Mode!  Press OK to quit.");
                    Stop%();  'Call a stop
                    iStatus% := 0;  
                endif;
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else 
                'Check for fixation break, if broken move out
                if LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                    fvFixationWasBroken% := 1;
                    ChangeStateTo(stateHoldImage%, tTrigger);
                else 'check for image on
                    if View(DataWindow%).FindRisingEdge%(FrameChannel%, tStateStart, tTrigger) = 0 then
                        ' Image is up
                        LogStatus("WaitForImageOn", "Image started at " + str$(tTrigger));
                        tLastTrigger := tTrigger;
                        fvCurrImageIndex% := fvImageIndices%[fvImageOrder%[nTrialsCompleted%]][fvPeriodCount%];
                        docase
                        case fvDoCSD% = 0 then
                            sampletext(fvImageList$[fvCurrImageIndex%] + "," + Str$(fvImageXPos[fvCurrImageIndex%]) + "," + Str$(fvImageYPos[fvCurrImageIndex%]), tTrigger);
                            'If we want to note the size of the image in the sampletext, uncomment below line(s) - too long for one line
                            'sampletext(fvImageList$[fvCurrImageIndex%] + "," + Str$(fvImageXPos[fvCurrImageIndex%]) + "," + Str$(fvImageYPos[fvCurrImageIndex%]) + "," 
                            '+ Str$(fvImageWidthPix%[fvCurrImageIndex%]) + "," + Str$(fvImageHeightPix%[fvCurrImageIndex%]), tTrigger);
                            ChangeStateTo(stateHoldImage%, tTrigger);
                        case fvDoCSD% = 1 and fvPeriodCount% < fvNumPeriods% then
                            sampletext(fvImageList$[fvCurrImageIndex%] + "," + Str$(fvImageXPos[fvCurrImageIndex%]) + "," + Str$(fvImageYPos[fvCurrImageIndex%]), tTrigger);
                            'For CSD, there is no ISI, so there will not be an image offset trigger.  The next trigger
                            'will be an "image change" trigger.  So we need to count triggers and stay here until
                            'we have found enough (when fvPeriodCount% = fvNumPeriods%).
                            fvPeriodCount% += 1;
                            ChangeStateTo(stateWaitForImageOn%, tTrigger);  'change to same state to update tStateStart!
                        else 'i.e., fvDoCSD% = 1 and fvPeriodCount% = fvNumPeriods% 
                            sampletext("Stimulus off", tTrigger);
                            ChangeStateTo(stateHoldImage%, tTrigger);
                        endcase
                    endif
                endif
            endif
            
            
            
            
            
            
        case iState% = stateHoldImage% then
            'Probably not useful to put a log statement up top here...
            
            'Note that the structure here is somewhat interesting (and will be a pain in the rear if...when...Henry
            'decides to mix it up).  We are breaking each image up into two halves.  Each half is broken into a 
            'number of periods, the same number for each half.  One half will have no opto presentations - during all
            'periods the laser will be off.  The other half will have alternating opto and non-opto periods, with the
            'laser on for one period and off for the next.  There will be a short (however long it takes) inter-period
            'time during which we will randomly determine if the animal is rewarded.  Any reward will be administered
            'during the inter-period time, so that the sequencer is not asked to deliver both laser and reward 
            'simultaneously (greatly easing the process).  After each period, we will return to this state to 
            'determine what to do next (image done, fixation broken, paused, image continues).
            
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 1;  'If we are in blitz mode go to next state immediately no matter what the result (redundant, is already 1)  
            endif
            
            docase
 
            'Only for opto - if fixation was broken, but was held long enough to advance, don't penalize
            case fvPeriodCount% >= fvMinViewPeriodsForAdvance% and (LookingAtScreenOrFixpt%(xEye,yEye) = 0 or fvFixationWasBroken% = 1) and fvDoOpto% > 0 then 'if fixation is held through enough periods to advance, then broken
                ' turn off stimulus, get ready to advance
                if fvMaintainFixation% = 1 then
                    SafeSampleKey("s");  'Take stim down, leave fixpt up
                else
                    SafeSampleKey("X");  'Turn off all
                endif;
                SampleText("+");  'indicates successful trial  TODO - check to see if that's what Henry wants
                LogStatus("HoldImage", "Fixation broken after minimum view time. Turn off and advance stimulus at " + str$(tNow));
                
                fvAdvance% := 1;  'Advance, but not until stimulus is off
                fvFixationWasBroken% := 0;  'Reset, we got this fixation break
                
                ' Now wait until stim is off
                fvGiveLookingTO% := 0; 'TODO - Not sure about setting this to 0, animal might try to look for minimum no-TO time
                ChangeStateTo(stateWaitForStimOff%, tNow);
                
            'If fixation was broken otherwise, penalize
            case LookingAtScreenOrFixpt%(xEye,yEye) = 0 or fvFixationWasBroken% = 1 then
                'If animal breaks fixation, turn off image and penalize, do not advance
                SafeSampleKey("X");  'Turn off all, do not advance
                LogStatus("HoldImage", "Fixation broken, aborting trial at " + str$(tNow));
                SampleText("-");  'indicates failed trial
                
                fvGiveLookingTO% := 1;
                fvAdvance% := 0;
                fvFixationWasBroken% := 0;  'Reset, we got this fixation break
                
                ' Now wait until stim is off
                if fvDoImageSeries% = 1 or fvDoOpto% = 1 then
                    ChangeStateTo(stateWaitForStimOff%, tNow);
                else
                    fvFixWaitState% := 1;
                    ChangeStateTo(stateWaitForBlank%, tNow);  'This is both stim and fixpt
                endif;
                
            'if fixation is held fully through all periods    
            case fvPeriodCount% >= fvNumPeriods% then 
                ' turn off stimulus, get ready to advance
                if fvMaintainFixation% = 1 then
                    SafeSampleKey("s");  'Take stim down, leave fixpt up
                else
                    SafeSampleKey("X");  'Turn off all
                endif;
                SampleText("++");  'indicates fully successful trial
                LogStatus("HoldImage", "Image time complete. Turn off and advance stimulus at " + str$(tNow));
                
                fvAdvance% := 1;  'Advance, but not until stimulus is off
                fvFixationWasBroken% := 0;  'We didn't check to see if there was a fixation break in the last period, but reset just in case there was
                
                'And wait for stim to turn off
                fvGiveLookingTO% := 0;  'no timeout on successful fixation
                ChangeStateTo(stateWaitForStimOff%, tNow);
                
            'if pausing    
            case Pause% = 1 then  'putting PAUSE here.  IMAGE DONE will supercede PAUSE
                'If pause is pressed, turn off image, do not penalize, do not advance
                if fvMaintainFixation% = 1 then
                    SafeSampleKey("s");  'Take stim down, leave fixpt up
                else
                    SafeSampleKey("X");  'Turn off all
                endif;
                LogStatus("HoldImage", "Experiment paused, removing image at " + str$(tNow));
                'SampleText("-");  'indicates failed trial, TODO I don't think we want to call this a failure
                
                ' Now wait until stim is off
                fvGiveLookingTO% := 0;
                fvAdvance% := 0;
                fvFixationWasBroken% := 0;  'Reset, in case there was a break.  Benevolence!
                ChangeStateTo(stateWaitForStimOff%, tNow); 
                
            
                
            case fvDoImageSeries% = 1 or fvDoCSD% = 1 then 
                'If no other cases are met, and this is an image series, go straight to wait for image off
                'Do not go to intervening stateBeginImagePeriod or if there is a long delay between idle
                'cycles we can miss the frame pulse.  Use tLastTrigger as state start time for additional security
                changeStateTo(stateWaitForImageOff%,tLastTrigger);
                
            else
                'If no other cases are met, begin next image period
                ChangeStateTo(stateBeginImagePeriod%, tNow); 
            endcase        
            
            
            
            
            
        case iState% = stateBeginImagePeriod% then
            tNow := View(DataWindow%).MaxTime();  'update tNow so the duration of the period is as precise as possible
            'Determine if we are in the opto half or no-opto half of the image
            docase
            case fvDoOpto% <> 1 then 'we are not doing opto, it is not an opto period
                ChangeStateTo(stateNoOptoPeriod%,tNow);
            case (fvPeriodCount% < fvNumPeriodsPerBlock% and fvOptoOrderThisTrial% = 1) or (fvPeriodCount% >= fvNumPeriodsPerBlock% and fvOptoOrderThisTrial% = 2) then
                'If we are in an opto block
                fvOptoState% := 1-fvOptoState%;  'toggle opto state
                if fvOptoState% = 1 then
                    'toggle opto on
                    SafeSampleKey("O");  'turn on opto
                    tOpt := View(DataWindow%).MaxTime();
                    SampleText("OptoOn",tOpt);
                    ChangeStateTo(stateOptoPeriod%,tNow);
                else 'this time it is not an opto period
                    ChangeStateTo(stateNoOptoPeriod%,tNow);
                endif;
            else 'we are not in an opto block, it is not an opto period
                ChangeStateTo(stateNoOptoPeriod%,tNow);
            endcase;
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)  
            endif
            
            
        case iState% = stateWaitForImageOff% then
            'Wait for the image to turn off, do for each image in image series
            if stateBegin% = 1 then
                LogStatus("WaitForImageOff", "Waiting for image off at " + str$(tNow));
                stateBegin% := 0;
            endif
            
            if fvBlitzMode% = 1 then
                tBlitz := tNow;  'reset tBlitz
                blitzNow% := 1;
                while tBlitz+10 > tNow  and blitzNow% = 1 do  'we don't know how long the image will be in the image series, give 10 seconds
                    blitzTO% := 1;  'assume failure, if we succeed, fix this
                    'have to update tNow and xEye/yEye if we are checking eye position in the Blitz
                    tNow := View(DataWindow%).MaxTime();
                    xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
                    yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
                    'Check for fixation break, note if broken 
                    if LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                        fvFixationWasBroken% := 1;
                    endif;
                    'check for image off
                    if View(DataWindow%).FindRisingEdge%(FrameChannel%, tStateStart, tTrigger) = 0 then
                        ' Image is off
                        LogStatus("WaitForImageOff", "Image ended at " + str$(tTrigger));
                        tLastTrigger := tTrigger;
                        if fvFixationWasBroken% = 1 then  'wait until image is off to continue
                            ChangeStateTo(stateHoldImage%, tNow);
                        else 
                            fvPeriodCount% += 1;  'Increment period count before image comes on, so fvPeriodCount% is current image, only increment on successful hold of fixation               
                            sampletext("+", tTrigger);  'Indicate successful viewing of image
                            if fvPeriodCount% >= fvNumPeriods% then
                                ' turn off stimulus, get ready to advance
                                if fvMaintainFixation% = 1 then
                                    SafeSampleKey("s");  'Take stim down, leave fixpt up
                                else
                                    SafeSampleKey("X");  'Turn off all
                                endif;
                                SampleText("++");  'indicates fully successful trial
                                LogStatus("WaitForImageOff", "Image time complete. Turn off and advance stimulus at " + str$(tNow));
                                
                                fvAdvance% := 1;  'Advance, but not until stimulus is off
                                fvFixationWasBroken% := 0;  'We didn't check to see if there was a fixation break in the last period, but reset just in case there was
                                
                                'And wait for stim to turn off
                                fvGiveLookingTO% := 0;  'no timeout on successful fixation
                                ChangeStateTo(stateWaitForStimOff%, tNow);
                            else
                                ChangeStateTo(stateWaitForImageOn%, tTrigger);
                            endif
                        endif
                        blitzNow% := 0;  'end blitz
                        blitzTO% := 0;  'blitz succeeded
                    endif;
                wend
                if blitzTO% = 1 then
                    LogStatus("waitForImageOff", "Failure during Blitz Mode!");
                    message("Failed to find Image Off trigger in Blitz Mode!  Press OK to quit.");
                    Stop%();  'Call a stop
                    iStatus% := 0;  
                endif;
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else 
                'Check for fixation break, note if broken 
                if LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                    fvFixationWasBroken% := 1;
                endif;
                'check for image off
                if View(DataWindow%).FindRisingEdge%(FrameChannel%, tStateStart, tTrigger) = 0 then
                    ' Image is off
                    LogStatus("WaitForImageOff", "Image ended at " + str$(tTrigger));
                    tLastTrigger := tTrigger;
                    if fvFixationWasBroken% = 1 then  'wait until image is off to continue
                        ChangeStateTo(stateHoldImage%, tNow);
                    else 
                        fvPeriodCount% += 1;  'Increment period count before image comes on, so fvPeriodCount% is current image, only increment on successful hold of fixation               
                        sampletext("+", tTrigger);  'Indicate successful viewing of image
                        if fvPeriodCount% >= fvNumPeriods% then
                            ' turn off stimulus, get ready to advance
                            if fvMaintainFixation% = 1 then
                                SafeSampleKey("s");  'Take stim down, leave fixpt up
                            else
                                SafeSampleKey("X");  'Turn off all
                            endif;
                            SampleText("++");  'indicates fully successful trial
                            LogStatus("WaitForImageOff", "Image time complete. Turn off and advance stimulus at " + str$(tNow));
                            
                            fvAdvance% := 1;  'Advance, but not until stimulus is off
                            fvFixationWasBroken% := 0;  'We didn't check to see if there was a fixation break in the last period, but reset just in case there was
                            
                            'And wait for stim to turn off
                            fvGiveLookingTO% := 0;  'no timeout on successful fixation
                            ChangeStateTo(stateWaitForStimOff%, tNow);
                        else
                            ChangeStateTo(stateWaitForImageOn%, tTrigger);
                        endif
                    endif
                endif
            endif
            
            
            
            
        case iState% = stateNoOptoPeriod% then
            'Wait for period to be over
            
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 0;  'for now, only intended to blitz on image series, won't get here on image series.  If we blitz on opto for some reason...don't blitz here...for now
            endif
            
            docase
            case tNow >= tStateStart + fvPeriodDuration then
                ChangeStateTo(stateRewardPeriod%,tNow);
            case LookingAtScreenOrFixpt%(xEye,yEye) = 0 and fvDoOpto% = 0 then 'end image in standard case
                fvFixationWasBroken% := 1;
                ChangeStateTo(stateHoldImage%,tNow);
            case LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                fvFixationWasBroken% := 1;  'but don't end the period, wait it out
            endcase
            
            
            
        case iState% = stateOptoPeriod% then
            'Wait for period to be over, opto is already on
            
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 0;  'for now, only intended to blitz on image series, won't get here on image series.  If we blitz on opto for some reason...don't blitz here...for now
            endif
            
            docase
            case tNow >= tStateStart + fvPeriodDuration then
                'toggle opto off
                SafeSampleKey("o");  'turn it off
                tOpt := View(DataWindow%).MaxTime();
                SampleText("OptoOff",tOpt);
                ChangeStateTo(stateRewardPeriod%,tNow);
            case LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                fvFixationWasBroken% := 1;  'but don't end the period, wait it out, turn off the opto once we're done
            endcase
            
            
            
        case iState% = stateRewardPeriod% then
            
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)  
            endif
            
            docase
            'if in maintain fixation mode, force fixation through reward delay to receive reward    
            case fvMaintainFixation% = 1 and LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                fvFixWaitState% := 0;  'From reward, do not go to LookAwayTO, because it will shuffle trials, just go to acquisitionTO, and don't give reward!
                fvGiveAcqTO% := 1;
                SafeSampleKey("X");  'Request all down (care about fixpt, nothing else should be up)
                ChangeStateTo(stateWaitForBlank%,tNow);    
            case tNow > fvRewardDelaySec + tStateStart then
                fvPeriodCount% += 1;  'increment number of periods
                'Determine if reward should be given (random, or if all periods finished)
                docase
                case fvSendINTANPulse% = 1 then  'if using the INTAN system, our reward is a bit more complicated
                    'set sequencer variable 11 to 6 to indicate 6-ms trial-success pulse
                    SampleSeqVar(11,6);
                    SafeSampleKey("T");  'Send a pulse
                    rewardRand := Rand();  'Calculate a random value
                    docase
                    case (rewardRand < fvProbDoubleRewardEachPeriod) then  'if dice roll is less than double probability, give double reward
                        JuiceRewardMS% := fvJuiceRewardMSorig%*2;  'set reward to double original value
                        DefaultReward();  'give reward, pReward has been set to 1 above, so once we get in here it's not random
                        TotalRewards% += 1;
                        SampleText("Double Reward",tNow);
                    case (rewardRand < fvProbRewardEachPeriod) then  'if dice roll is more than double probability, but less than overall probability, give regular reward
                        JuiceRewardMS% := fvJuiceRewardMSorig%;  'reset reward to original value
                        DefaultReward();  'give reward, pReward has been set to 1 above, so once we get in here it's not random
                        TotalRewards% += 1;
                        SampleText("Reward",tNow);
                    else 'don't give reward, BUT call it - this won't work unless pReward (from DAQ dialog) is recoded to 1
                        JuiceRewardMS% := 0;  'set reward to zero, this will prevent reward from being given, but the INTAN pulse for trial end will happen
                        DefaultReward();  'do not give reward (duration is 0) but make sure "R" is sent for marking the file at the time the reward would have happened
                        SampleText("No Reward",tNow);
                    endcase
                    
                    tNow := View(DataWindow%).MaxTime();  'update tNow so the reward wait is as precise as possible
                    ChangeStateTo(stateWaitReward%,tNow);  'wait for reward to be done
                case fvDoOpto% = 0 then  'If just doing an image, take down image and reward
                    DefaultReward();
                    tNow := View(DataWindow%).MaxTime();  'update tNow so the reward wait is as precise as possible
                    TotalRewards% += 1;
                    ChangeStateTo(stateWaitReward%,tNow);  'this seems to work fine
                case fvPeriodCount% >= fvNumPeriods% or (Rand() < fvProbRewardEachPeriod) then
                    'Give reward if appropriate
                    DefaultReward();
                    tNow := View(DataWindow%).MaxTime();  'update tNow so the reward wait is as precise as possible
                    TotalRewards% += 1;
                    ChangeStateTo(stateWaitReward%,tNow);  'wait for reward to be done
                else
                    ChangeStateTo(stateHoldImage%,tNow); 'HoldImage will now move forward to next period
                endcase;
            endcase;
            
        case iState% = stateWaitReward% then
            
            if fvBlitzMode% = 1 then
                blitzNow% := 1;
                while blitzNow% = 1 do  'don't need a timeout, this is based on a wait time already
                    'have to update tNow if we are checking time in the Blitz
                    tNow := View(DataWindow%).MaxTime();
                    docase
                    case tNow > tStateStart + (JuiceRewardMS%/1000) then  'for blitz mode, don't wait for reward if not given
                        blitzNow% := 0;  'end blitz
                        docase
                        case fvMaintainFixation% = 1 and fvFixationWasBroken% = 1 then
                            fvFixationWasBroken% := 0;  'reset
                            fvGiveAcqTO% := 1;
                            ChangeStateTo(stateWaitForBlank%,fvBlankTime);  'we have waited through the reward delivery rather than interrupt it, but look for blank trigger at right time
                        case fvDoOpto% = 0 then
                            ChangeStateTo(stateTrialCompleted%,tNow);
                        else
                            ChangeStateTo(stateHoldImage%,tNow); 'HoldImage will now move forward to next period
                        endcase;
                    case fvMaintainFixation% = 1 and LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                        fvFixWaitState% := 0;  'From RewardWait, do not go to LookAwayTO, because it will shuffle trials, just go to acquisitionTO
                        fvFixationWasBroken% := 1;
                        fvBlankTime := tNow;
                        SafeSampleKey("X");  'Request all down (care about fixpt, nothing else should be up)    
                    endcase;
                wend
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else
                docase
                case tNow > tStateStart + fvRewardDurSec then
                    docase
                    case fvMaintainFixation% = 1 and fvFixationWasBroken% = 1 then
                        fvFixationWasBroken% := 0;  'reset
                        ChangeStateTo(stateWaitForBlank%,fvBlankTime);  'we have waited through the reward delivery rather than interrupt it, but look for blank trigger at right time    
                    case fvDoOpto% = 0 then
                        ChangeStateTo(stateTrialCompleted%,tNow);
                    else
                        ChangeStateTo(stateHoldImage%,tNow); 'HoldImage will now move forward to next period
                    endcase;
                case fvMaintainFixation% = 1 and LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                    fvFixWaitState% := 0;  'From RewardWait, do not go to LookAwayTO, because it will shuffle trials, just go to acquisitionTO
                    fvFixationWasBroken% := 1;
                    fvBlankTime := tNow;
                    SafeSampleKey("X");  'Request all down (care about fixpt, nothing else should be up)     
                endcase;
            endif
            
            
            
            
        case iState% = stateWaitForStimOff% then
            'Wait for the stimulus to turn off
            if stateBegin% = 1 then
                LogStatus("WaitForStimOff", "Waiting for stimulus off at " + str$(tNow));
                stateBegin% := 0;
            endif
            
            if fvBlitzMode% = 1 then
                tBlitz := tNow;  'reset tBlitz
                blitzNow% := 1;
                while tBlitz+1 > tNow  and blitzNow% = 1 do
                    'have to update tNow if we are checking time in the Blitz
                    tNow := View(DataWindow%).MaxTime();
                    blitzTO% := 1;  'assume failure, if we succeed, fix this
                    if View(DataWindow%).FindFallingEdge%(StimChannel%, tLastTrigger, tTrigger) = 1 then
                        tLastTrigger := tTrigger;
                        LogStatus("WaitForStimOff", "Stimulus off at " + str$(tLastTrigger));
                        ' Decide what state to go to
                        docase
                        case fvAdvance% = 1 then 'If we advance the stimulus
                            fvAdvance% := 0;  'reset advance variable
                            if fvDoImageSeries% = 1 then  'image series sidestep the "(no)opto period" steps, to give reward we ahve to explicitly go there
                                ChangeStateTo(stateRewardPeriod%, tLastTrigger);
                            else 'if not image series, reward has already been taken care of through "(no)opto period" steps
                                ChangeStateTo(stateTrialCompleted%, tLastTrigger);
                            endif
                        case fvGiveLookingTO% = 0 then  'If we do not advance the stimulus, but do not give a TO penalty, go to ISI
                            ChangeStateTo(stateInterTrialInterval%, tLastTrigger); 
                        else 'otherwise do not advance stimulus, give TO penalty
                            ChangeStateTo(stateLookAwayTO%, tLastTrigger); 
                        endcase
                        blitzNow% := 0;  'end blitz
                        blitzTO% := 0;  'blitz succeeded
                    endif
                wend
                if blitzTO% = 1 then
                    LogStatus("waitForStimOff", "Failure during Blitz Mode!");
                    message("Failed to find Stimulus Offset trigger in Blitz Mode!  Press OK to quit.");
                    Stop%();  'Call a stop
                    iStatus% := 0;  
                endif;
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else 
                if View(DataWindow%).FindFallingEdge%(StimChannel%, tLastTrigger, tTrigger) = 1 then
                    tLastTrigger := tTrigger;
                    LogStatus("WaitForStimOff", "Stimulus off at " + str$(tLastTrigger));
                    ' Decide what state to go to
                    docase
                    case fvAdvance% = 1 then 'If we advance the stimulus
                        fvAdvance% := 0;  'reset advance variable
                        if fvDoImageSeries% = 1 or fvDoCSD% = 1 then  'image series sidestep the "(no)opto period" steps, to give reward we ahve to explicitly go there
                            ChangeStateTo(stateRewardPeriod%, tLastTrigger);
                        else 'if not image series, reward has already been taken care of through "(no)opto period" steps
                            ChangeStateTo(stateTrialCompleted%, tLastTrigger);
                        endif
                    case fvGiveLookingTO% = 0 then  'If we do not advance the stimulus, but do not give a TO penalty, go to ISI
                        ChangeStateTo(stateInterTrialInterval%, tLastTrigger); 
                    else 'otherwise do not advance stimulus, give TO penalty
                        ChangeStateTo(stateLookAwayTO%, tLastTrigger); 
                    endcase
                endif
            endif
            
            
            
            
        case iState% = stateInterTrialInterval% then 
            if stateBegin% = 1 then
                LogStatus("InterTrialInterval", "InterTrialInterval began at " + str$(tNow));
                stateBegin% := 0;
            endif   
            
            if fvBlitzMode% = 1 then
                blitzNow% := 1;
                while blitzNow% = 1 do
                    'have to update tNow if we are checking time in the Blitz
                    tNow := View(DataWindow%).MaxTime();
                    docase
                    case fvMaintainFixation% = 1 and LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                        fvFixWaitState% := 0;  'From ITI, do not go to LookAwayTO, because it will shuffle trials, just go to acquisitionTO
                        SafeSampleKey("X");  'Request all down (care about fixpt, nothing else should be up)
                        ChangeStateTo(stateWaitForBlank%,tNow);
                    case tNow > tStateStart + fvITI then
                        LogStatus("InterTrialInterval", "InterTrialInterval ended at " + str$(tNow));
                        docase
                        case fvFixScreen% = 1 then
                            ChangeStateTo(statePrepareOpto%, tNow);
                        case fvMaintainFixation% = 1 then  'if maintaining, skip fixpt up, cannot get to stateIntertrialInterval if fix is broken
                            ChangeStateTo(stateLogTrialStart%,tNow);
                        else
                            ChangeStateTo(stateFixptUp%,tNow);
                        endcase;
                        blitzNow% := 0;  'end blitz
                    endcase;
                wend
                remainInIdleLoop% := 1;  'go straight to next state in blitz mode (redundant, is already 1)
            else
                docase
                case fvMaintainFixation% = 1 and LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
                    fvFixWaitState% := 0;  'From ITI, do not go to LookAwayTO, because it will shuffle trials, just go to acquisitionTO
                    SafeSampleKey("X");  'Request all down (care about fixpt, nothing else should be up)
                    ChangeStateTo(stateWaitForBlank%,tNow);
                case tNow > tStateStart + fvITI then
                    LogStatus("InterTrialInterval", "InterTrialInterval ended at " + str$(tNow));
                    docase
                    case fvFixScreen% = 1 then
                        ChangeStateTo(statePrepareOpto%, tNow);
                    case fvMaintainFixation% = 1 then  'if maintaining, skip fixpt up, cannot get to stateIntertrialInterval if fix is broken
                        ChangeStateTo(stateLogTrialStart%,tNow);
                    else
                        ChangeStateTo(stateFixptUp%,tNow);
                    endcase;
                endcase
            endif
            
            
            
            
            
        case iState% = stateLookAwayTO% then  
            if stateBegin% = 1 then
                LogStatus("LookAwayTO", "Timeout for looking away began at " + str$(tNow));
                stateBegin% := 0;
            endif   
            
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 0;  'do not blitz on timeouts  
            endif
            
            if tNow > tStateStart + fvLookAwayTO + fvITI then  'this state just encompasses the ITI as well
                LogStatus("LookAwayTO", "Timeout for looking away ended at " + str$(tNow));
                if fvFixScreen% = 1 then
                    ChangeStateTo(statePrepareOpto%, tNow);
                else
                    'if image series, shuffle uncompleted trial back in
                    if fvDoImageSeries% = 1 then
                        printlog("\n\n\nBefore shuffling, nTrialsCompleted is %d and trial order is %d\n",nTrialsCompleted%,fvImageOrder%[0:fvNValues%]);
                        SendTrialToMiddle%(fvNValues%,nTrialsCompleted%,5,fvImageOrder%[]);  'nTrialsCompleted% has not been incremented so is the index of the uncompleted trial, skip at least 5 trials
                        printlog("After shuffling, nTrialsCompleted is %d and trial order is %d\n\n\n\n",nTrialsCompleted%,fvImageOrder%[0:fvNValues%]);
                        'Jump Stimulus to new "current" trial
                        JumpOrAdvance%(fvImageOrder%[nTrialsCompleted%]);
                    endif
                    ChangeStateTo(stateFixptUp%, tNow);
                endif;
            endif   
            
            
        case iState% = stateTrialCompleted% then
            
            'We have to step out of blitz mode SOMEWHERE to let the OS catch up...so, here?
            if fvBlitzMode% = 1 then
                remainInIdleLoop% := 0;  'step out of blitz mode  
            endif
            
            nTrialsCompleted% += 1; 
            printlog("Number of stimuli completed is %d\n",nTrialsCompleted%);
            ToolbarText(str$(nTrialsCompleted%) + "/" + str$(fvNValues%) + " stimuli completed.");
            if nTrialsCompleted% = fvNValues% then
                ' We're all done
                LogStatus("TrialCompleted", "All stimuli complete!");
                Stop%();  'Call a stop
                iStatus% := 0;  
                
            else
                'Advance Stimulus
                'SafeSampleKey("a");
                LogStatus("TrialCompleted", "Advancing stimulus");
                
                'Advance/Jump Stimulus
                JumpOrAdvance%(fvImageOrder%[nTrialsCompleted%]);
                
                docase
                case fvGiveAcqTO% = 1 then 'give acquisition TO (does not shuffle last trial back in)
                    ChangeStateTo(stateAcquisitionTO%, tStateStart);
                case fvGiveLookingTO% = 1 then  'give Looking TO penalty (shuffles last trial back in)
                    ChangeStateTo(stateLookAwayTO%, tStateStart);
                else 'otherwise go to ITI
                    ChangeStateTo(stateInterTrialInterval%, tStateStart);                    
                endcase
            endif
            
            '    case iState% = stateIntanPostRecPause% then
            '        LogStatus("IntanPostRecPause", "Pausing to stop INTAN recording");
            '        message("Stop INTAN recording!");
            '        LogStatus("IntanPostRecPause", "INTAN Recording stopped");
            '        Stop%();
            '        iStatus% := 0; 
            
            
        else
            
            ' Unknown state!
            Message("Unknown state=" + str$(iState%));
            SafeSampleKey("o");  'turn opto off, just in case
            
            'If the eyetracker is recording an output file, stop recording and close the file
            if RecordEyeTrackerOutputFile% = 1 then
                SafeSampleKey("w");  'Stop recording
                yield(0.1);
                SafeSampleKey("i");  'Close the file
                SafeSampleKey("Z");  'zero the DIGLOWs
            endif
            
            halt;
            
        endcase;
        
        tNow := View(DataWindow%).MaxTime();  'update tNow for blitz mode    
    wend        
        
	'tLast := tNow;  'unused
	return iStatus%;
end;






''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func LookingAtScreenOrFixpt%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
    'Here the fixation window is defined as the entire screen, function is adapted from Looking%()
    if fvAlwaysLooking% = 1 then 
        return 1; 
    endif;
    
    if fvFixScreen% = 1 then
        'The center of the screen is [0,0].  fvScreenX(Y)Deg is the distance from the center of the screen to the edge. 
        if Abs(EyePosX) <= fvScreenXDeg and Abs(EyePosY) <= fvScreenYDeg then
            return 1;
        else
            return 0;
        endif;
    else 'regular old fixation point 
        if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then 
            return 1; 
        else 
            return 0; 
        endif
    endif
    
    
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()  'note that this function is only used for Toolbar-based juice delivery
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverReward();
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNumber();
        endif;
    endif;
    return 1;
end;






' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if fvDoOpto% = 1 then
        SafeSampleKey("o");
    endif;
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
	FileClose(-1,-1);
	return 0;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
    stateBegin% := 1;  'Reset for next state - this line is unique (so far) to FreeViewer.s2s and is intended to allow us to do a bit more specific logging
	if tStart > 0 then tStateStart := tStart; endif;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectStimFolder%()
    var stimFolder$;
    var fh%;
    var strWhile% := 1;
    var strInd%;
    var temp$;
    
    'Put up dialog box to allow user to select stimulus folder to use
    fh%:=FileOpen(fvDefaultStimPath$+"*",9,0, "Select any file in the folder you will use");  'select any stimulus
    if fh% > 0 then
        fvStimFolder$ := FileName$(-1);  'this gets the name of the selected FOLDER, with path
        FileClose();  'close the file        
        temp$ := "Use FOLDER: " + fvStimFolder$;
    else
        fvStimFolder$ := "";  'assign empty folder, will have to select again
        temp$ := "No File/Folder Selected";
    endif;
    
    fvUseFile% := 0;  'set to use folder even if we cancel
    DlgValue$(fvdlgTextItem%,temp$);
    
    return 1;  'dialog remains open
end 



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectStimFile%()
    var fh%;
    var temp$;
    
    'Put up dialog box to allow user to select stimulus file to use
    fh%:=FileOpen(fvDefaultStimPath$+"*.txt",8,0, "Select the stimulus file");  'select the file - we're opening it as a text file, but we're just closing it again right now
    if fh% > 0 then
        fvStimFile$ := FileName$(0);  'this gets the name of the selected file, with path
        temp$ := "Use FILE: " + FileName$(-5);  'this chops off the path
        FileClose();  'close the file
        
    else
        fvStimFile$ := "";  'assign empty file, will have to select again
        temp$ := "No File/Folder Selected";
    endif
    fvUseFile% := 1;  'set to use file even if we cancel
    
    DlgValue$(fvdlgTextItem%,temp$);
    
    return 1; 'dialog remains open
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawFix
' 
' Draws Fixation in xy window (iDraw%==1) or blanks it (0). 
proc DrawFix(iDraw%)

	if iDraw% > 0 then
		'var xstim, ystim;
		'xstim := FixationX;
		'ystim := FixationY;

		' Draw stimulus in xy window
        'View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
        view(XYWindow%).XYAddData(iStimChannel%, FixWindowX[], FixWindowY[]);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ParseImageSeriesFile%()
' 
' Parses an image series file, returns success/failure and updates number of trials, the number of images
' per trial, an estimate of the duration of each trial, an index list of images, a list of the indices of
' the images used on each trial, and lists of the duration, the delay, the xpos and the ypos of each image
func ParseImageSeriesFile%(imageFile$,&nTrials%,&nImagesPerTrial%[],&trialDurEstimate[],&ImageList$[],&imageIndices%[][],&ImageDur[],&ImageDelay[],&ImageXPos[],&ImageYPos[])
    var success% := 1;
    var xpos;  
    var ypos;  
    var dur;
    var delay;
    var imageID%[1000];  'allow 1000 images per trial (ha ha)
    var i%;  'trial count
    var fh%;
    var numRead% := 1;
    var imageStr$;
    'fvXPos, fvYPos, fvImageDuration, fvISI are global
    
    'Open text file for reading
    fh% := FileOpen(imageFile$,8,0);
    if fh% < 0 then
        printlog("File open of %s returned error code %d, error is: %s\n",ImageFile$,fh%,Error$(fh%));
        return 0;
    endif;
    
    'Read images section, using default comma separator
    ReadSetup("","","","",",");  'Set string separator to comma
    numRead% := Read(imageStr$,xpos,ypos,dur,delay);  'read image, including dur and delay if present
    while numRead% > 0 do
        'fill imageList$[i%] with image name
        imageList$[i%] := imageStr$;
        'fill imageXPos[i%], imageYPos[i%] with x/y pos
        if numRead% > 1 then
            imageXPos[i%] := xpos;
            imageYPos[i%] := ypos;
        else
            imageXPos[i%] := fvXPos;
            imageYPos[i%] := fvYPos;
        endif
        'fill imageDur[i%] with dur or default
        if numRead% > 3 then  
            imageDur[i%] := dur;  
        else
            imageDur[i%] := fvImageDuration;
        endif
        'fill imageDelay[i%] with dur or default
        if numread% > 4 then
            imageDelay[i%] := delay;
        else
            imageDelay[i%] := fvISI;
        endif
        i% += 1; 'increment index
        numRead% := Read(imageStr$,xpos,ypos,dur,delay);  'read image, including dur and delay if present
    wend
    
    if i% = 0 then
        printlog("No images successfully read from file %s, check file, do not allow blank space at beginning!\n",ImageFile$);
        return 0;
    endif
    
    'printlog("%d images read, dur is %f and delay is %f and xpos is %f and ypos is %f\n",i%,imageDur[0:i%],imageDelay[0:i%],imageXPos[0:i%],imageYPos[0:i%]);
    
    
    'Find "Groups" indicator, don't let loop go infinite if not found
    i% := 0;
    while imageStr$ <> "Groups" and i% < 100 do
        i% += 1;
        Read(imageStr$);
    wend
    
    if i% > 99 then
        printlog("\"Groups\" indicator not found in file %s, check file!\n",ImageFile$);
        return 0;
    endif
    
    
    'Read image series lists until EOF
    nTrials% := 0;  'use for trial count, indexing
    numRead% := Read(imageID%[]);  'read comma-separated string of all image indices
    while numRead% > 0 do
        'Fill nImagesPerTrial%[]
        nImagesPerTrial%[nTrials%] := numRead%;
        'Fill trialDurEstimate[]
        for i% := 0 to numRead%-1 do
            trialDurEstimate[nTrials%] += imageDur[imageID%[i%]];  'Add in image dur
            trialDurEstimate[nTrials%] += imageDelay[imageID%[i%]];  'Add in delay, including final delay which will be subtracted
            imageIndices%[nTrials%][i%] := imageID%[i%];  'Keep a list of image indices
        next
        'Remove final delay added in, final delay doesn't count
        trialDurEstimate[nTrials%] -= imageDelay[imageID%[i%]];
        
        nTrials% += 1;  'increment trial count
        numRead% := Read(imageID%[]);  'read comma-separated string of all image indices
    wend
    
    FileClose();
    if nTrials% = 0 then
        success% := -1;  'return failure
        message("No groups found!  Is there a blank line between 'Groups' and the first group??");
    endif
    return success%;
end

