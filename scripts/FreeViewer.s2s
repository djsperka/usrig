' $Id$

const fvCVSID$ := "$Id$";


'Include Files

#include "../util/ChannelUtilities.s2s"
#include "../util/UsreyUtil.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "UsreyFixationPoint.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' FreeViewer script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Overall script control vars
var Pause% := 0;


' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		
var XChannel%;
var YChannel%;
var iStimChannel%;

var FrameChannel%;
var FrameSlaveChannel%;
var StimChannel%;
var ReadyChannel%;
var ReadySlaveChannel%;
var StimSlaveChannel%;
var DigitalLaserChannel%;
var OptoCopyChannel%;
var SequencerPeriodMS;
var StimulatorChannel%;
var UtilityChannel%;
var TimingChannel%;
var FixationPointChannel%;

' XY window stuff
var XYWindow%;			' 
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iStimWindowChannel%;

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];
var fvBackgroundColor$ := "gray";  'for right now, let's not even allow changing this...

' dummy vars
var iScript%;


var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastFixPtDisplayUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before image is presented)
var tRise, tFall;
var tKludge := 0.06;    ' Add to Fixation time to account for stim sequence. Ugly hack, admittedly, but one does what one must. 
var fvFixationWasBroken% := 0;  'this allows us to monitor fixation through the individual image "periods"
var fvFixWaitState%;

' Constants for states

const stateVSGWait%:=0;		           ' Wait for VSG to send ready signal
const stateWaitForAcquisition%:=1;	   ' Waiting for subject to acquire fixation on screen
const stateAcquisitionTO%:=2;          ' Wait through acquisition timeout
const stateWaitForStimOn%:=3;		   ' Wait for stimulus return trigger (on)
const stateHoldImage%:=4;		       ' Holding fixation on screen while image is up
const stateWaitForStimOff%:=5;		   ' Wait for stimulus return trigger (off)
const stateInterStimulusInterval%:=6;  ' Wait until it is time to present the next stimulus
const stateLookAwayTO%:=7;             ' Wait through timeout for breaking fixation
const stateTrialCompleted%:=8;		   ' trial has been completed successfully
const statePrepareOpto%:=9;            ' Set up opto on a trial-by-trial basis
const stateBeginImagePeriod%:=10;      ' Determine if we will do opto this period, branch
const stateOptoPeriod%:=11;
const stateOptoOff%:=12;
const stateNoOptoPeriod%:=13;
const stateRewardPeriod%:=14;
const stateWaitReward%:=15;
const stateFixptUp%:=16;
const stateWaitForFixptUp%:=17;
const stateWaitForBlank%:=18;


var iState% := stateVSGWait%;	' present state
var stateBegin% := 1;  'For fun, in this script let's keep track of whether it is the first time through a state, for logging purposes

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;	

var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
var pulseFound%;
'var pulseFoundSlave%;
var tOpt;

'variables for reading image files
var fvFileLen%; 
var fvdlgFileSelectButton% := 100;
var fvdlgFolderSelectButton% := 101;
var fvdlgTextItem%;
var fvStimFolder$;
var fvStimFile$;
var fvUseFile%;  '1 if use file, 0 if use folder
var fvDefaultStimPath$ := "D:\\Images\\";  'Set this folder for Henry's computer - how about just F:\Images?
var fvDefaultStimFile$ := "DefaultStimFile.txt";  'this file will be updated 
var fvDialogText$;
var fvImageList$[2000];  'allow up to 2000 unique images
var fvImageOrder%[10000];  'allow up to 10000 images to be presented total
var dummyResult[10000];  'This just lets me run GRPP to get the index order on fvImageOrder%[] instead of writing new code, just allows return of dummy values

' Wavemarks and continuous ports
var fvNWavemarks% := 0;
var fvWavemarkPorts%[64];
var fvNContinuous% := 0;
var fvContinuousPorts%[64];


' Reward variables
var fvProbRewardEachPeriod;
var fvRewardDurSec;
fvRewardDurSec := (GetJuiceRewardMS%()+20)/1000;  'Set reward duration up top.  If we have any reason to think this will change through the experiment, then set it say each idle loop
                                                  'I am paranoid and I'm adding another 20 ms following the reward.


' Optogenetics variables
var fvOptoVoltageOut;
var fvDoOpto%; 
var fvOptoState% := 0;      'might be useful to keep track of opto state?  Possibly not, as the sequencer is going to be doing the heavy lifting
var fvLaserDiode% := 0;     'Are we recording the output of the laser using a photodiode?
var fvOptoOrderThisTrial%;  'Set to 1 for opto first, and 2 for opto second
var fvPeriodCount%;         'How many periods we have completed
var fvLastPeriodStart;      'When did the last period start?

' Dialog box variables
var fvAlwaysLooking% := 1; ' If set eye signals ignored - subject presumed to be looking always. TESTING ONLY.
var fvRandomProgression%;
var fvNRepeats%;
var fvTrialISI;
var fvAcquisitionTime;
var fvAcquisitionTO;
var fvNumPeriods%;
var fvNumPeriodsPerBlock%;
var fvPeriodDuration;
var fvMinViewPeriodsForAdvance%;
var fvLookAwayTO;
var fvScreenMMX;  'we will assume that the 0,0 coordinate of fixation is at the center of the screen, and calculate the screen size from there
var fvScreenMMY;
var fvScreenXDeg;  'Defined as the distance from the center of the screen to the edge, for ease with creating the LookingAtScreenOrFixpt%() function
var fvScreenYDeg;
var fvGiveLookingTO%;
var fvAdvance%;
var fvNValues%;
var fvNAdvances%;
var fvXPos;
var fvYPos;
var fvUseStimLocation%;
var fvFixScreen%;


'Deprecated variables
'var fvRewardMinDelay;  'minimum time allowed between rewards
'var fvRewardMaxDelay;  'maximum time allowed between rewards
'var fvRewardDelay;     'actual time requested between rewards
'var fvOptoMaxNumPulses%;
'var fvOptoMinDelay;
'var fvOptoMaxDelay;
'var fvOptoDur;
'var fvMinTimeForAdvance;
'var fvMaxImageTime;



GetFreeViewerScriptParameters();  'We will just get these right off the bat, this supports the pre-dialog box
                                  'that warns about AlwaysLooking - though this pre-dialog is currently disabled


' Init logging
LogInit(1);

UseTwo1401s% := DoWeUseTwo1401s%();
GetPortsAndNumWMsWFs%(fvNWavemarks%,fvNContinuous%,fvWavemarkPorts%[],fvContinuousPorts%[]);


' Check if always looking flag is set. If so, issue a warning.
' I'm thinking that this is kind of a pain in the butt, we can possibly just put it in the dialog box
' and forget it.  If Henry wants it back as a warning up front, it's an easy uncomment.
'if fvAlwaysLooking% = 1 then
'    if Query("Always looking is SET. Unset?") = 1 then
'        fvAlwaysLooking% := 0;
'    endif
'endif


iScript% := FreeViewerScriptDialog%();


'halt;  'this is just so I can test out the dialog box but not go any farther... TODO - COMMENT THIS OUT, DUH
if iScript% = 1 then
    LogInfo("Proceed with DAQ.");
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 25;
YChannel% := 26;
ReadyChannel% := 40;
FrameChannel% := 41;
StimChannel% := 43;
ReadySlaveChannel% := 44;
'FrameSlaveChannel% := 45;  'replaced by fixation point channel
StimulatorChannel% := 46;
'StimSlaveChannel% := 47;
DigitalLaserChannel% := 48;  'is 32 on Acute tuning, but let's not shove it in the midst of other stuff
OptoCopyChannel% := 49;
UtilityChannel% := 39;
TimingChannel% := 38;
FixationPointChannel% := 45;

ExcludedChans%[0] := 25;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 49;  'OptoCopyChannel% is highest non-electrode channel used by this function  




'If we are not linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the dual-1401 setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401/SLAVE 1401 (the second, non-dominant instance of Spike2) FIRST and on the 
'MICRO 1401/MASTER 1401 (the first,  dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run 
'the VSG program (Fixstim) which gives the sampling trigger and sets the experiment in motion.
if UseTwo1401s% = 0 then
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();
    
    tic := View(DataWindow%).BinSize(ReadyChannel%);
    
    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' FreeViewer script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'From here on out, it's just various necessary functions


' FreeViewerScriptDialog

func FreeViewerScriptDialog%()
	var i%;
	var iReturn%;
    var screenMMPerDegree;
    var pi := 3.141592653589793;  'There is a pre-defined constant "_pi", but only on 8.03 and beyond, explicitly defining pi for back-compatibility
    var fixscreen$[2];
    fixscreen$[0] := "Use Fixation Point";
    fixscreen$[1] := "Use Screen";
    var exptype$[3];
    exptype$[0] := "Standard Image";
    exptype$[1] := "Opto (blocked)";
    exptype$[2] := "No Opto (blocked)";
    
    
    'Since the opto is incorporated into this dialog (for now) we don't have to do a separate parameter grab for opto
    GetFreeViewerScriptParameters();
    
    
    if fvUseFile% = 0 then
        if Len(fvStimFile$) > 0 then
            fvDialogText$ := "Use FILE: " + fvStimFile$;
        else
            fvDialogText$ := "No File/Folder Selected";
        endif
    else
        if Len(fvStimFolder$) > 0 then
            fvDialogText$ := "Use FOLDER: " + fvStimFolder$;
        else
            fvDialogText$ := "No File/Folder Selected";
        endif
    endif
    
        
    DlgCreate("FreeViewer Parameters", 0, 0, 0, 0, -1, 1, 1);  'center dialog relative to screen and not to application window to eliminate cutting off the bottom of the dialog!
    DlgGroup("Stimulus and Fixation", 1, 1, 50, 16);
    DlgInteger(1, "Number of repeats", 1, 1000, 0, 2);
    DlgCheck(2, "Random Progression?", 0, 3);
    DlgList(3, "View/Opto Condition: ", exptype$, 3, 32, 4);
    DlgReal(4, "Period Duration, s", 0.05, 100, 0, 5);
    DlgInteger(5, "Number of periods per block", 1, 1000, 0, 6);
    DlgInteger(6, "Minimum Viewed Periods To Advance", 0, 1000, 0, 7);
    DlgReal(7, "Interstimulus Interval, s", 0.05, 100, 0, 8);
    DlgReal(8, "Fixation Acquisition Time, s", 0.1, 100, 0, 9);
    DlgReal(9, "Acquisition Time Out, s", 0, 100, 0, 10);
    DlgReal(10, "Look Away Time Out, s", 0, 100, 0, 11);
    DlgList(11, "Fixation: ", fixscreen$, 2, 32, 12);
    DlgCheck(12, "Always Looking?", 0, 13);
    DlgCheck(13, "Use Stimulus Location From Config?", 0, 14);
    DlgReal(14, "Image X Position (deg)", -20, 20, 0, 15);
    DlgReal(15, "Image Y Position (deg)", -20, 20, 0, 16);
    
    DlgGroup("Screen", 1, 17, 50, 3);
    DlgReal(16, "Screen Width, mm", 10, 3000, 0, 18);
    DlgReal(17, "Screen Height, mm", 10, 3000, 0, 19);
    
    DlgGroup("Reward", 1, 20, 50, 2);
    DlgReal(18, "Prob of reward each period", 0, 1, 0, 21);
    
    DlgGroup("Optogenetics", 1, 22, 50, 2);
    'DlgCheck(18, "Use Opto", 0, 22);
    DlgReal(19, "Opto Voltage Out (V)", 0.0002, 5, 0, 23); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    
    
    DlgGroup("Images", 1, 24, 50, 3);
    fvdlgTextItem% := DlgText(fvDialogText$, 3, 25, 40);
    DlgButton(fvdlgFolderSelectButton% , "Select Folder", SelectStimFolder%, 3, 26);
    DlgButton(fvdlgFileSelectButton% , "Select File", SelectStimFile%, 23, 26);
   
    'these have been removed from the dialog before ever being used, just a guide
    'DlgReal(4, "Maximum Image Display Time, s", 0.1, 1000, 0, 5);  
    'DlgReal(7, "Minimum View Time For Advance, s", 0.1, 1000, 0, 8);
    'DlgReal(12, "Reward minimum delay, s", 0.05, 1000, 0, 15);
    'DlgReal(13, "Reward maximum delay, s", 0.05, 1000, 0, 16);  
    'DlgInteger(16, "Max number of pulses per image", 1, 1000, 0, 20);
    'DlgReal(17, "Opto pulse duration, s", 0.05, 1000, 0, 21);
    'DlgReal(18, "Opto minimum delay, s", 0.05, 1000, 0, 22);
    'DlgReal(19, "Opto maximum delay, s", 0.05, 1000, 0, 23);    
    
'    DlgButton(tundlgOptogeneticsButton%, "Optogenetics Parameters", TunOptoDialog%, 18, 19);  'for now, keep them in the same dialog   
    
    'Right now we don't seem to need a callback, it's ready directly below if we do 
    DlgAllow(0xffff, 0, FreeViewerScriptDialogChanged%);

    i%:=DlgShow(fvNRepeats%, fvRandomProgression%, fvDoOpto%, fvPeriodDuration, fvNumPeriodsPerBlock%, fvMinViewPeriodsForAdvance%, 
    fvTrialISI, fvAcquisitionTime, fvAcquisitionTO, fvLookAwayTO, fvFixScreen%, fvAlwaysLooking%, fvUseStimLocation%, fvXPos, fvYPos, 
    fvScreenMMX, fvScreenMMY, fvProbRewardEachPeriod, fvOptoVoltageOut);
    
    if i% = 1 then
		SaveFreeViewerScriptParameters();
        'Calculate screen values in degrees here
        screenMMPerDegree := Val(GetDistanceToScreenMM$())*pi/180;  
        fvScreenXDeg := (fvScreenMMX/2)/screenMMPerDegree;  'we are defining fvScreenX(Y)Deg as HALF the screen so it is the distance from fixation to the edge
        fvScreenYDeg := (fvScreenMMY/2)/screenMMPerDegree;
        
        'If we are doing the opto blocking (or pseudo-opto blocking) 
        if fvDoOpto% > 0 then
            fvNumPeriods% := fvNumPeriodsPerBlock%*2;   'two "blocks" per image
        else
            fvNumPeriods% := 1;  'only one period
            if fvMinViewPeriodsForAdvance% > 1 then
                fvMinViewPeriodsForAdvance% := 1;
            endif;
        endif;
        
'        if fvRewardMinDelay > fvRewardMaxDelay then
'            fvRewardMinDelay := fvRewardMaxDelay;
'            message("Reward min delay was greater than max delay!\nBoth values set to max delay!");
'        endif;
        
        'This is now done in the dialog-changed function
        'if fvUseStimLocation% = 1 then
        '    var temp1;
        '    var temp2;
        '    ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"),fvXPos,fvYPos,temp1,temp2);
        'endif
        
        
        iReturn% := 1;  'set return value to success, otherwise we'll just quit.
        
	endif;

	return iReturn%;
end;

func FreeViewerScriptDialogChanged%(item%) 
    var gr$;
    var x, y, w, h;
    
    
    'Grating parameters will be used to set stimulus location
    if DlgValue(13) = 1 then
        gr$ := GetGratingParameters$("Stimulus");
        ParseGratingParametersBrief%(gr$, x, y, w, h);  'w, h are diameters
    endif;
    
    'Enable/disable screen size entries based on using screen/fixation point for fixation
    if DlgValue(13) = 0 then  
        DlgEnable(1,14);
        DlgEnable(1,15);
    else
        DlgEnable(0,14);
        DlgEnable(0,15);
        DlgValue(14,x);
        DlgValue(15,y);
    endif;
    
    'Enable/disable screen size entries based on use of fixpt
    DlgEnable(DlgValue(11),16);
    DlgEnable(DlgValue(11),17);
    
    'Enable/disable opto voltage based on using opto
    if DlgValue(3) = 1 then
        DlgEnable(1,19);
    else
        DlgEnable(0,19);
    endif;
    
    'Change labeling/enable based on using opto-style vs, regular style
    if DlgValue(3) = 0 then
        DlgValue$(1004,"Image Duration, s");
        DlgEnable(0,5);
        DlgValue$(1006,"New Image On Fix Break? (0/1)");
        DlgValue$(1018,"Prob of reward each image");
    else
        DlgValue$(1004,"Period Duration, s");
        DlgEnable(1,5);
        DlgValue$(1006,"Minimum Viewed Periods To Advance");
        DlgValue$(1018,"Prob of reward each period");
    endif;
    
    
    
    return 1;
end



proc GetFreeViewerScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\FreeViewer";
    
	
    fvAlwaysLooking% := GetIntRegistryValue%(key$, "AlwaysLooking", fvAlwaysLooking%);
    fvRandomProgression% := GetIntRegistryValue%(key$, "RandomProgression", fvRandomProgression%);
    fvNRepeats% := GetIntRegistryValue%(key$, "NRepeats", fvNRepeats%);
    fvTrialISI := GetFloatRegistryValue(key$, "TrialISI", fvTrialISI);
    fvAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", fvAcquisitionTime);
    fvAcquisitionTO := GetFloatRegistryValue(key$, "AcquisitionTO", fvAcquisitionTO);
    fvLookAwayTO := GetFloatRegistryValue(key$, "LookAwayTO", fvLookAwayTO);
    fvScreenMMX := GetFloatRegistryValue(key$, "ScreenMMX", fvScreenMMX);
    fvScreenMMY := GetFloatRegistryValue(key$, "ScreenMMY", fvScreenMMY);
    fvUseFile% := GetIntRegistryValue%(key$, "UseFile", fvUseFile%);
    fvStimFolder$ := GetStringRegistryValue$(key$, "StimFolder", fvStimFolder$);
    fvStimFile$ := GetStringRegistryValue$(key$, "StimFile", fvStimFile$);
    fvOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", fvOptoVoltageOut);
    fvDoOpto% := GetIntRegistryValue%(key$, "DoOpto", fvDoOpto%);
    fvNumPeriodsPerBlock% := GetIntRegistryValue%(key$, "NumPeriodsPerBlock", fvNumPeriodsPerBlock%);
    fvMinViewPeriodsForAdvance% := GetIntRegistryValue%(key$, "MinViewPeriodsForAdvance", fvMinViewPeriodsForAdvance%);
    fvPeriodDuration := GetFloatRegistryValue(key$, "PeriodDuration", fvPeriodDuration);
    fvProbRewardEachPeriod := GetFloatRegistryValue(key$, "ProbRewardEachPeriod", fvProbRewardEachPeriod);
    fvUseStimLocation% := GetIntRegistryValue%(key$, "UseStimLocation", fvUseStimLocation%);
    fvXPos := GetFloatRegistryValue(key$, "XPos", fvXPos);
    fvYPos := GetFloatRegistryValue(key$, "YPos", fvYPos);
    fvFixScreen% := GetIntRegistryValue%(key$, "FixScreen", fvFixScreen%);
    
    'from an older conception, not used
    'fvMinTimeForAdvance := GetFloatRegistryValue(key$, "MinTimeForAdvance", fvMinTimeForAdvance);
    'fvMaxImageTime := GetFloatRegistryValue(key$, "MaxImageTime", fvMaxImageTime);
    'fvRewardMinDelay := GetFloatRegistryValue(key$, "RewardMinDelay", fvRewardMinDelay);
    'fvRewardMaxDelay := GetFloatRegistryValue(key$, "RewardMaxDelay", fvRewardMaxDelay);
    'fvOptoMaxNumPulses% := GetIntRegistryValue%(key$, "OptoMaxNumPulses", fvOptoMaxNumPulses%);
    'fvOptoMinDelay := GetFloatRegistryValue(key$, "OptoMinDelay", fvOptoMinDelay);
    'fvOptoMaxDelay := GetFloatRegistryValue(key$, "OptoMaxDelay", fvOptoMaxDelay);
    'fvOptoDur := GetFloatRegistryValue(key$, "OptoDur", fvOptoDur);
    
    
  
end;

proc SaveFreeViewerScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\FreeViewer";
    
    SetIntRegistryValue(key$, "AlwaysLooking", fvAlwaysLooking%);
    SetIntRegistryValue(key$, "RandomProgression", fvRandomProgression%);
    SetIntRegistryValue(key$, "NRepeats", fvNRepeats%);
    SetFloatRegistryValue(key$, "TrialISI", fvTrialISI);
    SetFloatRegistryValue(key$, "AcquisitionTime", fvAcquisitionTime);
    SetFloatRegistryValue(key$, "AcquisitionTO", fvAcquisitionTO);
    SetFloatRegistryValue(key$, "LookAwayTO", fvLookAwayTO);
    SetFloatRegistryValue(key$, "ScreenMMX", fvScreenMMX);
    SetFloatRegistryValue(key$, "ScreenMMY", fvScreenMMY);
    SetIntRegistryValue(key$, "UseFile", fvUseFile%);
    SetStringRegistryValue(key$, "StimFolder", fvStimFolder$);
    SetStringRegistryValue(key$, "StimFile", fvStimFile$);
    SetFloatRegistryValue(key$, "OptoVoltageOut", fvOptoVoltageOut);
    SetIntRegistryValue(key$, "DoOpto", fvDoOpto%);
    SetIntRegistryValue(key$, "NumPeriodsPerBlock", fvNumPeriodsPerBlock%);
    SetIntRegistryValue(key$, "MinViewPeriodsForAdvance", fvMinViewPeriodsForAdvance%);
    SetFloatRegistryValue(key$, "PeriodDuration", fvPeriodDuration);
    SetFloatRegistryValue(key$, "ProbRewardEachPeriod", fvProbRewardEachPeriod);
    SetIntRegistryValue(key$, "UseStimLocation", fvUseStimLocation%);
    SetFloatRegistryValue(key$, "XPos", fvXPos);
    SetFloatRegistryValue(key$, "YPos", fvYPos);
    SetIntRegistryValue(key$, "FixScreen", fvFixScreen%);
    
    'From an older conception, not used
    'SetFloatRegistryValue(key$, "MinTimeForAdvance", fvMinTimeForAdvance);
    'SetFloatRegistryValue(key$, "MaxImageTime", fvMaxImageTime);
    'SetFloatRegistryValue(key$, "RewardMinDelay", fvRewardMinDelay);
    'SetFloatRegistryValue(key$, "RewardMaxDelay", fvRewardMaxDelay);
    'SetIntRegistryValue(key$, "OptoMaxNumPulses", fvOptoMaxNumPulses%);
    'SetFloatRegistryValue(key$, "OptoMinDelay", fvOptoMinDelay);
    'SetFloatRegistryValue(key$, "OptoMaxDelay", fvOptoMaxDelay);
    'SetFloatRegistryValue(key$, "OptoDur", fvOptoDur);
    
end;







''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
    var temp1$;
    var temp2$;
    var od;
    var key$;
    var eof% := 1;
    
    var primaryTxt$;
    var secondaryTxt$;
    
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
    
	SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    
    DoSampleAutoName(key$,"imgs","img",primaryTxt$,secondaryTxt$);
       
    SampleAutoFile(1);  'Enable automatic file naming
    
    ' Text marks make extraction easier
    SampleTextMark(200);  'Channel 30 is textmark channel
    

	'----Event Channel recording definitions----
    
   	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");

	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"Ready");
	SampleTitle$(ReadyChannel%,"Ready");
    
    SampleEvent(FixationPointChannel%, 2, 2, 3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixpt");
	SampleTitle$(FixationPointChannel%,"Fixpt");
	
	SampleEvent(StimChannel%, 3, 2, 3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
    if UseTwo1401s% = 1 then
    
        SampleEvent(FrameSlaveChannel%, 4, 2, 3600);
        SampleComment$(FrameSlaveChannel%,"Frame-Slave");
        SampleTitle$(FrameSlaveChannel%,"Frame-Slave");
    
        SampleEvent(ReadySlaveChannel%, 5, 2, 3600); 'Trigger channel, level
        SampleComment$(ReadySlaveChannel%,"Ready-Slave");
        SampleTitle$(ReadySlaveChannel%,"Ready-Slave");
	
        SampleEvent(StimSlaveChannel%, 7, 2,3600); 'Trigger channel, level
        SampleComment$(StimSlaveChannel%,"Stim-Slave");
        SampleTitle$(StimSlaveChannel%,"Stim-Slave");
        
    endif
    
    
    
    'Add a digital marker channel for pulsing optogenetics
    'Do it for every opto, easy enough to add this into the wraparound calls in the PLS
    'Will record a '1' for laser on and a '0' for laser off
    docase
    case fvDoOpto% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(DigitalLaserChannel%,"Laser On");
    case UseTwo1401s% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Timing");  'Digital marker is by definition channel 32
    endcase
    
    
    '----Analog, non-spiking electrode recording conditions
    'Add a waveform channel for efference copy.  This can come from either the 1401 itself or
    'from the stimulator, it doesn't really matter.
    if fvDoOpto% = 1 and OptoEffCopyPort% > -1 then
        SampleWaveform(OptoCopyChannel%,OptoEffCopyPort%,5000);  'is 30000 Hz on Acute, but here was defined as 5000 Hz, could change...
        SampleTitle$(OptoCopyChannel%,OptoPortLabel$);
    endif;
       
    
    
    'if we are recording the laser output, turn off any electrode channels
    'this will not happen currently, as the laser diode collection has been disabled at the dialog box
    'If we re-implement this, test to see if it actually works as intended!
    docase
    case fvLaserDiode% = 1 and StimEffCopyPort% > -1 then
        SampleWaveform(StimulatorChannel%,StimEffCopyPort%,50000);  
        SampleTitle$(StimulatorChannel%,StimPortLabel$);

        fvNWavemarks% := 0;  'no wavemarks!
        fvNContinuous% := 0;  'no continuous!
        'SampleWaveform(1,0,50000);  'on waveform port 0
        'SampleTitle$(1,"Diode output (laser)");
    case fvLaserDiode% = 1 and StimEffCopyPort% = -1 then
        message("fvLaserDiode is set to 1 but no StimEffCopyPort is set!  Quitting!");
        halt
    endcase;
    
    SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
	SampleTitle$(XChannel%,EyeXPortLabel$);
	SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
	SampleTitle$(YChannel%,EyeYPortLabel$);
    
    if UtilityPort% > -1 then
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);       
        SampleTitle$(UtilityChannel%,UtilityPortLabel$);
    endif;

    
    if UseTwo1401s% = 1 then
        SampleEvent(TimingChannel%, 6, 2, 3600); 'Trigger channel, level
        SampleComment$(TimingChannel%,"Handshake");
        SampleTitle$(TimingChannel%,"Hndshk");
    endif;

    
    
    '----Set up "spiking" Electrode Channels----
    SetUpElectrodeConfiguration(fvNWavemarks%,ExcludedChans%[]);
    
        
	
    
	if UseTwo1401s% = 0 then
        SampleSequencer(script$ + "Tuning.pls");
    else
        SampleSequencer(script$ + "TuningSendTrigger.pls");
    endif;

	DoSampleOptimise();
	SampleMode(1); 'Continuous sampling
    
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeWindows()
    var i%;
    var WindowStep;
    
    ' Make spike2 use all of monitor 1
    View(App()).Window(0, 0, 100, 100, 1);
    
	'Open the data sampling window
    DataWindow% := FileNew(0,4);
    if DataWindow% < 0 then
        PrintLog("FileNew Error: %s\n", Error$(DataWindow%));
    endif

	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
            

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);
	XYSize(1,-1);


	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);


	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
'	XYAddData(4,-9,-7);  'this assumes an 18x14 degree monitor, could literally calculate it, and should
'	XYAddData(4,9,-7);
'	XYAddData(4,9,7);
'	XYAddData(4,-9,7);
    XYAddData(iMonitorChannel%,-fvScreenXDeg,-fvScreenYDeg);  'this calculates it instead
	XYAddData(iMonitorChannel%,fvScreenXDeg,-fvScreenYDeg);
	XYAddData(iMonitorChannel%,fvScreenXDeg,fvScreenYDeg);
	XYAddData(iMonitorChannel%,-fvScreenXDeg,fvScreenYDeg);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
    if UseTwo1401s% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    ToolbarSet(6,"Select Wavemarks",SelectWavemarkDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    fp$ := SetPathToScriptDirectory$();
    
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();    
    
    StartSecondInstanceOfSpike2();
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work
    

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var cmdLine$;
    var Opener$;
    var ProgName$;
    var RemoteArg$:="";     'Extra arg needed if vsg is not on local machine...
    var BGColor$;
    var Dist2Screen$;
    var TriggerPort$;
    var ImageFileLoc$;  'We can just set this outright
    ImageFileLoc$ := fvDefaultStimPath$ + fvDefaultStimFile$;
    var FixationArg$;
    var ImageArg$;
    var Verbose$:=" -v ";  'For now, verbose is always on 
    'vars for opto setup
    var voltageInteger%;
    var stimRemaining;
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;
    var i%;
    var j%;
    var returnToPath$;  'this is where we start, we'll move back here after reading the folder
    var fh%;
    var readInputFile% := 1;
    var readTemp$;
    var startSecs := 5;
    
    'Get list of images, either from folder or from file, and create a randomized order (via list of indices),
    'write entire randomized trial-by-trial image list to text file for passing to VSG
    if fvUseFile% = 0 then  'if using folder
        returnToPath$ := FilePath$();  'keep track of current directory
        FilePathSet(fvStimFolder$);  'move to selected folder
        fvFileLen% := FileList(fvImageList$[],-1,"*.bmp");  'return the list of all .bmps and the number in fvFileLen%
        FilePathSet(returnToPath$);  'return current directory to where it was
        'and finally, convert fvImageList$[] to full-path
        for i% := 0 to fvFileLen%-1 do
            fvImageList$[i%] := fvStimFolder$ + fvImageList$[i%];  'fvStimFolder$ will have the trailing slashie
        next
    else 'if using file
        fvFileLen% := 0;
        fh% := FileOpen(fvStimFile$,8,0);  'open file for reading only
        if fh% < 0 then
            message("File " + fvStimFile$ + " failed to open!!!  Quitting!");
            halt
        endif;
        while readInputFile% do
            j% := Read(readTemp$);
            if j% = 1 then
                fvImageList$[fvFileLen%] := readTemp$;  'by expectation, these will have full paths
                fvFileLen% += 1;
            else
                readInputFile% := 0;
            endif;
        wend
        FileClose(fh%);
    endif;
    'Now, regardless of source, fvImageList$ contains a full path to a list of images and fvFileLen% contains the number of images
    'Use GRPP to get a list of indices determining presentation order - this is easier than writing new code, even if it does some extra stuff
    fvNValues% := fvFileLen%*fvNRepeats%;
    GetRepeatedParameterProgression%(fvFileLen%, fvNRepeats%, dummyResult[], fvImageOrder%[], 1, 2, 0, fvRandomProgression%);  'We will ignore dummyResult, which holds values between (1) and (2) that are not logspaced (0)
    'Create the file to send to the VSG, use order created in line above
    fh% := FileOpen(ImageFileLoc$,8,1);  'Open a new text file for writing, replace current file
    printlog("result of opening text file is %d\n",fh%);
    for j% := 0 to fvNValues% -1 do
        view(fh%).Print("%s\n",fvImageList$[fvImageOrder%[j%]]);
    next
    FileClose(fh%);  'Close the VSG image list file
	
    
	'start sampling
    if UseTwo1401s% = 1 then
        SampleStart(0);  'Set sampling to start immediately
        Yield(0.5);  'Wait half a second
        'Look for handshake, unless disabled
        while pulseFound% < 1 and startSecs > 0 and Dual1401IgnoreHandshake% = 0 do
            pulseFound% := View(DataWindow%).FindPulseUp%(TimingChannel%, 0, tRise, tFall);
            yield(0.1);
            startSecs := startSecs - 0.1;
        wend
        'Send timing pulse
        SafeSampleKey("T");
    else
    	SampleStart(0); 'Start sampling now
    endif;
    
    if startSecs <= 0 then
        message("Handshake not found in 5 seconds!  Quitting!");
        halt
    endif

    
    'Set sequencer variable 5, this value is appropriate for no rivalry
    SampleSeqVar(5, 0);

    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
    

    if fvDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable. Use vdac32% to get the right value.
        voltageInteger% := vdac32%(fvOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
        printlog("Voltage integer is %d\n",voltageInteger%);        
    endif;
    

    'Begin building the command line argument
    Opener$ := "cmd /k " + bin$;
    
    ' Get remote args if needed
    if GetUseRemoteStimulus%() = 1 then
        RemoteArg$  := " " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim ";
    endif;
        
    if GetUseRemoteStimulus%() = 1 then
        ProgName$ := "\\remote.exe "; 'set program name for one VSG
    else
        ProgName$ := "\\fixstim.exe "; 'set program name for one VSG
    endif;
        
    
    'Set background color
    BGColor$ := " -b " + fvBackgroundColor$;
    
    'Set distance to screen
    Dist2Screen$ := " -d " + GetDistanceToScreenMM$();
    
    'Set trigger port
    TriggerPort$ := " -p 2 ";  'This one's hard-coded for now
    
    'Turn on verbose
    Verbose$ := " -v ";
    
    'For now, explicitly no fixation.  For no longer.  Optional fixation point has been requested.
    'FixationArg$ := "";  'Blank out fixation point, we won't do this, we just won't put it up if we aren't using it
    'FixationArg$ is automatically filled by #including UsreyFixationPoint.s2s
    
    ImageArg$ := " -i " + ImageFileLoc$ + "," + Str$(fvXPos) + "," + Str$(fvYPos) + ",0,0";
    

    'Build command line, any values that are unnecessary will be empty, so the build should work no matter what type of command line is required
    ' ------ Here is a sample command line ------
    'cmdLine$ := "remote.exe 127.0.0.1 7000 fixstim -v -d 500 -i c:/Users/location/stimulus-images.txt";  'This has no fixation point
    'cmdLine$ := "remote.exe 127.0.0.1 7000 fixstim -v -d 500 -f 0,0,1,red -i c:/Users/location/stimulus-images.txt";  'This has a fixation point
    ' ------ So that looks like this ------
    cmdLine$ := Opener$ + ProgName$ + RemoteArg$ + Verbose$ + FixationArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + ImageArg$;  'Not sure about the TriggerPort and BGColor but this might work.
    
    
    ' Initial text marks
    ' djs Always version 3. NO difference if maintainmode is used or not. 
    SampleText("FreeViewer,3," + str$(Len(cmdLine$)));
    SampleText(fvCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next

   
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",fvNAdvances%,fvNRepeats%);  

    StimHandle% := ProgRun(cmdLine$, 1);
    if StimHandle% <0 then 
        Message("Could not start stimulus."); 
        halt; 
    endif
    
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(5);
return 1;
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if fvDoOpto% = 1 then
        SafeSampleKey("o");
    endif;
    
    ' Tell stim app to shut down.
	SafeSampleKey("Q");
	SampleStop();
    
    
    ProgKill(StimHandle%);
    while ProgStatus(StimHandle%) > 0 do
        Yield();
    wend

    
    
	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	SaveDailyTotals();
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectWavemarkDialog%()
	var iReturn%:=1;
	var i%;
    var whichWaveMark% := 1;
	DlgCreate("Select Wavemark");
	DlgInteger(1, "Input Wavemark to view, -1 for all", -1, 256);  'max is based on highest possible wavemark value
    
	i% := DlgShow(whichWaveMark%);

	if i% = 1 then
		PrintLog("SelectWavemarkDialog - user hit OK\n");
        for i% := 0 to fvNWavemarks%-1 do  'for each wavemark channel
            View(DataWindow%).MarkMask(i%+1,0,0,-1);  'exclude all codes on layer 0
            View(DataWindow%).MarkMask(i%+1,0,1,whichWaveMark%);  'then include requested code (or all, if -1) on layer 0
        next;       
	endif;
	if i% = 0 then
		PrintLog("SelectWavemarkDialog - user hit Cancel\n");
	endif;
    'PrintLog("Return value is %d\n", iReturn%);  'always return 1, so don't bother reporting this
	return iReturn%;
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var ii%;


	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	Print("Background color           : %s\n", fvBackgroundColor$);
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

    Print("Always Looking?                          : %d\n", fvAlwaysLooking%);
	Print("Random Progression?                      : %d\n", fvRandomProgression%);
	Print("Number of repeats                        : %d\n", fvNRepeats%);
    Print("Number of periods per block              : %d\n", fvNumPeriodsPerBlock%);
    Print("Min number of periods viewed for advance : %d\n", fvMinViewPeriodsForAdvance%);
    Print("Period duration (s)                      : %f\n", fvPeriodDuration);
    Print("Probability of reward each period        : %f\n", fvProbRewardEachPeriod);
	Print("Inter-image interval                     : %f\n", fvTrialISI);
    Print("Acquisition time (s)                     : %f\n", fvAcquisitionTime);
    Print("Acquisition time out (s)                 : %f\n", fvAcquisitionTO);
    Print("Look away time out (s)                   : %f\n", fvLookAwayTO);
    Print("Screen width (mm)                        : %f\n", fvScreenMMX);
    Print("Screen Height (mm)                       : %f\n", fvScreenMMY);
     
    
    
    if fvDoOpto% = 1 then
        Print("\nOptogenetics parameters\n");
        Print("-------------------------\n\n");
        if fvLaserDiode% = 1 then
            Print("Laser Diode recorded\n");
        endif;
        Print("Opto Voltage Out: %f\n", fvOptoVoltageOut);       
    endif;    
    
    
    'Write out image list
    Print("\nImage List\n");
    for ii% := 0 to fvFileLen%-1 do 
        Print("Image %d: %s",ii%+1,fvImageList$[ii%]);
    next
    
    
	' close parfile
	FileClose(0);

end;




func IdleProcessing%()
	var iStatus% := 1;	
    var xval;
    var yval;
    var xind%;
    var yind%;
    
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    'unused
'    if tLast < 0 then
'        tLast := 1;
'        return 1;
'    endif
    
    
	xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
	yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastFixPtDisplayUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastFixPtDisplayUpdate := tNow;
	endif

	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        if stateBegin% = 1 then
            LogStatus("VSGWait", "Begin waiting for Ready Pulse from VSG at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        
        if pulseFound% = 1 then
            LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
            Yield(1.0);
            tLastTrigger := tFall;
            fvAdvance% := 0;  'Ensure value is 0 on first run
            if fvFixScreen% = 0 then
                ChangeStateTo(statePrepareOpto%, tFall);
            else
                ChangeStateTo(stateFixptUp%, tFall);
            endif;
        else
            if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                tLastTrigger := tFall;
            endif;
        endif;
        
    case iState% = stateFixptUp% then
        LogStatus("RequestFixpt", "Request fixpt");
        SafeSampleKey("F");
        fvPeriodCount% := 0; 'Also reset period count
        fvGiveLookingTO% := 0;  'Also reset looking TO
        ChangeStateTo(stateWaitForFixptUp%, tNow);
        
    case iState% = stateWaitForFixptUp% then
        if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 0 then
            ' Fixation point is up
            LogStatus("WaitForFixPtOn", "Fixpt on at " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            if fvDoOpto% = 0 then
                ChangeStateTo(stateWaitForAcquisition%, tTrigger);
                DrawFix(1);	' this draws the location of the fixpt on the Spike2 window
            else
                ChangeStateTo(statePrepareOpto%, tTrigger);
            endif;
            
        endif
        
    case iState% = statePrepareOpto% then
        if fvDoOpto% = 1 then
            fvOptoOrderThisTrial% := round(rand(1,1));  'set this to 1 or 2 (1 = opto first, 2 = opto second)
            if fvOptoOrderThisTrial% = 1 then
                LogStatus("PrepareOpto", "Opto order for trial " + Str$(nTrialsCompleted%+1) + "is opto first");
            else
                LogStatus("PrepareOpto", "Opto order for trial " + Str$(nTrialsCompleted%+1) + "is opto second");
            endif;
        else
            LogStatus("PrepareOpto", "No opto in this experiment")
        endif;
        
        fvOptoState% := 0;  'This value will toggle, but we need to start at zero for each trial
        fvPeriodCount% := 0; 'Also reset period count
        ChangeStateTo(stateWaitForAcquisition%, tNow);

    case iState% = stateWaitForAcquisition% then
        ' Wait for animal to acquire the screen
        ' If experiment is paused, this is where we should wait 
        if Pause% = 0 then
            if stateBegin% = 1 then
                LogStatus("WaitForAcquisition", "Begin waiting for screen/fixpt acquisition at " + str$(tNow));
                stateBegin% := 0;
            endif
            
            docase
            case LookingAtScreenOrFixpt%(xEye,yEye) = 1 then  'here, successful acquisition overrides the acquisition timeout if they happen simultaneously
                SafeSampleKey("S");  'request stimulus
                sampletext(fvImageList$[fvImageOrder%[nTrialsCompleted%]], tNow);
                LogStatus("WaitForAcquisition", "Request stimulus at " + str$(tNow));
                ChangeStateTo(stateWaitForStimOn%, tNow);
            case tNow - tStateStart > fvAcquisitionTime then
                LogStatus("WaitForAcquisition", "Acquisition window timed out at " + str$(tNow));
                if fvFixScreen% = 1 then
                    ChangeStateTo(stateAcquisitionTO%, tNow);
                else
                    'request fixpt down
                    SafeSampleKey("X");
                    fvFixWaitState% := 0;  'indicate to go to acquisition TO
                    ChangeStateTo(stateWaitForBlank%,tNow);
                endif
            endcase
        else 'if we are paused, reset tStateStart so that when pause comes off there is a full acquisition window
            tStateStart := tNow;
        endif
        
        
    case iState% = stateWaitForBlank% then

        if View(DataWindow%).FindFallingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 1 then
            ' Fixation point is off
            tLastTrigger := tTrigger;
            DrawFix(0);	' actually this draws the location of the fixpt.
            docase
            case fvFixWaitState% = 0 then
                ChangeStateTo(stateAcquisitionTO%, tTrigger);
            case fvFixWaitState% = 1 then
                if fvMinViewPeriodsForAdvance% = 0 then
                    ChangeStateTo(stateTrialCompleted%, tTrigger);
                else
                    ChangeStateTo(stateLookAwayTO%, tTrigger);
                endif;
            case fvFixWaitState% = 2 then
                ChangeStateTo(stateWaitReward%, tTrigger);                
            endcase
            
        endif    
        
        
    case iState% = stateAcquisitionTO% then
        'If the animal fails to acquire, then administer timeout
        if stateBegin% = 1 then
            LogStatus("AcquisitionTO", "Begin acquisition timeout at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if tNow - tStateStart > fvAcquisitionTO then
            LogStatus("AcquisitionTO", "End acquisition timeout at " + str$(tNow));
            if fvDoOpto% = 0 then
                ChangeStateTo(stateFixptUp%,tNow);
            else
                ChangeStateTo(stateWaitForAcquisition%, tNow); 
            endif;
        endif
        
        
    case iState% = stateWaitForStimOn% then
        'Wait for the stimulus to come on
        if stateBegin% = 1 then
            LogStatus("WaitForStimOn", "Waiting for stimulus on at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if View(DataWindow%).FindRisingEdge%(StimChannel%, tStateStart, tTrigger) = 0 then
            ' Stimulus is up
            LogStatus("WaitForStimOn", "Stimulus started at " + str$(tTrigger));
            tLastTrigger := tTrigger;
            ChangeStateTo(stateHoldImage%, tTrigger);
            'SampleText("Stim On",tTrigger);  'TODO - see if Henry wants this sampletext
            
        endif
        
        
    case iState% = stateHoldImage% then
        'Probably not useful to put a log statement up top here...
        
        'Note that the structure here is somewhat interesting (and will be a pain in the rear if...when...Henry
        'decides to mix it up).  We are breaking each image up into two halves.  Each half is broken into a 
        'number of periods, the same number for each half.  One half will have no opto presentations - during all
        'periods the laser will be off.  The other half will have alternating opto and non-opto periods, with the
        'laser on for one period and off for the next.  There will be a short (however long it takes) inter-period
        'time during which we will randomly determine if the animal is rewarded.  Any reward will be administered
        'during the inter-period time, so that the sequencer is not asked to deliver both laser and reward 
        'simultaneously (greatly easing the process).  After each period, we will return to this state to 
        'determine what to do next (image done, fixation broken, paused, image continues).
        
        docase
        case fvPeriodCount% >= fvNumPeriods% then 'if fixation is held through all periods
            ' turn off stimulus, get ready to advance
            SafeSampleKey("X");  'Turn off all
            SampleText("++");  'indicates fully successful trial
            LogStatus("HoldImage", "Image time complete. Turn off and advance stimulus at " + str$(tNow));
            
            fvAdvance% := 1;  'Advance, but not until stimulus is off
            fvFixationWasBroken% := 0;  'We didn't check to see if there was a fixation break in the last period, but reset just in case there was
            
            'And wait for stim to turn off
            fvGiveLookingTO% := 0;  'no timeout on successful fixation
            ChangeStateTo(stateWaitForStimOff%, tNow);
            
        case fvPeriodCount% >= fvMinViewPeriodsForAdvance% and (LookingAtScreenOrFixpt%(xEye,yEye) = 0 or fvFixationWasBroken% = 1) and fvDoOpto% > 0 then 'if fixation is held through enough periods to advance, then broken
            ' turn off stimulus, get ready to advance
            SafeSampleKey("X");  'Turn off all
            SampleText("+");  'indicates successful trial  TODO - check to see if that's what Henry wants
            LogStatus("HoldImage", "Fixation broken after minimum view time. Turn off and advance stimulus at " + str$(tNow));
            
            fvAdvance% := 1;  'Advance, but not until stimulus is off
            fvFixationWasBroken% := 0;  'Reset, we got this fixation break
            
            ' Now wait until stim is off
            fvGiveLookingTO% := 0; 'TODO - Not sure about setting this to 0, animal might try to look for minimum no-TO time
            ChangeStateTo(stateWaitForStimOff%, tNow);
            
        case Pause% = 1 then  'putting PAUSE here.  Image done will supercede PAUSE, but magnanimously, PAUSE will supercede fixation break
            'If pause is pressed, turn off image, do not penalize, do not advance
            SafeSampleKey("X");  'Turn off all, do not advance
            LogStatus("HoldImage", "Experiment paused, removing image at " + str$(tNow));
            'SampleText("-");  'indicates failed trial, TODO I don't think we want to call this a failure
            
            ' Now wait until stim is off
            fvGiveLookingTO% := 0;
            fvAdvance% := 0;
            fvFixationWasBroken% := 0;  'Reset, in case there was a break.  Benevolence!
            ChangeStateTo(stateWaitForStimOff%, tNow); 
            
        case LookingAtScreenOrFixpt%(xEye,yEye) = 0 or fvFixationWasBroken% = 1 then
            'If animal breaks fixation, turn off image and penalize, do not advance
            SafeSampleKey("X");  'Turn off all, do not advance
            LogStatus("HoldImage", "Fixation broken, aborting trial at " + str$(tNow));
            SampleText("-");  'indicates failed trial

            fvGiveLookingTO% := 1;
            fvAdvance% := 0;
            fvFixationWasBroken% := 0;  'Reset, we got this fixation break
            
            ' Now wait until stim is off
            if fvDoOpto% = 0 then
                fvFixWaitState% := 1;
                ChangeStateTo(stateWaitForBlank%, tNow);  'This is both stim and fixpt
            else
                ChangeStateTo(stateWaitForStimOff%, tNow); 
            endif;
  
        else
            'If no other cases are met, begin next image period
            ChangeStateTo(stateBeginImagePeriod%, tNow); 
        endcase        
           
    case iState% = stateBeginImagePeriod% then
        tNow := View(DataWindow%).MaxTime();  'update tNow so the duration of the period is as precise as possible
        'Determine if we are in the opto half or no-opto half of the image
        docase
        case fvDoOpto% <> 1 then 'we are not doing opto, it is not an opto period
            ChangeStateTo(stateNoOptoPeriod%,tNow);
        case (fvPeriodCount% < fvNumPeriodsPerBlock% and fvOptoOrderThisTrial% = 1) or (fvPeriodCount% >= fvNumPeriodsPerBlock% and fvOptoOrderThisTrial% = 2) then
            'If we are in an opto block
            fvOptoState% := 1-fvOptoState%;  'toggle opto state
            if fvOptoState% = 1 then
                'toggle opto on
                SafeSampleKey("O");  'turn on opto
                tOpt := View(DataWindow%).MaxTime();
                SampleText("OptoOn",tOpt);
                ChangeStateTo(stateOptoPeriod%,tNow);
            else 'this time it is not an opto period
                ChangeStateTo(stateNoOptoPeriod%,tNow);
            endif;
        else 'we are not in an opto block, it is not an opto period
            ChangeStateTo(stateNoOptoPeriod%,tNow);
        endcase;
        
        
    case iState% = stateNoOptoPeriod% then
        'Wait for period to be over
        docase
        case tNow >= tStateStart + fvPeriodDuration then
            ChangeStateTo(stateRewardPeriod%,tNow);
        case LookingAtScreenOrFixpt%(xEye,yEye) = 0 and fvDoOpto% = 0 then 'end image if this is the only image
            SafeSampleKey("X");  'Request everything down
            fvFixWaitState% := 1;  'will go to hold TO if no advance
            fvGiveLookingTO% := 1;  'will go to hold TO if advance
            ChangeStateTo(stateWaitForBlank%, tNow);
        case LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
            fvFixationWasBroken% := 1;  'but don't end the period, wait it out
        endcase

        
        
    case iState% = stateOptoPeriod% then
        'Wait for period to be over, opto is already on
        docase
        case tNow >= tStateStart + fvPeriodDuration then
            'toggle opto off
            SafeSampleKey("o");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            SampleText("OptoOff",tOpt);
            ChangeStateTo(stateRewardPeriod%,tNow);
        case LookingAtScreenOrFixpt%(xEye,yEye) = 0 then
            fvFixationWasBroken% := 1;  'but don't end the period, wait it out, turn off the opto once we're done
        endcase

        
        
    case iState% = stateRewardPeriod% then
        fvPeriodCount% += 1;  'increment number of periods
        'Determine if reward should be given (random, or if all periods finished)
        docase
        case fvDoOpto% = 0 then  'If just doing an image, take down image and reward
            SafeSampleKey("X");
            DefaultReward();
            tNow := View(DataWindow%).MaxTime();  'update tNow so the reward wait is as precise as possible
            TotalRewards% += 1;
            fvFixWaitState% := 2;
            ChangeStateTo(stateWaitForBlank%,tNow);
        case fvPeriodCount% >= fvNumPeriods% or (Rand() < fvProbRewardEachPeriod) then
            'Give reward if appropriate
            DefaultReward();
            tNow := View(DataWindow%).MaxTime();  'update tNow so the reward wait is as precise as possible
            TotalRewards% += 1;
            ChangeStateTo(stateWaitReward%,tNow);
            'wait for reward to be done
        else
            ChangeStateTo(stateHoldImage%,tNow); 'HoldImage will now move forward to next period
        endcase;
        
        
    case iState% = stateWaitReward% then
        if tNow > tStateStart + fvRewardDurSec then
            if fvDoOpto% = 0 then
                ChangeStateTo(stateTrialCompleted%,tNow);
            else
                ChangeStateTo(stateHoldImage%,tNow); 'HoldImage will now move forward to next period
            endif;
        endif;
        
        
        
        
    case iState% = stateWaitForStimOff% then
        'Wait for the stimulus to turn off
        if stateBegin% = 1 then
            LogStatus("WaitForStimOff", "Waiting for stimulus off at " + str$(tNow));
            stateBegin% := 0;
        endif
        
        if View(DataWindow%).FindFallingEdge%(StimChannel%, tLastTrigger, tTrigger) = 1 then
            tLastTrigger := tTrigger;
            LogStatus("WaitForStimOff", "Stimulus off at " + str$(tLastTrigger));
            ' Decide what state to go to
            docase
            case fvAdvance% = 1 then 'If we advance the stimulus
                fvAdvance% := 0;  'reset advance variable
                ChangeStateTo(stateTrialCompleted%, tLastTrigger);
            case fvGiveLookingTO% = 0 then  'If we do not advance the stimulus, but do not give a TO penalty, go to ISI
                ChangeStateTo(stateInterStimulusInterval%, tLastTrigger); 
            else 'otherwise do not advance stimulus, give TO penalty
                ChangeStateTo(stateLookAwayTO%, tLastTrigger); 
            endcase
        endif
        
        
    case iState% = stateInterStimulusInterval% then 
        if stateBegin% = 1 then
            LogStatus("InterStimulusInterval", "InterStimulusInterval began at " + str$(tNow));
            stateBegin% := 0;
        endif   
        
        if tNow > tStateStart + fvTrialISI then
            LogStatus("InterStimulusInterval", "InterStimulusInterval ended at " + str$(tNow));
            if fvFixScreen% = 0 then
                ChangeStateTo(stateFixptUp%,tNow);
            else
                ChangeStateTo(statePrepareOpto%, tNow);
            endif;
        endif
        
        
    case iState% = stateLookAwayTO% then  
        if stateBegin% = 1 then
           LogStatus("LookAwayTO", "Timeout for looking away began at " + str$(tNow));
           stateBegin% := 0;
        endif   
        
        if tNow > tStateStart + fvLookAwayTO + fvTrialISI then  'this state just encompasses the ISI as well
            LogStatus("LookAwayTO", "Timeout for looking away ended at " + str$(tNow));
            if fvFixScreen% > 0 then
                ChangeStateTo(statePrepareOpto%, tNow);
            else
                ChangeStateTo(stateFixptUp%, tNow);
            endif;
        endif   
        
        
    case iState% = stateTrialCompleted% then
        nTrialsCompleted% += 1; 
        printlog("Number of stimuli completed is %d\n",nTrialsCompleted%);
        ToolbarText(str$(nTrialsCompleted%) + "/" + str$(fvNValues%) + " stimuli completed.");
        if nTrialsCompleted% = fvNValues% then
            ' We're all done
            LogStatus("TrialCompleted", "All stimuli complete!");
            Stop%();
            iStatus% := 0;  
        else
            'Advance Stimulus
            SafeSampleKey("a");
            LogStatus("TrialCompleted", "Advancing stimulus");
            if fvGiveLookingTO% = 0 then  'go to ISI
                ChangeStateTo(stateInterStimulusInterval%, tLastTrigger); 
            else 'otherwise give TO penalty
                ChangeStateTo(stateLookAwayTO%, tLastTrigger); 
            endif
        endif
        

    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        SafeSampleKey("o");  'turn opto off, just in case
        halt;

	endcase;

	'tLast := tNow;  'unused
	return iStatus%;
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'proc DoSampleAutoName(key$,long$,short$,master$,slave$)
'    'This function will do the auto-naming of files.  It will take into account the setup of the system
'    '(if there are one or two 1401s, and whether this is a micro/power or master/slave relationship)
'    'The long$ name should be 8 characters or fewer
'    'The short$ name should be 3 character or fewer
'    
'    if UseTwo1401s% = 0 then
'        SampleAutoName$(dataCellName$ + "_" + long$ + "_000");  'NOTE: maximum of 13 characters!!!
'    else
'        EqualizeSMRFilenumbers(dataPathRoot$ + "\\" + dataDataSet$,dataCellName$+"_" + short$ + master$ + "_",dataCellName$+"_" + short$ + slave$ + "_");
'        SampleAutoName$(dataCellName$ + "_" + short$ + master$ + "_000");  'NOTE: maximum of 13 characters!!!
'        SetStringRegistryValue(key$, "pref", short$);
'    endif;    
'end



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func LookingAtScreenOrFixpt%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
    'Here the fixation window is defined as the entire screen, function is adapted from Looking%()
    if fvAlwaysLooking% = 1 then 
        return 1; 
    endif;
    
    if fvFixScreen% = 1 then
        'The center of the screen is [0,0].  fvScreenX(Y)Deg is the distance from the center of the screen to the edge. 
        if Abs(EyePosX) <= fvScreenXDeg and Abs(EyePosY) <= fvScreenYDeg then
            return 1;
        else
            return 0;
        endif;
    else 'regular old fixation point 
        if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then 
            return 1; 
        else 
            return 0; 
        endif
    endif
    
    
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()  'note that this function is only used for Toolbar-based juice delivery
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverReward();
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNumber();
        endif;
    endif;
    return 1;
end;






' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if fvDoOpto% = 1 then
        SafeSampleKey("o");
    endif;
    
	FileClose(-1,-1);
	return 0;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
    stateBegin% := 1;  'Reset for next state - this line is unique (so far) to FreeViewer.s2s and is intended to allow us to do a bit more specific logging
	if tStart > 0 then tStateStart := tStart; endif;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectStimFolder%()
    var stimFolder$;
    var fh%;
    var strWhile% := 1;
    var strInd%;
    var temp$;
    
    'Put up dialog box to allow user to select stimulus folder to use
    fh%:=FileOpen(fvDefaultStimPath$+"*",9,0, "Select any file in the folder you will use");  'select any stimulus
    if fh% > 0 then
        stimFolder$ := FileName$(fh%);  'this gets the name of the selected FILE, with path
        FileClose();  'close the file
        
        'Loop to find final slash, so we can get just the folder name
        while strWhile% <> 0 do
            strInd% := strWhile%;  'this grabs the index for each '\', after the last one strWhile% will be 0 and will exit out
            strWhile% := InStr(stimFolder$,"\\",strInd%+1);  'search for ''\'
        wend
        'get name of folder containing stimuli to calibrate
        fvStimFolder$ := Left$(stimFolder$,strInd%);
        
        temp$ := "Use FOLDER: " + fvStimFolder$;
    else
        fvStimFolder$ := "";  'assign empty folder, will have to select again
        temp$ := "No File/Folder Selected";
    endif;
    
    fvUseFile% := 0;  'set to use folder even if we cancel
    DlgValue$(fvdlgTextItem%,temp$);
    
    return 1;  'dialog remains open
end 



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SelectStimFile%()
    var fh%;
    var temp$;
    
    'Put up dialog box to allow user to select stimulus file to use
    fh%:=FileOpen(fvDefaultStimPath$+"*.txt",8,0, "Select the stimulus file");  'select the file - we're opening it as a text file, but we're just closing it again right now
    if fh% > 0 then
        fvStimFile$ := FileName$(fh%);  'this gets the name of the selected file, with path
        FileClose();  'close the file
        temp$ := "Use FILE: " + fvStimFile$;
    else
        fvStimFile$ := "";  'assign empty file, will have to select again
        temp$ := "No File/Folder Selected";
    endif
    fvUseFile% := 1;  'set to use file even if we cancel
    
    DlgValue$(fvdlgTextItem%,temp$);
    
    return 1; 'dialog remains open
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawFix
' 
' Draws Fixation in xy window (iDraw%==1) or blanks it (0). 
proc DrawFix(iDraw%)

	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif

end;