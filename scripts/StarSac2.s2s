' $Id$
' Update 11/8/11 Jeff, includes SafeSampleKey and multi-juicer updates

const starCVSID$ := "$Id$";

#include "../util/UsreyUtil.s2s"
#include "../util/MiscUtilities.s2s"
#include "../util/TrialBlockGen.s2s"
#include "../util/ChannelUtilities.s2s"
#include "../util/Directories.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	StarStim script parameters START
'
'	Vars that control the alert msequence script. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
var starAlwaysLooking% := 0;    ' Leave = 0 for normal use, set to 1 for testing only!!!

var starFixationDuration;			' Time required to maintain fixation, seconds
var starFixationDurationMin;		' Time required to maintain fixation, seconds (min of range)
var starFixationDurationMax;		' Time required to maintain fixation, seconds (max of range)
var starAcquisitionTime;			' Time allowed to acquire target before fail trial, seconds
var starInterTrialTime;				' Blank time following a trial (both successful and failed), seconds
var starAnswerTime;					' time to move to answer window, seconds
var starHoldAnswer;                 ' required time to hold answer, seconds
var starNumTargets%;				' number of targets to use
var starUseStimulusXY% := 1;
var starTargetX := 5.0;
var starTargetY := 0.0;
var starNumSmall% := 0;
var starNumPerBlock% := 1;
var starNumBlocks% := 1;
var starMSPerRewardHit% := 25;
var starUseDefaultTargetSize% := 1;
var starTargetDiameter := 1.0;
var starTargetIsGrating%;
var UtilityChannel%;

' keep fixpt on stuff
var starKeepFixptOn% := 1;
var starMinSmallRewardDelta := 0.4;
var starMaxSmallRewardDelta := 0.8;
var starJuicePerSmallReward% := 1;

var starNWavemarks% := 0;
var starNContinuous% := 0;
var starWavemarkPorts%[63];
var starContinuousPorts%[64];
var starXAxis%, starXNumPerSide%, starYAxis%, starYNumPerSide%;
var starXOffset, starYOffset;
var starTargetColor$ := "red";
const MAXTRIALS% := 5000;
var starTargetOrder%[MAXTRIALS%];
const MAXTARGETPOSITIONS% := 100;
var starTargetPositions[MAXTARGETPOSITIONS%][2];
var starNTargetPositions% := 0;
var starNTargetOrder% := 0;
var starTrialCounter% := 0;
var starDoTargetGrid% := 0;
const MAXEYETRACECOLORS% := 12;
var starEyeTraceColors%[MAXEYETRACECOLORS%];    ' These are used to draw colors
var starAnswerWindowRadius := 2;


' Optogenetics variables - since we will only be using wraparound and not pulsed (at least, that's my understanding) much of this might be unnecessary
var starPreStimOptoTime;
var starPostStimOptoTime;
var starMaxOptoTime;
var starOptoVoltageOut;
var starProbOfOpto;
'var starRecOptoBox% := 0;      'record the output from the opto box?
var starDoOpto%;                     ' New, 1 if doing optogenetics
'var starRecStimulator% := 0;   'record the stimulator?
var voltageInteger%;
var starDoOptoThisTrial% ;  'will keep track of trial-by-trial opto
var optoIsOn%;  'Keeps track of if the laser is actually on
var starOptoOffMidStimTime;  'used to turn off the opto laser mid-stimulus, if required by the timing

var smallAreaTextItemNumber%;


'Grating Bar variables
var starGratingBarIsSquarewave%;
var starGratingBarWidth;
var starGratingBarHeight;
var starGratingBarYCenter;
var starGratingBarXCenter;
var starGratingBarSpFreq;
var starGratingBarContrast%;
var starGratingBarPhase;
var starGratingBarColorAtCenter%;  'for this, 0 = white, 1 = black, 2 = use phase value
var starGratingBarTargetWidth;
var starGratingBarTargetHeight;
var starGratingBarTargetContrast;
var starGratingBarTargetIsCircle%;
var starGratingBarTargetIsWidthOfStripe%;


var starGratingBarWidthOfStripe;
var starGratingBarNStripes%;
var starTargetXPosition;
var starBarContrastAtTarget[MAXTARGETPOSITIONS%];
var starGratingBarFirstTargetColor%;


var HBCycle% := 1;



UseTwo1401s% := DoWeUseTwo1401s%();
GetPortsAndNumWMsWFs%(starNWavemarks%,starNContinuous%,starWavemarkPorts%[],starContinuousPorts%[]);


proc GetStarStimScriptParameters()
	var key$;
    key$ := GetRegistryKey$(1) + "\\Scripts\\StarStim";
	starFixationDurationMin := GetFloatRegistryValue(key$, "FixationDurationMin", starFixationDurationMin);
	starFixationDurationMax := GetFloatRegistryValue(key$, "FixationDurationMax", starFixationDurationMax);
	starAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", starAcquisitionTime);
	starInterTrialTime := GetFloatRegistryValue(key$, "InterTrialTime", starInterTrialTime);
    starAnswerTime := GetFloatRegistryValue(key$, "AnswerTime", starAnswerTime);
    starHoldAnswer := GetFloatRegistryValue(key$, "HoldAnswer", starHoldAnswer);
    starNumTargets% := GetIntRegistryValue%(key$, "NumTargets", starNumTargets%);
    starNumBlocks% := GetIntRegistryValue%(key$, "NumBlocks", starNumBlocks%);
    starNumPerBlock% := GetIntRegistryValue%(key$, "NumPerBlock", starNumPerBlock%);
    starUseStimulusXY% := GetIntRegistryValue%(key$, "UseStimulusXY", starUseStimulusXY%);
    starTargetX := GetFloatRegistryValue(key$, "TargetX", starTargetX);
    starTargetY := GetFloatRegistryValue(key$, "TargetY", starTargetY);
    'starTargetRotation := GetFloatRegistryValue(key$, "TargetRotation", starTargetRotation);
    starXAxis% := GetIntRegistryValue%(key$, "XAxis", starXAxis%);
    starXNumPerSide% := GetIntRegistryValue%(key$, "XNumPerSide", starXNumPerSide%);
    starXOffset := GetFloatRegistryValue(key$, "XOffset", starXOffset);
    starYAxis% := GetIntRegistryValue%(key$, "YAxis", starYAxis%);
    starYNumPerSide% := GetIntRegistryValue%(key$, "YNumPerSide", starYNumPerSide%);
    starYOffset := GetFloatRegistryValue(key$, "YOffset", starYOffset);
    starKeepFixptOn% := GetIntRegistryValue%(key$, "KeepFixptOn", starKeepFixptOn%);
    starJuicePerSmallReward% := GetIntRegistryValue%(key$, "JuicePerSmallReward", starJuicePerSmallReward%);
    starMinSmallRewardDelta := GetFloatRegistryValue(key$, "MinSmallRewardDelta", starMinSmallRewardDelta);
    starMaxSmallRewardDelta := GetFloatRegistryValue(key$, "MaxSmallRewardDelta", starMaxSmallRewardDelta);
    starDoOpto% := GetIntRegistryValue%(key$, "DoOpto", starDoOpto%);
    starMSPerRewardHit% := GetIntRegistryValue%(key$, "SmallRewardSize", starMSPerRewardHit%);
    starUseDefaultTargetSize% := GetIntRegistryValue%(key$, "UseDefaultTargetSize", starUseDefaultTargetSize%);
    starTargetDiameter := GetFloatRegistryValue(key$, "TargetDiameter", starTargetDiameter);
    starDoTargetGrid% := GetIntRegistryValue%(key$, "DoTargetGrid", starDoTargetGrid%);
    starTargetIsGrating% := GetIntRegistryValue%(key$, "TargetIsGrating", starTargetIsGrating%);
    starAnswerWindowRadius := GetFloatRegistryValue(key$, "AnswerWindowRadius", starAnswerWindowRadius);
    
end;
 	
proc SaveStarStimScriptParameters()
	var key$;
    key$ := GetRegistryKey$(1) + "\\Scripts\\StarStim";
	SetFloatRegistryValue(key$, "FixationDurationMin", starFixationDurationMin);
	SetFloatRegistryValue(key$, "FixationDurationMax", starFixationDurationMax);
	SetFloatRegistryValue(key$, "AcquisitionTime", starAcquisitionTime);
	SetFloatRegistryValue(key$, "InterTrialTime", starInterTrialTime);
    SetFloatRegistryValue(key$, "AnswerTime", starAnswerTime);
    SetFloatRegistryValue(key$, "HoldAnswer", starHoldAnswer);
    SetIntRegistryValue(key$, "NumTargets", starNumTargets%);
    SetIntRegistryValue(key$, "NumBlocks", starNumBlocks%);
    SetIntRegistryValue(key$, "NumPerBlock", starNumPerBlock%);
    SetIntRegistryValue(key$, "UseStimulusXY", starUseStimulusXY%);
    SetFloatRegistryValue(key$, "TargetX", starTargetX);
    SetFloatRegistryValue(key$, "TargetY", starTargetY);
    'SetFloatRegistryValue(key$, "TargetRotation", starTargetRotation);
    SetIntRegistryValue(key$, "XAxis", starXAxis%);
    SetIntRegistryValue(key$, "XNumPerSide", starXNumPerSide%);
    SetFloatRegistryValue(key$, "XOffset", starXOffset);
    SetIntRegistryValue(key$, "YAxis", starYAxis%);
    SetIntRegistryValue(key$, "YNumPerSide", starYNumPerSide%);
    SetFloatRegistryValue(key$, "YOffset", starYOffset);
    SetIntRegistryValue(key$, "KeepFixptOn", starKeepFixptOn%);
    SetIntRegistryValue(key$, "JuicePerSmallReward", starJuicePerSmallReward%);
    SetFloatRegistryValue(key$, "MinSmallRewardDelta", starMinSmallRewardDelta);
    SetFloatRegistryValue(key$, "MaxSmallRewardDelta", starMaxSmallRewardDelta);
    SetIntRegistryValue(key$, "DoOpto", starDoOpto%);
    SetIntRegistryValue(key$, "SmallRewardSize", starMSPerRewardHit%);
    SetIntRegistryValue(key$, "UseDefaultTargetSize", starUseDefaultTargetSize%);
    SetFloatRegistryValue(key$, "TargetDiameter", starTargetDiameter);
    SetIntRegistryValue(key$, "DoTargetGrid", starDoTargetGrid%);
    SetIntRegistryValue(key$, "TargetIsGrating", starTargetIsGrating%);
    SetFloatRegistryValue(key$, "AnswerWindowRadius", starAnswerWindowRadius);
end;



func StarStimScriptDialog%()
	var i%;
    var gratingAsTargetOpts$[3];
    var sixFloats[6];
    
    gratingAsTargetOpts$[0] := "Use dot for target";
    gratingAsTargetOpts$[1] := "Use grating for target";
    gratingAsTargetOpts$[2] := "Do squarewave bar";
    
    'Get various parameters, in case we don't click on these buttons but still use the function
	GetStarStimScriptParameters();
    GetStarStimOptoParameters();
    GetStarStimGratingBarParameters();
    
    sixFloats[0] := starFixationDurationMin;
    sixFloats[1] := starFixationDurationMax;
    sixFloats[2] := starAcquisitionTime;
    sixFloats[3] := starInterTrialTime;
    sixFloats[4] := starAnswerTime;
    sixFloats[5] := starHoldAnswer;
    
	DlgCreate("StarSac2 Script Parameters");
	DlgReal(1, "Fixation duration min(s):", .01, 10);
	DlgReal(2, "Fixation duration max(s):", .01, 10);
	DlgReal(3, "Acquisition time(s):", .01, 10);
	DlgReal(4, "Intertrial time(s):", .01, 10);
	DlgReal(5, "Answer time(s):", .01, 10);
    DlgReal(6, "Answer hold time(s):", .01, 10);
	DlgInteger(7, "Number of targets:", 1, 99);
    DlgInteger(8, "Number of blocks", 1, 50);
    DlgInteger(9, "Num each targ per block", 1, 10);
    DlgCheck(10, "Use opto?");
    DlgCheck(11, "Use stimulus position?");
    DlgReal(12, "Target X", -20.0, 20.0);
    DlgReal(13, "Target Y", -20.0, 20.0);
    'DlgReal(13, "Rotation(deg)", 0.0, 360.0);
    DlgCheck(14, "Keep fixpt on?");
    DlgReal(15, "Min small reward time", 0, 10);
    DlgReal(16, "Max small reward time", 0, 10);
    DlgInteger(17, "Juice per small reward", 0, 10, 0, 0, 1);
    DlgInteger(18, "Small reward size(ms)", 1, 200);
    DlgCheck(19, "Use fixpt diameter for target");
    DlgReal(20, "Target diameter", 0.1, 100);
    DlgReal(21, "Answer window diameter",0.1,100);
    
    smallAreaTextItemNumber% := DlgText("Text Here",2,22,25);
    'DlgCheck(20, "Use grating for target",2,21);
    DlgList(22,30,gratingAsTargetOpts$[],3,0,23);
    DlgButton(101, "SmallArea", StarStimSmallAreaDialog%,2,24);
    DlgButton(102, "Opto Parameters", StarStimOptoDialog%,20,24);
    DlgButton(103, "Squarewave Bar Parameters", StarStimGratingBarDialog%,2,25);
    DlgAllow(0xffff, 0, StarStimScriptDialogChanged%);
	'i%:=DlgShow(starFixationDurationMin, starFixationDurationMax, starAcquisitionTime, starInterTrialTime, starAnswerTime, starNumTargets%, 
    i%:=DlgShow(sixFloats[], starNumTargets%,
    starNumBlocks%, starNumPerBlock%, starDoOpto%, starUseStimulusXY%, starTargetX, starTargetY,
    starKeepFixptOn%, starMinSmallRewardDelta, starMaxSmallRewardDelta, starJuicePerSmallReward%, starMSPerRewardHit%,
    starUseDefaultTargetSize%, starTargetDiameter, starAnswerWindowRadius, starTargetIsGrating%);
	if i% = 1 then
        
        'extract six floats
        starFixationDurationMin := sixFloats[0]; 
        starFixationDurationMax := sixFloats[1]; 
        starAcquisitionTime := sixFloats[2];
        starInterTrialTime := sixFloats[3];
        starAnswerTime := sixFloats[4];
        starHoldAnswer  := sixFloats[5];
        
        
		SaveStarStimScriptParameters();
        
        
        
        'Adjust starPostStimOptoTime, which must not allow the opto time to go past the max time
        if (starPreStimOptoTime + starPostStimOptoTime + starAnswerTime) > starMaxOptoTime then
            starPostStimOptoTime := starMaxOptoTime - starAnswerTime - starPreStimOptoTime;
        endif;
        
        'Set starOptoOffMidStimTime, which will allow us to cut the opto off mid-trial if required
        if (starMaxOptoTime - starPreStimOptoTime) < starAnswerTime then
            starOptoOffMidStimTime := starMaxOptoTime - starPreStimOptoTime;
        else
            starOptoOffMidStimTime := starAnswerTime + .1;  'this will simply prevent starOptoOffMidStimTime from having any effect if the requested time is true wraparound
        endif;
        
        
        
        'Make sure that the pre-opto time is shorter than the min fixation time (if doing opto)
        '(otherwise the request to turn on the opto might come before the fixation point)
        if starDoOpto% = 1 and starFixationDurationMin <= starPreStimOptoTime then
            message("The minimum fixation duration must be longer than the pre-stim opto time!  Quitting!");
            halt;
        endif;
        
        
        
	endif;
	return i%;
end;

func StarStimScriptDialogChanged%(item%)
    'set small area text string every time
    var textStr$ := "SmallArea: X=";
    if starXAxis% = 1 then
        textStr$ := textStr$ + "on, Y=";
    else
        textStr$ := textStr$ + "off, Y=";
    endif
    if starYAxis% = 1 then
        textStr$ := textStr$ + "on";
    else
        textStr$ := textStr$ + "off";
    endif
    DlgValue$(smallAreaTextItemNumber%,textStr$);
    
    docase
    case item% = 0 then
        DlgEnable(1-DlgValue(11), 12, 13);
        DlgEnable(DlgValue(14), 15, 16, 17, 18);
        DlgEnable(1-DlgValue(22),19);  'disable target diameter = fixation point if target is grating
        DlgEnable(1-DlgValue(22),20);
        DlgEnable(1-DlgValue(19), 20);
    case item% = 11 then
        DlgEnable(1-DlgValue(11), 12, 13);
    case item% = 14 then
        DlgEnable(DlgValue(14), 15, 16, 17, 18);
    case item% = 19 then
        DlgEnable(1-DlgValue(19), 20);
    case item% = 22 then
        DlgEnable(1-DlgValue(22),19);  'disable target diameter = fixation point if target is grating
        DlgEnable(1-DlgValue(22),20);
        if DlgValue(22) <> 1 then
            DlgEnable(1-DlgValue(19), 20);
        endif
    endcase
    return 1;
end


func StarStimSmallAreaDialog%()
	var i%;
	DlgCreate("Small Area Parameters", 25, 10);
    DlgCheck(1, "X-axis");
    DlgInteger(2, "Num per side", 0, 10);
    DlgReal(3, "Degree offset", 0.0, 5.0);
    DlgCheck(4, "Y-axis");
    DlgInteger(5, "Num per side", 0, 10);
    DlgReal(6, "Degree offset", 0.0, 5.0);
    DlgCheck(7, "Use Grid");
    DlgAllow(0xffff, 0, StarStimSmallAreaDialogChanged%);
    DlgShow(starXAxis%, starXNumPerSide%, starXOffset, starYAxis%, starYNumPerSide%, starYOffset, starDoTargetGrid%);
    
    var textStr$ := "SmallArea: X=";
    if starXAxis% = 1 then
        textStr$ := textStr$ + "on, Y=";
    else
        textStr$ := textStr$ + "off, Y=";
    endif
    if starYAxis% = 1 then
        textStr$ := textStr$ + "on";
    else
        textStr$ := textStr$ + "off";
    endif
    DlgValue$(smallAreaTextItemNumber%,textStr$);    
    
    return 1;
end

func StarStimSmallAreaDialogChanged%(item%)
    docase
    case item% = 0 then
        DlgEnable(starXAxis%, 2, 3);
        DlgEnable(starYAxis%, 5, 6);
    case item% = 1 then
        DlgEnable(DlgValue(1), 2, 3);
    case item% = 4 then
        DlgEnable(DlgValue(4), 5, 6);
    endcase
    if DlgValue(7) = 1 then 'If grid is selected, force both X and Y to be on
        DlgEnable(1, 2, 3, 5, 6);  'Enable x/y entries
        DlgValue(1,1);  'Force x checkbox to 1
        DlgValue(4,1);  'Force y checkbox to 1
    endif;
    return 1;
end




proc GetStarStimOptoParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\StarStim\\Opto";
    
    starPreStimOptoTime := GetFloatRegistryValue(key$, "PreStimOptoTime", starPreStimOptoTime);
    starPostStimOptoTime := GetFloatRegistryValue(key$, "PostStimOptoTime", starPostStimOptoTime);
    starOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", starOptoVoltageOut);
    starMaxOptoTime := GetFloatRegistryValue(key$, "MaxOptoTime", starMaxOptoTime);
    starProbOfOpto := GetFloatRegistryValue(key$, "ProbOfOpto", starProbOfOpto);    
    
    
    'starRecOptoBox% := GetIntRegistryValue%(key$, "RecOptoBox", starRecOptoBox%);
    'starRecStimulator% := GetIntRegistryValue%(key$, "RecStimulator", starRecStimulator%);

end;

proc SaveStarStimOptoParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\StarStim\\Opto";
    SetFloatRegistryValue(key$, "PreStimOptoTime", starPreStimOptoTime);
    SetFloatRegistryValue(key$, "PostStimOptoTime", starPostStimOptoTime);
    SetFloatRegistryValue(key$, "OptoVoltageOut", starOptoVoltageOut);
    SetFloatRegistryValue(key$, "MaxOptoTime", starMaxOptoTime);
    SetFloatRegistryValue(key$, "ProbOfOpto", starProbOfOpto); 
    
    'SetIntRegistryValue(key$, "RecOptoBox", starRecOptoBox%);
    'SetIntRegistryValue(key$, "RecStimulator", starRecStimulator%);
end;


func StarStimOptoDialog%()
	var iReturn% := 1;
	var i%;
    var labels$[4];
    var stimdur;
    var tempNPulses%;
    var tempCount%;
    stimdur := dlgvalue(4);  'get stimulus duration value from calling (main) dialog, limit opto period based on this
    
    labels$[0] := "Opto Off First";
    labels$[1] := "Opto On First";
    labels$[2] := "Random First";
    labels$[3] := "Opto On All Blocks";
	GetStarStimOptoParameters();
	DlgCreate("Optogenetics Parameters");
    DlgReal(1, "Opto Voltage Out (V)",0.0002,5,50,1); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    DlgReal(2, "PreStimulus Opto On (s)",0,10,50,2);
    DlgReal(3, "PostStimulus Opto On (s)",0,10,50,3);
    DlgText("If max opto dur is less than post opto on, opto will turn off during stimulus",2,4);
    DlgReal(4, "Maximum Opto Duration (s)",0,10,50,5);
    DlgReal(5, "Probability of Opto on each trial (0-100)",0,100,50,7);

    
    'DlgCheck(6, "Record control box voltage");
    'DlgCheck(7, "Record stimulator");
     
    
    i% := DlgShow(starOptoVoltageOut,starPreStimOptoTime,starPostStimOptoTime,starMaxOptoTime,starProbOfOpto);
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.

    'starMaximalDiam := starAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveStarStimOptoParameters();    
	endif;
    
	return iReturn%;
end;



proc GetStarStimGratingBarParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\StarStim\\GratingBar";
    
    starGratingBarIsSquarewave% := GetIntRegistryValue%(key$, "GratingBarIsSquarewave", starGratingBarIsSquarewave%);
    starGratingBarWidth := GetFloatRegistryValue(key$, "GratingBarWidth", starGratingBarWidth);
    starGratingBarHeight := GetFloatRegistryValue(key$, "GratingBarHeight", starGratingBarHeight);
    starGratingBarXCenter := GetFloatRegistryValue(key$, "GratingBarXCenter", starGratingBarXCenter);
    starGratingBarYCenter := GetFloatRegistryValue(key$, "GratingBarYCenter", starGratingBarYCenter);
    starGratingBarSpFreq := GetFloatRegistryValue(key$, "GratingBarSpFreq", starGratingBarSpFreq);
    starGratingBarContrast% := GetIntRegistryValue%(key$, "GratingBarContrast", starGratingBarContrast%);
    starGratingBarPhase := GetFloatRegistryValue(key$, "GratingBarPhase", starGratingBarPhase);
    starGratingBarColorAtCenter% := GetIntRegistryValue%(key$, "GratingBarColorAtCenter", starGratingBarColorAtCenter%);
    starGratingBarTargetWidth := GetFloatRegistryValue(key$, "GratingBarTargetWidth", starGratingBarTargetWidth);
    starGratingBarTargetHeight := GetFloatRegistryValue(key$, "GratingBarTargetHeight", starGratingBarTargetHeight);
    starGratingBarTargetContrast := GetFloatRegistryValue(key$, "GratingBarTargetContrast", starGratingBarTargetContrast);
    starGratingBarTargetIsCircle% := GetIntRegistryValue%(key$, "GratingBarTargetIsCircle", starGratingBarTargetIsCircle%);
    starGratingBarTargetIsWidthOfStripe% := GetIntRegistryValue%(key$, "GratingBarTargetIsWidthOfStripe", starGratingBarTargetIsWidthOfStripe%);


end;

proc SaveStarStimGratingBarParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\StarStim\\GratingBar";
    
    'TODO - everything
    SetIntRegistryValue(key$, "GratingBarIsSquarewave", starGratingBarIsSquarewave%);
    SetFloatRegistryValue(key$, "GratingBarWidth", starGratingBarWidth);
    SetFloatRegistryValue(key$, "GratingBarHeight", starGratingBarHeight);
    SetFloatRegistryValue(key$, "GratingBarXCenter", starGratingBarXCenter);
    SetFloatRegistryValue(key$, "GratingBarYCenter", starGratingBarYCenter);
    SetFloatRegistryValue(key$, "GratingBarSpFreq", starGratingBarSpFreq);
    SetIntRegistryValue(key$, "GratingBarContrast", starGratingBarContrast%);
    SetFloatRegistryValue(key$, "GratingBarPhase", starGratingBarPhase);
    SetIntRegistryValue(key$, "GratingBarColorAtCenter", starGratingBarColorAtCenter%);
    SetFloatRegistryValue(key$, "GratingBarTargetWidth", starGratingBarTargetWidth);
    SetFloatRegistryValue(key$, "GratingBarTargetHeight", starGratingBarTargetHeight);
    SetFloatRegistryValue(key$, "GratingBarTargetContrast", starGratingBarTargetContrast);
    SetIntRegistryValue(key$, "GratingBarTargetIsCircle", starGratingBarTargetIsCircle%);
    SetIntRegistryValue(key$, "GratingBarTargetIsWidthOfStripe", starGratingBarTargetIsWidthOfStripe%);

end;


func StarStimGratingBarDialog%()

	var iReturn% := 1;
	var i%;
    var colorAtCenterLabel$[3];
    colorAtCenterLabel$[0] := "Center is White";
    colorAtCenterLabel$[1] := "Center is Black";
    colorAtCenterLabel$[2] := "Use Phase (0=Black)";
    
	GetStarStimGratingBarParameters();
    
	DlgCreate("Grating Bar Parameters");
    DlgCheck(1, "Use Squarewave");
    DlgReal(2, "Grating Bar Width (deg)",0.1,50);
    DlgReal(3, "Grating Bar Height (deg)",0.1,50);
    DlgReal(4, "Grating Bar X Center (deg)",-30,30);
    DlgReal(5, "Grating Bar Y Center (deg)",-30,30);
    DlgReal(6, "Grating Bar Spatial Freq (cyc/deg)",.01,100);
    DlgInteger(7, "Grating Bar Contrast (0-100)",0,100);
    DlgReal(8, "Grating Bar Phase (deg)",0,360);
    DlgList(9, 30, colorAtCenterLabel$[]);
    DlgReal(10, "Target Width (deg)",0.01,30);
    DlgReal(11, "Target Height (deg)",0.01,30);
    DlgReal(12, "Target Contrast (0=gray, 100=b/w)",0,100);
    DlgCheck(13, "Target Is Circle");
    DlgCheck(14, "Target Is Width Of Stripe");
    
    DlgAllow(0xffff, 0, StarStimGratingBarDialogChanged%);
     
    
    i% := DlgShow(starGratingBarIsSquarewave%,starGratingBarWidth,starGratingBarHeight,starGratingBarXCenter,starGratingBarYCenter,
    starGratingBarSpFreq,starGratingBarContrast%,starGratingBarPhase,starGratingBarColorAtCenter%,starGratingBarTargetWidth,
    starGratingBarTargetHeight,starGratingBarTargetContrast,starGratingBarTargetIsCircle%,starGratingBarTargetIsWidthOfStripe%);
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.

    'starMaximalDiam := starAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveStarStimGratingBarParameters();    
	endif;
    
    if starGratingBarColorAtCenter% = 2 then
        message("Sorry, intermediate phases have not yet been implemented!  Quitting!");
        halt;
    endif;
    
	return iReturn%;
end;



func StarStimGratingBarDialogChanged%(item%)
    if DlgValue(13) = 1 then 'If circle target is selected, do not allow target height
        DlgEnable(0,11);  'Disable target height
    else
        DlgEnable(1,11);  'Enable target height
    endif;
    if DlgValue(9) < 2 then 'If color is specified, disable phase
        DlgEnable(0,8);  'Disable phase
    else
        DlgEnable(1,8);  'Enable phase
    endif;
    if DlgValue(14) = 1 then 'If width is width of stripe, do not allow target width
        DlgEnable(0,10);  'Disable target width
    else
        DlgEnable(1,10);  'Enable target width
    endif;
    return 1;
end;





' Window handles and channel numbers
var XChannel%,YChannel%;		' Channel number assigned to eye x and y
var FixationChannel%;
var StimChannel%;
var ChangeChannel%;
var ReadyChannel%;			' channel number for VSG ready pulse signal
var TimingChannel%;
var DataWindow%;	' time view
var XYWindow%;		' window with eye pos shown -- this is for eye pos and fixpt only
var StarWindow%;    ' window to show star
var iTargetChannel%;	' channel number for target in xy window
var iTargetWindowChannel%;' channel number for target window in xy window
var iFixChannel%;	' channel number for fixpt in xy window
var iFixWindowChannel%;' channel number for fixpt window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iEyePosChannel% := 1;   ' channel 1 is always used as eye position channel in xy windows
var iStarPosChannel% := 1;
var StimHandle%;	' handle for stimulus application
' Experimental control
var Pause%:=0;		' When 1, expt is paused - no idle processing done

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];
' Stimulus location stuff
var iStimX%[8];
var iStimY%[8];
var iStimIndex%;

LogInit(1);

' Check if always looking flag is set. If so, issue a warning. 
if starAlwaysLooking% = 1 then
    if Query("Always looking is SET. Unset?") = 1 then
        starAlwaysLooking% := 0;
    endif
endif

' Fetch electrode config
starNWavemarks% := GetWavemarkPorts%(starWavemarkPorts%[]);
starNContinuous% := GetContinuousPorts%(starContinuousPorts%[]);


' Run dialog
if StarStimScriptDialog%() = 0 then
    halt;
endif


' Assign color values
starEyeTraceColors%[0] := 8;
starEyeTraceColors%[1] := 16;
starEyeTraceColors%[2] := 24;
starEyeTraceColors%[3] := 32;
starEyeTraceColors%[4] := 10;
starEyeTraceColors%[5] := 12;
starEyeTraceColors%[6] := 14;
starEyeTraceColors%[7] := 20;
starEyeTraceColors%[8] := 22;
starEyeTraceColors%[9] := 26;
starEyeTraceColors%[10] := 27;
starEyeTraceColors%[11] := 39;

' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
ReadyChannel% := 23;
FixationChannel% := 24;
StimChannel% := 25;
ChangeChannel% := 26;
UtilityChannel% := 27;
TimingChannel% := 28;

ExcludedChans%[0] := 21;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 32;  'Digmark (default) is highest non-electrode channel used by this function


if UseTwo1401s% = 0 then
    CreateSampleConfiguration();
    
    ' Get display windows ready
    InitializeWindows();
    
    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;

'CreateSampleConfiguration();
'
'' Get display windows ready
'InitializeWindows();
'
'' Prepare the toolbar buttons
'InitializeToolbar();

const stateStartTrial%				:= 0;
const stateWaitForFixPtOn%			:= 1;
const stateWaitForAcquisition%	    := 2;
const stateHoldFixation%			:= 3;
const stateShowStim%				:= 4;
const stateWaitForStimOn%			:= 5;
const stateWaitForAnswer%			:= 6;
const stateSuccess%					:= 7;
const stateWaitForFixPtOff%		    := 8;
const stateAbort%			        := 9;
const stateWaitForStimOff%			:= 10;
const stateFailure%					:= 11;
const stateAbortTime%				:= 12;
const stateInterTrial%		 		:= 13;

const stateVSGWait%					:= 14;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%			:= 15;		' wait for vsg to send ready signal #2
const stateWaitThroughPreOpto%      := 16;      ' wait for pre-opto to finish, if opto trial
const stateWaitForPostOpto%         := 17;      ' wait for post-opto to finish, and turn off laser
const stateHoldAnswer%              := 18;


var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var iState%:=stateVSGWait%;		' present state
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var nTrialsStarted%:=0;
var nTrialsSuccess%:=0;
var nTrialsFail%:=0;
var nTrialsAbort% := 0;
var nTrialsStartedByTarget%[MAXTARGETPOSITIONS%];
var nTrialsSuccessByTarget%[MAXTARGETPOSITIONS%];
var nTrialsFailByTarget%[MAXTARGETPOSITIONS%];
var iTargetPoint% := 0;
var iStarPosColor%;
var TargetX, TargetY;		' location of stimulus grating - this is target position "0"
const numRandomTargets% := 1000;
var aTargets[numRandomTargets%];			' if randomized target locations, this array holds those random positions

' for variable small reward
const constNEVER := 99999e99;   ' time will never be greater than this time
var tNextSmallReward := -1;
var fixBrokenThisTrial% := 0;   ' only valid for a few states TODO



' Run real time analysis here. 
func IdleProcessing%()
	var iStatus% := 1;	' this is return value. value of 1 (0) continues (stops) processing
    var tOpt;
    var tPostStimStart;  'will be useful for turning off "wraparound" opto after reward
    var tStimOn;  'tLast does not work to find stim off if we have intervening steps in the state logic, which we do.
	tNow := View(DataWindow%).MaxTime();

	xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
	yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;

	' Don't update display every time. 
	' Note that this stim displays eye continuously, without erasing... 
	if tNow-tLastUpdate > .005 then
        if iState% = stateWaitForAnswer% and iStarPosChannel% > 0 then
            View(StarWindow%).XYAddData(iStarPosChannel%, xEye, yEye);
        endif
		View(XYWindow%).XYAddData(iEyePosChannel%, xEye, yEye);
		tLastUpdate := tNow;
	endif

	' What state are we in? 
	docase 

	
    case iState% = stateVSGWait% then
        
        if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tTrigger, tLastTrigger) = 1 then
            LogStatus("VSGWait", "Got ready pulse at " + str$(tTrigger));
            ChangeStateTo(stateStartTrial%, tNow);
            if RecordEyeTrackerOutputFile% = 1 then
                'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
            endif;
        endif

    case iState% = stateStartTrial% then
        
        'put timing marker in both eyetracker file, smr file
        if RecordEyeTrackerOutputFile% = 1 then
            'SafeSampleKey("1");
            docase
            case HBCycle% = 1 then
                SafeSampleKey("1");
            case HBCycle% = 2 then
                SafeSampleKey("2");
            case HBCycle% = 3 then
                SafeSampleKey("3");
            case HBCycle% = 4 then
                SafeSampleKey("4");
            case HBCycle% = 5 then
                SafeSampleKey("5");
            case HBCycle% = 6 then
                SafeSampleKey("6");
            case HBCycle% = 7 then
                SafeSampleKey("7");
            endcase
            HBCycle% += 1;  'increment HBCycle%
            if HBCycle% = 8 then  'and cycle when necessary
                HBCycle% := 1;
            endif
            yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
        endif;
        
        nTrialsStarted% += 1;
        starFixationDuration := Rand(starFixationDurationMax-starFixationDurationMin, starFixationDurationMin);
        LogStatus("StartTrial", "Start trial " + str$(nTrialsStarted%) + " Fix time " + str$(starFixationDuration));
        SafeSampleKey("F");
        
        'determine if we are doing opto on this trial
        if starDoOpto% = 1 then
            if rand(100,0) < starProbOfOpto then
                starDoOptoThisTrial% := 1;
                starFixationDuration := starFixationDuration - starPreStimOptoTime;  'update fixation duration to not include pre-opto time
                SampleText("Opto This Trial",tNow)
            else
                starDoOptoThisTrial% := 0;
                SampleText("No Opto This Trial",tNow)
            endif;
        endif;
        
        ChangeStateTo(stateWaitForFixPtOn%, tNow);

    case iState% = stateWaitForFixPtOn% then
        
        if View(DataWindow%).FindRisingEdge%(FixationChannel%, tLast, tTrigger) = 0 then
            ' Stimulus has been presented. Display stim location and window. Enter state 2
            DrawFix(1);
            ChangeStateTo(stateWaitForAcquisition%, tNow);
        endif

    case iState% = stateWaitForAcquisition% then

        if tNow-tStateStart < starAcquisitionTime then
            
            ' Acquisition happens when the eye falls within the fixation window.
            if InFixationWindow%(xEye, yEye) > 0 then
                
                ChangeStateTo(stateHoldFixation%, tNow);
                
                ' Small reward handling.
                if starKeepFixptOn% = 1 then
                    tNextSmallReward := tNow + GetSmallRewardDelta();
                else
                    tNextSmallReward := constNEVER;
                endif
                fixBrokenThisTrial% := 0;
                
            endif
            
        else

            ' Failed. Turn off stim and try again.
            LogStatus("WaitForAcquisition", "Time out.");
            ChangeStateTo(stateAbort%, tNow);

        endif

    case iState% = stateAbort% then
        
        nTrialsAbort% += 1;
        DrawFix(0);
        DrawTarget(0);
        SafeSampleKey("X");
        
        'There are multiple places that can lead to an abort with opto laser still on
        if optoIsOn% = 1 then
            'turn off opto
            SafeSampleKey("o");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOff at %f\n",tOpt);
            SampleText("OptoOff",tOpt);
            optoIsOn% := 0;
        endif;
        
        
        ChangeStateTo(stateWaitForFixPtOff%, tNow);

    case iState% = stateWaitForFixPtOff% then
        
        if View(DataWindow%).FindFallingEdge%(FixationChannel%, tLast, tTrigger) = 1 then
            
            ChangeStateTo(stateInterTrial%, tNow);
            
        endif
        
    case iState% = stateHoldFixation% then

        if InFixationWindow%(xEye, yEye) <= 0 then
            
            LogStatus("HoldFixation", "Broken fixation at " + str$(tNow));
            ChangeStateTo(stateAbort%, tNow);
            fixBrokenThisTrial% := 1;

        else
            
            if tNow > tNextSmallReward then
                RewardSmall%();
                tNextSmallReward := tNow + GetSmallRewardDelta();
            endif
            
            if tNow - tStateStart >= starFixationDuration then
                if starDoOptoThisTrial% = 0 then
                    LogStatus("HoldFixation", "Request target at " + str$(tNow));
                    ChangeStateTo(stateShowStim%, tNow);
                else
                    LogStatus("HoldFixation", "Request opto on at " + str$(tNow));
                    ChangeStateTo(stateWaitThroughPreOpto%, tNow);
                    
                    SafeSampleKey("O");  'turn on opto
                    tOpt := View(DataWindow%).MaxTime();
                    'printlog("OptoOn at %f\n",tOpt);
                    SampleText("OptoOn",tOpt);
                    optoIsOn% := 1;
                    
                endif;

            endif

        endif
        
        
    case iState% = stateWaitThroughPreOpto% then
        
        if InFixationWindow%(xEye, yEye) <= 0 then
            
            LogStatus("HoldFixation", "Broken fixation at " + str$(tNow));
            ChangeStateTo(stateAbort%, tNow);
            fixBrokenThisTrial% := 1;

        else
            
            if tNow - tStateStart >= starPreStimOptoTime then
                LogStatus("HoldFixation", "Request target at " + str$(tNow));
                ChangeStateTo(stateShowStim%, tNow);
            endif;
        endif;
        
        
    case iState% = stateShowStim% then
        
        ' Record stim pos
        SampleText(str$(starTargetOrder%[iTargetPoint%]));
            
        ' Send stim signal, yield short time, then turn off fix pt (unless we don't want to).
        SafeSampleKey("S");
        DrawTarget(1);
        Yield(0.05);
        
        if starKeepFixptOn% = 0 then
            SafeSampleKey("f");
            DrawFix(0);
        endif
        ChangeStateTo(stateWaitForStimOn%, tNow);

    case iState% = stateWaitForStimOn% then
        
        ' Fixation may be broken while waiting for stim to come on. 
        ' Even if fix is broken, we wait here until the stim comes on.
        
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' TODO: Must carefully analyze whether fix was broken first, or whether
        ' target came up first. 
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        
        if InFixationWindow%(xEye, yEye) <= 0 then
            
            LogStatus("WaitForStimOn", "Broken fixation at " + str$(tNow));
            ChangeStateTo(stateAbort%, tNow);
            fixBrokenThisTrial% := 1;
            
        endif
        
        ' We can have a small reward here
        if starKeepFixptOn% = 1 and fixBrokenThisTrial% = 0 and tNow > tNextSmallReward then
            RewardSmall%();
            tNextSmallReward := tNow + GetSmallRewardDelta();
        endif
        
        ' Check if stim target has come on finally.
        if View(DataWindow%).FindRisingEdge%(StimChannel%, tLast, tTrigger) = 0 then
            ChangeStateTo(stateWaitForAnswer%, tNow);
            tStimOn := tNow;
            iStarPosColor% := GetEyeTraceColor%(starTargetOrder%[iTargetPoint%]);
            iStarPosChannel% := View(StarWindow%).XYSetChan(0, 0, 0, 1, iStarPosColor%);
            if iStarPosChannel% > 0 then
                View(StarWindow%).XYDrawMode(iStarPosChannel%, 1, 0);
                View(StarWindow%).XYDrawMode(iStarPosChannel%, 2, 0);
            endif
        endif

    case iState% = stateWaitForAnswer% then
        
        ' If fixation is broken here, don't do anything, but note it -- if starKeepFixptOn is set, 
        ' we need to know if the subject broke fixation if we get to stateFailure.
        ' If fixation has not been broken, then check if a small reward is in order.
        
        if fixBrokenThisTrial% = 0 and InFixationWindow%(xEye, yEye) <= 0 then
            
            LogStatus("WaitForAnswer", "Broken fixation at " + str$(tNow));
            fixBrokenThisTrial% := 1;
            
        else
            
            if starKeepFixptOn% = 1 and fixBrokenThisTrial% = 0 and tNow > tNextSmallReward then
                RewardSmall%();
                tNextSmallReward := tNow + GetSmallRewardDelta();
            endif
            
        endif

        if InTargetWindow%(xEye, yEye) = 1 then
            
            LogStatus("WaitForAnswer", "Entered answer window at " + str$(tNow));
            ChangeStateTo(stateHoldAnswer%, tNow);
            'tPostStimStart := tNow;

        else
            
            'Turn off opto mid stream, if required
            if tNow - tStateStart >= starOptoOffMidStimTime  and optoIsOn% = 1 then
                LogStatus("WaitForAnswer", "Turning off laser at " + str$(tNow));
                'do not change state
                'turn off opto
                SafeSampleKey("o");  'turn it off
                tOpt := View(DataWindow%).MaxTime();
                'printlog("OptoOff at %f\n",tOpt);
                SampleText("OptoOff",tOpt);
                optoIsOn% := 0;
            endif;
            
            
            if tNow - tStateStart >= starAnswerTime then
                
                LogStatus("WaitForAnswer", "Timeout at " + str$(tNow));
                ChangeStateTo(stateFailure%, tNow);
                tPostStimStart := tNow;

            endif

        endif
        
    case iState% = stateHoldAnswer% then
        
        docase
        case InTargetWindow%(xEye, yEye) = 1 and tNow > tStateStart+starHoldAnswer then
            
            LogStatus("HoldAnswer", "Answer fully held at " + str$(tNow));
            ChangeStateTo(stateSuccess%, tNow);
            tPostStimStart := tNow;
        case InTargetWindow%(xEye, yEye) = 0 then
            LogStatus("Hold Answer", "Answer broken at " + str$(tNow));
            ChangeStateTo(stateFailure%, tNow);
            tPostStimStart := tNow;
            fixBrokenThisTrial% := 1;
        endcase
        
        
        
    case iState% = stateSuccess% then

        nTrialsSuccess% += 1;
        nTrialsSuccessByTarget%[starTargetOrder%[iTargetPoint%]] += 1;
        SampleText("+");
        SafeSampleKey("X");
        Yield();
        Reward%();
        if optoIsOn% = 1 then
            ChangeStateTo(stateWaitForPostOpto%, tNow);
        else
            ChangeStateTo(stateWaitForStimOff%, tNow);
            Yield(0.05);
            AdvanceTarget();
        endif;

    case iState% = stateFailure% then

        nTrialsFail% += 1;
        nTrialsFailByTarget%[starTargetOrder%[iTargetPoint%]] += 1;
        SampleText("-");
        if starKeepFixptOn% = 1 and fixBrokenThisTrial% = 0 then
            SafeSampleKey("s")
        else
            SafeSampleKey("X");
        endif
        if optoIsOn% = 1 then
            ChangeStateTo(stateWaitForPostOpto%, tNow);
        else
            ChangeStateTo(stateWaitForStimOff%, tNow);
            Yield(0.05);
            AdvanceTarget();
        endif;
        
        
    case iState% = stateWaitForPostOpto% then
        if tNow - tPostStimStart > starPostStimOptoTime then
            'turn off opto
            SafeSampleKey("o");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOff at %f\n",tOpt);
            SampleText("OptoOff",tOpt);
            optoIsOn% := 0;
            Yield(0.05);
            AdvanceTarget();  'must do this here, didn't get done in previous state (wanted to avoid the yield, get opto off promptly...)
            ChangeStateTo(stateWaitForStimOff%, tNow);
        endif;
        
        

    case iState% = stateWaitForStimOff% then

        ' We can have a small reward here
        if fixBrokenThisTrial% = 0 and tNow > tNextSmallReward then
            RewardSmall%();
            tNextSmallReward := tNow + GetSmallRewardDelta();
        endif
        
        ' Wait for stim to be off
        if View(DataWindow%).FindFallingEdge%(StimChannel%, tStimOn, tTrigger) = 1 then

            if starKeepFixptOn% = 1 and fixBrokenThisTrial% = 0 then
                DrawTarget(0);
                ChangeStateTo(stateShowStim%, tNow);
            else
                DrawTarget(0);
                DrawFix(0);
                ChangeStateTo(stateInterTrial%, tNow);
            endif
            
            
            ' Stimulus has been turned off by vsg.
            

        endif

    case iState% = stateInterTrial% then
        
        UpdateToolbarText();
        if (tNow - tStateStart >= starInterTrialTime) then
            ChangeStateTo(stateStartTrial%, tNow);
        endif;

    else 

        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        
        'If the eyetracker is recording an output file, stop recording and close the file
        if RecordEyeTrackerOutputFile% = 1 then
            SafeSampleKey("w");  'Stop recording
            yield(0.1);
            SafeSampleKey("i");  'Close the file
            SafeSampleKey("Z");  'zero the DIGLOWs
        endif
        
        halt;

	endcase;

	tLast := tNow;
	
	return iStatus%;

end;

func GetEyeTraceColor%(i%)
    LogStatus("GetTargetColor", "pos " + str$(i%) + " mod " + str$(i% mod MAXEYETRACECOLORS%) + " color " + str$(starEyeTraceColors%[i% mod MAXEYETRACECOLORS%]));
    return starEyeTraceColors%[i% mod MAXEYETRACECOLORS%];
end


func GetSmallRewardDelta()
    return Rand(starMaxSmallRewardDelta - starMinSmallRewardDelta, starMinSmallRewardDelta);
end


proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;

proc UpdateToolbarText()
    var s$;
    
    if iStarPosChannel% > 0 then
        s$ := Print$("Ntrials/Success/Fail/Abort %d/%d/%d/%d", nTrialsStarted%, nTrialsSuccess%, nTrialsFail%, nTrialsAbort%);
    else
        s$ := Print$("WARNING -- NO LONGER DRAWING NEW TRACES!!!  Ntrials/Success/Fail/Abort %d/%d/%d/%d", nTrialsStarted%, nTrialsSuccess%, nTrialsFail%, nTrialsAbort%);
    endif;
    ToolbarText(s$);
    return;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
    var key$;
    var primaryTxt$;
    var secondaryTxt$;
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
	SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
	' Set path for new data files
	FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3, 1);
	FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1, 1);
	DoSampleAutoName(key$,"star","str",primaryTxt$,secondaryTxt$);
	SampleAutoFile(1);
    
    ' Text marks make extraction easier
    SampleTextMark(200);
    
	'----Event Channel recording definitions----
	SampleEvent(FixationChannel%, 2, 2, 3600);
	SampleComment$(FixationChannel%, "FixPt");
	SampleTitle$(FixationChannel%, "FixPt");

	SampleEvent(StimChannel%, 3, 2, 3600);
	SampleComment$(StimChannel%, "Stim");
	SampleTitle$(StimChannel%, "Stim");

	SampleEvent(ChangeChannel%, 4, 2, 3600); 'Trigger channel, level
	SampleComment$(ChangeChannel%, "Advance");
	SampleTitle$(ChangeChannel%, "Advance");


	' channel to look for ready signal from vsg
	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"Ready");
	SampleTitle$(ReadyChannel%,"Ready");
    
    
    'Digmark channel for eyetracker timing pulses
    if RecordEyeTrackerOutputFile% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"EyeFilePulse");  'Digital marker is by definition channel 32
    endif
    
    
    '----Analog, non-spiking electrode recording conditions
    'EYE COIL CHANNELS. Last # is sampling freq in Hz. 
	SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
	SampleTitle$(XChannel%,EyeXPortLabel$);
	SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
	SampleTitle$(YChannel%,EyeYPortLabel$);
    
    if UtilityPort% > -1 then
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);         
        SampleTitle$(UtilityChannel%,UtilityPortLabel$);
    endif;
    
    if UseTwo1401s% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Timing");  'Digital marker is by definition channel 32
        
        SampleEvent(TimingChannel%, 6, 2, 3600); 'Trigger channel, level
        SampleComment$(TimingChannel%,"Handshake");
        SampleTitle$(TimingChannel%,"Hndshk");
    endif
    
    
    
    
    '----Set up "spiking" Electrode Channels----
    SetUpElectrodeConfiguration(starNWavemarks%,ExcludedChans%[]);


	

	if UseTwo1401s% = 0 then
        SampleSequencer(script$ + "Tuning.pls");
    else
        SampleSequencer(script$ + "TuningSendTrigger.pls");
    endif;

	DoSampleOptimise();
	SampleMode(1); 'Continuous sampling
    
    
'    'Add a digital marker channel for pulsing optogenetics
'    'Do it for every opto, easy enough to add this into the wraparound calls in the PLS
'    'Will record a '1' for laser on and a '0' for laser off
'    if starDoOpto% = 1 then
'        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
'        SampleTitle$(DigitalLaserChannel%,"Laser On");
'    endif
    
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawTarget
' 
' Draws target in xy window (iDraw%==1) or blanks it (0). 
proc DrawTarget(iDraw%)


	if iDraw% > 0 then
		var xstim, ystim;
		xstim := starTargetPositions[starTargetOrder%[iTargetPoint%]][0];
		ystim := starTargetPositions[starTargetOrder%[iTargetPoint%]][1];

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iTargetChannel%, xstim, ystim);
	
		' draw fixation window
		ArrConst(windowX[], FixWindowX[]);
		ArrAdd(windowX[], xstim);
		ArrConst(windowY[], FixWindowY[]);
		ArrAdd(windowY[], ystim);

		View(XYWindow%).XYAddData(iTargetWindowChannel%, windowX[], windowY[]);		
        PrintLog("DrawTarget " + str$(iDraw%) + " iTargetPoint=" + str$(iTargetPoint%) + " target " + str$(starTargetOrder%[iTargetPoint%]) + "\n");
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iTargetChannel%);
		View(XYWindow%).XYDelete(iTargetWindowChannel%);
	endif

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawFix
' 
' Draws fixpt in xy window (iDraw%==1) or blanks it (0). 
proc DrawFix(iDraw%)

	if iDraw% > 0 then

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iFixChannel%, FixationX, FixationY);
	
		' draw fixation window
		ArrConst(windowX[], FixWindowX[]);
		ArrAdd(windowX[], FixationX);
		ArrConst(windowY[], FixWindowY[]);
		ArrAdd(windowY[], FixationY);

		View(XYWindow%).XYAddData(iFixWindowChannel%, windowX[], windowY[]);		
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iFixChannel%);
		View(XYWindow%).XYDelete(iFixWindowChannel%);
	endif

end;


proc InitializeWindows()

	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0, 50, 100, 100);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
    
	'Open an XY view to display the star
	StarWindow% := FileNew(12);
	XRange(-15,15);
	YRange(-2,-15,15);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(50, 0, 100, 50);
	XYColour(1,16);
    
	' Channel 1 is eye pos. Set size of this channel's data to 0 - expands as needed. Join points, too. 
	XYSize(iEyePosChannel%, 0);
	XYJoin(iEyePosChannel%, 1);
	XYDrawMode(1, 2, 1);	' dot size is 1
    
    
	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-15,15);
	YRange(-2,-15,15);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 50);
	XYSize(iEyePosChannel%, -1);
	XYColour(iEyePosChannel%, 16);
    

	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iFixWindowChannel% := XYSetChan(0);
	XYColour(iFixWindowChannel%, 13);
	XYDrawMode(iFixWindowChannel%, 2, 1);
	XYJoin(iFixWindowChannel%, 1);

	'Create a new channel in the XY view to display the fixation point
	iFixChannel% := XYSetChan(0);

	'Create a new channel in the XY view to display the target window
	iTargetWindowChannel% := XYSetChan(0);
	XYColour(iTargetWindowChannel%, 13);
	XYDrawMode(iTargetWindowChannel%, 2, 1);
	XYJoin(iTargetWindowChannel%, 1);

	'Create a new channel in the XY view to display the target point
	iTargetChannel% := XYSetChan(0);



	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%, 13);
	XYDrawMode(iMonitorChannel%, 3, 1);
	XYJoin(iMonitorChannel%, 2);
	XYAddData(iMonitorChannel%, -9, -7);
	XYAddData(iMonitorChannel%, 9, -7);
	XYAddData(iMonitorChannel%, 9, 7);
	XYAddData(iMonitorChannel%, -9, 7);

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
    if UseTwo1401s% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Quit", Quit%);
	ToolbarEnable(2,0);
	Toolbar("Go", 0x3ff);

end;


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
	FileClose(-1,-1);
	return 0;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Targ$(x, y, d, c$)
    return " -t " + str$(x) + "," + str$(y) + "," + str$(d) + "," + c$ + " ";
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func TargGrating$(x, y)
    'This function gets the current grating parameters, replaces the x and y location with the specified location, and returns
    'the grating with the new location with the correct syntax for adding into the command line
    var gr$;
    var newgr$;
    var NOTx; 
    var NOTy;
    var w;
    var h;
    var iw;
    var ih;
    var contrast%;
    var sf;
    var tf;
    var ori;
    var phase;
    var cv$;
    var pattern$;
    var aperture$;
    var ctf;
    gr$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(gr$, NOTx, NOTy, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    newgr$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    return " -g " + newgr$ + " ";
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func TargRect$(x,y,w,h,barcont,targcont)
    var localcolor$;
    var localval%;
    if barcont = 1 then 'bar white, target dark
        localval% := 127.5 - (127.5*targcont/100);
        localcolor$ := "(" + str$(localval%) + "/" + str$(localval%) + "/" + str$(localval%) + ") ";
    else 'bar black, target light
        localval% := 127.5 + (127.5*targcont/100);
        localcolor$ := "(" + str$(localval%) + "/" + str$(localval%) + "/" + str$(localval%) + ") ";
    endif;
    
    return " -r " + str$(x) + "," + str$(y) + "," + str$(w) + "," + str$(h) + "," + localcolor$; 
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func TargCircle$(x,y,w,barcont,targcont)
    var localcolor$;
    var localval%;
    if barcont = 1 then 'bar white, target dark
        localval% := 127.5 - (127.5*targcont/100);
        localcolor$ := "(" + str$(localval%) + "/" + str$(localval%) + "/" + str$(localval%) + ") ";
    else 'bar black, target light
        localval% := 127.5 + (127.5*targcont/100);
        localcolor$ := "(" + str$(localval%) + "/" + str$(localval%) + "/" + str$(localval%) + ") ";
    endif;
    
    return " -t " + str$(x) + "," + str$(y) + "," + str$(w) + "," + localcolor$; 
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var FixationPoint$;
	var Extras$;
	var tmp$;
	var TargetArg$;
    var progName$;
    var targx, targy, w, h;
    var count% := 0;
    var fpx, fpy, fpd, fpr;     ' fixpt parameters
    var vec[2], targetvec[2];
    var length;
    var angstep;
    var i%;
    var j%;
    var gridX[(starXNumPerSide%*2)+1];
    var gridY[(starYNumPerSide%*2)+1];
    var startSecs := 5;
    var pulseFound%;
    var tRise;
    var tFall;
    
    GetFixationPointParameterValues(fpx, fpy, fpd, fpr);
    if starUseDefaultTargetSize% = 0 then
        fpd := starTargetDiameter;
    endif
    
    if UseTwo1401s% = 1 then
        SampleStart(0);  'Set sampling to start immediately
        Yield(0.5);  'Wait half a second
        'Look for handshake, unless disabled
        while pulseFound% < 1 and startSecs > 0 and Dual1401IgnoreHandshake% = 0 do
            pulseFound% := View(DataWindow%).FindPulseUp%(TimingChannel%, 0, tRise, tFall);
            yield(0.1);
            startSecs := startSecs - 0.1;
        wend
        'Send timing pulse
        SafeSampleKey("T");
    else
        SampleStart(0); 'Start sampling now
    endif;
    
    if startSecs <= 0 then
        message("Handshake not found in 5 seconds!  Quitting!");
        halt
    endif

    
    
    ' generate target args. 
    if starUseStimulusXY% then
        tmp$ := GetGratingParameters$("Stimulus");
        ParseGratingParametersBrief%(tmp$, targx, targy, w, h);
    else
        targx := starTargetX;
        targy := starTargetY;
    endif
    
    
    if starDoTargetGrid% = 0 then
        ' base target first
        starTargetPositions[0][0] := targx;
        starTargetPositions[0][1] := targy;
        starNTargetPositions% := 1;
        
        ' Small area targets on x-axis
        if starXAxis% = 1 then
            for i% := 1 to starXNumPerSide% do
                starTargetPositions[starNTargetPositions%][0] := targx + i% * starXOffset;
                starTargetPositions[starNTargetPositions%][1] := targy;
                starNTargetPositions% += 1;
                starTargetPositions[starNTargetPositions%][0] := targx - i% * starXOffset;
                starTargetPositions[starNTargetPositions%][1] := targy;
                starNTargetPositions% += 1;
            next
        endif
        
        ' Small area targets on x-axis    
        if starYAxis% = 1 then
            for i% := 1 to starYNumPerSide% do
                starTargetPositions[starNTargetPositions%][0] := targx;
                starTargetPositions[starNTargetPositions%][1] := targy + i% * starYOffset;
                starNTargetPositions% += 1;
                starTargetPositions[starNTargetPositions%][0] := targx;
                starTargetPositions[starNTargetPositions%][1] := targy - i% * starYOffset;
                starNTargetPositions% += 1;
            next
        endif
        
        ' Total number of small area targets (includes the base target)
        starNumSmall% := 1 + starXAxis% * starXNumPerSide% * 2 + starYAxis% * starYNumPerSide% * 2;
        
    else  'if we are doing a grid
        count% := 0;
        for i% := 0 to starXNumPerSide% do
            if i% = 0 then
                gridX[count%] := targx;
                count% += 1;
            else
                gridX[count%] := targx + i% * starXOffset;
                count% += 1;
                gridX[count%] := targx - i% * starXOffset;
                count% += 1;
            endif                
        next;

        count% := 0;
        for i% := 0 to starYNumPerSide% do
            if i% = 0 then
                gridY[count%] := targy;
                count% += 1;
            else
                gridY[count%] := targy + i% * starYOffset;
                count% += 1;
                gridY[count%] := targy - i% * starYOffset;
                count% += 1;
            endif 
        next; 
        
        starNTargetPositions% := 0;
        for i% := 0 to (starXNumPerSide%*2) do
            for j% := 0 to (starYNumPerSide%*2) do
                starTargetPositions[starNTargetPositions%][0] := gridX[i%];
                starTargetPositions[starNTargetPositions%][1] := gridY[j%];
                starNTargetPositions% += 1;
            next  
        next
        ' Total number of small area targets (includes the base target)
        starNumSmall% := ((starXNumPerSide%*2)+1) * ((starYNumPerSide%*2)+1);
    endif;
    
    
    LogInfo("targxy " + str$(targx) + ", " + str$(targy));
    
    ' Now the rest of the targets. First normalize vector from fp to base target (vec[])
    vec[0] := targx - fpx;
    vec[1] := targy - fpy;
    length := sqrt(vec[0]*vec[0] + vec[1]*vec[1]);
    ArrDiv(vec[], length);
    LogInfo("Normalized vector " + str$(vec[0]) + ", " + str$(vec[1]));
    
    ' angstep is the angular diff between the targets
   	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
    'angstep := twopi / starNumTargets%;  'moved inside FOR loop below to allow starNumTargets to be 0
    
    
    ' rotate vec[] to get direction vec for each target. The base target is already saved in
    ' starTargetPositions, as are any additional small-area targets -- we use count% as the index
    ' into starTargetPositions for this reason. 
    for i% := 1 to starNumTargets%-1 do
        angstep := twopi / starNumTargets%;
        starTargetPositions[starNTargetPositions%][0] := (vec[0] * cos(i% * angstep) - vec[1] * sin(i% * angstep)) * length + fpx;
        starTargetPositions[starNTargetPositions%][1] := (vec[0] * sin(i% * angstep) + vec[1] * cos(i% * angstep)) * length + fpy;
        
        'add in dot on xyplot
        'View(starWindow%).XYAddData(iEyePosChannel%, starTargetPositions[starNTargetPositions%][0], starTargetPositions[starNTargetPositions%][1]);
        'XYDrawMode(1, 2, 5);	' dot size is 5
        
        starNTargetPositions% += 1;
        'iEyePosChannel% += 1;
    next
    
    'Do lots of preliminary calcs for using a grating bar
    'Number of targets is different if we are using a grating bar
    'Calculate number of stripes (half-cycles) and width of stripes, only is using a grating bar
    if starTargetIsGrating% = 2 then
        starGratingBarWidthOfStripe := 0.5/starGratingBarSpFreq;  'Two stripes per cycle
        'note that if the phase is 0 or 180 that a stripe will be centered in the created grating
        'the number of full stripes will be 1 (center stripe) + 2*floor(((0.5*width)-half a stripe)/stripe width) (how many stripes on each side)
        starGratingBarNStripes% := 1 + 2*(floor(((0.5*starGratingBarWidth)-(starGratingBarWidthOfStripe/2)))/starGratingBarWidthOfStripe);
        'we are NOT making any adjustments for if the phase is not centered, because...too much work and right now it won't be done
        'As of now if the user selects a phase, the program says "NOPE!" and quits.  But the dialog is capable.
        
        'Calculate FirstTargetColor - this should work, there's no mod function, dividing by 4 because there's a *2 built in
        if frac((starGratingBarNStripes% - 1)/4) = 0 then
            starGratingBarFirstTargetColor% := starGratingBarColorAtCenter%;
        else
            starGratingBarFirstTargetColor% := 1 - starGratingBarColorAtCenter%;
        endif;
        
        
        'Calculate starting X position
        starTargetXPosition := starGratingBarXCenter - ((starGratingBarNStripes%-1)/2)*starGratingBarWidthOfStripe;
        starNTargetPositions% := starGratingBarNStripes%;  'Set one target per stripe
        starNumTargets% := starGratingBarNStripes%;  'Set one target per stripe
        starNumSmall% := 1;  'No small targets! -- ah, but it has to be 1 anyway due to the function below subtracting 1 when dealing out targets!
        for i% := 0 to starNTargetPositions%-1 do
            starTargetPositions[i%][0] := starTargetXPosition;
            starTargetPositions[i%][1] := starGratingBarYCenter;
            starTargetXPosition := starTargetXPosition + starGratingBarWidthOfStripe;
            starBarContrastAtTarget[i%] := starGratingBarFirstTargetColor%;
            starGratingBarFirstTargetColor% := 1 - starGratingBarFirstTargetColor%;  'invert for next target
        next
        
        'This doesn't quite work, there is an offset
        if starGratingBarTargetIsWidthOfStripe% = 1 then
            starGratingBarTargetWidth := starGratingBarWidthOfStripe;
            starGratingBarTargetHeight := starGratingBarWidthOfStripe;
        endif;
        
        
    endif
    
    
    
    
    ' Generate target args for starstim program
    for i% := 0 to starNTargetPositions% -1 do
        LogInfo("target pos[" + str$(i%) + "] " + str$(starTargetPositions[i%][0]) + ", " + str$(starTargetPositions[i%][1]));
        docase
        case starTargetIsGrating% = 0 then
            TargetArg$ += Targ$(starTargetPositions[i%][0], starTargetPositions[i%][1], fpd, starTargetColor$);
        case starTargetIsGrating% = 1 then
            TargetArg$ += TargGrating$(starTargetPositions[i%][0], starTargetPositions[i%][1]);
        case starTargetIsGrating% = 2 and starGratingBarTargetIsCircle% = 0 then
            TargetArg$ += TargRect$(starTargetPositions[i%][0],starTargetPositions[i%][1],starGratingBarTargetWidth,starGratingBarTargetHeight,starBarContrastAtTarget[i%],starGratingBarTargetContrast);
        case starTargetIsGrating% = 2 and starGratingBarTargetIsCircle% = 1 then
            TargetArg$ += TargCircle$(starTargetPositions[i%][0],starTargetPositions[i%][1],starGratingBarTargetWidth,starBarContrastAtTarget[i%],starGratingBarTargetContrast);
        endcase;
    next
    
    
    ' Generate Bar argument for barstim program, assign program name
    if starTargetIsGrating% = 2 then
        progName$ := " barstim ";  'use BARSTIM
        TargetArg$ := TargetArg$ + StringifyBar$();  'Add a bar spec for BARSTIM
    else
        progName$ := " starstim ";  'use STARSTIM
    endif;
    
    
    ' Randomize target order
    if GenerateTrials%(starTargetOrder%[], starNTargetOrder%, starNumTargets%, starNumSmall%, starNumBlocks%, starNumPerBlock%) <> 0 then
        LogError("Start", "Error generating trials.");
        return 0;
    else
        ' Must generate string list.
        TargetArg$ += " -o ";
        TargetArg$ += GetIntegerArrayNAsString$(starTargetOrder%[], starNTargetOrder%);
    endif
    
    ' Remaining command line args
	Extras$ += GetFixationArg$() + " -p 2 -b gray -d " + GetDistanceToScreenMM$();

	
	SampleStart(0); 'Start sampling
    ' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");      
    
	CommandLine$ := "cmd /k " + GetBinDir$(1) + "remote " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() +  progName$ + TargetArg$ + Extras$;
    
    
    
    if starDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable. Use vdac32% to get the right value.
        voltageInteger% := vdac32%(starOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
        printlog("Voltage integer is %d\n",voltageInteger%);
    endif;
        
    
    
    ' Record initial text marks
    SampleText("StarStim,1");
    SampleText(starCVSID$);
    SampleText(CommandLine$);
    tmp$ := Print$("%f,%f", fpx, fpy);
    SampleText(tmp$);
    for i% := 0 to starNTargetPositions%-1 do
        tmp$ := Print$("%d,%f,%f", i%, starTargetPositions[i%][0], starTargetPositions[i%][1]);
        SampleText(tmp$);
    next
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
    '	Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.
    
    
   'If we are asking the eyetracker to record an output file, open the file and start recording
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("I");  'Open the file (this is done by setting a DIGLOW bit), file name will be saved in a sampletext
        yield(0.5);
        SafeSampleKey("W");  'Begin recording the file
        yield(0.5);
    endif
    

	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	View(DataWindow%);
	Yield(.1);
	return 1;
end;



func StartPlexon%()
    
    var fp$;  'to hold current file path
    fp$ := SetPathToScriptDirectory$();
    CreateSampleConfiguration();    
    
    StartSecondInstanceOfSpike2();
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work
    
    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar    
    
end



func GenerateTrials%(t%[], &nt%, ntargets%, nsmall%, nblocks%, nperblock%)
    var status% := 0;
    const maxtargets% := 50;
    var ind%[maxtargets%];
    var nextsmall% := 0;
    var i%, index%;
    
    if ntargets% > maxtargets% then
        '        LogError();
        return -1;
    endif
    
    ' Prepare ind%[] array...
    ind%[0] := 0;
    for i% := 1 to ntargets%-1 do
        ind%[i%] := i% + nsmall% -1;
    next

    ' Generate trials...
'    nt% := 0;
'    tbgInit(ntargets%, nperblock%, nblocks%);
'    while tbgGetTrialIndex%(index%) = 1 do
'        t%[nt%] := ind%[index%];
'        if t%[nt%] = 0 then
'            t%[nt%] := nextsmall%;
'            nextsmall% += 1;
'            if nextsmall% = nsmall% then
'                nextsmall% := 0;
'            endif
'        endif
'        nt% += 1;
'        tbgTrialIndexCompleted(index%);
'    wend
    
    '   HACK modify to use all small area targets each block    
    '   ntargets -> nsmall + ntargets - 1
    nt% := 0;
    tbgInit(ntargets% + nsmall% - 1, nperblock%, nblocks%);
    while tbgGetTrialIndex%(index%) = 1 do
        t%[nt%] := index%;
        nt% += 1;
        tbgTrialIndexCompleted(index%);
    wend
    
    
    
    PrintLog("ntargets %d nsmall %d nblocks %d nperblock %d\n",  ntargets%, nsmall%, nblocks%, nperblock%);
    for i% := 0 to nt%-1 do
        PrintLog("%d %d\n", i%, t%[i%]);
    next
    
    return 0;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()

	' Disable idle process func
	ToolbarSet(0,"");
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif

	' Tell stim app to shut down
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();
	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if starDoOpto% = 1 then
        SafeSampleKey("o");
    endif;

	WriteParameterFile();

'	ProgRun(bin$ + "\\ClearTrigger",0);

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	TotalRewards% += nTrialsSuccess%;
	SaveDailyTotals();

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func InFixationWindow%(EyePosX,EyePosY)
	var i% := 0;
	'Determine if the eye position is within the fixation window
	if starAlwaysLooking% = 1 or (Pow(EyePosX-FixationX, 2) + Pow(EyePosY-FixationY, 2)) <= Pow(WindowRadius,2) then 
		i% := 1;
	endif
	return i%;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func InTargetWindow%(EyePosX,EyePosY)
	var i% := 0;
	var x, y;
	x := starTargetPositions[starTargetOrder%[iTargetPoint%]][0];
	y := starTargetPositions[starTargetOrder%[iTargetPoint%]][1];
	'Determine if the eye position is within the answer window
	if starAlwaysLooking% = 1 or (Pow(EyePosX-x, 2) + Pow(EyePosY-y, 2)) <= Pow(starAnswerWindowRadius,2) then 
		i% := 1;
	endif
	return i%;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc AdvanceTarget()

	SafeSampleKey("a");
	iTargetPoint%+=1;
    if iTargetPoint% = starNTargetOrder% then
        iTargetPoint% := 0;
    endif
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' With new ability for multiple juicers, there is no ability to specify the juice per reward
'    because it would be a pain in the butt to code and would take up a lot of space on the
'    dialog boxes.  Instead I have arbitrarily decided that for each hit, the
'    "timed" juicer will deliver 200 ms of reward.  That value can be changed right here.

func Juice%()
    Reward%();
	return 1;
end;

func Reward%()
    'Check juicer type and deliver reward
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverRewardMS(GetJuicePerReward%()*GetJuiceRewardMS%());
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNumber();
        endif;
    endif;
	return 1;
end;

func RewardSmall%()
    'Check juicer type and deliver reward
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverRewardMS(starJuicePerSmallReward%*starMSPerRewardHit%);
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNum%(starJuicePerSmallReward%);
        endif;
    endif;	
	return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Stim parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
'	Print("Number of electrodes       : %d\n", NumberOfElectrodes%);
'	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());

	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);

	' write stimulus parameters
	Print("\nTargets\n");
	Print("-------------------\n\n");
	Print("Number of Targets          : %d\n", starNTargetPositions%);

	iTargetPoint% := 0;
	var i%;
    Print("Pos (123.56, 123.56) SUCCESS FAIL\n");
	for i%:= 0 to starNTargetPositions%-1 do
		Print("%3d (%6.2f, %6.2f) %4d %4d\n", i%, starTargetPositions[i%][0], starTargetPositions[i%][1], nTrialsSuccessByTarget%[i%], nTrialsFailByTarget%[i%]);
	next;
    if starXAxis% = 1 then
        Print("\nSmall Area X: ON\n");
        Print("NumPerSide         : %d\n",starXNumPerSide%);
        Print("X Offset           : %f\n",starXOffset);
    else
        Print("\nSmall Area X: OFF\n");
    endif
    if starYAxis% = 1 then
        Print("Small Area Y: ON\n");
        Print("NumPerSide         : %d\n",starYNumPerSide%);
        Print("Y Offset           : %f\n",starYOffset);
    else
        Print("Small Area Y: OFF\n");
    endif
    if starDoTargetGrid% = 1 then
        Print("Small Area Use Target Grid: ON\n");
    else
        Print("Small Area Use Target Grid: OFF\n");
    endif;


	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

	Print("Acquisition time (s)   : %f\n", starAcquisitionTime);
	Print("Fixation time(s)       : %f\n", starFixationDuration);
	Print("Answer time (s)        : %f\n", starAnswerTime);
	Print("Inter trial time (s)   : %f\n", starInterTrialTime);
    
    
    if starDoOpto% = 1 then
        Print("\nOptogenetics parameters\n");
        Print("-------------------------\n\n");
'        if tunLaserDiode% = 1 then
'            Print("Laser Diode recorded\n");
'        endif;
        Print("Opto Voltage Out: %f\n", starOptoVoltageOut);
        Print("Pre Stim Opto Time: %f\n", starPreStimOptoTime);
        Print("Post Stim Opto Time: %f\n", starPostStimOptoTime);
        Print("Max Opto Time: %f\n", starMaxOptoTime);
        Print("Probability Of Opto: %f\n", starProbOfOpto);
        
    endif;    
    
    
    
	' close parfile
	FileClose(0);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end



func StringifyBar$()
    var out$;
    var localphase;
    
    out$ := " -B ";  'bar indicator
    out$ := out$ + Str$(starGratingBarXCenter) + ",";
    out$ := out$ + Str$(starGratingBarYCenter) + ",";
    out$ := out$ + Str$(starGratingBarWidth) + ",";
    out$ := out$ + Str$(starGratingBarHeight) + ",";
    out$ := out$ + "0,0,";  'inner width of 0, inner height of 0
    out$ := out$ + Str$(starGratingBarContrast%) + ",";
    out$ := out$ + Str$(starGratingBarSpFreq) + ",";
    out$ := out$ + "0,90,";  'temporal frequency of 0, orientation of 90 (vertical bar)
    docase
    case starGratingBarColorAtCenter% = 0 then
        localphase := 180;  'Center is white, use phase 180
    case starGratingBarColorAtCenter% = 1 then
        localphase := 0; 'Center is black, use phase 0
    else
        localphase := starGratingBarPhase;  'Use specified phase value
    endcase
    out$ := out$ + Str$(localphase) + ",";
    out$ := out$ + "b,";  'Use b/w color vector
    if starGratingBarIsSquarewave% = 1 then
        out$ := out$ + "q,";  'Use squarewave grating
    else
        out$ := out$ + "s,";  'Use sinewave grating
    endif;
    out$ := out$ + "r ";  'Use rectangular aperture  
    
    return out$;
end
