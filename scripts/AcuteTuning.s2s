' $Id$
const tunCVSID$ := "$Id$";

'var TuningCurveScriptDialogAllowOK%;  'allows OK to button to work on main dialog

' CHANGELOG:
'   

#include "../util/ChannelUtilities.s2s"
#include "../util/UsreyUtil.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "AcuteTuningDialogs.s2s"
#include "UsreyGratings.s2s"
#include "UsreyDAQ.s2s"


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'render fallback IP, NOTE: this *MUST* by updated manually following render system reboots
'this *SHOULD* be set in Config under "DAQ->Remote IP"
const RENDERDEFAULTIP$ := "128.120.140.49";

'Port number for stim and ready channels
const STIMCHANNELPORT% := 3; 'MUST be 0-7
const READYCHANNELPORT% := 2;

'bit representation of the port number (port 3 = bit 4 = 0001 = 8)
'NOTE: ports are 0-based so port 3 is the 4th port and thus 4th bit
'var STIMCHANNELCODE%;
'STIMCHANNELCODE% := Pow(2, STIMCHANNELPORT%);
'
'DJS Use ready channel for the reasy pulse. 
' Rename vars to make sure
var READYCHANNELCODE%;
READYCHANNELCODE% := Pow(2, READYCHANNELPORT%);

' replace vars herezzzzzzzzzzzzzzzz

' This vector will hold the actual values to step through. Some are log steps, some are not. 
' The Indices array is the order to step through the values with: tunValues[tunValuesIndices%[0]], tunValues[tunValuesIndices%[1]], ...
' djs Make a constant tunMaxTrials to set the max number of trials. Arrays etc should be declared with this const. See below and
' tunF1Sum, tunF2Sum. 
const tunMaxTrials% := 10000;
var tunValues[tunMaxTrials%];
var tunValuesIndices%[tunMaxTrials%]; 
var tunTwoWayContrastValues[tunMaxTrials%];
var tunConditionedContrastValues[tunMaxTrials%];
var tunNValues%;
var tunValuesStringified$;
var tunDurValuesStringified$;
var nTriggersExpected%;     'only for tunTypeCRG$
var triggerCount%;
var isConditioningStimulus%;  'really only useful for Conditioned Contrast
var tunThisStimulusDuration;  'again, only useful for Conditioned Contrast, though we will need to fill it no matter what



' Wavemarks and continuous ports are specified elsewhere
var tunNWavemarks% := 0;  'This is really the number of Wavemark CHANNELS, hence the number of 'trodes
var tunWavemarkPorts%[16];
var tunNContinuous% := 0;
var tunContinuousPorts%[16];


'Variables for creating rasters
var memChanRasterTriggers%;  'a memory channel that holds raster triggers
var memChanRasterTriggersOpto%;  'a memory channel that holds raster trigger for the opto state
var memChanBetterTextMark%;  'a memory channel that mimics the textmark channel, but with better temporal fidelity
var handlePSTH%[32];         'a list of PSTH handles
var stimCodes%[4];           'For the raster textmark channel; we'll only use index 0 but the textmark requires a 4-length vector
var rasterTotal;  'total duration for raster
var rasterPre := .2;  'Hard coded for now, will change if necessary
var rasterPost := 0;  'No post-stim for now, but this will facilitate a change in the future
var histBinWidth := 0.05;  'Just throwing out 50 ms as a number
var histBins%;
var histBins2%;
var myTitle$;
var myTitle2$;
var trodes[10];  'global, for creating rasters at the end
var vals[30];    'global, for creating rasters at the end
var handlePSTHend%[10];  'For creating rasters at the end

' Hold sum of F1 values. Each channel (up to 16) has values saved according to the index of the tuning value
' Rely on the fact that arrays are initialized with 0s in Spike2. 
var tunF1Sum[16][tunMaxTrials%];
var tunF2Sum[16][tunMaxTrials%];
var tunF1OptoSum[16][tunMaxTrials%];
var tunF2OptoSum[16][tunMaxTrials%];
var tunF1SumDesc[16][tunMaxTrials%];  'We need to have these also keep separate track of descending for two-way contrast
var tunF2SumDesc[16][tunMaxTrials%];
var tunF1OptoSumDesc[16][tunMaxTrials%];
var tunF2OPtoSumDesc[16][tunMaxTrials%];
var tunTF;              ' Will need to use this during FFT analysis. Use at your own risk....
'var tunF1Cum[16];  'These are unused, their lines are all commented out
'var tunF2Cum[16];
'var tunRateCum[16];

' djs 10-19-11 trigger hack for Visage trigger bug.
var tunTriggerHack% := 0;  'setting to 0 to read from stim channel due to RENDER trigger line hell
var renderIsBroken% := 0;  'if 1, Render is not sending pulses, just fly blind!!!

var memorychannel% := 28;
var memorychannel2% := 29;
var memorychannelopto% := 45;  'avoiding textmarks
'var memorychannelvisible% := 0;  'unused...?

var optoOffChan% := 1;  'This will be the primary channel on the histogram
var optoOnChan%;
var optoOffF1Chan%;
var optoOnF1Chan%;
var optoOffF2Chan%;
var optoOnF2Chan%;
var optoOffChanDesc%;
var optoOnChanDesc%;
var optoOffF1ChanDesc%;
var optoOnF1ChanDesc%;
var optoOffF2ChanDesc%;
var optoOnF2ChanDesc%;
var burstChan%;


' replace hereZZZZZZZZZZZZZZZZZZZZZZZZZZ

' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;
var StimulatorChannel%;
var OptoEfferenceChannel%;
var PhotodiodeChannel%;
var SequencerPeriodMS;
var CameraTriggerChannel%;
var TemperatureChannel%;
var EEGChannel%;
var UtilityChannel%;

' xy windows for plotting (TuningWindow) and PSTH. 
var TuningWindow%[16];	' one for each wavemark channel
var PSTHWindow%[16];    ' used for f1 and f2. Will be made invisible when in use. 

' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Init logging
LogInit(1);

' run parameters script....
tunContext$ := tunContextDAQ$;
tunType$ := tunTypeNone$;

GetTuningCurveScriptParameters();
iScript% := TuningCurveScriptDialog%();
if iScript% = 1 then
	if tunType$ = tunTypeNone$ then
		LogInfo("No tuning type selected, exit gracefully\n");
		Halt;
	else
		'LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ. DoRivalry = " + str$(tunDoRivalry%));
        LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ.");
	endif;
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' When TF curve or TF = 0, don't do f1 and f2. 
if tunType$ = tunTypeTemporal$ or GetTemporalFrequency() = 0 then
    tunDoF12% := 0;
endif


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
StimChannel% := 25;
ReadyChannel% := 26;            ' Look for ready signal on port 2 (same as fixpt). 
FrameChannel% := 27;
StimulatorChannel% := 35;
OptoEfferenceChannel% := 36;
CameraTriggerChannel% := 37;
TemperatureChannel% := 38;
PhotodiodeChannel% := 39;
EEGChannel% := 40;
UtilityChannel% := 41;

ExcludedChans%[0] := 21;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 42;  'leaving a bit of room, right now 37 is highest channel used


' Fetch electrode information. 
tunNWavemarks% := GetWavemarkPorts%(tunWavemarkPorts%[]);
tunNContinuous% := GetContinuousPorts%(tunContinuousPorts%[]);

CreateSampleConfiguration();


' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()
    
    if DisplayHardwareIndex% = 1 then
        'reset render: while this doesn't fix the pin-stuck-high issue (that is fixed in stop() )
        'it does remove the green calibration square if render is in that state (e.g. it's been restarted)
        'the backgroud is not set (usually ends up black, but that is set by the tuning scripts so it's fine)
        ProgRun("cmd /c C:\\Users\\Lab\\Desktop\\render_relay\\reset.bat");
    endif
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
'	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
'	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before fix point is presented)
var tRise, tFall;

' Constants for states
const stateStartTrial%:=0;		' Start trial state
'const stateWaitForStimOn%:=3;		' Wait for stimulus return trigger (on), this has been replaced entirely by stateWaitForStimTrigger ¯\_(ツ)_/¯
const stateWaitForStimOff%:=4;		' Wait for stimulus return trigger (off)
const stateStimulusPlaying%:=5;     ' New, wait for tNow to exceed stimulus duration
const stateMaintainFixation%:=8;	' Maintaining fixation (stim off period)
const stateInterTrialInterval%:=9;	' time out after failed trial
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForStimTrigger% := 14; ' Rising edge indicating start of stim sequence
const stateBarPlaying%:=15;
const stateWaitingForBarOff%:=16;
const stateCRGPlaying%:=17;
const stateWaitingForCRGOff%:=18;
const stateStartOpto%:=19;
const stateWaitOptoPrestim%:=20;
const stateCheckTurnOnOpto%:=21;
const stateCheckTurnOffOpto%:=22;
const stateTurnOffOpto%:=23;
const stateWaitOptoPoststim%:=24;
const statePulsedOpto%:=25;
const stateWaitPulsedOpto%:=26;
const stateWaitCameraTrigger%:=27;
const stateWaitCameraBaselinePeriod%:=28;
const stateSendNeuropixelStart%:=29;  'we are not sure if we can even trigger the GLX remotely.  Keep skeleton as there is a good chance we will need this in the future for other software.


var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 

const cameraModeNone% := 0;
const cameraModeWait% := 1;
const cameraModeTrigger% := 2;

var triggeredCamera% := 0;

' ============================================================================ '
' Serial Port constants
' ============================================================================ '
const serialCOMPort% := 8; 
const serialBaudRate% := 115200;
const serialDataBits% := 8;
const serialParity% := 0;
const serialStopBits% := 1;
const serialFlowCtrl% := 0;

var neuropixelStatus%;
var autoNameStr$;
var stimOffTime;
var tOpt;
var pulseFound%;
var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
tic := View(DataWindow%).BinSize(ReadyChannel%);

func IdleProcessing%()
	var iStatus% := 1;	
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    if tLast < 0 then
        tLast := 1;
        return 1;
    endif
    
	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        'if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tRise, tFall) = 1 then
        if DisplayHardwareIndex% = 1 then  'RENDER does not give a ready pulse.  In the future, it will, and the first half of this statement will need to be removed
            pulseFound% := 1;
            tFall := tNow;
        else
            pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        endif;
        if pulseFound% = 1 then  
            'yield(0.5);  'this pause is because we can't find the ready pulse from Render
            LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
            'Yield(1.0);
            tLastTrigger := tFall;
            'ChangeStateTo(stateCheckTurnOnOpto%, tFall);
            docase
            case tunDoNeuropixel% = 1 then
                ChangeStateTo(stateSendNeuropixelStart%, tFall);
            case tunCameraMode% = cameraModeWait% then
                ChangeStateTo(stateWaitCameraTrigger%, tFall);
            else
                ChangeStateTo(stateInterTrialInterval%, tFall);
                'ChangeStateTo(stateCheckTurnOnOpto%, tFall);
            endcase;
        else
            if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                tLastTrigger := tFall;
            endif;
        endif;
        
        
        
    case iState% = stateSendNeuropixelStart% then
        'We would do one of two things here, either trigger a DIG I/O line up, or send a 
        'serial instruction (and wait for a return serial acknowledgment), but we are not
        'certain at this moment that either will work.
        'autoNameStr$ := FileName$(2) + FileName$(3) + FileName$(4);
        autoNameStr$ := dataDataSet$ + "_" + FileName$(-4);
        printlog("Sending START to Neuropixel, using name string '%s'\n",autoNameStr$);
        
        neuropixelStatus% := SendSerialMsgNeuropixel(serialCOMPort%, "START " + autoNameStr$, "\n");
        if neuropixelStatus% = 0 then
            message("SpikeGLX recording did not successfully start!  Quitting!"); 
            Stop%();
        endif;
        
        'ChangeStateTo(stateInterTrialInterval%, tFall);  'this will allow us to go forward in the event we accidentally check the DoNeuropixel box
        
        ChangeStateTo(stateInterTrialInterval%, View(DataWindow%).MaxTime());  'If implemented, put in a real time for tStateStart
        
    case iState% = stateWaitCameraTrigger% then
        if View(DataWindow%).FindPulseUp%(CameraTriggerChannel%, -1, tRise, tFall) = 1 then
            LogStatus("CameraWait", "Got Shutter Pulse from Camera at " + str$(tRise));
            tLastTrigger := tFall;
            if tunCameraBaselinePeriod > 0 then
                ChangeStateTo(stateWaitCameraBaselinePeriod%, tFall);
            else
                ChangeStateTo(stateCheckTurnOnOpto%, tFall);
            endif;
        endif;
        
        
        
    case iState% = stateWaitCameraBaselinePeriod% then  'note that this is a pretty sloppy way to do this, timewise.  However, Scottie will be using pulses to sync the camera so this is OK.
        if tNow >= tStateStart + tunCameraBaselinePeriod then
            ChangeStateTo(stateCheckTurnOnOpto%, tNow);
        endif;
        
        
        
    case iState% = stateCheckTurnOnOpto% then
        'printlog("tunOptoUsePulse is %d and tunOptoState is %d and dontToggleOpto is %d\n",tunOptoUsePulse%,tunOptoState%,dontToggleOpto%);
        docase
        case tunDoOpto% = 0 then 'if this is not an opto trial, just start it
            ChangeStateTo(stateStartTrial%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tNow);
        case isConditioningStimulus% = 1 then 'well, it could potentially be an opto trial, but we won't stimulate during the conditioning stimuli
            ChangeStateTo(stateStartTrial%, tNow);
            printlog("Conditioning stimulus, not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tNow);
        case tunOptoUsePulse% = 1 and tunOptoState% = 0 then 'if this is a pulsed opto scenario, but not an opto trial, just start it
            'This is the same as the above step, separated to make the logic of the case statement easier
            ChangeStateTo(stateStartTrial%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tNow);
        case tunOptoUsePulse% = 1 and tunOptoState% = 1 then  'it is a pulsed opto trial, the sequencer will time this
            ChangeStateTo(statePulsedOpto%,tNow);
        case tunOptoStaysOn% = 1 and (nTrialsCompleted% mod (tunNAdvances%+1)) <> 0 then 'this is for when we're keeping the opto on and it's mid block
            ChangeStateTo(stateStartTrial%, tNow);
            printlog("Opto is already on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",tunOptoStaysOn%,(nTrialsCompleted% mod (tunNAdvances%+1)),tNow);
        else 'otherwise it is a wraparound opto trial and we need to turn opto on
            ChangeStateTo(stateStartOpto%, tNow);
            printlog("Turning Opto On at time = %f\n",tNow);
        endcase
        
        
    case iState% = statePulsedOpto% then
        
        if tunPulsedOptoIPImax <> tunPulsedOptoIPImin then
            'Set random IPI every trial
            tunPulsedOptoIPI := Rand(tunPulsedOptoIPImax-tunPulsedOptoIPImin,tunPulsedOptoIPImin);  'this will work if max=min or even if max<min.  Simple.  Nice.
            SetPulsedOptoSequencerVariables();
            SampleText("Pulsed Opto IPI is " + str$(tunPulsedOptoIPI));
        endif     
        
        if tunPulsedOptoOnsetMax <> tunPulsedOptoOnsetMin then
            'Set random onset on every trial
            tunPulsedOptoOnset := Rand(tunPulsedOptoOnsetMax-tunPulsedOptoOnsetMin,tunPulsedOptoOnsetMin);  'this will work if max=min or even if max<min.  Simple.  Nice.
            SetPulsedOptoSequencerVariables();
            SampleText("Pulsed Opto Onset is " + str$(tunPulsedOptoOnset));
        endif 
        
        SafeSampleKey("P");  'start pulsed opto, the whole sequence is controlled by the sequencer
        tOpt := View(DataWindow%).MaxTime();
        SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)));
        ChangeStateTo(stateWaitPulsedOpto%, tNow);
        printlog("Started opto trial at %f\n",tNow);
        
        
    case iState% = stateWaitPulsedOpto% then 'wait for sequencer-controlled timing to complete
        if tNow > tStateStart + tunStimulusDuration + 0.1 then 'wait an extra tenth of a second just in case
            ChangeStateTo(stateTrialCompleted%,tNow);
            
            
            'Set stimCodes[0] to hold the index of the current stimulus
            stimCodes%[0] := tunValuesIndices%[nTrialsCompleted%]; 'nTrialsCompleted has not yet been incremented, so this is right
            'log stimulus start time in pseudotextmark channel and for raster triggering
            if tunOptoState% = 0 then
                view(DataWindow%).MemSetItem(memChanRasterTriggers%,0,tOpt,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            else
                view(DataWindow%).MemSetItem(memChanRasterTriggersOpto%,0,tOpt,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            endif;
            
            view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tOpt,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            ' Process spikes
            PlotSpikes(tOpt, tNow-0.1, tunOptoState%+1, nTrialsCompleted%);
            
            
            'the "X" is not necessary as the pulsed opto sequence does the stimulus-off.  But maybe somebody someday will want to SEE the "X"...can uncomment if so
            'SafeSampleKey("X"); 
            'Advance, this we DO have to do
            SafeSampleKey("a");
            nTrialsCompleted% += 1;  'trial is complete
            SampleSeqVar(6,tunOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens on trial #2
            printlog("Completed opto trial at %f\n",tNow);
        endif;
        
        
    case iState% = stateStartOpto% then
        if tunOptoState% = 1 then 'this is an opto-on trial
            SafeSampleKey("O");  'turn on opto
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("OptoOn",tOpt);
        else 'this is an opto-off trial
            SafeSampleKey("N");  'don't turn on opto
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("NoOpto",tOpt);
        endif;
        
        ChangeStateTo(stateWaitOptoPrestim%, tNow);
        
        
    case iState% = stateWaitOptoPrestim% then
        if tNow > tStateStart + tunPreStimOptoTime then
            ChangeStateTo(stateStartTrial%, tNow);
        endif;
        

    case iState% = stateStartTrial% then
       
        
        ' Start trial. Put up stimulus.
        LogStatus("StartTrial", "Request stimulus");
        docase
        case tunType$ = tunTypeTwoWayContrast$ then  'We need to write a distinct SampleText for two-way contrast to indicate ascending, descending stimuli
            SampleText("T," + GetPlotXCoordTWC$(nTrialsCompleted%));
        case tunType$ = tunTypeConditionedContrast$ and isConditioningStimulus% = 1 then
            SampleText("Conditioning Stimulus," + str$(GetPlotXCoord(nTrialsCompleted%)));  'straight GetPlotXCoord should work here, nothing fancy
        case tunType$ = tunTypeConditionedContrast$ and isConditioningStimulus% = 0 then
            SampleText("T," + GetPlotXCoordCC$(nTrialsCompleted%));
        case tunType$ = tunTypeBorderOwnership$ then
            SampleText("T," + BorderOwnershipString$(GetPlotXCoord(nTrialsCompleted%)));
        else
            SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)));
        endcase;
        
        'Update stimulus duration based on whether this is a Conditioning stimulus, so we know when to send the "X"
        if isConditioningStimulus% = 1 then
            tunThisStimulusDuration := tunConditionedContrastDuration;
        else
            tunThisStimulusDuration := tunStimulusDuration;
        endif;
        
        SafeSampleKey("S");
        'iHoldCount% := 0;
        ChangeStateTo(stateWaitForStimTrigger%, tNow);
    

    case iState% = stateWaitForStimTrigger% then
        
        
        if renderIsBroken% = 1 then
            tTrigger := tNow;  'faking a trigger time if Render is broken
        endif
        
        if tunTriggerHack% = 0 then
            if View(DataWindow%).FindRisingEdge%(StimChannel%, tLast, tTrigger) = 0 or renderIsBroken% = 1 then
                ' Stimulus has begun
                LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tTrigger));
                tStimOn := tTrigger;
                tLastTrigger := tTrigger;
                'ChangeStateTo(stateHoldFixation%, tTrigger);
                docase
                case tunType$ = tunTypeCRG$ then
                    ChangeStateTo(stateCRGPlaying%, tTrigger);
                case tunType$ = tunTypeDriftingBar$ then
                    ChangeStateTo(stateBarPlaying%, tTrigger);
                else
                    ChangeStateTo(stateStimulusPlaying%, tTrigger);
                endcase;                
            endif
        else
            if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1  or renderIsBroken% = 1 then
                ' Stimulus has begun
                LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tRise));
                tStimOn := tRise;
                tLastTrigger := tRise;
                docase
                case tunType$ = tunTypeCRG$ then
                    ChangeStateTo(stateCRGPlaying%, tRise);
                case tunType$ = tunTypeDriftingBar$ then
                    ChangeStateTo(stateBarPlaying%, tRise);
                else
                    ChangeStateTo(stateStimulusPlaying%, tRise);
                endcase;
            endif
        endif
        
        
    case iState% = stateStimulusPlaying% then

        if tNow - tStateStart > tunThisStimulusDuration then  'was tunStimulusDuration, but this will now allow stimulus duration to be variable
            
            ' turn off stimulus and advance it
            SampleText("+");
            LogStatus("StimulusPlaying", "Turn off and advance stimulus.");
            
            SafeSampleKey("X");            
                        
            Yield();
            
            'Set stimCodes[0] to hold the index of the current stimulus
            stimCodes%[0] := tunValuesIndices%[nTrialsCompleted%]; 'nTrialsCompleted has not yet been incremented, so this is right
            'log stimulus start time in pseudotextmark channel and for raster triggering
            if tunOptoState% = 0 then
                view(DataWindow%).MemSetItem(memChanRasterTriggers%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            else
                view(DataWindow%).MemSetItem(memChanRasterTriggersOpto%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            endif;
            
            view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            
            ' Process spikes, do not do this on conditioning stimuli
            if isConditioningStimulus% = 0 then
                PlotSpikes(tStimOn, tNow, tunOptoState%+1, nTrialsCompleted%);
            endif;
            
            
            ' Now wait until stim is off
            ChangeStateTo(stateWaitForStimOff%, tNow);
            
        endif
        
        
        
    case iState% = stateWaitForStimOff% then
        
        if renderIsBroken% = 1 then
            tTrigger := tNow;  'faking a trigger time if Render is broken
        endif
        
        if tunTriggerHack% = 0 then
            if View(DataWindow%).FindFallingEdge%(StimChannel%, tLast, tTrigger) = 1  or renderIsBroken% = 1 then
                ' Advance
                SafeSampleKey("a");

                tLastTrigger := tTrigger;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            endif
        else
            if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1  or renderIsBroken% = 1 then
                ' Advance
                SafeSampleKey("a");

                tLastTrigger := tRise;
                ChangeStateTo(stateCheckTurnOffOpto%, tRise);
            endif
        endif
        
        
    case iState% = stateBarPlaying% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar is off screen
            
            'Note stimulus is off
            SampleText("+");
            LogStatus("BarPlaying", "Turn off and advance stimulus.");          
            
            SafeSampleKey("X");            
            
            Yield();
            
            ' Process spikes
            PlotSpikes(tStimOn, tNow, tunOptoState%+1, nTrialsCompleted%);
            
            'Advance
            'SafeSampleKey("a");

            tLastTrigger := tRise;
            'ChangeStateTo(stateTrialCompleted%, tRise);
            ChangeStateTo(stateWaitingForBarOff%, tRise);
        endif
        
    case iState% = stateWaitingForBarOff% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar stimulus has been turned off
            
            'Advance
            SafeSampleKey("a");
            
            tLastTrigger := tRise;
            ChangeStateTo(stateCheckTurnOffOpto%, tRise);
        endif;
        
        
   case iState% = stateCRGPlaying% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar is off screen
            
            triggerCount% += 1;
            tStateStart := tRise;  'reset time to find all triggers
            'printlog("Found trigger %d at %f\n",triggerCount%,tStateStart);
            
            if triggerCount% = nTriggersExpected% then
            
                'Note stimulus is off
                stimOffTime := tStateStart;
                SampleText("+",tStateStart);
                'Log time of offset only in pseudotextmark channel
                view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tStateStart,stimCodes%[],"+");
                LogStatus("CRGPlaying", "Turn off and advance stimulus.");          
            
                SafeSampleKey("X");            
            
                Yield();
                
                'Set stimCodes[0] to hold the index of the current stimulus
                stimCodes%[0] := tunValuesIndices%[nTrialsCompleted%]; 'nTrialsCompleted has not yet been incremented, so this is right
                'log stimulus start time in pseudotextmark channel and for raster triggering
                if tunOptoState% = 0 then
                    view(DataWindow%).MemSetItem(memChanRasterTriggers%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
                else
                    view(DataWindow%).MemSetItem(memChanRasterTriggersOpto%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
                endif;
                
                view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));            
                
                ' Process spikes
                PlotSpikes(tStimOn, tNow, tunOptoState%+1, nTrialsCompleted%);

                tLastTrigger := tRise;
                'ChangeStateTo(stateTrialCompleted%, tRise);
                ChangeStateTo(stateWaitingForCRGOff%, tRise);
            endif;
            
        endif
        
    case iState% = stateWaitingForCRGOff% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar stimulus has been turned off
            printlog("Maxtime is now %f, writing sample text\n",view(DataWindow%).maxtime());
            'Advance
            SafeSampleKey("a");
            triggerCount% := 0;
            
            tLastTrigger := tRise;
            ChangeStateTo(stateCheckTurnOffOpto%, tRise);
        endif;  
        
        
    case iState% = stateCheckTurnOffOpto% then
        nTrialsCompleted% += 1;  'trial is complete, change of count here makes logic easier 
        docase
        case tunDoOpto% = 0 or (tunOptoState% = 0 and tunOptoUsePulse% = 1) then 'if this is not an opto trial, trial is complete
            ChangeStateTo(stateTrialCompleted%, tStateStart);
            printlog("Trial complete, Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tStateStart);
        case tunOptoStaysOn% = 1 and (nTrialsCompleted% mod (tunNAdvances%+1)) <> 0 then 'this is for when we're keeping the opto on and it's mid block
            ChangeStateTo(stateTrialCompleted%, tStateStart);
            printlog("Opto is staying on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",tunOptoStaysOn%,(nTrialsCompleted% mod (tunNAdvances%+1)),tStateStart);
        else 'otherwise it is an opto trial and we need to turn opto off
            ChangeStateTo(stateWaitOptoPoststim%, tStateStart);
            printlog("Turning Opto Off at time = %f\n",tStateStart);
        endcase
        
        
        
    case iState% = stateWaitOptoPoststim% then
        if tNow > tStateStart + tunPostStimOptoTime then
            ChangeStateTo(stateTurnOffOpto%, tNow);
        endif;
        
        
    case iState% = stateTurnOffOpto% then
        if tunOptoState% = 1 then
            SafeSampleKey("o");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOff at %f\n",tOpt);
            SampleText("OptoOff",tOpt);
        else
            SafeSampleKey("n");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOff at %f\n",tOpt);
            SampleText("NoOptoSoNoOff",tOpt);
        endif;
        
        ChangeStateTo(stateTrialCompleted%,tNow);        
        
        
    case iState% = stateTrialCompleted% then
        printlog("number of trials completed is %d\n",nTrialsCompleted%);
        
'        'Set stimCodes[0] to hold the index of the current stimulus
'        stimCodes%[0] := tunValuesIndices%[nTrialsCompleted%]; 'nTrialsCompleted has not yet been incremented, so this is right
'        'log stimulus start time in pseudotextmark channel and for raster triggering
'        if tunOptoState% = 0 then
'            view(DataWindow%).MemSetItem(memChanRasterTriggers%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
'        else
'            view(DataWindow%).MemSetItem(memChanRasterTriggersOpto%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
'        endif;
'        
'        view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
'        
'        ' Process spikes
'        PlotSpikes(tStimOn, tNow, tunOptoState%+1, nTrialsCompleted%);
        
        'if we are doing conditioned contrast, update variable tracking whether this is a conditioning stimulus
        if tunType$ = tunTypeConditionedContrast$ then
            isConditioningStimulus% := 1-isConditioningStimulus%;
        endif;
        
        'if we are doing two-way contrast, check to see if it is the gap between the stimuli
        var isDescending1%;
        var isDescending2%;
        if tunType$ = tunTypeTwoWayContrast$ and nTrialsCompleted% > 0 then
            GetPlotXCoordTWC(nTrialsCompleted%-1,isDescending1%);
            GetPlotXCoordTWC(nTrialsCompleted%,isDescending2%);
        endif;
        
        
        
        docase
        case nTrialsCompleted% = (tunNAdvances%+1)*tunNRepeats% then
            ' We're all done
            'ChangeStateTo(stateDone%, tNow);  'This does nothing, stateDone% does not exist!
            Stop%();
            iStatus% := 0;
        case (nTrialsCompleted% mod (tunNAdvances%+1)) = 0 then 'toggle tunOptoState at the end of a block, use interblock time
            if tunDoOpto% = 1 and dontToggleOpto% = 0 then
                tunOptoState% := 1-tunOptoState%;  'but only toggle if we're actually doing opto, and we haven't been told to not toggle opto
            endif;
            if tunType$ = tunTypeTwoWayContrast$ then
                tInterTrialTime := tunTwoWayContrastReverseDelay;  'On block change for Two-Way Contrast, respect the specified reversal delay, not the interblock time
            else
                tInterTrialTime := tunInterTrialTime + tunInterBlockTime;
            endif;
            ChangeStateTo(stateInterTrialInterval%, tNow);
        case tunType$ = tunTypeTwoWayContrast$ and isDescending1% <> isDescending2% then
            tInterTrialTime := tunTwoWayContrastReverseDelay;
            ChangeStateTo(stateInterTrialInterval%, tNow);
        else
            tInterTrialTime := tunInterTrialTime;
            ChangeStateTo(stateInterTrialInterval%, tNow);
        endcase        
        
        view(datawindow%).MemSave(memChanRasterTriggers%,memorychannel%,0,1);
        view(datawindow%).MemSave(memChanRasterTriggersOpto%,memorychannelopto%,0,1);
        view(datawindow%).MemSave(memChanBetterTextMark%,memorychannel2%,0,1);
        
        triggeredCamera% := 0;
        

    case iState% = stateInterTrialInterval% then
        ' HERE is where we write to the SerialPort
        if ((tunCameraMode% = cameraModeTrigger%) and (triggeredCamera% = 0)) then
            'printlog("tnow = %f, tstatestart = %f, tintertrial = %f, camerabaseline = %f\n",tNow,tStateStart,tInterTrialTime,tunCameraBaselinePeriod);
            if (tNow - tStateStart) > (tInterTrialTime - tunCameraBaselinePeriod) then
                var msg$;
                msg$ := str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]);                
                SendSerialMsg(serialCOMPort%, msg$, "\n");
                triggeredCamera% := 1;
                samplekey("z");
            endif
        endif
        'printlog("tnow = %f, tstatestart = %f, tintertrial = %f\n",tNow,tStateStart,tInterTrialTime);
        if (tNow - tStateStart) > tInterTrialTime then
            ChangeStateTo(stateCheckTurnOnOpto%, tNow);
        endif
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;
' ============================================================================ '
' Send a message to an open serial port and read an AWK reply
' ============================================================================ '
proc SendSerialMsg(port%, msg$, term$)
    var buffer$;
    SerialWrite(port%, msg$, term$);
    SerialRead(port%, buffer$, term$);
    if not (buffer$ = "AWK") then
        PrintLog("[ERROR]: Failed to receive AWK from imaging acq machine\n");
    endif
end;


func SendSerialMsgNeuropixel(port%, msg$, term$)
    var buffer$;
    var count% := 60;  'Yikes, it takes a long time to get the Neuropixel stuff ready!
    var status% := 0;
    SerialWrite(port%, msg$, term$);
    while count% > 0 and status% < 1 do
        count% := count% - 1;
        status% := SerialRead(port%, buffer$, term$);
        printlog("read status %d buffer %s\n", status%, buffer$);
        if status% > 0 then
            if not (buffer$ = "ACK") then
                PrintLog("[ERROR]: Failed to receive ACK from imaging acq machine\n");
                message("Received error from Neuropixel listener!  Error is\n" + buffer$);
                status% := 0;
                break;
            endif
        endif
    wend;
    if status% > 0 then
        return 1;
    else
        return 0;
    endif    
end;


func GetPlotXCoord(nTrials%)
    return tunValues[tunValuesIndices%[nTrials%]];
end;


func GetPlotXCoordTWC(nTrials%,&isDescending%)
    var temp;
    temp := tunValues[tunValuesIndices%[nTrials%]];
    if temp <= 100 then
        isDescending% := 0;
        return temp;
    else
        isDescending% := 1;
        return temp-100;
    endif;
end;


func GetPlotXCoordTWC$(nTrials%)
    var temp;
    temp := tunValues[tunValuesIndices%[nTrials%]];
    if temp <= 100 then
        return Str$(temp) + ", ascending";
    else
        return Str$(temp-100) + ", descending";
    endif;
end;


func GetPlotXCoordCC$(nTrials%)
    var temp;
    var tempC;
    temp := tunValues[tunValuesIndices%[nTrials%]];
    tempC := tunValues[tunValuesIndices%[nTrials%-1]];
    if temp <= 100 then
        return Str$(temp) + ", conditioning contrast " + Str$(tempC);
    else
        return Str$(temp-100) + ", conditioning contrast " + Str$(tempC);
    endif;
end;


func GetPlotXIndex%(nTrials%)
    return tunValuesIndices%[nTrials%];
end;



proc PlotSpikes(t1, t2, whichPlot%, index%)
	var rate;
    var i%;
    var tSweep;
    var fftData[16];        ' size of this array should be same as number of bins! 
    var x;  'the x value to plot
    var xind%;  'the x value index
    var mCd1%;
    var mCd2%;
    var preEvent;
    var myCount%;  'for bursts
    var myCount2%; 'for bursts
    var t[10000];  'for bursts, we shouldn't have more than 10000 spikes in a window here
    var nBursts%;
    var isDescending%;
    
    'whichPlot% is a switch that allows us to plot (in this case) opto-on and opto-off with different colors
    
    
    if tunType$ = tunTypeTwoWayContrast$ or tunType$ = tunTypeConditionedContrast$ then
        x := GetPlotXCoordTWC(index%,isDescending%);  'Will get correct x-value, fill isDescending
    else
        x := GetPlotXCoord(index%);  'Getting correct x-value is trivial
    endif;
    
    'xind% := GetPlotXIndex%(index%);  'for keeping an average...may be difficult to implement (currently unused!)
    
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
        'tunRateCum[i%] := tunRateCum[i%] + rate;  
        'if tunRateCum[i%] >= 0 then  
        if rate >= 0 then
            if whichPlot% = 1 then
                if isDescending% = 0 then
                    View(TuningWindow%[i%]).XYAddData(optoOffChan%, x, rate);    ' channel 1 is opto-off; channel 2 is opto-on
                else
                    View(TuningWindow%[i%]).XYAddData(optoOffChanDesc%, x, rate);
                endif;
            else
                if isDescending% = 0 then
                    View(TuningWindow%[i%]).XYAddData(optoOnChan%, x, rate);
                else
                    View(TuningWindow%[i%]).XYAddData(optoOnChanDesc%, x, rate);
                endif;
            endif;
        
                'if whichPlot% = 1 then
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				'View(TuningWindow%[i%]).XYAddData(1, x, rate);    ' channel 1 is data; channel 2 is background
                'Grr.  Deleting data will make this hard.
                'View(TuningWindow%[i%]).XYSort(1,1);  'sort by x
                'View(TuningWindow%[i%]).XYDelete(1,index2%);  'delete the last entry for this value
                'View(TuningWindow%[i%]).XYAddData(1, x, tunRateCum[i%]/(index%+1));    ' channel 1 is data; channel 2 is background
			'endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
        
        'I'm not yet confident this will work as I'm envisioning it...
        if tunHistogramBursts% = 1 then  'use channel burstChan% for bursts
            ArrConst(t[],0);  'clear time array
            myCount% := view(DataWindow%).ChanData(i%+1, t[], t1, t2);  'This gets a count of the number of spikes in the DESIRED window
            myCount2% := view(DataWindow%).ChanData(i%+1, t[], t1-0.1, t2);   'This gets a count of the number of spikes in the desired window PLUS 100 ms before, because it might be different
            nBursts% := BurstCount(myCount2%,t[],myCount2%-myCount%);  'This finds and counts bursts
            if nBursts% >= 0 then
                View(TuningWindow%[i%]).XYAddData(burstChan%, x, nBursts%);    
            'else
                'View(TuningWindow%[i%]).XYAddData(burstChan%, x, 3.14);  'testing
            endif;
        endif;
        
        if whichPlot% = 1 then
            'update the raster even if there are no spikes on this trial
            view(handlePSTH%[i%]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggers%,rasterTotal,rasterPre,stimCodes%[0]);  'Update single-stim histogram        
            'And update the title, to indicate which stimulus it is
            view(handlePSTH%[i%]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[i%]+1) + myTitle2$ + Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));  'Rename single-stim histogram
        else
            'update the raster even if there are no spikes on this trial
            view(handlePSTH%[i%+8]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggersOpto%,rasterTotal,rasterPre,stimCodes%[0]);  'Update single-stim histogram        
            'And update the title, to indicate which stimulus it is
            view(handlePSTH%[i%+8]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[i%]+1) + " Opto On " + myTitle2$ + Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));  'Rename single-stim histogram
        endif
        
        'do Scotty rasters, these are gated so we can do them on every trial and not worry about it
        if tunDoOpto% = 1 then
            if tunOptoUsePulse% = 1 then
                mCd1% := Asc("P");
                mCd2% := Asc("S");
                preEvent := 0;
            else
                mCd1% := Asc("o");
                mCd2% := Asc("n");
                preEvent := tunPreStimOptoTime + 0.5;
            endif;
            
            'update the rasters
            view(handlePSTH%[i%+16]).process(0,view(-1).maxtime(),1,1,0,31,0.5,preEvent,mCd1%); 'stimuli with opto
            view(handlePSTH%[i%+24]).process(0,view(-1).maxtime(),1,1,0,31,0.5,preEvent,mCd2%); 'stimuli with no opto
            'update the titles
            view(handlePSTH%[i%+16]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[i%]+1) + " Opto On");
            view(handlePSTH%[i%+24]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[i%]+1) + " Opto Off");
        endif;
        
            
        'do F1/F2 if requested
        if tunDoF12% = 1 then
            ' Process for each cycle of the stimulus. A single cycle of the stim takes 1/tf
			View(PSTHWindow%[i%]);
			Process(t1, t2, 1, 1);
			for tSweep := t1+1/tunTF to t2-1/tunTF step 1/tunTF do 
				Process(tSweep, tSweep+1/tunTF, 0, 1);
			next
			ArrConst(fftData[], View(PSTHWindow%[i%]).[]);
			ArrFFT(fftData[], 4); 
            
            docase
            case whichPlot% = 1 and isDescending% = 1 then
                View(TuningWindow%[i%]).XYAddData(optoOffF1ChanDesc%, x, fftData[1]);
                tunF1SumDesc[i%][index%] += fftData[1];
                View(TuningWindow%[i%]).XYAddData(optoOffF2ChanDesc%, x, fftData[2]);
                tunF2SumDesc[i%][index%] += fftData[2];
            case whichPlot% = 2 and isDescending% = 1 then
                View(TuningWindow%[i%]).XYAddData(optoOnF1ChanDesc%, x, fftData[1]);  
                tunF1OptoSumDesc[i%][index%] += fftData[1];
                View(TuningWindow%[i%]).XYAddData(optoOnF2ChanDesc%, x, fftData[2]);  
                tunF2OptoSumDesc[i%][index%] += fftData[2];
            case whichPlot% = 1 then  'isDescending% = 0
                View(TuningWindow%[i%]).XYAddData(optoOffF1Chan%, x, fftData[1]);
                tunF1Sum[i%][index%] += fftData[1];
                View(TuningWindow%[i%]).XYAddData(optoOffF2Chan%, x, fftData[2]);
                tunF2Sum[i%][index%] += fftData[2];
            case whichPlot% = 2 then  'isDescending% = 0
                View(TuningWindow%[i%]).XYAddData(optoOnF1Chan%, x, fftData[1]);  
                tunF1OptoSum[i%][index%] += fftData[1];
                View(TuningWindow%[i%]).XYAddData(optoOnF2Chan%, x, fftData[2]);  
                tunF2OptoSum[i%][index%] += fftData[2];
            endcase
            
            
            'This code is old, hasn't been implemented in quite some time and is definitely behind
            'tunF1Cum[i%] += fftdata[1];
            'tunF2Cum[i%] += fftdata[2];
            'View(TuningWindow%[i%]).XYSort(2,1);  'sort by x
            'View(TuningWindow%[i%]).XYSort(3,1);  'sort by x
            'View(TuningWindow%[i%]).XYDelete(2,index2%);  'delete the last entry for this value
            'View(TuningWindow%[i%]).XYDelete(3,index2%);  'delete the last entry for this value
            
            'View(TuningWindow%[i%]).XYAddData(3, x, fftData[2]);
            'View(TuningWindow%[i%]).XYAddData(2, x, tunF1Cum[i%]/(index%+1));
            'View(TuningWindow%[i%]).XYAddData(3, x, tunF2Cum[i%]/(index%+1));
            
            'tunF2Sum[i%][index%] += fftData[2];      
        endif
        
	next
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()
    var i%;
    var WindowStep;
    var ch1%, ch2%, ch3%;
    var tunL, tunR, histL, histR, histOptoL, histOptoR;
    
    'set tunL, etc.
    if tunDoOpto% = 0 then
        tunl := 50;
        tunr := 75;
        histL := 75;
        histR := 100;
    else
        tunl := 50;
        tunr := 66;
        histL := 66;
        histR := 83;
        histOptoL := 83;
        histOptoR := 100;
    endif;
    
    
    ' Get tf of stim
    tunTF := GetStimulusTF();
    
    ' Make spike2 use allof monitor 1
    View(App()).Window(5, 5, 95, 95, 2);
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);
    if DataWindow% < 0 then
        PrintLog("FileNew Error: %s\n", Error$(DataWindow%));
    endif
	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
    
    'Create textmark channel to hold onset times of stimuli
    memChanRasterTriggers% := MemChan(8, 25); 'Create textmarker channel for stimtype
    ChanTitle$(MemChanRasterTriggers%,"RasterTriggers"); 'give it a title, could be useful if channel is saved
    chanhide(MemChanRasterTriggers%); 'hide the memchan, don't need to see it.    
    'chanshow(MemChanRasterTriggers%);
    
    'Create textmark channel to hold onset times of stimuli
    memChanRasterTriggersOpto% := MemChan(8, 25); 'Create textmarker channel for stimtype
    ChanTitle$(MemChanRasterTriggersOpto%,"RasterTriggersOpto"); 'give it a title, could be useful if channel is saved
    chanhide(MemChanRasterTriggersOpto%); 'hide the memchan, don't need to see it.
    
    'Create textmark channel to hold onset times of stimuli
    memChanBetterTextMark% := MemChan(8, 25); 'Create textmarker channel for stimtype
    ChanTitle$(memChanBetterTextMark%,"PseudoTextMark"); 'give it a title, could be useful if channel is saved
    'chanhide(memChanBetterTextMark%); 'hide the memchan, don't need to see it.    
    chanshow(memChanBetterTextMark%);
    
    
	' open xy window to display tuning results    
    if tunNWavemarks% > 0 then
        WindowStep := 100/tunNWavemarks%;
    endif
    for i% := 0 to tunNWavemarks%-1 do
        TuningWindow%[i%] := FileNew(12);
        Window(tunL, i%*WindowStep, tunR, (i%+1)*WindowStep);
        ChanTitle$(0, "Spikes/s");
        TuningCurveLabels(tunWavemarkPorts%[i%]);
        WindowVisible(1);        
       
        
        'Create raster/PSTH result view for each electrode
        rasterTotal := rasterPre + rasterPost + tunStimulusDuration;  'calculate total raster time
        histBins% := rasterTotal/histBinWidth;  'and number of bins
        'handlePSTH%[i%] := View(DataWindow%).SetPsth(tunWavemarkPorts%[i%]+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggers%,3);  '3 makes rasters and scales to spikes per second
        handlePSTH%[i%] := View(DataWindow%).SetPsth(i%+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggers%,3);  '3 makes rasters and scales to spikes per second
        View(handlePSTH%[i%]).windowtitle$("No Data");  'name gets changed later
        View(handlePSTH%[i%]).Window(histL, i%*WindowStep, histR, (i%+1)*WindowStep);  'size window as above, squeeze in
        View(handlePSTH%[i%]).WindowVisible(1);  'make window visible
        
        if tunDoOpto% = 1 then  'Create raster/PSTH result view for each electrode, opto-on
            'handlePSTH%[i%+8] := View(DataWindow%).SetPsth(tunWavemarkPorts%[i%]+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggersOpto%,3);  '3 makes rasters and scales to spikes per second
            handlePSTH%[i%+8] := View(DataWindow%).SetPsth(i%+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggersOpto%,3);  '3 makes rasters and scales to spikes per second
            View(handlePSTH%[i%+8]).windowtitle$("No Data");  'name gets changed later
            View(handlePSTH%[i%+8]).Window(histOptoL, i%*WindowStep, histOptoR, (i%+1)*WindowStep);  'size window as above, squeeze in
            View(handlePSTH%[i%+8]).WindowVisible(1);  'make window visible
            
            'Make PSTH for Scotty
            histBins2% := rasterTotal/.005;  'hard code to 5 ms
            'This one is for opto-on stimuli
            'handlePSTH%[i%+16] := View(DataWindow%).SetPsth(tunWavemarkPorts%[i%]+1,histBins2%,.005,rasterPre,StimChannel%,1);  '1 enables spikes per second
            handlePSTH%[i%+16] := View(DataWindow%).SetPsth(i%+1,histBins2%,.005,rasterPre,StimChannel%,1);  '1 enables spikes per second
            View(handlePSTH%[i%+16]).windowtitle$("No Data");  'name gets changed later
            View(handlePSTH%[i%+16]).WindowVisible(1);  'make window visible
            'but not sizing this, just let it be whatever
            
            'this one is for opto-off stimuli
            'handlePSTH%[i%+24] := View(DataWindow%).SetPsth(tunWavemarkPorts%[i%]+1,histBins2%,.005,rasterPre,StimChannel%,1);  '1 enables spikes per second
            handlePSTH%[i%+24] := View(DataWindow%).SetPsth(i%+1,histBins2%,.005,rasterPre,StimChannel%,1);  '1 enables spikes per second
            View(handlePSTH%[i%+24]).windowtitle$("No Data");  'name gets changed later
            View(handlePSTH%[i%+24]).WindowVisible(1);  'make window visible
            
        endif
        
        FrontView(DataWindow%);  'bring main window back to front to avoid view is not a time view shit
    
        optoOnChan% := View(TuningWindow%[i%]).XYSetChan(0);   ' Make this even if we aren't using opto/E-stim
        View(TuningWindow%[i%]).ChanColourSet(optoOnChan%, 1, .1, .8, .1);  'deep green for on
        optoOffChan% := View(TuningWindow%[i%]).XYSetChan(0);   
        View(TuningWindow%[i%]).ChanColourSet(optoOffChan%, 1, .8, .1, .1);  'deep red for off
        
        optoOnChanDesc% := View(TuningWindow%[i%]).XYSetChan(0);   ' Make this even if we aren't using opto/E-stim
        View(TuningWindow%[i%]).ChanColourSet(optoOnChanDesc%, 1, 0, 0, 1);  'deep blue for on
        optoOffChanDesc% := View(TuningWindow%[i%]).XYSetChan(0);   
        View(TuningWindow%[i%]).ChanColourSet(optoOffChanDesc%, 1, .6, .1, 1);  'deep purple for off
        
        ' Create psth window if f1 and f2 analysis needed
        if tunDoF12% = 1 then
            
            optoOffF1Chan% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1 (of opto-off), red
            View(TuningWindow%[i%]).ChanColourSet(optoOffF1Chan%, 1, 1, 0, 0);
            optoOffF2Chan% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f2 (of opto-off), pale red
            View(TuningWindow%[i%]).ChanColourSet(optoOffF2Chan%, 1, 1, 0.8, 0.8);
            optoOnF1Chan% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1 of opto-on, green
            View(TuningWindow%[i%]).ChanColourSet(optoOnF1Chan%, 1, 0, 1, 0);
            optoOnF2Chan% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f2 of opto-on, pale green
            View(TuningWindow%[i%]).ChanColourSet(optoOnF2Chan%, 1, 0.8, 1, 0.8);
            
            optoOffF1ChanDesc% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1 (of opto-off Desc), blue
            View(TuningWindow%[i%]).ChanColourSet(optoOffF1ChanDesc%, 1, 0.4, 0.4, 1);
            optoOffF2ChanDesc% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f2 (of opto-off Desc), pale blue
            View(TuningWindow%[i%]).ChanColourSet(optoOffF2ChanDesc%, 1, 0.7, 0.8, 1);
            optoOnF1ChanDesc% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1 of opto-on Desc, purple
            View(TuningWindow%[i%]).ChanColourSet(optoOnF1ChanDesc%, 1, 0.75, 0.45, 1);
            optoOnF2ChanDesc% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f2 of opto-on Desc, pale purple
            View(TuningWindow%[i%]).ChanColourSet(optoOnF2ChanDesc%, 1, 0.9, 0.75, 1);            
            
            LogStatus("InitializeWindows", "Channel " + str$(i%+1) + " " + str$(ch1%) + " " + str$(ch2%));
            'PSTHWindow%[i%] := View(DataWindow%).SetPSTH(tunWavemarkPorts%[i%]+1, 16, 1 /(tunTF*16), 0, 0, 3);  'must use index to tWMP%[] now that channel #s correspond to port #s (+1)
            PSTHWindow%[i%] := View(DataWindow%).SetPSTH(i%+1, 16, 1 /(tunTF*16), 0, 0, 3);  'well, channel #s DON'T correspond to port #s, so...
            View(PSTHWindow%[i%]).WindowVisible(0);
        endif        
        
        if tunHistogramBursts% = 1 then
            burstChan% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot burst count
            View(TuningWindow%[i%]).XYColour(burstChan%, 15);  'this is another color...should be light blue
        endif;
        
        
    next

end;

proc TuningCurveLabels(iport%)

    var s$;
    's$ := "Port " + str$(iport%);
    s$ := "Electrode " + str$(iport%);
	docase 
    case tunType$ = tunTypeContrast$ then
        
        myTitle$ := s$ + " - Contrast = ";
        myTitle2$ := " - Contrast = ";
        WindowTitle$("Contrast Tuning - " + s$);
        XUnits$("Contrast (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunContrastMinContrast, tunContrastMaxContrast);
        
    case tunType$ = tunTypeTwoWayContrast$ then
        
        myTitle$ := s$ + " - Two Way Contrast = ";
        myTitle2$ := " - Two Way Contrast = ";
        WindowTitle$("Two Way Contrast Tuning (over 100 is downwards) - " + s$);
        XUnits$("Contrast (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunTwoWayContrastMinContrast, tunTwoWayContrastMaxContrast+100);
    
    case tunType$ = tunTypeConditionedContrast$ then
        
        myTitle$ := s$ + " - Conditioned Contrast = ";
        myTitle2$ := " - Conditioned Contrast = ";
        WindowTitle$("Conditioned Contrast Tuning (over 100 is downwards) - " + s$);
        XUnits$("Contrast (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunConditionedContrastMinContrast, tunConditionedContrastMaxContrast);
    
    case tunType$ = tunTypeOrientation$ then
        
        myTitle$ := s$ + " - Orientation = ";
        myTitle2$ := " - Orientation = ";
        WindowTitle$("Orientation Tuning - " + s$);
        XUnits$("Orientation (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunOriMinOrientation, tunOriMaxOrientation);
        
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 0 then
        
        myTitle$ := s$ + " - Plaid Orientation = ";
        myTitle2$ := " - Plaid Orientation = ";
        WindowTitle$("Plaid Orientation Tuning - " + s$);
        XUnits$("Plaid Orientation (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunPlaidMinDirection, tunPlaidMaxDirection);
        
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 1 then
        
        myTitle$ := s$ + " - Plaid Temporal Freq = ";
        myTitle2$ := " - Plaid Temporal Freq = ";
        WindowTitle$("Plaid Temporal Freq Tuning - " + s$);
        XUnits$("Plaid Temporal Freq");
        ChanTitle$(1, "Chan 1");
        XRange(tunPlaidMinTF, tunPlaidMaxTF);
        
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 2 then
        
        myTitle$ := s$ + " - Plaid Contrast = ";
        myTitle2$ := " - Plaid Contrast = ";
        WindowTitle$("Plaid Contrast Tuning - " + s$);
        XUnits$("Plaid Contrast");
        ChanTitle$(1, "Chan 1");
        XRange(tunPlaidMinContrast, tunPlaidMaxContrast);
        
    case tunType$ = tunTypeSpatial$ then
        
        myTitle$ := s$ + " - Spatial Freq = ";
        myTitle2$ := " - Spatial Freq = ";
        WindowTitle$("Spatial Frequency Tuning - " + s$);
        XUnits$("Spatial Frequency");
        ChanTitle$(1, "Chan 1");
        XRange(tunSpatialMinSF, tunSpatialMaxSF);
        
    case tunType$ = tunTypeTemporal$ then
        
        myTitle$ := s$ + " - Temporal Freq = ";
        myTitle2$ := " - Temporal Freq = ";
        WindowTitle$("Temporal Frequency Tuning - " + s$);
        XUnits$("Temporal Frequency");
        ChanTitle$(1, "Chan 1");
        XRange(tunTemporalMinTF, tunTemporalMaxTF);
        
    case tunType$ = tunTypeArea$ then
        
        myTitle$ := s$ + " - Area = ";
        myTitle2$ := " - Area = ";
        WindowTitle$("Aperture Area Tuning - " + s$);
        XUnits$("Aperture Diameter");
        ChanTitle$(1, "Chan 1");
        XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
    case tunType$ = tunTypeID$ then
        
        myTitle$ := s$ + " - ID = ";
        myTitle2$ := " - ID = ";
        WindowTitle$("Inner Diameter Tuning - " + s$);
        XUnits$("Inner Diameter");
        ChanTitle$(1, "Chan 1");
        XRange(tunIDMinDiam, tunIDMaxDiam);
        
    case tunType$ = tunTypeDriftingBar$ then
        
        myTitle$ := s$ + " - Bar Orientation = ";
        myTitle2$ := " - Bar Orientation = ";
        WindowTitle$("Drifting Bar Orientation Tuning - " + s$);
        XUnits$("Orientation (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunBarMinOrientation, tunBarMaxOrientation);
        
    case tunType$ = tunTypeNullTest$ then
        
        myTitle$ := s$ + " - Phase = ";
        myTitle2$ := " - Phase = ";
        WindowTitle$("Null Test Counterphase Tuning - " + s$);
        XUnits$("Phase (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunNullTestMinPhase, tunNullTestMaxPhase);
        
    case tunType$ = tunTypeCRG$ then
        
        myTitle$ := s$ + " - Contrast = ";
        myTitle2$ := " - Contrast = ";
        WindowTitle$("CRG Contrast Tuning - " + s$);
        XUnits$("Contrast (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunCRGMMinContrast, tunCRGMMaxContrast);
        
    case tunType$ = tunTypeBorderOwnership$ then
        
        myTitle$ := s$ + " - Border Ownership = ";
        myTitle2$ := " - Border Ownership = ";
        WindowTitle$("Border Ownership - " + s$);
        XUnits$("Stimulus #");
        ChanTitle$(1, "Chan 1");
        XRange(1, 32);  'there are 32 stimuli
        
    case tunType$ = tunTypeCSD$ then
        'For this, I don't think we actually care, we just want to not throw a warning
        myTitle$ := s$ + " - CSD = ";
        myTitle2$ := " - CSD = ";
        WindowTitle$("Current Source Density - " + s$);
        XUnits$("Not Meaningful (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunCRGMMinContrast, tunCRGMMaxContrast);  'yeah, whatever
        
    case tunType$ = tunTypeStimTrigPSTH$ then
        'For this, I don't think we actually care, we just want to not throw a warning
        myTitle$ := s$ + " - STP = ";
        myTitle2$ := " - STP = ";
        WindowTitle$("Stim Triggered PSTH - " + s$);
        XUnits$("Not Meaningful (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunCRGMMinContrast, tunCRGMMaxContrast);  'yeah, whatever
        
    case tunType$ = tunTypeDanish$ then
        
        WindowTitle$("Danish Area Tuning - " + s$);
        XUnits$("Contrast (%)");
        XRange(tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter);
        ChanTitle$(1, "Chan 1");    
        
        
    else
        
        Message("TuningCurveLabels Error - unknown value for tunType$: " + tunType$);
        
	endcase;

end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
    var j%;
    var tunOptoRepeats%;

	SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    if tunDoNeuropixel% = 1 then
        SampleBigFile(0);  'Create an .smr file INSTEAD of .smrx so that Scottie's analysis suite can read it, max file size is 2GB
        'SampleBigFile(1);  'Create a "big" .smr file, max file size 1 TB.  It is not known if Scottie's analysis suite can read these.
    endif;
    
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    'read tuning file, if one is specified
    if tunUseFile% = 1 then  'This should also work for plaids in the same manner, as stringification of tune values is still required
        var tunFileLen%;
        var eof%:=1;
        readsetup(",","	 ","","","	");  'Standard read setup
        FileOpen(tunTuningFile$,8,0);  'open specified file
        while eof% > 0 do
            eof% := read(tunValues[tunFileLen%]);  'read to end of file, must put each value on a new line to count number of stimuli in a block
            tunFileLen%+=1;  'increment tuning file length
        wend
        tunFileLen%-=1;  'decrement tuning file length because we increment when we find EOF.
        FileClose();  'close the file
    endif
    
    'Calculate number of repeats to do.  If Opto is always on, don't double the repeats
    if tunOptoStartState% = 3 then 
        tunOptoRepeats% := 1
    else
        tunOptoRepeats% := 1 + tunDoOpto%;
    endif;
    
    
    docase
        
    case tunType$ = tunTypeContrast$ then 
        SampleAutoName$(dataCellName$ + "_con_000");
        tunNRepeats% := tunContrastNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunContrastProgression%);
        else
            tunNAdvances% := tunContrastNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunContrastNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, tunContrastProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunContrastMinContrast;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%; 
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeTwoWayContrast$ then 'This function needs to make something like 10 20 40 80 180 140 120 110... for tunValues using GRPP or the like
        SampleAutoName$(dataCellName$ + "_twc_000");
        tunNRepeats% := tunTwoWayContrastNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],0);  'force progression to 0 here, can't be random
        else
            tunNAdvances% := 2*tunTwoWayContrastNSteps%+1;
            if tunNAdvances% > 1 then
                'no option for randomization in GRPPTWC, would not make sense, note that we are hardcoding iLog% to 1, I checked and linear contrast WOULD work
                GetRepeatedParameterProgressionTwoWayContrast%(tunTwoWayContrastNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunTwoWayContrastMinContrast, tunTwoWayContrastMaxContrast, 1);  
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunTwoWayContrastMinContrast;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%; 
        
        'here assign tunTwoWayContrastValues[] to have literal contrast value (e.g. 10 20 40 80 80 40 20 10) based on tunValues (e.g. 10 20 40 80 180 140 120 110)
        'this COULD have been done in GRPPTWC about 9 lines above, but would then not adjust the values from an input file, this way we fix either
        for j% := 0 to tunMaxTrials%-1 do
            if tunValues[j%] <= 100 then
                tunTwoWayContrastValues[j%] := tunValues[j%];
            else
                tunTwoWayContrastValues[j%] := tunValues[j%]-100;
            endif;
        next

        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunTwoWayContrastValues, tunValuesIndices%); 'note we don't use tunValues
        'Sanity check, the values created are correct
        'printlog("TunValues is %f\n",tunValues[0:2*(tunTwoWayContrastNSteps%+1)]);
        'printlog("TunTwoWayContrastValues is %f\n",tunTwoWayContrastValues[0:2*(tunTwoWayContrastNSteps%+1)]);
        'printlog("tunValuesStringified$ is %s\n",tunValuesStringified$);
        'halt;
        
    case tunType$ = tunTypeConditionedContrast$ then
        var tunValuesIndicesTemp%[tunMaxTrials%];  'That's actually too big, but we should be OK
        var tunDurValuesIndices%[tunMaxTrials%];
        SampleAutoName$(dataCellName$ + "_cc_000");
        
        'double number of blocks automatically because we are using two different conditioning contrasts
        tunNRepeats% := tunConditionedContrastNRepeats%*2*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndicesTemp%[],tunConditionedContrastProgression%);
        else
            tunNAdvances% := tunConditionedContrastNSteps%;
            if tunNAdvances% > 1 then
                GetRepeatedParameterProgression%(tunConditionedContrastNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndicesTemp%[], tunConditionedContrastMinContrast, tunConditionedContrastMaxContrast, 1, tunConditionedContrastProgression%); 
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunConditionedContrastMinContrast;
                tunValuesIndicesTemp%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%; 'This does NOT include the conditioning stimuli, will be used then updated below
        
        'so I have to:
        '1) Expand tunValues to include a second +100 set of values, then add in the conditioning stimuli 1 and 2 at the end
        '    e.g. [10 20 40 80] -> [10 20 40 80 110 120 140 180 0 100]
        '2) Make a parallel tunConditionedContrastValues for StringifyProgression that is the same, but without the +100
        '    e.g. [10 20 40 80] -> [10 20 40 80 10 20 40 80 0 100]
        for j% := 0 to tunNAdvances% do
            tunValues[j%+tunNAdvances%+1] := tunValues[j%]+100;
            tunConditionedContrastValues[j%] := tunValues[j%];
            tunConditionedContrastValues[j%+tunNAdvances%+1] := tunValues[j%];
        next;
        var C1index%;
        var C2index%;
        C1index% := (2*tunNAdvances%)+2;
        C2index% := (2*tunNAdvances%)+3;
        tunValues[C1index%] := tunConditionedContrastC1;
        tunValues[C2index%] := tunConditionedContrastC2;
        tunConditionedContrastValues[C1index%] := tunConditionedContrastC1;
        tunConditionedContrastValues[C2index%] := tunConditionedContrastC2;
        
        '3) Update/expand/interleave TunValuesIndices%[] to present both conditioning and test stimuli
        '    e.g. for above example tunValues[], [9 1 9 2 9 3 9 4 10 5 10 6 10 7 10 8]
        '    This will probably require an intermediate variable, and we have to count to know if we are in conditioning block 1 or 2, this will be a bit of a pain
        var advanceCount% := 0;
        var isC1% := 1;
        for j% := 0 to tunNValues%-1 do
            'Populate tunValuesIndices%[]
            if isC1% = 1 then
                tunValuesIndices%[2*j%] := C1index%;  'put in C1
                tunDurValuesIndices%[2*j%] := 0;
                tunValuesIndices%[(2*j%)+1] := tunValuesIndicesTemp%[j%];  'put in actual calculated index
                tunDurValuesIndices%[(2*j%)+1] := 1;
                advanceCount% += 1;
            else
                tunValuesIndices%[2*j%] := C2index%;  'put in C2
                tunDurValuesIndices%[2*j%] := 0;
                tunValuesIndices%[(2*j%)+1] := tunValuesIndicesTemp%[j%]+tunNAdvances%+1;  'put in adjusted index
                tunDurValuesIndices%[(2*j%)+1] := 1;
                advanceCount% += 1;
            endif;
            'Reset advanceCount% and update isC1% as necessary
            if advanceCount% > tunNAdvances% then
                advanceCount% := 0;
                isC1% := 1-isC1%;
            endif;
        next
        
        'set up durValues
        var durValues[tunMaxTrials%];
        durValues[0] := tunConditionedContrastDuration;
        durValues[1] := tunStimulusDuration;
        
        'This is the actual tunNValues% after adding in the conditioning stimuli
        tunNValues% := 2*(tunNAdvances%+1)*tunNRepeats%;
        'This is a faked number of advances which will allow us to have blocks behave normally in the idle loop
        tunNAdvances% := (2*(tunNAdvances%+1))-1;  
        tunNRepeats% := tunConditionedContrastNRepeats%*(tunOptoRepeats%);  'Reduce NRepeats by factor of 2, cond1/cond2 factor has been pushed into tunNAdvances%
        
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunConditionedContrastValues, tunValuesIndices%); 'note we don't use tunValues
        tunDurValuesStringified$ := StringifyProgression$(tunNValues%, durValues, tunDurValuesIndices%);
        
        
        'Sanity check, the values created are correct
        'printlog("TunValues is %f\n",tunValues[0:2*(tunConditionedContrastNSteps%+1)+2]);
        'printlog("TunConditionedContrastValues is %f\n",tunConditionedContrastValues[0:2*(tunConditionedContrastNSteps%+1)+2]);
        'printlog("tunValuesStringified$ is %s\n",tunValuesStringified$);
        'printlog("tunDurValuesStringified$ is %s\n",tunDurValuesStringified$);
        'halt;
        
        isConditioningStimulus% := 1;  'We start on a conditioning stimulus, of course
        
        tunNAdvances% := (2*tunNAdvances%)+1;  'update tunNAdvances% to keep blocks straight (i.e. when the interblock time is used) in idle loop
        
    case tunType$ = tunTypeOrientation$ then 
        SampleAutoName$(dataCellName$ + "_ori_000");
        tunNRepeats% := tunOriNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunOriProgression%);
        else
            tunNAdvances% := tunOriNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunOriNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, tunOriProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunOriMinOrientation;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        'message(str$(tunNValues%));
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 0 then    
        SampleAutoName$(dataCellName$ + "_plo_000");
        tunNRepeats% := tunPlaidNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunPlaidProgression%);
        else
            tunNAdvances% := tunPlaidNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunPlaidNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunPlaidMinDirection, tunPlaidMaxDirection, 0, tunPlaidProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunPlaidMinDirection;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        'message(str$(tunNValues%));
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 1 then    
        SampleAutoName$(dataCellName$ + "_plt_000");
        tunNRepeats% := tunPlaidNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunPlaidProgression%);
        else
            tunNAdvances% := tunPlaidNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunPlaidNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunPlaidMinTF, tunPlaidMaxTF, 0, tunPlaidProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunPlaidMinTF;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        'message(str$(tunNValues%));
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 2 then    
        SampleAutoName$(dataCellName$ + "_plc_000");
        tunNRepeats% := tunPlaidNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunPlaidProgression%);
        else
            tunNAdvances% := tunPlaidNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunPlaidNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunPlaidMinContrast, tunPlaidMaxContrast, 1, tunPlaidProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunPlaidMinContrast;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        'message(str$(tunNValues%));
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeSpatial$ then 
        SampleAutoName$(dataCellName$ + "_spa_000");
        tunNRepeats% := tunSpatialNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunSpatialProgression%);
        else
            tunNAdvances% := tunSpatialNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunSpatialNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, tunSpatialProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunSpatialMinSF;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeTemporal$ then 
        SampleAutoName$(dataCellName$ + "_tem_000");
        tunNRepeats% := tunTemporalNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunTemporalProgression%);
        else
            tunNAdvances% := tunTemporalNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunTemporalNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 0, tunTemporalProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunTemporalMinTF;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeArea$ then 
        SampleAutoName$(dataCellName$ + "_area_000");
        tunNRepeats% := tunAreaNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunAreaProgression%);
        else
            tunNAdvances% := tunAreaNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunAreaMinDiam;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeID$ then 
        SampleAutoName$(dataCellName$ + "_id_000");
        tunNRepeats% := tunIDNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunIDProgression%);
        else
            tunNAdvances% := tunIDNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunIDNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunIDMinDiam, tunIDMaxDiam, 1, tunIDProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunIDMinDiam;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        
        ' Note that for inner diam test we have to pass an outer,inner diameter PAIR for each trial.
        ' First, fetch the outer diameter as currently specified.
        ' Second, form the argument string in a loop - StringifyProgression only works with a single parameter.
        
        var x,y,w,h;
        var w$;
        ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"), x, y, w, h);
        w$ := str$(w) + ",";
        
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        for i% := 0 to tunNValues%-1 do
            if i% > 0 then 
                tunValuesStringified$ += ",";
            endif
            tunValuesStringified$ += w$ + str$(tunValues[tunValuesIndices%[i%]]);
        next
        
    case tunType$ = tunTypeDriftingBar$ then 
        SampleAutoName$(dataCellName$ + "_bar_000");
        tunNAdvances% := tunBarNSteps%;
        tunNRepeats% := tunBarNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        GetRepeatedParameterProgression%(tunBarNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunBarMinOrientation, tunBarMaxOrientation, 0, tunBarProgression%);
        tunNValues% := (tunBarNSteps%+1)*tunBarNRepeats%*(1+tunDoOpto%);
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeNullTest$ then 
        SampleAutoName$(dataCellName$ + "_nulltest_000");
        tunNRepeats% := tunNullTestNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunNullTestProgression%);
        else
            tunNAdvances% := tunNullTestNSteps%;
            if tunNAdvances% > 0 then
                GetRepeatedParameterProgression%(tunNullTestNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunNullTestMinPhase, tunNullTestMaxPhase, 0, tunNullTestProgression%);
            else  'cannot run GRPP on a value of 0 steps, simply use minimum value
                tunValues[0] := tunNullTestMinPhase;
                tunValuesIndices%[0] := 0;
            endif;
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeCRG$ then 
        SampleAutoName$(dataCellName$ + "_crg_000");
        tunNAdvances% := tunCRGMNSteps%;
        tunNRepeats% := tunCRGMNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        GetRepeatedParameterProgression%(tunCRGMNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunCRGMMinContrast, tunCRGMMaxContrast, 1, tunCRGMProgression%);
        tunNValues% := (tunCRGMNSteps%+1)*tunCRGMNRepeats%*(1+tunDoOpto%);
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeBorderOwnership$ then 
        SampleAutoName$(dataCellName$ + "_bor_000");
        tunNAdvances% := 31;  'keep this at 31, blocks are 31 long regardless of the possible "interblocking"
        tunNRepeats% := tunBONRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunBOType% = 0 then
            'Here we are setting up all 31 border values in order, they will not be "interblocked"
            for i% := 0 to 31 do
                tunValues[i%] := i%;
            next
            ShuffleAndExpand(32,tunNRepeats%,tunValuesIndices%[],1); 'Always randomize, 
            tunNValues% := (tunNAdvances%+1)*tunNRepeats%;
            tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        else
            'Here we are setting up tunValues[] so that the first 16 have the same BG color and the last 16 have the same BG color, for "interblocking"
            for i% := 0 to 7 do
                tunValues[i%] := i%;
            next
            for i% := 8 to 15 do
                tunValues[i%] := i%+8;
            next
            for i% := 16 to 23 do
                tunValues[i%] := i%-8;
            next
            for i% := 24 to 31 do
                tunValues[i%] := i%;
            next
            'Now just explicitly build tunValuesStringified$ rather than make a function to do it
            for i% := 1 to tunNRepeats% do
                'Do first half
                Shuffle%(16, tunValuesIndices%[]);
                tunValuesStringified$ := tunValuesStringified$ + StringifyProgression$(16, tunValues, tunValuesIndices%[]) + ",";
                'Do second half
                Shuffle%(16, tunValuesIndices%[]);
                for j% := 0 to 15 do  'This time, increment values by 16 to get the other BG
                    tunValuesIndices%[j%] := tunValuesIndices%[j%] + 16;
                next
                tunValuesStringified$ := tunValuesStringified$ + StringifyProgression$(16, tunValues, tunValuesIndices%[]);
                'Only add final comma if we are not done
                if i% < tunNRepeats% then
                    tunValuesStringified$ := tunValuesStringified$ +  ",";
                endif;
            next
        endif;
        
    case tunType$ = tunTypeStimTrigPSTH$ then
        SampleAutoName$(dataCellName$ + "_stp_000");
        tunNRepeats% := 1;
        tunNAdvances% := tunSTPNStims%-1;
        if tunNAdvances% > 0 then
            'GetRepeatedParameterProgression%(tunSTPNStims%, tunNRepeats%, tunValues[], tunValuesIndices%[], 0, 0, 1, tunContrastProgression%);
            GetRepeatedParameterProgression%(tunSTPNStims%, tunNRepeats%, tunValues[], tunValuesIndices%[], 100, 100, 1, tunContrastProgression%);
        else  'cannot run GRPP on a value of 0 steps, simply use minimum value
            tunValues[0] := 0;
            tunValuesIndices%[0] := 0;
        endif;
        tunNValues% := (tunSTPNStims%)*tunNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeCSD$ then
        SampleAutoName$(dataCellName$ + "_csd_000");
        tunNValues% := tunCSDNStims%;  'I don't think this does anything, in too much of a hurry to check
        tunNAdvances% := tunCSDNStims%-1;
        tunNRepeats% := 1;
    case tunType$ = tunTypeDanish$ then 
        SampleAutoName$(dataCellName$ + "_dan_000");
        tunNAdvances% := tunDanishNSteps%;
        tunNRepeats% := tunDanishNRepeats%*(tunOptoRepeats%);  'double number of blocks if doing on/off optogenetics
        if tunDanishIncludeBlank% = 0 then
            GetRepeatedParameterProgression%(tunDanishNSteps%+1, tunDanishNRepeats%, tunValues[], tunValuesIndices%[], tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, 1, tunDanishProgression%); 
            tunNValues% := (tunDanishNSteps%+1)*tunDanishNRepeats%;
        else  'include blank, include one blank of "0" per tuning cycle, 0 will result in no donut being drawn
            GetRepeatedParameterProgressionWithConstant%(tunDanishNSteps%+1, 1, 0, tunDanishNRepeats%, tunValues[], tunValuesIndices%[], tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, 1, tunDanishProgression%); 
            tunNValues% := (tunDanishNSteps%+2)*tunDanishNRepeats%;
        endif        
        
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%); 
    else
        SampleAutoName$(dataCellName$ + "_tun_000");
    endcase;
    
    'printlog("values are %f\n",tunValues[]);
    'printlog("Indices are %d\n",tunValuesIndices%[]);
    
    
    SampleAutoFile(1);
    
    'Text marks make extraction easier
    SampleTextMark(200);
    
    'Add a digital marker channel (channel 32 by default) for pulsing optogenetics (and wraparound, PLS updated)
    'Will record a '1' for laser on and a '0' for laser off
    if tunDoOpto% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"SigOut");
    endif
    
    
    
    '----Event Channel recording definitions----
	SampleEvent(StimChannel%, STIMCHANNELPORT%, 2, 3600); 'Trigger channel, level
	SampleComment$(StimChannel%, "Stim");
	SampleTitle$(StimChannel%, "Stim");
    
	'SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
    SampleEvent(ReadyChannel%, READYCHANNELPORT%, 2, 3600); 'Trigger channel, level, moved to port 2 in order to allow port 1 (front of 1401) to carry camera signal
    SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    SampleEvent(FrameChannel%, 0, 2, 3600);
    SampleComment$(FrameChannel%,"Frame");
    SampleTitle$(FrameChannel%,"Frame");
    
    'Camera frame trigger channel
    if not (tunCameraMode% = cameraModeNone%) then
        SampleEvent(CameraTriggerChannel%, 1, 2, 3600); 'Camera trigger channel, level
        SampleComment$(CameraTriggerChannel%, "CamTrg");
        SampleTitle$(CameraTriggerChannel%, "CamTrg");
    endif
    
    
   
    
    '----Analog, non-spiking electrode recording conditions
    'DO NOT record EEG with AcuteTuning
'    if EEGPort% > -1 then
'        SampleWaveform(EEGChannel%,EEGPort%,5000);
'        SampleTitle$(EEGChannel%, EEGPortLabel);
'    endif;
    
    if tunDoOpto% = 1 and OptoEffCopyPort% > -1 then
        SampleWaveform(OptoEfferenceChannel%,OptoEffCopyPort%,30000); 
        SampleTitle$(OptoEfferenceChannel%, OptoPortLabel$);
    endif;
    
    if tunDoOpto% > 0 and StimEffCopyPort% > -1 then
        SampleWaveform(StimulatorChannel%,StimEffCopyPort%,30000); 
        SampleTitle$(StimulatorChannel%, StimPortLabel$);
    endif;
    
    if tunUseTemperature% = 1 and TemperaturePort% > -1 then
        SampleWaveform(TemperatureChannel%,TemperaturePort%,5000);       
        SampleTitle$(TemperatureChannel%, TemperaturePortLabel$);
    endif;
    
    if PhotodiodePort% > -1 then
        SampleWaveform(PhotodiodeChannel%,PhotodiodePort%,30000);  
        SampleTitle$(PhotodiodeChannel%, PhotodiodePortLabel$);
    endif;
    
    if UtilityPort% > -1 then
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);  
        SampleTitle$(UtilityChannel%, UtilityPortLabel$);
    endif;
    

    
    'No EyeX, EyeY, Joystick for AcuteTuning, because animal is *not* behaving

    
   
    
    
       
    'if we are recording the laser output, turn off any electrode channels ----- this seems unnecessary
'    if tunLaserDiode% = 1 then
'        tunNWavemarks% := 0;  'no wavemarks!
'        tunNContinuous% := 0;  'no continuous!
'        SampleWaveform(1,0,50000);  'on waveform port 0
'        SampleTitle$(1,"Diode output (laser)");
'    endif;
    
    
    '----Set up "spiking" Electrode Channels----
    CreateElectrodeSamplingConfiguration32(1, 1+numWavemarkPorts%, ExcludedChans%);  'Allows a lot of channels while preventing accidentally re-defining a channel
    
    'Set channel for Opto box efference copy, if needed - turned off because opto box won't output for the analog input
    'if tunRecOptoBox% > 0 then
    '    SampleWaveform(13, 5, 1000);  'there are a possible 7 'trodes in ADC0-ADC6; here 5 is port ADC5, 13 is channel: port 5 + 7 'trodes + 1 (because channel numbering starts at 1), 1kHz sampling should be fine
    '    SampleTitle$(13, "Opto voltage");
    'endif;
   
    
    
    
	SampleSequencer(script$ + "Tuning.pls");
	SampleOptimise(2,2,Get1401Type%(),2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;

' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, j%, m%, mylen%;
    var fn$;
    var serialStatus%;
    var chanToExport%[30];
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    
    'turn off opto if it happens to be on
    SafeSampleKey("o");
    
    'turn the stimulus off if it happens to be on
    'NOTE: this is extremely important for render to ensure that the stim digout pin is set low
    SafeSampleKey("X");
    
	' Tell stim app to shut down    
	SafeSampleKey("Q");
    if tunCameraMode% = cameraModeTrigger% then
        Yield(((tunCameraBaselinePeriod+tunStimulusDuration)*0.2)+0.5);
    else
        Yield(0.1);
    endif
    
    docase
    case tunDoNeuropixel% = 1 and neuropixelStatus% = 1 then 
        serialStatus% := SendSerialMsgNeuropixel(serialCOMPort%, "STOP", "\n");
        SerialClose(serialCOMPort%);
        if serialStatus% = 0 then
            message("Warning! SpikeGLX recording may not have stopped!\nPlease manually stop SpikeGLX!");
        endif;
    case tunDoNeuropixel% = 1 and neuropixelStatus% = 0 then 'On failure to start recording, neuropixelStatus% will be 0, don't try stopping recording that didn't start
        SerialClose(serialCOMPort%);
    endcase;
    
	SampleStop();

	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend

	' Write parameter file
	WriteParameterFile();
    
    ' close serial port
    if tunCameraMode% = cameraModeTrigger% then
        SendSerialMsg(serialCOMPort%, "STOP", "\n");
        SerialClose(serialCOMPort%);
    endif
    
    view(dataWindow%);
    MemSave(memChanRasterTriggers%,memorychannel%,0,1);  'final update of memory channel
    MemSave(memChanRasterTriggersOpto%,memorychannelopto%,0,1);  'final update of memory channel
    MemSave(memChanBetterTextMark%,memorychannel2%,0,1);  'final update of memory channel
    
    ExportChanList();
    chanToExport%[1] := 29;  'channels to export go in elements 1:...
    chanToExport%[2] := 30;
    for j% := 0 to tunNWavemarks%-1 do
        chanToExport%[j%+3]:=tunWavemarkPorts%[j%]+1;
    next;
    chanToExport%[0] := 2+j%;  'total number of channels goes in element 0
    ExportChanList(0,view(datawindow%).maxtime(),chanToExport%[]);
    
    ' Write matlab file
    'fn$ := FileName$();  'get current file name
    'mylen% := Len(fn$);
    'fn$ := Left$(fn$,mylen%-4);
    'fn$ := fn$ + ".mat";
    'j% := view(datawindow%).FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag

    
    
	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
'	TotalRewards% += nTrialsCompleted%;
	SaveDailyTotals();
    
    ' Figure out max F1 values
    if tunDoF12% = 1 then
        for i% := 0 to tunNWavemarks%-1 do
            m% := Max(tunF1Sum[i%][]);
            LogStatus("F1 Max", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F1 at x=" + str$(tunValues[m%]));
        next
        for i% := 0 to tunNWavemarks%-1 do
            m% := Max(tunF2Sum[i%][]);
            LogStatus("F2 Max", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F2 at x=" + str$(tunValues[m%]));
        next
        if tunType$ = tunTypeTwoWayContrast$ then
            for i% := 0 to tunNWavemarks%-1 do
                m% := Max(tunF1SumDesc[i%][]);
                LogStatus("F1 Max, Descending", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F1 at x=" + str$(tunValues[m%]));
            next
            for i% := 0 to tunNWavemarks%-1 do
                m% := Max(tunF2SumDesc[i%][]);
                LogStatus("F2 Max, Descending", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F2 at x=" + str$(tunValues[m%]));
            next
        endif;
    endif    
    
    ' Plot rasters for each individual stimulus, for each electrode
    ' Caitlin sez "too many rasters"
    'for j% := 0 to tunNWavemarks%-1 do
    '    for i% := 0 to tunValuesIndices%[max(tunValuesIndices%[])] do
    '        handlePSTH%[i%] := View(DataWindow%).SetPsth(tunWavemarkPorts%[j%]+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggers%,3);  '3 makes rasters and scales to spikes per second
    '        'not sure what the best sizing mech is, punting for now
    '        'View(handlePSTH%[i%]).Window(75, i%*WindowStep, 100, (i%+1)*WindowStep);  'size window as above, squeeze in
    '        View(handlePSTH%[i%]).WindowVisible(1);  'make window visible
    '        
    '        'create the raster
    '        view(handlePSTH%[i%]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggers%,rasterTotal,rasterPre,i%);  'Update single-stim histogram        
    '        'And update the title, to indicate which stimulus it is
    '        view(handlePSTH%[i%]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[j%]) + myTitle2$ + Str$(tunValues[i%]));  'Rename single-stim histogram
    '    next
    'next
    
    if tunNWavemarks% > 0 then
        InvestigateRastersDialog%();
    endif;
    
    'We are getting strange freezes, sometimes, for no apparent reason. The PAR, SMR, and MAT files are written
    'but the S2R file is not written in these cases.  There is no explicit halt, so I am putting one in to see
    'if that helps.  Well, the S2R file isn't written until the SMR is closed, so it makes sense that we don't
    'get it on crashes.  I've got no idea what's going on, but at least this is worth a try.
    halt;
    
end;

' ============================================================================ '
' JSON formatted stimulus parameters for imaging DAQ machine
' ============================================================================ '
func GetParameterString$()
    var paramString$;
    paramString$ := "{\"stimulus_duration\": " + str$(tunStimulusDuration);
    paramString$ := paramString$ + ", \"baseline_duration\": " + str$(tunCameraBaselinePeriod);
    paramString$ := paramString$ + ", \"ntrial\": " + str$((tunOriNSteps% + 1) * tunOriNRepeats%);
    paramString$ := paramString$ + "}";
    return paramString$;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetAcuteDistanceToScreenMM$());
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	'Print("Background color           : %s\n", tunBackgroundColor$);
    Print("Background gray level      : %d\n", tunBackgroundGrayLevel%);

	' write stimulus parameters
	Print("\nStimulus\n");
	Print("-------------------\n\n");

	var Tstimstr$;
    var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;	
	'var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
    i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	'i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
    if tunType$ = tunTypeStimTrigPSTH$ then  'if we are using the stimulus-triggered PSTH, contrast is defined as 0
        Tstimcontrast$ := "0";
    endif;
    Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
    
    
    if tunType$ = tunTypeDanish$ then  'Do donut grating only if we're using it
        Print("\Donut Stimulus\n");  'Donut grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor1");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        Print("Width (degrees)                 : %s\n", Tstimw$);
        Print("Height (degrees)                : %s\n", Tstimh$);
        Print("Inner Width (degrees)           : %s\n", Tstiminnerw$);
        Print("Inner Height (degrees)          : %s\n", Tstiminnerh$);
        Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
        Print("Temporal frequency              : %s\n", Tstimtf$);
        Print("Spatial frequency               : %s\n", Tstimsf$);
        Print("Orientation (degrees)           : %s\n", Tstimorientation$);
        Print("Initial Phase (degrees)         : %f\n", Tstimphase$);
        Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
        Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
        Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);  
    endif;
    
    if tunType$ = tunTypePlaid$ then
        docase
        case tunPlaidUseTwoGratings% = 1 then
            Print("\Plaid Second Grating\n");  'Donut grating
            Print("-------------------\n\n");
            Tstimstr$ := GetGratingParameters$("Distractor1");
            ReadSetup(",",",",",",",",",");
            i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
            'i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
            if tunType$ = tunTypeStimTrigPSTH$ then  'if we are using the stimulus-triggered PSTH, contrast is defined as 0
                Tstimcontrast$ := "0";
            endif;
            Print("Position (x, degrees)           : %s\n", Tstimx$);
            Print("Position (y, degrees)           : %s\n", Tstimy$);
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        else
            Print("Angle Between Plaids            : %f\n", tunPlaidAngle);
        endcase
        Print("Full Screen Mode?               : %d\n", tunPlaidFullScreen%);
        
    endif;
    

	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");
    Print("Stimulus Duration (s)  : %f\n", tunStimulusDuration);
    Print("Intertrial Interval (s): %f\n", tunInterTrialTime);
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");
	docase 
    case tunType$ = tunTypeContrast$ then
        
        Print("Type:                  : Contrast\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeTwoWayContrast$ then
        
        Print("Type:                  : Two Way Contrast\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTwoWayContrastMinContrast, tunTwoWayContrastMaxContrast, tunTwoWayContrastNSteps%, tunTwoWayContrastNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");        
        
        
    case tunType$ = tunTypeConditionedContrast$ then
        
        Print("Type:                  : Conditioned Contrast\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunConditionedContrastMinContrast, tunConditionedContrastMaxContrast, tunConditionedContrastNSteps%, tunConditionedContrastNRepeats%);
        Print("Cond1,Cond2,CondDur: %f,%f,%f\n", tunConditionedContrastC1, tunConditionedContrastC2, tunConditionedContrastDuration);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("Durations: " + tunDurValuesStringified$ + "\n");
        Print("\n");      
        
        
       
        
        
    case tunType$ = tunTypeOrientation$ then
        
        Print("Type:                  : Orientation\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 0 then
        
        Print("Type:                  : Plaid Direction\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunPlaidMinDirection, tunPlaidMaxDirection, tunPlaidNSteps%, tunPlaidNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n"); 
        
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 1 then
        
        Print("Type:                  : Plaid Temporal Freq\n");
        Print("Static Direction       : %f\n",tunPlaidStaticDirection);
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunPlaidMinTF, tunPlaidMaxTF, tunPlaidNSteps%, tunPlaidNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");   
        
    case tunType$ = tunTypePlaid$ and tunPlaidTuneType% = 2 then
        
        Print("Type:                  : Plaid Contrast\n");
        Print("Static Direction       : %f\n",tunPlaidStaticDirection);
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunPlaidMinContrast, tunPlaidMaxContrast, tunPlaidNSteps%, tunPlaidNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");   
        
        
    case tunType$ = tunTypeSpatial$ then
        
        Print("Type:                  : Spatial Frequency\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeTemporal$ then
        
        Print("Type:                  : Temporal Frequency\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeArea$ then
        
        Print("Type:                  : Aperture Area\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeID$ then
        
        Print("Type:                  : Inner Diameter\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunIDMinDiam, tunIDMaxDiam, tunIDNSteps%, tunIDNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeDriftingBar$ then
        
        Print("Type:                  : DriftingBar\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunBarMinOrientation, tunBarMaxOrientation, tunBarNSteps%, tunBarNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeNullTest$ then
        
        Print("Type:                  : Null Test Counterphase Gratings\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunNullTestMinPhase, tunNullTestMaxPhase, tunNullTestNSteps%, tunNullTestNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeCRG$ then
        
        Print("Type:                           : CRG\n");
        Print("FramesPerTerm,MSeqStart,Balanced: %d,%d,%d\n", tunCRGMFramesPerTurn%, tunCRGMFirstTerm%, tunCRGMBalanced%);
        Print("Min,Max,#Steps,#Repeats         : %f,%f,%d,%d\n", tunCRGMMinContrast, tunCRGMMaxContrast, tunCRGMNSteps%, tunCRGMNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
       
        
    case tunType$ = tunTypeBorderOwnership$ then
        
        Print("Type:                  : Border Ownership ");
        if tunBOType% = 0 then
            Print("(Interleaved)\n");
        else
            Print("(Blocked by BG color)\n");
        endif;
        Print("NRepeats: %d\n", tunBONRepeats%);
        Print("Size1,Size2: %f,%f\n",tunBOSize1,tunBOSize2);
        Print("\n");    
        
    case tunType$ = tunTypeStimTrigPSTH$ then
        
        Print("Type:                  : Stimulus Triggered PSTH\n");
        'Print("NStims,StimISI: %d,%f\n", tunSTPNStims%, tunSTPISI);
        Print("NStims: %d\n", tunSTPNStims%);
        Print("\n");
        
    case tunType$ = tunTypeCSD$ then        
        
        Print("Type:                  : Current Source Density\n");
        Print("NStims,NFlips,FlipISI,InitPhase: %d,%d,%f,180\n", tunCSDNStims%, tunCSDNFlips%*2, tunCSDISI);  'Hard coded 180 phase means Black first, which is hard coded in the CreateFFFlashString$ function
        Print("\n");
        
    case tunType$ = tunTypeDanish$ then
        
        Print("Type:                  : Danish\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, tunDanishNSteps%, tunDanishNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    else
        
        Print("TuningCurve Error - unknown value for tunType$: %s\n", tunType$);
        
	endcase;
    
    if tunDoOpto% = 1 then
        Print("\nOptogenetics parameters\n");
        Print("-------------------------\n\n");
        if tunLaserDiode% = 1 then
            Print("Laser Diode recorded\n");
        endif;
        Print("Opto Voltage Out: %f\n", tunOptoVoltageOut);
        var label$[4]; 
        label$[0] := "Opto Off First";
        label$[1] := "Opto On First";
        label$[2] := "Random First";
        label$[3] := "Opto On All Blocks";
        Print("Order of blocks : %s\n", label$[tunOptoStartState%]);
        if tunOptoUsePulse% = 1 then
            Print("Pulsing Opto selected\n");
            'Print("Opto#Pulses,OptoPeriodOnset,OptoPulseWidth,OptoInterpulseInterval: %d,%f,%f,%f\n",tunOptoNPulses%,tunPulsedOptoOnset,tunPulsedOptoWidth,tunPulsedOptoIPI);
            Print("Opto#Pulses,OptoPeriodOnsetMin,OptoPulseOnsetMax,OptoPulseWidth,OptoInterpulseIntervalMin,OptoInterpulseIntervalMax: ");
            Print("%d,%f,%f,%f,%f,%f\n",tunOptoNPulses%,tunPulsedOptoOnsetMin,tunPulsedOptoOnsetMax,tunPulsedOptoWidth,tunPulsedOptoIPImin,tunPulsedOptoIPImax);
        else
            Print("Wraparound Opto selected\n");
            Print("PreStimulusOptoOn,PostStimulusOptoOn,KeepOptoOnBetweenStims: %f,%f,%d\n",tunPreStimOptoTime,tunPostStimOptoTime,tunOptoStaysOn%);
        endif;
        
    endif;
    
    
	' close parfile
	FileClose(0);

end;


' Gets the temporal freq of the current stimulus. 
' Make sure to call this only after all user dialogs have been completed (so you know that the stim parameters will not change)

func GetStimulusTF()
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var cv$, pattern$, aperture$;
    
    if tunType$ = tunTypeNullTest$ then 'get the temporal frequency of the counterphase shift, grating does not drift
        tf := tunNullTestTF;
    else  'get the temporal frequency of the grating
    	gr$ := GetGratingParameters$("Stimulus");
        ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    endif;
    
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var cmdLine$;
'	var FixationPoint$;
	var Extras$;
	var Tune$;
	var Stim$:="";
'	var SlaveStim$:="";
	var Values$;
    var durValues$;
'    var Dual$;
    var key$;
    var offsetFilename$;
    var i%;
    var ProgName$;
    var tunBGStr$;
    var tunFGStr$;
    var tunBarStr$;
    var tunCRGBal$;
    var tunCRGNumTerms%;
    'vars for opto setup
    var voltageInteger%;
    var stimRemaining;
    stimRemaining := tunStimulusDuration;
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;
    var DGrat$;
    var DGratParam$;
    'Temporary variables allowing us to grab, manipulate grating parameters (useful for plaids)
    var Tgr$;
    var Tx;
    var Ty;
    var Tw; 
    var Th; 
    var Tiw; 
    var Tih; 
    var Tcontrast%; 
    var Tsf; 
    var Ttf; 
    var Ttf2;
    var Tori;
    var Tori2;
    var Tphase; 
    var Tcv$; 
    var Tpattern$; 
    var Taperture$;
    var specFileName$;
    var specHandle%;
    
    specFileName$ := GetScriptDir$(0)+"..\\..\\AcuteTuningSpecFile.txt";
    
    
    if renderIsBroken% = 1 then
        message("Variable renderIsBroken has been set!  \nWe are FLYING BLIND, IGNORING ALL INCOMING PULSES!");
    endif;
    
    'For camera mode, open serial comm port
    if tunCameraMode% = cameraModeTrigger% then
        SerialOpen(serialCOMPort%, serialBaudRate%, serialDataBits%, serialParity%, serialStopBits%, serialFlowCtrl%);
        SendSerialMsg(serialCOMPort%, GetParameterString$(), "\n");
    endif;
    
    'For serial communications with Neuropixel, use the same values as camera mode but do not send initial message
    if tunDoNeuropixel% =  1 then
        SerialOpen(serialCOMPort%, serialBaudRate%, serialDataBits%, serialParity%, serialStopBits%, serialFlowCtrl%);
    endif;
    
	'Start sampling
	SampleStart(0); 
    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
    
	SafeSampleKey("0");  'clear any digital bits
    
    'Set scaling for temperature channel
    if tunUseTemperature% = 1 then  
        ChanUnits$(7,"Deg C");
        ChanScale(7,10);  'this will allow us to get the temperature right
        ChanOffset(7,20);
    endif;        
    
    'Do required prep for opto
    if tunDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable. Use vdac32% to get the right value.
        voltageInteger% := vdac32%(tunOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
        printlog("Voltage integer is %d\n",voltageInteger%);
        
        'If pulsing, because the user could have changed the duration of the stimulus after setting the opto
        'parameters, we need to check the parameters again (even though the opto dialog box did it already)
        if tunOptoUsePulse% = 1 then
            
            'Set random IPI, Onset
            tunPulsedOptoIPI := Rand(tunPulsedOptoIPImax-tunPulsedOptoIPImin,tunPulsedOptoIPImin);  'this will work if max=min or even if max<min.  Simple.  Nice.
            tunPulsedOptoOnset := Rand(tunPulsedOptoOnsetMax-tunPulsedOptoOnsetMin,tunPulsedOptoOnsetMin);  'this will work if max=min or even if max<min.  Simple.  Nice.
            SetPulsedOptoSequencerVariables();  'this replaces a lot of code here, will be used again on each trial if necessary
            
        endif;
                
    endif;
    
    'build background gray level string
    tunBGStr$ := "(" + Str$(tunBackgroundGrayLevel%) + "/" + Str$(tunBackgroundGrayLevel%) + "/" + Str$(tunBackgroundGrayLevel%) + ") ";
    
    'Set various subcomponents of the to-be-built command line
    Stim$ := " -s " + GetGratingParameters$("Stimulus");    
    Values$ := tunValuesStringified$;
    durValues$ := tunDurValuesStringified$;
    Extras$ := " -b " + tunBGStr$ + " -d " + GetAcuteDistanceToScreenMM$();
    Extras$ := Extras$ + " -p " + Str$(READYCHANNELCODE%) + " -v";  'changed ready pulse (-p) to 4 so that it comes on port 2 - this is bitmapped, not linear mapped
    
    
    'By default, set ProgName$ to be FIXSTIM
    if DisplayHardwareIndex% = 0 then
        
        if UseRemoteStimulus% = 0 then
            ProgName$ := "\\fixstim.exe ";
        else
            ProgName$ := "\\remote.exe " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim ";
        endif

    else
        ProgName$ := "\\render_relay.exe ";        
        bin$ := "C:\\Users\\Lab\\Desktop\\render_relay";
        
        var jsonFilePre$;
        var RenderIP$;
        jsonFilePre$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
        
        'if the user has selected to use remote stimulus then assume that the IP given is for render
        'otherwise fall back to the hardcoded constant at the top of this script (which needs to be
        'changed each time the render machine is rebooted)
        if UseRemoteStimulus% = 1 then            
            RenderIP$ := RemoteStimulusIP$;
        else
            RenderIP$ := RENDERDEFAULTIP$;
        endif
        
        ProgName$ := ProgName$ + "-ip " + RenderIP$ + " -prefix " + jsonFilePre$ + " ";
    endif
    
    
	docase 
    case tunType$ = tunTypeContrast$ or tunType$ = tunTypeTwoWayContrast$ then  'The call to the VSG is the same for both, Values$ will change of course
        
        'Tune$ := Dual$ + " -C " + Values$;
        Tune$ := " -C " + Values$;
        
        
    case tunType$ = tunTypeConditionedContrast$ then
        Tune$ := " -C " + Values$ + " -t" + durValues$;

    case tunType$ = tunTypeOrientation$ then
        'Tune$ := Dual$ + " -O " + Values$;
        Tune$ := " -O " + Values$;
        
    case tunType$ = tunTypePlaid$ then
        'TODO - test this, but it might actually work, you never know!
        
        if tunPlaidUseTwoGratings% = 1 then  'if two gratings, take both at face value, make sure TF is same
            'Get Distractor1 first so that Tx/Ty/Tw/Th/Tcontrast% come from Stimulus
            ParseGratingParameters%(GetGratingParameters$("Distractor1"), Tx, Ty, Tw, Th, Tiw, Tih, Tcontrast%, Tsf, Ttf2, Tori, Tphase, Tcv$, Tpattern$, Taperture$);
            ParseGratingParameters%(GetGratingParameters$("Stimulus"), Tx, Ty, Tw, Th, Tiw, Tih, Tcontrast%, Tsf, Ttf, Tori2, Tphase, Tcv$, Tpattern$, Taperture$);
            if Ttf = Ttf2 then 'Stim$ already has GetGratingParameters$("Stimulus") in it
                Stim$ := Stim$ + " -s " + GetGratingParameters$("Distractor1");
            else
                Message("Temporal frequency of Stimulus and Distractor1 gratings must be the same, quitting!");
                SampleStop();
                Halt;  'nothing has really happened yet, so we should be able to stop gracefully (test this)
            endif
            if Tori-Tori2 = 0 or Tori-Tori2 = 180 or Tori-Tori2 = -180 or Tori-Tori2 = 360 or Tori-Tori2 = -360 then
                Message("Orientation of Stimulus and Distractor1 gratings cannot be the same, or 180 degrees apart, quitting!");
                SampleStop();
                Halt;  'nothing has really happened yet, so we should be able to stop gracefully (test this)
            endif;
        else 'if one grating, use plaidAngle to adjust orientation so that the plaid is "zero degrees" (moves rightward)
            ParseGratingParameters%(GetGratingParameters$("Stimulus"), Tx, Ty, Tw, Th, Tiw, Tih, Tcontrast%, Tsf, Ttf, Tori, Tphase, Tcv$, Tpattern$, Taperture$);
            'Assign orientations
            Tori := 360 - (tunPlaidAngle/2);
            if Tori < 0 then
                Tori := Tori + 360;
            endif
            Tori2 := (tunPlaidAngle/2);
            if Tori2 > 360 then
                Tori2 := Tori2 - 360;
            endif
            'Start over with stim, because the orientations had to be adjusted
            'Stim$ := "-s " + EncodeGratingParameters$(Tx, Ty, Tw, Th, Tiw, Tih, Tcontrast%, Tsf, Ttf, Tori, Tphase, Tcv$, Tpattern$, Taperture$);
            'Stim$ := Stim$ + " -s " + EncodeGratingParameters$(Tx, Ty, Tw, Th, Tiw, Tih, Tcontrast%, Tsf, Ttf, Tori2, Tphase, Tcv$, Tpattern$, Taperture$);
            'Force contrast to 100 if using one grating
            Stim$ := " -s " + EncodeGratingParameters$(Tx, Ty, Tw, Th, Tiw, Tih, 100, Tsf, Ttf, Tori, Tphase, Tcv$, Tpattern$, Taperture$);
            Stim$ := Stim$ + " -s " + EncodeGratingParameters$(Tx, Ty, Tw, Th, Tiw, Tih, 100, Tsf, Ttf, Tori2, Tphase, Tcv$, Tpattern$, Taperture$);
        endif;
        
        'Have to change the Values$ variable because the default does not give us what we want, tunValuesStringified$ is OK, but there's more!
        docase
        case tunPlaidTuneType% = 0 then 'if tuning on orientation
            Values$ := "100," + Str$(Ttf) + ",[" + tunValuesStringified$ + "]";
        case tunPlaidTuneType% = 1 then 'if tuning on temporal frequency  
            Values$ := "100,[" + tunValuesStringified$ + "]," + Str$(tunPlaidStaticDirection);
        case tunPlaidTuneType% = 2 then 'if tuning on contrast
            Values$ := "[" + tunValuesStringified$ + "]," + Str$(Ttf) + "," + Str$(tunPlaidStaticDirection);
        endcase
        
        if tunPlaidFullScreen% = 1 then  'if full screen, set w/h to 0 to indicate this
            Tw := 0;
            Th := 0;
        endif;
        Tune$ := " -x " + Str$(Tx) + "," + Str$(Ty) + "," + Str$(Tw) + "," + Str$(Th) + "," + Values$;

    case tunType$ = tunTypeSpatial$ then

        'Tune$ := Dual$ + " -S " + Values$;
        Tune$ := " -S " + Values$;

    case tunType$ = tunTypeTemporal$ then

        'Tune$ := Dual$ + " -T " + Values$;
        Tune$ := " -T " + Values$;

    case tunType$ = tunTypeArea$ then
        
        'Tune$ := Dual$ + " -A " + Values$;
        Tune$ := " -A " + Values$;
        
    case tunType$ = tunTypeID$ then
        
        Tune$ := " -M " + Values$;
        
    case tunType$ = tunTypeNullTest$ then
        
        Tune$ := " -P " + Str$(tunNullTestTF) + ",";
        if tunNullTestStepFunc% = 0 then
            Tune$ += "q," + Values$;
        else
            Tune$ += "s," + Values$;
        endif;
        
    case tunType$ = tunTypeDriftingBar$ then
        
        'build foreground gray level string
        tunFGStr$ := "(" + Str$(tunBarForegroundGrayLevel%) + "/" + Str$(tunBarForegroundGrayLevel%) + "/" + Str$(tunBarForegroundGrayLevel%) + ")";
        'build drifting bar string
        tunBarStr$ := Str$(tunBarWidth) + "," + Str$(tunBarHeight) + "," + Str$(tunBarSpeed) + ",";
        
        Tune$ := " -G " + tunFGStr$ + "," + tunBarStr$ + "," + Values$;
        
    case tunType$ = tunTypeCRG$ then
        
        if tunCRGMBalanced% = 1 then
            tunCRGBal$ := " -B ";
            tunCRGNumTerms% := (tunStimulusDuration/2)*(dataScreenHz/tunCRGMFramesPerTurn%);
            nTriggersExpected% := (tunStimulusDuration)*(dataScreenHz/tunCRGMFramesPerTurn%);
        else
            tunCRGBal$ := " -R ";
            tunCRGNumTerms% := tunStimulusDuration*(dataScreenHz/tunCRGMFramesPerTurn%);
            nTriggersExpected% := tunCRGNumTerms%;  'There is one trigger per frame change.  The first trigger is parsed as the stim on, so each trigger we count is an offset, there are as many offsets as turns
        endif;
            printlog("number of triggers expected is %d\n",nTriggersExpected%);
        
        Tune$ := " -F " + tunMSeqLocation$ + tunCRGBal$ + Str$(tunCRGMFramesPerTurn%) + "," + Str$(tunCRGMFirstTerm%) + "," + Str$(tunCRGNumTerms%) + "," + Values$;  'Values$ indicates the contrasts
        
    case tunType$ = tunTypeBorderOwnership$ then
        var X,Y,W,H;
        ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"),X,Y,W,H);
        Tune$ := " -c " + Str$(X) + "," + Str$(Y) + "," + Str$(tunBOSize1) + "," + Str$(tunBOSize2) + ",white,black," + Values$;
        
    case tunType$ = tunTypeStimTrigPSTH$ then
        'Just do a contrast tuning curve with values of 0
        Tune$ := " -C " + Values$;
        'tunInterTrialTime := tunSTPISI;  'redefine intertrial time  (why?!?)
        
    case tunType$ = tunTypeCSD$ then        

        Tune$ := CreateFFFlashString$(tunCSDNFlips%,tunCSDISI);
        tunStimulusDuration := tunCSDISI*tunCSDNFlips%*2;  'redefine stimulus duration
        Stim$ := "";  'We do not want any stim value set
        
    case tunType$ = tunTypeDanish$ then
        Tune$ := " -H " + Values$;
        'Only set DGrat/DGratParam if we're using them
        DGrat$ := " -s ";
        DGratParam$ := GetGratingParameters$("Distractor1");  'the donut - this goes FIRST 
        Stim$ := DGrat$ + DGratParam$ + Stim$;  'Adjust stim for Danish syntax
    
    else

        Message("Error - unknown value for tunType$: " + tunType$);
        Halt;

	endcase;
    
    cmdLine$ := "cmd /c " + bin$ + ProgName$ + Extras$ + Stim$ + Tune$;
    'if command line is too long, do file version
    if Len(cmdLine$) > 8000 then
        cmdLine$ := "cmd /k " + bin$ + ProgName$ + " -F " + specFileName$;
        'open a file to write the trial-by-trial specs for the VSG
        specHandle% := FileOpen(specFileName$, 8, 1);
        'print to spec file
        Print("%s %s %s",Extras$,Stim$,Tune$);  'file should be everything starting from FixationArg$ on   
        'close spec file
        FileClose(0);
    endif;

    
    ' Record initial text marks. The command line may need to be broken into pieces. 
    if tunTriggerHack% = 0 then
        SampleText("Tuning,3," + str$(Len(cmdLine$)));  'not clear what this should be, if anything.
    else
        SampleText("Tuning,4," + str$(Len(cmdLine$)));  'not clear what this should be, if anything.
    endif
    
    SampleText(tunCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    PrintLog("num advances is %d and num repeats is %d and length cmdline is %d\n",tunNAdvances%,tunNRepeats%,Len(cmdLine$));
    
	StimHandle% := ProgRun(cmdLine$,1);
	if StimHandle% < 0 then Message("Could not start stimulus."); halt; endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
    
    'Given a large number of trials (i.e. a long json file) render need a bit of time
    'to parse the whole thing and get ready, so just make sure there is enough time
    '(about a second seems sufficient) for render to finish preping before we roll...
    'NOTE: this is especially important if no WaveMark channels are being recorded as
    'there is no pause for thresholding etc.
    tInterTrialTime := tunInterTrialTime;
    while ProgStatus(StimHandle%) = 1 and DisplayHardwareIndex% = 1 do  'wait for render app to close, VSG does not close
        yield(0.1);
    wend;
    
return 1;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
	'	PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
    'message(str$(len(ind%)));
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
        
		s$ += str$(vec[ind%[i%]]);
	next
	return s$;
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Allow investigation of rasters

func InvestigateRastersDialog%()
	var i%;
    var trodes$[10];
    'var trodes[10];  'make global
    var vals$[30];
    'var vals[30];    'make global
    var nTrodes%;
    var nVals%;
    var ind1%;
    var ind2%;
    var temp;
    
    ArrConst(trodes,-4341);  'arbitrary values that won't come up
    ArrConst(vals,-235124);
    
    'Fill out lists, get number of unique entries
    for i% := 0 to Len(trodes$[])-1 do
        temp := tunWavemarkPorts%[i%];
        if ArrFindFloat%(trodes,temp) = -1 then
            nTrodes% := nTrodes% + 1;
        endif;
        trodes$[i%] := Str$(tunWavemarkPorts%[i%]+1);
        trodes[i%] := temp;
    next;
    
    for i% := 0 to Len(vals$[])-1 do
        temp := tunValues[i%];
        if ArrFindFloat%(vals,temp) = -1 then
            nVals% := nVals% + 1;
        endif;
        vals$[i%] := Str$(tunValues[i%]);
        vals[i%] := temp;
    next;
    
	DlgCreate("Investigate Rasters", 50, 10);
	DlgList(1, "Electrode:", trodes$, nTrodes%, 20, 2);  'List of available electrodes
    DlgList(2, "Tuning Curve Value:", vals$, nVals%, 20, 3);  

	'DlgButton(1, "View Raster", InvestigateRasters%, 2, 5);
    DlgAllow(1023,0,InvestigateRasters%);
    
    i%:=DlgShow(ind1%,ind2%);  'we're not keeping any of these values
    
    return i%;
        
end;


func InvestigateRasters%(i%)
    var t%;
    var v%;
    var WindowStep;
    var mCd1%;
    var mCd2%;
    var preEvent;
    
    WindowStep := 100/tunNWavemarks%;
    t% := DlgValue(1);
    v% := DlgValue(2);
           
    'create the raster
    view(handlePSTH%[t%]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggers%,rasterTotal,rasterPre,v%);  'Update single-stim histogram        
    'And update the title, to indicate which stimulus it is
    view(handlePSTH%[t%]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[t%]+1) + myTitle2$ + Str$(tunValues[v%]));  'Rename single-stim histogram
    
    if tunDoOpto% = 1 then
        'create the raster
        view(handlePSTH%[t%+8]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggersOpto%,rasterTotal,rasterPre,v%);  'Update single-stim histogram        
        'And update the title, to indicate which stimulus it is
        view(handlePSTH%[t%+8]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[t%]+1) + " Opto On " + myTitle2$ + Str$(tunValues[v%]));  'Rename single-stim histogram
        
        'do Scotty rasters, these are gated so we can do them on every trial and not worry about it
        if tunOptoUsePulse% = 1 then
            mCd1% := Asc("P");
            mCd2% := Asc("S");
            preEvent := 0;
        else
            mCd1% := Asc("o");
            mCd2% := Asc("n");
            preEvent := tunPreStimOptoTime + 0.5;
        endif;
        
        'update the rasters
        view(handlePSTH%[t%+16]).process(0,view(-1).maxtime(),1,1,0,31,0.5,preEvent,mCd1%); 'stimuli with opto
        view(handlePSTH%[t%+24]).process(0,view(-1).maxtime(),1,1,0,31,0.5,preEvent,mCd2%); 'stimuli with no opto
        'update the titles
        view(handlePSTH%[t%+16]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[t%]+1) + " Opto On");
        view(handlePSTH%[t%+24]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[t%]+1) + " Opto Off");
        
        
    endif;
    
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Just a quickie that grabs the current temporal frequency, useful for making sure
' F1/F2 calcs aren't done is TF = 0

func GetTemporalFrequency()
    var Tstimstr$;
    var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;	
    var i%;
    Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
    printlog("OK, in GTF the TF is %s\n",Tstimtf$);
    return Val(Tstimtf$);
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This proc sets the sequencer variables for pulsing opto
'We will run this at the beginning, and if we are changing the opto values on each trial, we will run it again
'for each trial
proc SetPulsedOptoSequencerVariables()
    
    var stimRemaining;
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;

    stimRemaining := tunStimulusDuration;
    stimRemaining := stimRemaining - tunPulsedOptoOnset;  'duration of stimulus after onset delay
    stimRemaining := stimRemaining - tunPulsedOptoWidth;  'duration of stimulus after first opto pulse
    if stimRemaining < 0 then  'if first pulse will extend beyond stimulus duration
        tunOptoNPulses% := 0;  'turn off opto by using no pulses
        'tell user they blew it
        Message("The first opto pulse will extend beyond the stimulus!  Quitting!!!");
        Quit%();
    else
        tempNPulses% := tunOptoNPulses% - 1;  'how many more pulses are left?
        tempCount% := 1;  'temporary successful pulse count
        while tempNPulses% > 0 do
            stimRemaining := stimRemaining - tunPulsedOptoWidth - tunPulsedOptoIPI;  'subtract duration of one more pulse+IPI
            if stimRemaining < 0 then  'if this pulse will extend beyond stimulus duration
                Message("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed!");
                tunOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                stimRemaining := stimRemaining + tunPulsedOptoWidth + tunPulsedOptoIPI;  'add back duration of one more pulse+IPI, gets actual stimulus duration remaining
                tempNPulses% := 0;  'break while
            else  'if this pulse is OK
                tempCount% += 1;  'increment temporary successful pulse count
            endif;
            tempNPulses% -= 1;  'decrement temporary pulse count remaining
        wend
    endif;
    
    SampleSeqVar(6,tunOptoNPulses%);  'set number of pulses
    printlog("Opto N pulses is %d\n",tunOptoNPulses%);
    'For below calculations, the standard numbers we are getting are in seconds, sequencer period is in MS (because that's how it comes)
    
    tempSeqVarValue := tunPulsedOptoWidth*1000/SequencerPeriodMS;  'do math in float
    tempSeqVarValue% := tempSeqVarValue-2;  'now convert to integer, subtract two ticks for sequencer instructions
    if tempSeqVarValue% < 0 then  'Do not give sequencer variable a negative duration, minimum opto width is 3 ticks
        tempSeqVarValue% := 0;
    endif;
    SampleSeqVar(7,tempSeqVarValue%);  'set duration of pulse in clock ticks
    printlog("Opto width is %d\n",tempSeqVarValue%);
    
    tempSeqVarValue := tunPulsedOptoIPI*1000/SequencerPeriodMS;  'do math in float
    tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
    if tempSeqVarValue% < 0 then  'Do not give sequencer variable a negative duration, minimum IPI width is 4 ticks
        tempSeqVarValue% := 0;
    endif;
    SampleSeqVar(8,tempSeqVarValue%);  'set interpulse interval in clock ticks
    printlog("Opto IPI width is %d\n",tempSeqVarValue%);
    
    tempSeqVarValue := tunPulsedOptoOnset*1000/SequencerPeriodMS;  'do math in float
    tempSeqVarValue% := tempSeqVarValue-1;  'now convert to integer, subtract one tick for sequencer instructions
    if tempSeqVarValue% < 0 then  'If the user specifies 0 offset, we pass -1 to DELAY, which turns out to be crossing-the-streams level of bad. (Original discovery of DELAY error comment retained)
        tempSeqVarValue% := 0;
    endif;
    SampleSeqVar(9,tempSeqVarValue%);  'set pre-pulse stimulus duration in clock ticks
    printlog("Opto onset is %d\n",tempSeqVarValue%);
    
    tempSeqVarValue := stimRemaining*1000/SequencerPeriodMS;  'do math in float
    tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
    if tempSeqVarValue% < 0 then  'Do not give sequencer variable a negative duration, minimum stimulus following pulse offset is 4 ticks
        tempSeqVarValue% := 0;
    endif;
    SampleSeqVar(10,tempSeqVarValue%);  'set post-pulse stimulus duration in clock ticks
    printlog("Opto remaining time is %d\n",tempSeqVarValue%);
end



'--------- BurstCount -----------
func BurstCount(nSpikes%,times[],startInd%)
    var nBurstsFound%;
    var i%;
    
    ArrDiff(times[]);  'Will do a difference on times[], times[0] does not change, times[1] is times[1]-times[0], etc.
    
    for i% := startInd% to nSpikes%-2 do  'we are looking at spikes i% and i%+1, so the last legal pair to check is: i% = nSpikes%-2; i%+1 = nSpikes%-1
        if times[i%] >= 0.1 and times[i%+1] <= 0.004 then
            nBurstsFound% += 1;
        endif;
    next;

    'printlog("Number of spikes is %d and number of bursts is %d\n",nSpikes%,nBurstsFound%);

    return nBurstsFound%;
    
end




'--------- CreateFFFlashString$ -----------
func CreateFFFlashString$(NFlips%,ISI);
    var outString$;
    var framesPerTermLocal%;
    var ValuesLocal$;
    var i%;
    
    'Make a long string of black followed by white flashes
    for i% := 1 to NFlips% do
        ValuesLocal$ := ValuesLocal$ + "01";  'Hardcoded Black first and WE WILL NEVER DO ANYTHING ELSE SO HELP ME GOD
    next
    
    
    'Get number of frames per flash
    framesPerTermLocal% := dataScreenHz*ISI;  
    
    outString$ := " -e " + ValuesLocal$ + " -L " + Str$(framesPerTermLocal%) + " ";
    
    return outString$;
end


'--------- BorderOwnershipString$ -----------
func BorderOwnershipString$(byte%);
    var binary%[8];
    var outString$;
    
    Byte2Binary(byte%,binary%[]);
    
    if binary%[3] = 0 then
        outString$ := "Sq=white,BG=black,";
    else
        outString$ := "Sq=black,BG=white,";
    endif;
    
    docase
    case binary%[0] = 0 and binary%[1] = 0 then
        outString$ := outString$ + "Ori=0,";
    case binary%[0] = 1 and binary%[1] = 0 then
        outString$ := outString$ + "Ori=45,";
    case binary%[0] = 0 and binary%[1] = 1 then
        outString$ := outString$ + "Ori=90,";
    case binary%[0] = 1 and binary%[1] = 1 then
        outString$ := outString$ + "Ori=135,";
    endcase
    
    if binary%[2] xor binary%[3] then
        outString$ := outString$ + "LocCont=0,";  'This means that color 0 (white) is on the left/top
    else
        outString$ := outString$ + "LocCont=1,";  'This means that color 1 (black) is on the left/top
    endif
    
    if binary%[4] = 0 then 
        outString$ := outString$ + "Size=" + Str$(tunBOSize1);
    else
        outString$ := outString$ + "Size=" + Str$(tunBOSize2);
    endif
    
    return outString$;
end
