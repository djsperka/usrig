'Welcome to PresEngine Version 1.6!

'PresEngine 1.6 is a major revision of the PresEngine line.  In this version additions are made to
'implement the multimodal experiments.  Here we are sending commands via serial port to a separate
'computer (typically, Daisuke) which runs Matlab with Psychtoolbox and will present the requested
'random-dot stimuli coincident with the auditory stimulus.  Note that the Matlab side is basically
'passive, simply presenting what is requested.


'Note that the revision history prior to version 1.6 has been expunged.  This history may be found
'in "Pres_Engine1.1.20.s2s" and "Pres_Engine1.0.10.s2s" and "Pres_Engine1.3.33.s2s" and 
'"Pres_Engine1.4.25.s2s" and "Pres_Engine1.5.4.s2s"

'Code has been slightly adapted to work for Henry in the Usrey Lab.
'Henry wants to have the code updated to use the same autonaming scheme that is used in the Usrey
'Lab code.
'
'For the Usrey Lab, GetDrivePath will point the drive path to:
'D:/Sutter_Stuff/
'and I think we need to keep working with that - updating everything to get it into the normal repository
'location will be pretty messy.



'==================================== Very Variable Variables ============================
var ThisVersion$ := "vUsrey";  'Usrey, adapting for use in Usrey Lab
'===================================== Included Files ====================================


    #include "../../../Sutter_Stuff/experiments/ced_scripts/TransStair.s2s"  'BigAl
    #include "../../../Sutter_Stuff/experiments/ced_scripts/GetDrivePath.s2s"  'BigAl

    '#include "../../../experiments/ced_scripts/TransStair.s2s"  'Seager
    '#include "../../../experiments/ced_scripts/GetDrivePath.s2s"  'Seager





'===================================== Global Variables ==================================
'Note that the following IF statement is not functional code, it simply allows me to fold the VAR declarations
if 1 then  'VAR declarations are folded below
    
	'===== Paths and Directories =====
    var FilePrefix$;
    var MonkeyLetter$;
    var DrivePath$;
    var TrialFile$;  'location of Trials file
    var TrialFileShort$;   'just the filename, for registry
    const MaxTrialsFiles% := 10; 'ceiling
    var TrialFileList$[MaxTrialsFiles%];   'Holds all trials files for adaptive switching scenarios, will write all filenames to IDX file
    var TrialFileListShort$[MaxTrialsFiles%];  'same thing, only the file name, for registry
    var ParamFile$;  'Location of Param File
    
    'Determine which drive has the CED stuff on it - it's different on different machines
    DrivePath$ := GetDrivePath$();
    if DrivePath$ = "quit" then
        quit%();
    endif;
    
    var DataPath$;
    DataPath$ := DrivePath$+"experiments\\spkdata\\";  'Directory containing final data
    var OnlineDir$;
    OnlineDir$ := DrivePath$+"experiments\\online\\";  'Directory containing data updated online
    var StimRootPath$;
    StimRootPath$ := DrivePath$+"experiments\\stimuli\\";  'Directory containing stimuli
    var StimPath$[20];  'StimPath$ read from parameter file, can now take many multiple stimpaths
    var ParamDir$;
    ParamDir$ := DrivePath$+"experiments\\parameters\\";  'Directory containing Parameter and Trials files/folders
    var LogDir$;
    LogDir$ := DrivePath$+"experiments\\log\\";  'Directory containing log files written by this script  
    
    '  ======= Important =======
    '  Sequencer file syntax has obligatorily changed starting with v1.3.0
    '  You must either use SEQ_CONTROL_ENGINE_2.PLS or the sequencer file
    '  must assign V3 (variable 3) to be the current number of clock ticks
    '  after every stimulus play
    var SeqFileName$;
    SeqFileName$ := DrivePath$+"experiments\\ced_seq\\seq_control_engine_3.PLS";  'Sequencer file to run
    '  ======= End Important =======
    
    
    '  ======= Note =======
    'The original versions of Pres_Engine used hard-coded configuration files.  This was changed back in April of 2013 (1.4.17)
    'to have the configuration "built" by the script.  Due to apathy, it was not until March of 2015 that the now-unused
    'ConfigFileName*$ variables were commented out.  Note that the solenoid cleaning CONTINUES to use the behavioral config file.
    'There's not much reason to go to the effort to convert this over, but in the future it will be good to know this before
    'zapping all the config files or whatever.
    'var ConfigFileName$;
    'ConfigFileName$ := DrivePath$+"experiments\\pres_engine_config.s2c";  'Configuration file to open for physiological experiments using the lever
    var ConfigFileNameBehav$;
    ConfigFileNameBehav$ := DrivePath$+"experiments\\pres_engine_behavioral.s2c";  'Configuration file to open for behavioral experiments using the lever
    'var ConfigFileNameJoystick$;
    'ConfigFileNameJoystick$ := DrivePath$+"experiments\\pres_engine_joystick.s2c";  'Configuration file to open for physiological experiments using the joystick
    'var ConfigFileNameJoystickMotion$;
    'ConfigFileNameJoystickMotion$ := DrivePath$+"experiments\\pres_engine_joystick_motion.s2c";  'Configuration file to open for physiological experiments using the joystick
    'var ConfigFileNameJBehav$;
    'ConfigFileNameJBehav$ := DrivePath$+"experiments\\pres_engine_jbehav.s2c";  'Configuration file to open for behavioral experiments using the joystick
    'var ConfigFileNameJBehavMotion$;
    'ConfigFileNameJBehavMotion$ := DrivePath$+"experiments\\pres_engine_jbehav_motion.s2c";  'Configuration file to open for behavioral experiments using the joystick
    'var ConfigFileNameGod$;
    'ConfigFileNameGod$ := DrivePath$+"experiments\\pres_engine_joygod.s2c";  'Configuration file to open for shaping, when god button is active
    '  ======= End Note =======
    
    
    var CloseAllPath$;
    CloseAllPath$ := DrivePath$+"experiments\\ced_scripts\\CloseAll.s2s";  'Path to simple script that closes all windows w/o saving or asking
    var SetPA5Loc$;
    SetPA5Loc$ := DrivePath$+"experiments\\SetPA5\\Release\\SetPA5";  'Path to SetPA5 program
    var SetPA5sLoc$;
    SetPA5sLoc$ := DrivePath$+"experiments\\SetPA5\\Release\\SetPA5s";  'Path to SetPA5s program, sets multiple PA5s
    var GenericPath$;
    GenericPath$ := DrivePath$+"experiments\\stimuli\\generic\\";  'Path to generic stimuli
    
    
    '==== Verbosity Variables ====
    var VerboseStimID% := 1;  'Do we report trial-by-trial stimulus information verbosely?
    var VerboseAccuracy%;     'Trial-by-trial accuracy?
    var VerboseIncrements%;   'Requested increment changes?
    var VerbosePA5%;          'PA5 information
    var VerboseTrialTiming%;  'Trial timing?
    var VerboseMainLoop%;     'Main loop iteration and IF statements?
    var VerboseStimLoad%;     'Stimulus load details, can be extensive
    var VerboseJoyLev%;       'Joystick/Lever details?
    var VerboseUberVerbose%;  'Want to see everything on the main loop?  Are you insane?  OK!
    var AllowMainLoopVerbose% := 1;  'Don't repeat every single time we re-run
    
    
    '====Constants====
    const NMaxTrials% := 15000;
    const NMaxStim% := 2000;
    
	'==== Parameter File Variables ====
	'Please note that defaults are now set with a separate function, so changing them here will not be effective
    var ExpectNewStim%;    '1 if we expect new stimuli in an adaptive procedure
    var Passive%;          '1 if it is a passive scenario (no responses), 0 if active, -1 forces parameter file to specify
    var Behavioral%;	   	'1 if experiment is behavioral (no histograms), 0 if physiological, -1 forces parameter file to specify
    var NTrodes%;          'replacing Behavioral% because there's no clean way to indicate multiple electrodes      
    var OrigNTrodes%:=-1;  '-1 indicates that we haven't reloaded params...if we have, we have to check to make sure NTrodes% is the same (was OrigBehavioral%)
    var RespDevice%;       '0 if experiment uses lever, negative values are for go/no-go, positive values for forced choice
    var NSpeakers%;         'Number of speakers, 0 forces parameter file to specify
    var stimN%;            'Number of stimuli
    var MinITI;         'The minimum length of the ITI, in seconds, default = 1
    var DeltaITI;       'The ITI change (positive or negative) per completed trial, in seconds
    var MaxDeltaITI;    'The maximum ITI change created by DeltaITI
    var MinITIFloor;    'So that MinITI does not surpass the MaxDeltaITI
    var MinITICeil;
    var AddITIactive;		  'The max amount of ITI to add in randomization in active scenarios, in seconds
    var AddITIpassive;	  'The max amount of ITI to add in randomization in passive scenarios, in seconds
    var ITI;               'Actual length of inter-trial interval, in seconds
    var ResponseWindow;    'Length of monkey's (initial) response window, in seconds, default = 0.8
    var RespWindowDec;  'Size of Response Window decrement on correct trials in seconds, default = 0 (no decrementing)
    var RespWindowInc;  'Size of Response Window increment on incorrect trials
    var RespWindowMin;     'Minimum duration of response window in seconds, if decrementing, default = 0.8 
    var RespWindowMax;      'Maximum duration of response window in seconds, if incrementing, negative values take ResponseWindow
    var RespWindowDelay;  'The delay between the end of the stimulus and the opening of the response window
    var IntPenalty;	  'Timeout penalty for interrupt, in seconds, default = 9   
    var FAPenalty;     'Timeout penalty for False Alarm, in seconds, default = 15
    var MPenaltyTemp;    'Unlike other penalties, this one needs a temporary holder taht is filled with the correct value
    var MPenalty;       'Timeout penalty for Miss, in seconds, default = 0
    var MPenaltyTUp;     'Timeout penalty for Miss when target is up, default = 0
    var MPenaltyTDown;   'Timeout penalty for Miss when target is down, default = 0
    var CatchPenalty;    'Timeout penalty for catch trials, default = 0
    var NRPenalty;       'Timeout penalty for not responding on Forced Choice trials, default = 0
    var LazyTO;       'Once trial is ready, monkey has this long to start, or gets a time out, in seconds, default = 200
    var LazyTOPenalty; 'Timeout penalty for monkey not working, in seconds, default = 10
    var LazyTOFactor;   'Number to multiply LazyTOPenalty by to increase each time, default = 1 (no incrementing)
    var LazyTOMax;     'Maximum value of incremented LazyTOPenalty, in seconds, default = 10
    var ReleaseTO;     'If trial is over, monkey has this long to release lever or return joystick to center, or gets a time out, in seconds, default = 20
    var ReleaseTOPenalty;  'Timeout penalty for failure to release, in seconds, default = 10
    var ReleaseTOFactor;   'Number to multiply ReleaseTOPenalty by to increase each time, default = 1 (no incrementing)
    var ReleaseTOMax;      'Maximum value of incremented ReleaseTOPenalty, in seconds, default = 10
    var TrialOnsetDelay; 'Length of time between monkey initiation of trial and sound onset, in seconds, default = 0.2
    var TrialOnsetMax;      'maximum TrialOnsetDelay, default = 2 seconds
    var TrialOnsetInc;     'Size of increment for TrialOnsetDelay, in seconds, default = 0;
    var TrialOnsetMin;      'minimum TrialOnsetDelay, default = 0.1 seconds
    var TrialOnsetDec;     'Size of decrement for TrialOnsetDelay, in seconds, default = 0;
    var RewardDelay;       'Length of time until reward (from response [hit] or end of response window[CR]), in seconds, default = 0.2
    var StimInfo$[NMaxStim%];     'String holding arbitrary information about the stimulus
    var StimLet$[NMaxStim%];      'Letter corresponding to each stimulus
    var StimName$[NMaxStim%];     'Stimulus file name, without suffix, for each stimulus
    var StimPoints%[NMaxStim%];   'Number of points in each stimulus, including ISI after stimulus
    var ISI[NMaxStim%];           'Requested ISI after each stimulus (essentially, delay after stim before next in series)
    var SampP[NMaxStim%];		     'Sample Period of each stimulus in microseconds (must be the same for all stimuli - only keeping this b/c I might change it someday to allow multiple sampling frequencies...ugh!)
    var SampPOld;             'Sample period of stimuli in microseconds (only using one since they're all supposed to be the same!)
    var WhichStimPath%[NMaxStim%];   'Holds which stimpath to use
    ArrConst(WhichStimPath%[],1);  'Set values to one initially, so it defaults to the original StimPath$
    var SampleRate;                'Sample rate FOR STIM PLAYBACK, in Hz (only one for entire set of stimuli)
    var SamplesPerMS%;     'Sampling rate/1000, for LoadStim%()
    var NormAtten[NMaxStim%];     'Attenuation factor to normalize stimuli to each other, in dB, used to calculate ScaleFactor
    arrconst(NormAtten[],1000);  'start NormAtten with a value that is "too big" - allows the minimum to be taken
    var ScaleFactor[NMaxStim%];   'Multiplicative attenuation factor (0-1) for online normalization of stims - not sent to PA5
    var StimGroup%[NMaxStim%];    'Will hold the "grouping" of the stimulus, used to allow collapse across groups in Overall PSTH
    var StimGroupLabel$[NMaxStim%];  'hold the label of this stim group
    var UniqueStimGroup$[NMaxStim%];  'A unique list of stimulus group "labels" - where "label" means like for AM "100", "80", etc.
    var SolenoidOpenDur%;  'length of time to leave solenoid open, in ms
    var SolenoidOpenDurFloat;     'a float verison of SolenoidOpenDur%
    var GodButtonExists%;	'1 if there is a God Button, 0 if not
    var ContReinfDelay;    'continuous reinforcement delay period (how long joystick must be kept out of center)
                            'if negative, no continuous reinforcement
    var ContReinfDelayInc;  'amount of increment for correct trials during continuous reinforcement
    var ContReinfDelayDec;  'amount of decrement for interrupts during continuous reinforcement
    var ContReinfDelayMax;  'maximum ContReinfDelay after incrementing
    var ContReinfDelayMin;  'minimum ContReinfDelay after decrementing, if negative will be ContReinfDelay
    var ContReinfTO;     'Time Out penalty during continuous reinforcement
    var ContReinfInit$;     'Direction of initiation of CR, "x", "y", "up", "down", "left", "right"
    var ContReinfEnd$;      'Direction to end/reward CR, "return", "up", "down", "left", "right", "same"
    var CRInitPos%;         'Holds continuous reinforcement initial position for "x" and "y"
    var FadedBInit;			'How many dB below baseline do we start NT stim?  If 0, no fade.  Specifically for stereo stims   
    var FadedBInc;				'Fade incrememnt in dB
    var FadedBDec;              'Fade decrement in dB, only for non-staircase method
    var FadedBMax;              'Maximum SPL value (so min attenuation) during fade-in, floored at 0
    var FadedBMin;              'Minimum SPL value (so max attenuation) during fade-in
    var StairTargAcc;           'Intended percent correct on FadedB, overrides FadedBInc
    var FadedBLast;			'the most recent FadedB value, used only for IDX update (due to delayed write timing)
    var Errorless%;			'Do errorless training?
    var RepeatOnError%;		'Should we repeat a stimulus if it is answered wrong?
    var Interleaved%;       'Do we do interleaved passive and active trials, default = 0 = no
    var PassiveAndActive%;  'In contrast to INTERLEAVED (passive and active in same trials file) this allows passive and active in different trials files without being explicitly "interleaved"
    var IsSearchBMF%;       'Is this a BMF search scenario?
    var CollectEEG%;        'Is EEG being collected?  Default = 0 = no
    var MinRespTime;			'Minimum Response Time, in sec - the response must be at least this long.  Default = 0
    
    var MaxPoint%;          'Total size of audio out buffer, will allow three seconds of sound at 100000 Hz sampling rate
    var MaxPoint2%;         'For use in stereo experiments
    var MaxPoint1401% := 600000; 'Maximum size of audio buffer allowed by 1401
    var MaxPointSec;        'Maximum size of audio buffer allowed, in seconds
    var FastSwitch%;			'Do we bring up a dialog box for fast switching after BMF search? Default = 0 = no
    var PersevPct;          'Percentage of missed trials over PersevN trials (of that response) defined as Perseverance
    var PersevN;           'N for PersevPct
    var BrkPersevPct;       'Percentage accuracy during Repeat-On-Error to break Perseverance
    var BrkPersevN;        'N for BrkPersevPct
    var ReleaseFromPersevTrial%;  'On which trial did we last release from perseverance?
    var JoystickType%;      'Type of Joystick - "human" or "monkey", default = "monkey" (holds 1 = human, 0 = monkey)
    var FeedbackOff%;       'Do we turn all feedback (reward, light) off?
    var NumHitsCR%;         'how many solenoid hits for a correct rejection?
    var Motion%;            'are we using a motion detector?  (Joystick scenarios ONLY)
    var TrialWrap%;         'should trials wrap around when we reach the last one?
    var CalibrationMode;    'Are we in calibration mode?
    var CueLightEachTrial%; 'Are we using different cue lights on individual trials?
    var CueLightOverride$;  'Override default cue lighting for tasks (currently TargetMotion tasks) that have default cue light conditions
    var CueLightFRUDUp$ := "";  'We are going to force the setting of the color of the UP cue light in monojoystickFRUD scenarios
    var CueLightFRUDDown$ := "";  'and it's convenient to do this, I'll allow it to be set
    var TargetMotion% := 2; 'If using a Mono-Forced-Choice scenario, which direction is the target?  2 is an illegal value
    var TargetMotionWindow%;  'Length of target motion window for calculation of performance
    var TargetMotiondPrimeCrit;  'performance criterion, in dPrime, which will force a change in TargetMotion
    var TargetMotionChangeAt% := 0;  'holds most recent TargetMotion change trial, allowing calculation over the proper window only if enough trials have been done
    var IgnoreJoyThreshCap%;  'This will turn off the threshold caps if you want to set a threshold "out of reach"
    var CheckJoyTime;       'How long between joystick moves do we wait to make sure it's where we think it is? 
    var DoResponseBias%;    'Should we change reward size based on bias?  If 0, no.  If > 0 yes.  If < 0, no, but report bias in log file
    var FlashLEDOnError$ := "n";      'Which LED to flash if there is an error, set to (n)one to start (duration is miss/FA timeout)
    var FlashLEDOnCueChange%;   'Should we flash an LED when the cue light changes from one to another?
    var FlashLEDOnMiss%;
    var FlashLEDOnFA%;
    var FlashLEDFrequency;    'What frequency should the LED flash at?
    var FlashLEDCCDur;        'For what duration should the LED flash on cue change?
    var FlashLEDErrorDur;     'For what duration should LED flash on error, will occur before any timeout
    var FlashDur;             'This value calculated from FlashLEDErrorDur and FlashLEDOnError$, primary variable used in idle loop
    var NTrialsFiles% := 1;   'If greater than 1, will allow adaptive switching between trials files
    var SwitchWindow% := 20;  'Window size for switch calculations
    var SwitchWindow;         'We need a non-integer version for calcs
    var SwitchHarder := 0.85; 'If performance is >= this number, move to harder trial file
    var SwitchEasier := 0.60; 'If performance is <= this number, move to easier trial file
    var SwitchCurrFile%;     'Which file to start with when switching?
    var CriteriaIndPrime%;    'If 1, do criteria in d', if not, do criteria in accuracy
    var ContinuousRove;       'If non-zero, do continuous rove uniformly at 0.1 dB intervals between +-ContinuousRove
    var OverallPSTHType%;     'If 0, use all stimuli in overall PSTH.  If 1, split by AM, collapse across BW.  If 2 split by BW, collapse across AM
    var PA5Absent%;           'If 1, PA5 is missing, do all attenuation possible with software attenuation
    var HBCycle%;             'Heartbeat cycle
    
	'===== Trial Sequence Variables =====
    var StimOrder$[NMaxTrials%][10];   'A matrix of stimulus letters, trials in rows, stims to be concatenated in columns
    var StimOrder2$[NMaxTrials%][10];  'Second speaker, for stereo experiments
    var StimOrder%[NMaxTrials%][10];   'The order of stimuli (rows = trials, cols = stims) in integer rather than letter codes
    var StimOrder2%[NMaxTrials%][10];
    var ConcatStim%[NMaxTrials%];      'The number of stimuli in each row of StimOrder ( = the number of stims concatenated on each trial)
    var ConcatStim2%[NMaxTrials%];
    var TestStim%[NMaxTrials%];        'Holds the integer code of the final (test) stimulus on each trial
    var TestStim2%[NMaxTrials%];
    var TargVar%[NMaxTrials%];         'Holds whether the target is Nontarget(0), Target(1), or Probe(8,9)
    var TargVar2%[NMaxTrials%];
    var Atten[NMaxTrials%];            'Holds a trial-wide attenuation value
    var Atten2[NMaxTrials%];
    var ActivePassive%[NMaxTrials%];	  'Holds whether a trial is active (0) or passive (1), only used in interleaved experiments
    var TrialPoints%[NMaxTrials%];     'Holds the number of audio sample points in each trial
    var TrialPoints2%[NMaxTrials%];
    var TotalTrialsSutter%[MaxTrialsFiles%];  'Holds the maximum number of trials per trials file
    var MaxTFLen%;                'Maximum length of a trials file
    var TrialsInSwitchWindow%;         'How many trials have been done in this window (adaptive switching)
    var SwitchToTF%;                   'Which trial file to switch to, 0 if no switch this time
    var SwitchToTFInterrupt%;          'If there's an interrupt, we've got to hold this info while the interrupted trial is completed
    var SwitchWindowAcc;                'Accuracy in switch window, only calculated at end of window
    
	'===== Individual Trial Variables =====
    var CurrTrialIndexList%[MaxTrialsFiles%];  'holds the current index for each trials file
    var FutureTrialIndexList%[MaxTrialsFiles%];  'holds the future index for each trials file, don't know if this is necessary
    var CurrTrialIndex%;            'StimOrder index of current trial being presented
    var CurrentTrialIndexNoDec%;		  'Same as CurrTrialIndex%, but not decremented if repeating on error - used instead of CurrTrialIndex% in some places after the repeat on error decrement
    var FutureTrialIndex%;         'Same as CurrTrialIndex%, but for the next stim to be loaded.
    var SwitchFutureFile%;         'Same as SwitchCurrFile, but for the next stim to be loaded
    var TrialCount%;           'Holds actual number of stimuli presented
    var TrialCountList%[MaxTrialsFiles%];   'Used to count the number of trials presented from each trial file
    var StimOn;				      'Current trial onset time
    var PrevStimOn;               'Keeps track of previous StimOn, necessary from 1.3.0 to get accurate timing
    var EndOfStandards;          'Holds the time of the end of standards and the start of the test stimulus
    var EndOfStandards2;         'Holds the time of the end of standards and the start of the test stimulus
    var PrevEOS;                 'Holds the previous EndOfStandards; necessary because the next stim is loaded before the last one is finished playing
    var PrevEOS2;                'Holds the previous EndOfStandards2; necessary because the next stim is loaded before the last one is finished playing
    var StimDur;					  'Current stimulus duration
    var NextStimDur;             'Duration of the next stimulus - need two variables because of early load of subsequent stimulus
    var TrialBeginTime;          'Notes time that the LED comes on to start trial
    var TrialDoneTime;			  'Time at which trial is finished (with or without penalty)
    var NextTrialTime;           'Time when the next trial may begin
    var StimLoadTime;            'Time at which the stimulus was loaded
    var PA5SetTime;              'Time at which the PA5 has been set
    var TrialBeginLate;          'Amount of time trial is late starting
    var LeverPressTime;          'Time when lever pressed to start stimulus
    var ResponseTime2;           'Time when response is recorded, used in main loop
    var ResponseTime3;			  'Time when response is initiated, used in main loop
    var RecordStopTime;          'Time when we notice recording has been stopped
    var InterruptTime;           'Time when an interrupt occurs
    var StimDoneTime;            'Time we notice the stimulus is finished
    var TrialStatusTime;         'Time at which the response has been recorded
    var RewardGivenTime;         'Time the reward is given
    var BufferToPlay%:=2;        'Which stimulus buffer to load and play, by assigning at 2, Buffer 1 will be used first
    var StimCodes%[4];           'Holds stimulus code for each trial
    var GroupStimCodes%[4];      'Holds group code for each trial, only used if we are collapsing across either BW or AM in comod stims in Overall PSTH
    var Miss%;						  '1 if the trial was a miss
    var FalseAlarm%;				  '1 if the trial was a false alarm
    var TrialResult$;            '"H","CR","FA","M","PT","PN" (hit,corr_rej,false_alarm,miss,probe_target_resp,probe_nontarg_resp)
    var PlayTime1;					  'Holds time that buffer in DAC 0 played
    var PlayTime2;					  'Holds time that buffer in DAC 1 played
    var ExpectedResponse%;		  'Holds expected response (currently for joystick trials only)
    var IDXType$;					  'Holds the type of the trial for updating the IDX file
    var StimIsRepeating%;		  'Will be one when Stimulus is repeating
    var CurrentCueLights$;        'Cue light(s) to use on current trial, only used if CueLightEachTrial% is 1
    var NextCueLights$;           'Cue light(s) to use on next trial, only used if CueLightEachTrial% is 1
    var PenaltyDoneTime;          'Time any penalty is over, if 0, no penalty
    
	'===== Flow Variables =====
    var StimulusLoaded%;         '1 if the next stimulus has been loaded into a play buffer, 0 otherwise
    var StimulusReady%;          '1 if the current stimulus is ready to play, 0 otherwise
    var StimulusPlaying%;        '1 if the current stimulus is playing, 0 otherwise
    var MustReleaseLever%;       '1 if monkey is holding lever outside of trial
    var HoldLeverBegin;          'Indicates time that monkey began to hold lever after/between trials
    var LeverPos%;			     'Indicates position of lever
    var XPos%;					 'Indicates position of joystick in X axis
    var Ypos%;					 'Indicates position of joystick in Y axis
    var OffAxis%;				 'Indicates whether joystick has been moved in the "wrong" ("off") axis
    var CRaxis$;                 'Which is the Init$ axis?
    var LeverTime;			     'Holds time of most recent lever event
    var XTime;					 'Holds time of most recent event on joystick X axis
    var YTime;					 'Holds time of most recent event on joystick Y axis
    var InOrigin%:=1;			 'Indicates whether joystick/lever is in origin (centered joystick, up lever)
    var TrialInit%;				 'Indicates whether lever/joystick is in the trial initiation postion
    var TrialResponse%;			 'Indicates whether lever/joystick is in the trial response position
    var ResponseTime;			 'Holds time of last response event  
    var LastPos%:=11;			 'Holds most recent position of joystick, assume it starts in the center
    var JoystickReadOnce%:=0;	 'Indicates whether the joystick has ever been read or not
    var HoldLastCheckTime:=0;    'Holds the most recent time the joystick was read
    var HoldLastEventTime:=0;    'Holds the most recent real event time read from the joystick    
    var Interrupt%;              '1 indicates an interrupt
    var NumInterrupt%;			 'Unclassified interrupts during behavioral experiments
    var TargetResponse%;         'Keeps track of target response during go/no-go phase
    var TrialsFinished%;         'Are we all done with the trials from the current Trials file?
    var UpdatePSTHNow%:=0;		 'Have the PSTHs been updated this time through? (start at 1 to avoid crash)
    var UpdateSPKFile%;          'If 1, tells main%() to update the SPK file during an interrupt
    var ParamsLoadedOnce%;       'Will be changed to one once parameters are loaded for the first time, small bookkeeping to do
    var NewParamLoad%:=1;        'Holds the success of a new parameter load attempt
    var ResponseHistory%[10];    'Holds response history for fade-in stairstep
    var ResponseIndex%;          'Holds index to ResponseHistory%[] for fade-in stairstep
    var PersevHistory%[40];      'Holds response history for perseverance checking
    var RespPersevHistory%[40];  'Holds expected respose direction for perseverance checking
    var PersevIndex%;            'Holds index to PersevHistory%[]
    var LastResult%;             'Holds most recent result, -1 for miss, 1 for hit, 0 for indeterminate
    var PassiveToActive%;        'Is changed to 1 when we are switching from passive to active
    var SkipLoop%;               'Allows us to essentially re-run an IF in the main loop, normally 0.
    var NothingToLoad%;          'Allows us to skip loadstim step after final stimulus (if not trialwrapping)
    var RewardWait%;             'Are we waiting for a reward to finish?
    var MyAutoName$;             'what is the autoname of the file
    
	'===== Continuous Reinforcement Variables =====
    var BeginReinfTime;			  'Holds the time that the joystick X movement starts a continuous reinforcement trial
    var NextReinfTime;			  'Holds the timethe next reinforcement period should start - now an ITI can be added
    var NumCRInterrupt%;          'Holds the number of interrupts in continuous reinforcement, both on- and off- axis
    var NumDelayInterrupt%;		  'Holds the number of delay interrupts
    
	'===== Errorless Trial Variables =====
    var ExpectedResponseSet%;	  'Will be 1 if ExpectedResponse has been set (don't reset during long wait)
    var PrevPos%;					  'Holds previous joystick position so we can determine if an error is the "same" error or a new one
    var IsError%;					  'Holds current error state so the same error is not multiply counted
    
	'===== God Button Variables =====
    var GodButton%;				  'Holds current position of God Button
    var GodButtonTime;			  'Holds most recent time that God Button changed state
    var GodButtonPrev%;			  'Holds previous state of God Button
    var GodButtonTimePrev;       'Holds last known time that God Button changed state
    
	'===== Reward Variables =====
    var RewardCount%;            'N = # of rewards upcoming, 0 = no reward upcoming, -1 = waiting to determine status
    var RewardTime;              'time to give reward
    var RewardCodes%[4];         'Holds code for reward
    RewardCodes%[0] := 1;        'Reward code will be one if you're not assigning rewards later
    var NumRewards%;				  'Holds the number of reinforcements given
    var NumGBRewards%;           'Holds the number of rewards given by the God Button
    var PayPassProb;             'Probability of payoff on a passive trial
    var PayHProb:=1;				  'Probability of payoff on HIT (0-1)
    var PayHUProb:=1;				  'Probability of payoff on HIT (up) (0-1)
    var PayHDProb:=1;				  'Probability of payoff on HIT (down) (0-1)
    var PayHLProb:=1;				  'Probability of payoff on HIT (left) (0-1)
    var PayHRProb:=1;				  'Probability of payoff on HIT (right) (0-1)
    var PayCRProb:=1;				  'Probability of payoff on CORRECT REJECTION (0-1)
    var PayMProb:=0;             'Probability of payoff on MISS (0-1)
    var PayMUProb:=0;            'Probability of payoff on MISS (joystick up, target down) (0-1)
    var PayMDProb:=0;            'Probability of payoff on MISS (joystick down, target up) (0-1)
    var PayMRProb:=0;            'Probability of payoff on MISS (joystick right, target left) (0-1)
    var PayMLProb:=0;            'Probability of payoff on MISS (joystick left, target right) (0-1)
    var PayFAProb:=0;            'Probability of payoff on FALSE ALARM (0-1)
    var PayPTProb:=0;            'Probability of payoff on PROBE TARGET response (0-1)
    var PayPNTProb:=0;           'Probability of payoff on PROBE NONTARGET response (0-1)
    var PayNRProb:=0;            'Probability of payoff on NO RESPONSE (joystick) (0-1)
    var PayCatchProb:=0;		 'Probability of payoff on CATCH TRIALS (0-1)
    var PayPassVal:=200;         'Solenoid Open Duration for Passive reward (ms)  (Note that the parameter file is read in seconds, but this is OK because it's converted to ms later)
    var PayHVal:=200;            'Solenoid Open Duration for HIT (ms)
    var PayHUVal:=200;           'Solenoid Open Duration for HIT (up) (ms)
    var PayHDVal:=200;           'Solenoid Open Duration for HIT (down) (ms)
    var PayHLVal:=200;           'Solenoid Open Duration for HIT (left) (ms)
    var PayHRVal:=200;           'Solenoid Open Duration for HIT (right) (ms)
    var PayCRVal:=200;           'Solenoid Open Duration for CORRECT REJECTION (ms)
    var PayMVal:=200;            'Solenoid Open Duration for MISS (ms)
    var PayMUVal:=200;           'Solenoid Open Duration for MISS (joystick up, target down) (ms)
    var PayMDVal:=200;           'Solenoid Open Duration for MISS (joystick down, target up) (ms)
    var PayMRVal:=200;           'Solenoid Open Duration for MISS (joystick right, target left) (ms)
    var PayMLVal:=200;           'Solenoid Open Duration for MISS (joystick left, target right) (ms)
    var PayFAVal:=200;           'Solenoid Open Duration for FALSE ALARM (ms)
    var PayPTVal:=200;           'Solenoid Open Duration for PROBE TARGET response (ms)
    var PayPNTVal:=200;          'Solenoid Open Duration for PROBE NONTARGET response (ms)
    var PayNRVAl:=200;           'Solenoid Open Duration for NO RESPONSE (joystick) (ms)
    var PayCatchVal:=200;        'Solenoid Open Duration for CATCH TRIALS (ms)
    var TaperRew%;               'Is the reward tapered?
    var TapRewFac;     	   	     'Initial tapered reward factor
    var TapRewSec%;      	     'How long for tapered reward to last before baseline 
    var RewFac := 1;             'Actual reward factor, change if tapering reward
    var FirstReward% := 1;       'indicates that this is the first reward hit being given (for multiple reward hit cases)
    var BiasMax := 1;            'The maximum value of bias at which reward size change saturates, hard code at 1
    var BiasTaper% := 100;       'The number of trials (at beginning of session) during which the response bias should be linearly tapered
    var BiasWindow% := 50;       'The length of the trial window over which the bias calculations are done
    
	'===== Joystick Variables =====
    var UpThreshInner;               'Threshold in up direction, inner border, in degrees
    var DownThreshInner;             'etc.
    var LeftThreshInner;
    var RightThreshInner;
    var UpThreshInnerInc;            'Threshold Increment in up direction, inner border, in degrees
    var DownThreshInnerInc;          'etc.
    var LeftThreshInnerInc;
    var RightThreshInnerInc;
    var UpThreshInnerDec;            'Threshold Decrement in up direction, inner border, in degrees
    var DownThreshInnerDec;          'etc.
    var LeftThreshInnerDec;
    var RightThreshInnerDec;
    var UpThreshInnerMax;            'Threshold Maximum in up direction, inner border, in degrees
    var DownThreshInnerMax;          'etc.
    var LeftThreshInnerMax;
    var RightThreshInnerMax;
    var UpThreshInnerMin;            'Threshold Minimum in up direction, inner border, in degrees
    var DownThreshInnerMin;          'etc.
    var LeftThreshInnerMin;
    var RightThreshInnerMin;
    var UpThreshOuter;               'Threshold in up direction, outer border, in degrees
    var DownThreshOuter;             'etc.
    var LeftThreshOuter;
    var RightThreshOuter;
    var UpThreshOuterInc;            'Threshold Increment in up direction, outer border, in degrees
    var DownThreshOuterInc;          'etc.
    var LeftThreshOuterInc;
    var RightThreshOuterInc;
    var UpThreshOuterDec;            'Threshold Decrement in up direction, outer border, in degrees
    var DownThreshOuterDec;          'etc.
    var LeftThreshOuterDec;
    var RightThreshOuterDec;
    var UpThreshOuterMax;            'Threshold Maximum in up direction, outer border, in degrees
    var DownThreshOuterMax;          'etc.
    var LeftThreshOuterMax;
    var RightThreshOuterMax;
    var UpThreshOuterMin;            'Threshold Minimum in up direction, outer border, in degrees
    var DownThreshOuterMin;          'etc.
    var LeftThreshOuterMin;
    var RightThreshOuterMin;
    var OneAxis%;               'can be used to "turn off" off-axis joystick interrupts for some response devices 
    var Grow%;                  'determines the increment type: if 1, incremements/decrements will grow/shrink the gap
                                'between center and response areas; if 2, increments/decrements will move the gap
                                'away from/towards the center
    var xstat%:=1;              'current status of x position, 1 is center, 0 is left, 2 is right
    var ystat%:=10;             'current status of y position, 10 is center, 0 is down, 20 is up
    
    '===== Fixation Variables =====
    var DoFixation%;            'set to 1 to check animal's fixation
    var xEye;                   'Eye position
    var yEye;
    var FixWindowRadius;        'Size of fixation window radius, in degrees
    var FixXLoc;                'X location of fixation window, in degrees from 0,0 (positive = right)
    var FixYLoc;                'Y location of fixation window, in degrees from 0,0 (positive = up)
    
    'These are already defined in the included UsreyDAQ, so can't redefine them here
    'var DegreesPerVoltX;        'I assume that whatever eyetracker system we buy will have its own calibration, and once calibrated
    'var DegreesPerVoltY;        'will return 0,0 voltage at the center.  This is the volts-to-degrees multiplicative factor
    'var FixationX := 0;         'For now, the location of the fixation point will be hard coded at 0
    'var FixationY := 0;
    
    'var FixXOffset;            'I assume the calibration will by design return zero voltage at the center, if not we  
    'var FixYOffset;            'can activate some offsets.
    
    
    '===== Light/Light Logging Variables =====
    var YellowOn%;             'will be 1 if yellow LED is on, 0 if off
    var RedOn%;                'will be 1 if red LED is on, 0 if off
    var GreenOn%;              'will be 1 if green LED is on, 0 if off
    var IncOn%;                'will be 1 if incandescent is on, 0 if off  
    var YellowOnTimes[50];     'holds up to 50 yellow LED on-times
    var YellowOffTimes[50];    'holds up to 50 yellow LED off-times
    var RedOnTimes[50];        'holds up to 50 red LED on-times
    var RedOffTimes[50];       'holds up to 50 red LED off-times
    var GreenOnTimes[50];      'holds up to 50 green LED on-times
    var GreenOffTimes[50];     'holds up to 50 green LED off-times    
    var IncOnTimes[50];        'holds up to 50 incandescent on-times
    var IncOffTimes[50];       'holds up to 50 incandescent off-times
    var YellowOnIndex%;        'indexes the current position in YellowOnTimes[]
    var YellowOffIndex%;       'etc.
    var RedOnIndex%;           'indexes the current position in RedOnTimes[]
    var RedOffIndex%;          'etc.
    var GreenOnIndex%;         'indexes the current position in GreenOnTimes[]
    var GreenOffIndex%;        'etc.
    var IncOnIndex%;
    var IncOffIndex%;
    var YellowOnFlash[50];     'holds up to 50 yellow LED on-times
    var YellowOffFlash[50];    'holds up to 50 yellow LED off-times
    var RedOnFlash[50];        'holds up to 50 red LED on-times
    var RedOffFlash[50];       'holds up to 50 red LED off-times
    var GreenOnFlash[50];      'holds up to 50 green LED on-times
    var GreenOffFlash[50];     'holds up to 50 green LED off-times    
    var IncOnFlash[50];        'holds up to 50 incandescent on-times
    var IncOffFlash[50];       'holds up to 50 incandescent off-times
    var YellowOnFIndex%;        'indexes the current position in YellowOnTimes[]
    var YellowOffFIndex%;       'etc.
    var RedOnFIndex%;           'indexes the current position in RedOnTimes[]
    var RedOffFIndex%;          'etc.
    var GreenOnFIndex%;         'indexes the current position in GreenOnTimes[]
    var GreenOffFIndex%;        'etc.
    var IncOnFIndex%;
    var IncOffFIndex%;    
    var FlashDurationS;         'Flash duration in seconds    
    
	'===== Utility Variables =====
    var ok%;              'function output result holder
    var tbtext$;          'toolbar text holder
    var fh0%;             'file handle holder
    var ctview%;	       'Holds the handle of the current window
    var joyview%;          'Holds the handle of the joystick XY window
    var joydatachan%;      'holds the data channel which will have the joystick data
    var xaxisdrawchan%;     'for drawing x and y axis in joystick plot
    var yaxisdrawchan%;
    var EyeXYWindow%;      'Holds the handle of the eye position XY window
    var UpdateSuccess%[4];   'Holds whether SafeUpdate() has updated the online files or not
    arrconst(UpdateSuccess%[],1);  'Fill with ones to indicate success, for now
    var SkipStim%;		  	 'Used to avoid presentation of a stimulus which is ready if recording is stopped
    var SolenoidKilled%;  'Holds whether we have force-closed the juicer solenoid
    var LeverCodes%[4];   'First position holds lever position to put in MemChanLeverDebounce
    var SPKAppendTime;    'Holds last time SPK file was updated
    var TimePerADC;		 'Holds the number of time units per each Analog to Digital Conversion
    var UsPerTime;			 'Holds the number of microseconds per time unit
    var SecPerSample;		 'Holds the number of seconds per sample
    var LastMainTime;       'Holds the last time the main loop was started
    var tLastJoyUpdate;     'holds the last time the joystick was updated
    var tLastEyeUpdate;     'holds the last time the eye position was updated
    var CommondB;          'Holds the common dB attenuation for all stimuli (will be done via hardware) 
    var UseCommondB := 1;  'Do we use common dB attenuation, default = yes, will change to no if only one stim per trial
    var RovedB;            'the amount of dB to rove, if any
    var RoveValue$;        'used for Sampletext indication of rove data,not yet implemented
    var DataCollected%;    'Holds whether any data has been sampled - allows graceful quit on clean/magazine
    var StimLetConcat$;    'Holds a concatenation of all StimLet$s
    var StimLetLen%[NMaxStim%]; 'Holds the length of each entry in StimLet$ (mostly), same length as StimLet$
    var StimLetInd%;     'Holds the current index for doing the InStr on StimLet$
    var ResponseBias;    'Will hold an estimate of the response bias: (z(hit)+z(FA))/2 where positive values are bias towards "hit" response 
    var HiddenLogHandle%;  'Holds the handle to the hidden log window    
    var SequencerPeriodMS;   'Holds clock period of the sequencer
    
	'===== Channel variables =====
    var MemChanStim%;          'Memory channel for stimuli
    var MemChanRw%;            'Memory channel for reward
    var MemChanStart%;         'Memory channel for lever press to start trial
    var MemChanLeverDebounce%; 'Memory channel to hold debounced representation of lever presses
    var MemChanJoystick%;      'Memory channel to hold representation of joystick moves
    var MemChanHistTriggerA%;  'Memory channel to hold time of presentation of TEST portion of stimulus, active
    var MemChanHistTriggerP%;  'Memory channel to hold time of presentation of TEST portion of stimulus, passive
    var MemChanHistTrigger%;   'Memory Channel to hold time of presentation of TEST portion of stimulus, active or passive
    var MemChanHistTriggerAGroup%;  'Memory channel to hold time of presentation of TEST portion of stimulus, active, by group
    var MemChanHistTriggerPGroup%;  'Memory channel to hold time of presentation of TEST portion of stimulus, passive, by group
    var MemChanAtten%;         'Memory channel to hold attenuation level of stimulus
    var MemChanJoystickRO%;    'Memory channel holds center-to-right transitions
    var MemChanJoystickLO%;    'Memory channel holds center-to-left transitions
    var MemChanJoystickUO%;    'Memory channel holds center-to-up transitions
    var MemChanJoystickDO%;    'Memory channel holds center-to-down transitions
    var MemChanJoystickRI%;    'Memory channel holds right-to-center transitions
    var MemChanJoystickLI%;    'Memory channel holds left-to-center transitions
    var MemChanJoystickUI%;    'Memory channel holds up-to-center transitions
    var MemChanJoystickDI%;    'Memory channel holds down-to-center transitions
    
	'===== Plotting variables =====
    var HistTotal;              'Total length of histogram, in seconds
    var HistPost:=0.2;          'Length of histogram poststimulus, in seconds
    var HistPre:=0.2;           'Length of prestimulus portion of histogram, in seconds
    var StimLength[NMaxStim%];        'Length of stimuli, will be in seconds
    var HistBins%;			    'Total number of bins in the histograms
    var HistBinWidth:=.005;     'Width of histogram bins, in seconds
    var hApsthS%;			    'Handle of stimulus-specific PSTH, active
    var hApsthA%;               'Handle of overall PSTH, active
    var hPpsthS%;			    'Handle of stimulus-specific PSTH, passive
    var hPpsthA%;               'Handle of overall PSTH, passive
    var hApsthS2%;			    'Handle of stimulus-specific PSTH, active
    var hApsthA2%;               'Handle of overall PSTH, active
    var hPpsthS2%;			    'Handle of stimulus-specific PSTH, passive
    var hPpsthA2%;               'Handle of overall PSTH, passive
    var hApsthS3%;			    'Handle of stimulus-specific PSTH, active
    var hApsthA3%;               'Handle of overall PSTH, active
    var hPpsthS3%;			    'Handle of stimulus-specific PSTH, passive
    var hPpsthA3%;               'Handle of overall PSTH, passive
    var powspec%;               'Handle for eeg power spectrum result view
    var PSTHBeginTime;		    'When do we begin plotting the PSTH?
    
	'===== Behavioral variables, go/no-go =====
    var Hits;				'Total number of hits in the experiment
    var Misses;				'Total number of misses in the experiment
    var CRs;				'Total number of correct rejections
    var FAs;				'Total number of false alarms
    var PoTs;				'Total number of probe 1s with a target response (also used for Joystick, w/o regard for up/down)
    var PoNTs;				'Total number of probe 1s with a nontarget response (also used for Joystick, w/o regard for up/down)
    var PtTs;				'Total number of probe 2s with a target response (also used for Joystick, w/o regard for up/down)
    var PtNTs;				'Total number of probe 2s with a nontarget response (also used for Joystick, w/o regard for up/down)
    var HitsR;				'Same thing, but for RepeatOnError condition
    var MissesR;				
    var CRsR;				
    var FAsR;				
    var PoTsR;				
    var PoNTsR;
    var PtTsR;				
    var PtNTsR;
    var HitRTTotal;         'The total reaction time on hits, used for RT monitoring on Go/No-Go Trials only
    var Hits%[NMaxTrials%];          'Hits in the Bias Window
    var Misses%[NMaxTrials%];        'Misses in the Bias Window
    var FAs%[NMaxTrials%];           'FAs in the Bias Window
    var CRs%[NMaxTrials%];           'CRs in the Bias Window
    var HitsNR%[NMaxTrials%];          'Hits during RepeatOnError, only non-repeated trials
    var MissesNR%[NMaxTrials%];        'Misses during RepeatOnError, only non-repeated trials
    var FAsNR%[NMaxTrials%];           'FAs during RepeatOnError, only non-repeated trials
    var CRsNR%[NMaxTrials%];           'CRs during RepeatOnError, only non-repeated trials
    var NonRepeatedTrialCount%;        'count variable of non-repeated trials
    var Correct%[1000];              'This is a window which holds the sum of Hits% and CRs% (and UpHits%, DownHits%, LeftHits%, RightHits%)
                                     '1000 is way too large, but it has to be something.
    
	'===== Behavioral variables, forced choice (forced choice is only up/down for now) =====
    var UpHits;				'Total number of hits for up targets in the experiment
    var UpMisses;			'Total number of misses joystick up, stimulus down
    var UpNR;				'Total number of no responses for up stimuli
    var DownHits;			'Total number of hits for down stimuli
    var DownMisses;			'Total number of misses joystick down, stimulus up
    var DownNR;				'Total number of no responses for down stimuli
    var RightHits;			'Total number of hits for right targets in the experiment
    var RightMisses;		'Total number of misses joystick right, stimulus left
    var RightNR;			'Total number of no responses for right stimuli
    var LeftHits;			'Total number of hits for left stimuli
    var LeftMisses;			'Total number of misses joystick left, stimulus right
    var LeftNR;				'Total number of no responses for left stimuli
    var PoNRs;				'Total number of no responses for probe 1 stimuli
    var PtNRs;				'Total number of no responses for probe 2 stimuli
    var CatchUp;            'Total number of up responses on catch trials
    var CatchDown;          'Total number of down responses on catch trials
    var CatchRight;         'Total number of right responses on catch trials
    var CatchLeft;          'Total number of left responses on catch trials
    var CatchNR;		    'Total number of non responses on catch trials
    var UpHitsR;			'Same thing, but for RepeatOnError condition
    var UpMissesR;			
    var UpNRR;				
    var DownHitsR;			
    var DownMissesR;			
    var DownNRR;				
    var PoNRsR;	
    var PtNRsR;
    var CatchUpR;            
    var CatchDownR;          
    var CatchNRR;
    var RightHitsR;
    var RightMissesR;			
    var RightNRR;				
    var LeftHitsR;			
    var LeftMissesR;			
    var LeftNRR;							
    var CatchRightR;            
    var CatchLeftR;    
    var TotalErrorsUp%;      'Variables used to keep track of the number of errors made in an errorless scenario, etc.
    var TotalErrorsDown%;
    var TotalCorrectNoErrorsUp%;
    var TotalCorrectNoErrorsDown%;
    var TempErrors%;
    var UpHits%[NMaxTrials%];              'The total number of up hits outside of the bias window
    var UpMisses%[NMaxTrials%];            'The total number of up misses outside of the bias window
    var DownHits%[NMaxTrials%];            'The total number of down hits  outside of the bias window
    var DownMisses%[NMaxTrials%];          'The total number of down misses outside of the bias window
    var RightHits%[NMaxTrials%];           'The total number of right hits outside of the bias window
    var RightMisses%[NMaxTrials%];         'The total number of right misses outside of the bias window
    var LeftHits%[NMaxTrials%];            'The total number of left hits outside of the bias window
    var LeftMisses%[NMaxTrials%];          'The total number of leftmisses outside of the bias window
    var floatHits;                         'variables used to keep track of float values for d'
    var floatCRs;
    var floatMisses;
    var floatFAs;
    
    '===== Configuration Variables =====
    const configWaveMarkChannel% := 1;
    const configWaveformChannel% := 2;
    const configWaveMarkChannel2% := 3;
    const configWaveformChannel2% := 4;
    const configWaveMarkChannel3% := 5;
    const configWaveformChannel3% := 6;
    const configLeverChannel% := 8;
    const configMotionChannel% := 8;  'note conflict with lever port
    const configGodChannel% := 8;  'note conflict with lever/motion ports
    const configLFPChannel% := 22;
    const configTemporaryHighFrequencyLFPChannel% := 23;  'Conflicts with use of Thomas, as below
    const configLFPChannel2% := 23;
    const configLFPChannel3% := 24;
    const configJoyXChannel% := 10;
    const configJoyYChannel% := 11;
    const configJoyEventsChannel% := 12;
    const configTrialStartChannel% := 13;
    const configTestStimStartChannel% := 14;
    const configStimulusChannel% := 15;
    const configRewardChannel% := 16;
    const configTestStimStartAChannel% := 17;
    const configTestStimStartPChannel% := 18;
    const configTestStimGroupStartAChannel% := 19;
    const configTestStimGroupStartPChannel% := 20;
    const configEyeXChannel% := 25;
    const configEyeYChannel% := 26;
    const configWaveMarkPort% := 0;  'A2D port
    const configRewardPort% := 0;  'digital in port
    const configLeverPort% := 1;  'digital in port
    const configLFPPort% := 1;  'A2D port
    const configJoyXPort% := 2;  'A2D port
    const configJoyYPort% := 3;  'A2D port
    const configTemporaryHighFrequencyLFPPort% := 4;  'note that this conflicts with the second electrode on the Thomas - USE ONLY WITH SINGLE ELECTRODE, REMOVE WHEN TESTING IS DONE
    const configWaveMarkPort2% := 4;
    const configLFPPort2% := 5;
    const configWaveMarkPort3% := 6;
    const configLFPPort3% := 7;
    const configEyeXPort% := 1000;  'dummy value for now
    const configEyeYPort% := 1000;
    const configMotionPort% := 1;  'digital in port, note conflict with lever port
    const configGodPort% := 1;  'digital in port, note conflict with lever/motion ports
    var iEyePosChannel%:=1;  '1 is the correct channel for the XY data
    var iFixWindowChannel%;  'channel for displaying the fixation window
    var iFixChannel%;  'channel for displaying the fixation point
    var iMonitorChannel%;  'channel for displaying the monitor position
    var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
    var windowX[36], windowY[36];
    var joystickXOffset; 'use registry?  
    var joystickYOffset;
    var configLFPSampleRate% := 10000;
    var configTemporaryHighFrequencyLFPSampleRate% := 50000;
    var configWaveformSampleRate% := 50000;
    var configJoystickSampleRate% := 5000;
    
    
    '===== State Logic Variables =====
    var iState% := -1;           'The value of the current state, used in the main loop's DOCASE statement
    var iStatePause% := 0;       'Also used in main DOCASE, allows circumvent by pause
    var tStateStart;             'The time that we entered the current state
    var RepeatMainLoop%;         'Should we repeat the main loop before handing control back to the OS?
    const StateStartContinuousReinforcement% := 1;
    const StateWaitContinuousReinforcementInit% := 2;
    const StateContinuousReinforcementTO% := 3;
    const StateContinuousReinforcementDelay% := 4;
    const StateContinuousReinforcementWaitResponse% := 5;
    const StateReward% := 6;
    const StateRewardDeliveryWait% := 7;
    const StateLoadStimulus% := 8;
    const StateDone% := 9;
    const StateSetPA5% := 10;
    const StateWaitPassiveTrial% := 11;
    const StateBeginPassiveTrial% := 12;
    const StatePresentPassiveStimulus% := 13;
    const StateWaitPassiveStimEnd% := 14;
    const StateWaitActiveTrial% := 15;
    const StateMustReleaseLever% := 16;
    const StateReleaseTOPenalty% := 17;
    const StateBeginActiveTrial% := 18;
    const StatePresentActiveStimulus% := 19;
    const StateWaitActiveStimEnd% := 20;
    const StateActiveResponseWindow% := 21;
    const StateErrorlessResponseWindow% := 22;
    const StateMissFAPenalty% := 23;
    const StatePauseContinuousReinforcement% := 101;
    const StatePause% := 102;
    const StateParamPause% := 103;
    
    
	'===== Loop Variables =====
    var i%, j%, k%;
    
	'===== Pause variables =====
    var iPause% := 0;       'for regular pausing (why the 'i'?  I dont know anymore)
    var ParamPause% := 0;   'for the loading of new parameters
    
    '===== Debugging variables =====
    var NumFoundNegativeIndex%;
    var NumFoundTooBigIndex%;
    var TooBigIndexValue%;
    
    
endif;  'Just bookending the VAR declarations to allow folding them away    


'=============================== Preliminary Actions =================================


    #include "../../../Sutter_Stuff/experiments/ced_scripts/zTools.s2s"  'BigAl

    '#include "../../../experiments/ced_scripts/zTools.s2s"  'Seager




'These #include files have to point to the correct location, and since we will NOT be keeping this in 
'the repository for the time being (it's just such Frankencode that there are going to be inconveniences)
'the #include files will be in multiple locations.  So, for testing on Seager:
'#include "../GitRepositories/usrig/scripts/TuningDialogs.s2s"
'#include "../GitRepositories/usrig/scripts/UsreyDAQ.s2s"
'#include "../GitRepositories/usrig/util/UsreyUtil.s2s"
'#include "../GitRepositories/usrig/util/ChannelUtilities.s2s"
'#include "../GitRepositories/usrig/util/LogUtilities.s2s"
'#include "../GitRepositories/usrig/util/MiscUtilities.s2s"
'#include "../GitRepositories/usrig/scripts/UsreyGratings.s2s"
'#include "../GitRepositories/usrig/scripts/UsreyFixationPoint.s2s"
'
'But for the real deal on BigAl:
'#include "../../../work/usrig/scripts/TuningDialogs.s2s"
'#include "../../../work/usrig/scripts/UsreyDAQ.s2s"
'#include "../../../work/usrig/util/UsreyUtil.s2s"
'#include "../../../work/usrig/util/ChannelUtilities.s2s"
'#include "../../../work/usrig/util/LogUtilities.s2s"
'#include "../../../work/usrig/util/MiscUtilities.s2s"
'#include "../../../work/usrig/scripts/UsreyGratings.s2s"
'#include "../../../work/usrig/scripts/UsreyFixationPoint.s2s"

'Actually, maybe we WILL keep it in the repository after all, BigAl and Seager are the same:
#include "TuningDialogs.s2s"
#include "UsreyDAQ.s2s"
#include "../util/UsreyUtil.s2s"
#include "../util/ChannelUtilities.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"

GetDataParameters();  'This will grab the DataCellName$ variable that we need to do the autonaming

printlog("data cell name is %s\n",DataCellName$);


'prepare for adaptive stimulus presentation/online analysis
ok% := filedelete(OnlineDir$+"spike2_done.txt");  'don't let Matlab access online files yet
ok% := filecopy(OnlineDir$+"empty_file.txt",OnlineDir$+"matlab_done.txt"); 'assert that Matlab is not 
'accessing online files


'Create hidden log window, for printing to output log file, must do this before trying to write to window...
HiddenLogHandle% := FileNew(1);  'open the log window invisibly



'Define and set channel numbers as in TUNING
'Some of this stuff is unnecessary, just ripped from TUNING wholesale
var XChannel%;
var YChannel%;
var FrameChannel%;
var FixationPointChannel%;
var StimChannel%;
var ReadyChannel%;
var OptoCopyChannel%;
'var SequencerPeriodMS;
var ButtonChannel%;
var ButtonPort%;
var StimulatorChannel%;
var UtilityChannel%;
var JoyChannel%;

XChannel% := 25;
YChannel% := 26;
JoyChannel% := 28;
ReadyChannel% := 40;
FrameChannel% := 41;
FixationPointChannel% := 42;
StimChannel% := 43;
OptoCopyChannel% := 49;
StimulatorChannel% := 39;
UtilityChannel% := 38;
ButtonChannel% := 27;
ExcludedChans%[0] := 25;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 49;  'OptoCopyChannel% is highest non-electrode channel used by this function  







'======= Toolbar - Program stays in Toolbar and iterates Main%() until Quit%() =======

'Set up toolbar
ToolbarSet(0, "", Main%);
'ToolbarSet(0, "", MainStateLogic%);
ToolbarSet(1, "Quit", QuitTB%);
ToolbarSet(2, "LoadParam", LoadParam%);
ToolbarSet(3, "Start", StartSampling%);
ToolbarSet(4, "Stop", StopSampling%); 
ToolbarSet(5, "Pause", PrepPause%);
ToolbarSet(6, "Clean/Magazine", CleanSolenoid%);  'routine to clean solenoid
ToolbarSet(7, "Joystick Calibration", CalibrateJoystick%);  'automatic joystick calibration - make sure power is on to joystick
ToolbarSet(8, "Fixation Params", FixationParameters%);  'set fixation parameters
ToolbarSet(9, "Toggle Verbose", ToggleVerbose%);

'Enable Load, Quit, and Clean/Magazine buttons
ToolbarEnable(1,1);  'enable Quit
ToolbarEnable(2,1);  'enable LoadParam
ToolbarEnable(3,0);  'disable Start until stimuli are loaded
ToolbarEnable(4,0);  'disable Stop until Sampling is started
ToolbarEnable(5,0);  'disable Pause until sampling is started 
ToolbarEnable(6,1);  'enable solenoid cleaning until sampling is begun
ToolbarEnable(7,1);  'enable joystick calibration until sampling is begun
if DoFixation% > 0 then
    ToolbarEnable(8,1);  'enable fixation parameters until sampling is begun
else
    ToolbarEnable(8,0);  'do not enable fixation parameters if this is not a fixation scenario
endif;
ToolbarEnable(9,1);  'enable main loop verbosity toggling

'Run the toolbar...
Toolbar("Press LoadParam to load Parameter and Trials files or Quit",1+2+4);

'if we leave the toolbar, quit
printlog("Quitting because the program has exited the toolbar!\n");
view(HiddenLogHandle%).print("Quitting because the program has exited the toolbar!\r");
quit%();




'================= Load Parameters and Trials =====================
func LoadParam%()
    
    var Line1$, Line2$;  'For determining parameter file type
    var IsParam%;   '1 = old param file, 2 = new param file, 3 = not a param file
    var eof := 1;  'check for end of file
    var found%;  'have we found the letter?
    var SearchCount%;  'how many have we checked?
    var diff; 'difference between minimum normalization factor and current factor
    var fh1%;    'file handle for opening stims
    var n%;    'number of points in each stimulus waveform
    var WavTemp%[MaxPoint1401%];  'A temporary variable to hold each stim (just so we know how long each stim is) 
    var SOMax;    'Maximum solenoid open duration from parameter file
    var SOMin;    'Minimum solenoid open duration from parameter file
    var StimPathHolder$;  'Variable to hold which stimpath is current, now that we have multiple possible stimpaths
    var tempview%;		'Variable to temporarily hold view value
    var Path$;   'Path for Fast Switching files
    var NewFreq% := 0;  'index into Fast Switch list for frequency
    var NewType% := 0;  'index into Fast Switch list for response type
    var FreqTxt$;
    var q%;
    var CheckIsParam% := 1;  'do we check to see if it's a param file, always check first
    var TrialFileLoadSuccess%;  '1 if trial file load succeeded
    var Ascii%;
    var NTrialsFilesOld%;  'holds prior number of trials files, if we are loading a new parameter file
    
	'Set Fast Switching path - this is currently written specifically for Xerox
    Path$ := DrivePath$+"experiments\\parameters\\AM_physiology\\";
    
	'FastSwitch cannot be on (1) for the first load, only on subsequent loads
	'Note also that once LoadNewParam is run, the FastSwitch value is changed
	'so everything relying on the FastSwitch variable must be done before that.
    if FastSwitch% = 1 then  'use "fast" dialog box to get param and trial files
        DlgCreate("Select Frequency and Active/Passive");
        DlgList(1,"Frequency","3|5|10|15|20|30|60|120|250|500|1000");
        DlgList(2,"Reponse Type","Active|Passive");
        ok% := DlgShow(NewFreq%,NewType%);
		'Build Param and Trial File names
        docase  'first, use active or passive to get first part of file name
            case NewType% = 0 then  'active
			ParamFile$ := Path$+"pamfb";
			TrialFile$ := Path$+"trlamfb";
            case NewType% = 1 then  'passive
			ParamFile$ := Path$+"pambmf";
			TrialFile$ := Path$+"trlambmf";
        endcase;
        docase	'Then use frequency to get last part of trial name
            case NewFreq% = 0 then
			FreqTxt$ := "003.txt";
            case NewFreq% = 1 then
			FreqTxt$ := "005.txt";
            case NewFreq% = 2 then
			FreqTxt$ := "010.txt";
            case NewFreq% = 3 then
			FreqTxt$ := "015.txt";
            case NewFreq% = 4 then
			FreqTxt$ := "020.txt";
            case NewFreq% = 5 then
			FreqTxt$ := "030.txt";
            case NewFreq% = 6 then
			FreqTxt$ := "060.txt";
            case NewFreq% = 7 then
			FreqTxt$ := "120.txt";
            case NewFreq% = 8 then
			FreqTxt$ := "250.txt";
            case NewFreq% = 9 then
			FreqTxt$ := "500.txt";
            case NewFreq% = 10 then
			FreqTxt$ := "1k0.txt";
        endcase;
        ParamFile$ := ParamFile$+FreqTxt$;
        TrialFile$ := TrialFile$+FreqTxt$;
		'Open Parameter File automatically
        fh0%:=FileOpen(ParamFile$,8,0);
    else	'Select Parameter file to open with dialog box if FastSwitch is not on or first time through
        fh0%:=FileOpen(ParamDir$+"*.txt",8,0,"Please select a Parameter file");  
    endif;
    
    'Unless there is an error, there will be an open file now, which is expected to be a parameter file
    'In case the file open does not work, try file open again, give user option to quit
    'We do this outside of the previous IF in case the FastSwitch files don't exist
    while fh0%<0 do
        q% := query("Failed to load the parameter file!","Try Again","Quit");
        if q% = 0 then
            printlog("Quitting because the user pressed the 'Quit' button after failing to open a parameter file!\n");
            view(HiddenLogHandle%).print("Quitting because the user pressed the 'Quit' button after failing to open a parameter file!\r");        
            quit%();
        else
            fh0%:=FileOpen(ParamDir$+"*.txt",8,0,"Please select a Parameter file");
        endif;
    wend;
    'At this point, we will definitely have a file open, it is expected to be a parameter file
    
    'Get name of currently open file, then close it!
    ParamFile$ := filename$();
    fileclose();  'Close fh0%, currently open file
    
    if FastSwitch% = 0 then	  
        while CheckIsParam% = 1 do
            IsParam% := TestParamTrialFile%(ParamFile$); 
            if IsParam% = 3 then  'it's not a parameter file!            
                q% := query("USER ERROR! The specified file IS NOT a parameter file!","Try Again","Quit");
                if q% = 0 then
                    printlog("Quitting because the user pressed the 'Quit' button after opening something that wasn't a parameter file!\n");  
                    view(HiddenLogHandle%).print("Quitting because the user pressed the 'Quit' button after opening something that wasn't a parameter file!\r");
                    quit%();
                else
                    fh0%:=FileOpen(ParamDir$+"*.txt",8,0,"Please select a Parameter file");
                    ParamFile$ := filename$();  'get name of currently open file, as we've opened a new one
                    fileclose();  'and immediately close fh0% so TestParamTrialFile works
                endif;
            else
                CheckIsParam% := 0;  'we have found a valid parameter file              
            endif;        
        wend    
        'We now have found a valid parameter file, it is CLOSED
        printlog("\n\n\nCurrent parameter file is %s\n",ParamFile$);
        view(HiddenLogHandle%).print("\r\r\rCurrent parameter file is %s\r",ParamFile$);
        TrialFile$ := "";  'just make it empty, naming convention implementation was unsuccessful due to human recalcitrance
    else 'if we're doing Fast Switch, the names are already known
        'do not check to see if parameter file is valid, if it exists, and is NOT a parameter file the user can go cry in their beer
        printlog("\n\n\nCurrent parameter file is %s\n",ParamFile$);
        printlog("Trials file is %s\n",TrialFile$);
        view(HiddenLogHandle%).print("\r\r\rCurrent parameter file is %s\r",ParamFile$);
        view(HiddenLogHandle%).print("Trials file is %s\r",TrialFile$);
    endif;
    
	'Parameter file has been found.  If we are reloading, zero all of the previous info	
    NTrialsFilesOld% := NTrialsFiles%;  'Retain old number of trials files, only used if loading a new parameter file
    'Also must set defaults whether it's the first time through or not!
    SetDefaults%();
    if ParamsLoadedOnce% = 1 then
        OrigNTrodes% := NTrodes%;  'If we're reloading parameters, we can't change NTrodes% regardless of what is found in
        'the parameter file - because we're not stopping sampling.
        BufferToPlay% := 2;  'not exactly a default, but reset it
        tempview% := view();  'Remember current view value
        view(ctview%);  'change to view value of sampling window so we can call maxtime() and ClearRasters%()
        NextTrialTime := maxtime();  'reset NextTrialTime so that it will be LESS than maxtime() next time we run the
        'main loop.  Normally this shouldn't be a problem, but let's make sure.
        ClearRasters%();
        view(tempview%);  'change back to previous view								  
		'clearing strings, must loop because arrconst does not work
        for i% := 0 to 1999 do
            StimLet$[i%] := "";
            StimName$[i%] := "";
        next;
		'Parameter file variables
        arrconst(ISI[],0);
        arrconst(SampP[],0);
        arrconst(NormAtten[],1000);  'reset NormAtten with "too big" value
        arrconst(WhichStimPath%[],1);
        
		'Reset trials file variables, must loop for strings again, but it appears to be fastish (about 0.2 seconds for the loop complex)
        'ResetTrialFileVars%(MaxTrialsFiles%+1);  'this line appears to be stupidly wrong, don't know how it ever worked
        for i% := 1 to NTrialsFilesOld% do
            ResetTrialFileVars%(i%);
        next;        
    endif;
    
    
    'Load old-style parameter file or new-style parameter file
    'These require the parameter file to have been closed earlier
    if IsParam% = 1 then  'if old
        message("You appear to have selected an ancient parameter file that is no longer supported!|Quitting!");
        'LoadOldParam%(ParamFile$);
    else 'otherwise it's new
        ReadParamFile%(ParamFile$);
    endif;
    
    'Finished reading parameter file entirely, file is closed
    
    StimLetInd% := 1;  'StimLetInd% has to start at 1, reset every time through if loading subsequent parameter files
    'Make sure there are no repeated StimLet$s in parameter file
    for i%:=0 to stimN%-1 do
        StimLetInd% := StimLetInd% + StimLetLen%[i%];
        if instr(StimLetConcat$,"ë"+StimLet$[i%],StimLetInd%) > 0 then 'search for this StimLet$ (with "ë" tacked on)
            message("Warning Message | The same stimulus code was found twice in the parameter file!\nCode   " + StimLet$[i%] + "   was found twice, first on line " + str$(i%));
            printlog("Stimulus Code    %s    (first instance on line %d) was found twice in the parameter file!\n",StimLet$[i%],i%);
            view(HiddenLogHandle%).print("Stimulus Code    %s    (first instance on line %d) was found twice in the parameter file!\r",StimLet$[i%],i%);
            return ConditionalQuit%();
        endif;
        'If there are illegal stimcodes in param file, quit now
        for j% := 0 to len(StimLet$[i%])-1 do
            Ascii% := asc(mid$(StimLet$[i%],j%+1,1));  'get ascii value of each character
            docase
            case Ascii% >= 48 and Ascii% <= 57 then 'it's a number, which is illegal
                message("Warning Message | A number was found in the stimcode section of the parameter file!\nCode   " + StimLet$[i%] + "   is not legal, first found on line " + str$(i%));
                printlog("Stimulus Code    %s    (first instance on line %d) is illegal - number found!\n",StimLet$[i%],i%);
                view(HiddenLogHandle%).print("Stimulus Code    %s    (first instance on line %d) is illegal - number found!\r",StimLet$[i%],i%);
                return ConditionalQuit%();
            case Ascii% <= 32 or Ascii% >= 127 then 'it's an unexpected character
                message("Warning Message | An illegal character was found in the stimcode section of the parameter file!\nCode   " + StimLet$[i%] + "   is not legal, first found on line " + str$(i%));
                printlog("Stimulus Code    %s    (first instance on line %d) - illegal character found!\n",StimLet$[i%],i%);
                view(HiddenLogHandle%).print("Stimulus Code    %s    (first instance on line %d) - illegal character found!\r",StimLet$[i%],i%);
                return ConditionalQuit%();
            case Ascii% >= 65 and Ascii% <= 90 and j% < len(StimLet$[i%])-1 then 'it's a letter not in the last position
                message("Warning Message | A letter out of last position was found in the stimcode section of the parameter file!\nCode   " + StimLet$[i%] + "   is not legal, first found on line " + str$(i%));
                printlog("Stimulus Code    %s    (first instance on line %d) - letter out of last position found!\n",StimLet$[i%],i%);
                view(HiddenLogHandle%).print("Stimulus Code    %s    (first instance on line %d) - letter out of last position found!\r",StimLet$[i%],i%);
                return ConditionalQuit%();
            case Ascii% >= 97 and Ascii% <= 122 and j% < len(StimLet$[i%])-1 then 'it's a letter not in the last position
                message("Warning Message | A letter out of last position was found in the stimcode section of the parameter file!\nCode   " + StimLet$[i%] + "   is not legal, first found on line " + str$(i%));
                printlog("Stimulus Code    %s    (first instance on line %d) - letter out of last position found!\n",StimLet$[i%],i%);
                view(HiddenLogHandle%).print("Stimulus Code    %s    (first instance on line %d) - letter out of last position found!\r",StimLet$[i%],i%);
                return ConditionalQuit%();    
            case (Ascii% < 65 or Ascii% > 122 or (Ascii% > 90 and Ascii% < 97)) and j% = len(StimLet$[i%])-1 then 'non-letter in final position
                message("Warning Message | In the stimcode section of the parameter file, the last character was not a letter!\nCode   " + StimLet$[i%] + "   is not legal, first found on line " + str$(i%));
                printlog("Stimulus Code    %s    (first instance on line %d) - last position is not a letter!\n",StimLet$[i%],i%);
                view(HiddenLogHandle%).print("Stimulus Code    %s    (first instance on line %d) - last position is not a letter!\r",StimLet$[i%],i%);
                return ConditionalQuit%();
            endcase;
        next;            
    next;
    
    
    'If we are doing an alternate overall PSTH, build StimGroup%[] variable
    'First, tokenize the stimulus names, making sure all are legal
    if OverallPSTHType% > 0 then
        var AMValue$;
        var BWValue$;
        var remainderName$;
        var tempFront$;
        var breakOut% := 0;
        var breakOut2% := 0;
        i% := 0;
        while i% <= stimN%-1 and breakOut% = 0 do
            remainderName$ := StimName$[i%];
            'Note that naming convention of comod stimuli is "s1-15Hz-100A-0.5B"
            'Cut everything before AM indicator, which is actually the first dash
            if Tokenize("-",remainderName$,tempFront$) = 0 then
                message("Warning Message | Stimulus name does not follow Comodulated convention, cannot do grouped PSTH!");
                OverallPSTHType% := 0;
                breakOut% := 1;
            endif;
            'Get AM value
            if Tokenize("Hz-",remainderName$,AMValue$) = 0 and breakOut% = 0 then
                message("Warning Message | Stimulus name does not follow Comodulated convention, cannot do grouped PSTH!");
                OverallPSTHType% := 0;
                breakOut% := 1;
            endif;
            'Get rid of depth
            if Tokenize("A-",remainderName$,tempFront$) = 0 and breakOut% = 0 then
                message("Warning Message | Stimulus name does not follow Comodulated convention, cannot do grouped PSTH!");
                OverallPSTHType% := 0;
                breakOut% := 1;
            endif;
            'Get BW value
            if Tokenize("B",remainderName$,BWValue$) = 0 and breakOut% = 0 then
                message("Warning Message | Stimulus name does not follow Comodulated convention, cannot do grouped PSTH!");
                OverallPSTHType% := 0;
                breakOut% := 1;
            endif;
            'After stim name is tokenized, check to see if this stimulus group already exists, act appropriately
            docase
            case OverallPSTHType% = 1 then
                StimGroupLabel$[i%] := AMValue$;  'StimGroupLabel$ is zero-indexed, holds AM value for each stimulus in the parameter file
                j%:=0;
                breakOut2% := 0;
                while j% <= len(UniqueStimGroup$)-1 and breakOut2% = 0 do  'loop through the stimulus groups that have already been defined (if any)
                    docase
                    case UniqueStimGroup$[j%] = AMValue$ then  'if current AM value is found, assign index into UniqueStimGroup$, break
                        StimGroup%[i%] := j%;
                        breakOut2% := 1;
                    case UniqueStimGroup$[j%] = "" then  'if we reach the end of defined AM values and current AM value is not found, add this value, assign index into UniqueStimGroup$, break
                        UniqueStimGroup$[j%] := AMValue$;
                        StimGroup%[i%] := j%;
                        breakOut2% := 1;
                    endcase
                    j%+=1;
                wend
            case OverallPSTHType% = 2 then
                StimGroupLabel$[i%] := BWValue$;  'StimGroupLabel$ is zero-indexed, holds BW value for each stimulus in the parameter file
                j%:=0;  
                breakOut2% := 0;
                while j% <= len(UniqueStimGroup$)-1 and breakOut2% = 0 do   'loop through the stimulus groups that have already been defined (if any)                
                    docase
                    case UniqueStimGroup$[j%] = BWValue$ then  'if current BW value is found, assign index into UniqueStimGroup$, break
                        StimGroup%[i%] := j%;
                        breakOut2% := 1;
                    case UniqueStimGroup$[j%] = "" then  'if we reach the end of defined BW values and current BW value is not found, add this value, assign index into UniqueStimGroup$, break
                        UniqueStimGroup$[j%] := BWValue$;
                        StimGroup%[i%] := j%;
                        breakOut2% := 1;
                    endcase
                    j%+=1;
                wend
            endcase
            i%+=1;
        wend;
    endif;
    
    
    
    
	'Get lengths of each stimulus in points
    for i%:=0 to stimN%-1 do
        'calculate the number of samples in this stimulus
        StimPathHolder$ := StimPath$[WhichStimPath%[i%]-1];  'must subtract 1 because indices start at 0...
		'open the stimulus
        fh1%:=fileopen(StimPathHolder$+StimName$[i%]+".wfm",9,0);
        if fh1%<0 then
            message("Warning Message | failed to load the stimulus waveform!");
            printlog("Stim waveform %s failed to load!\n",StimPathHolder$+StimName$[i%]+".wfm");
            view(HiddenLogHandle%).print("Stim waveform %s failed to load!\r",StimPathHolder$+StimName$[i%]+".wfm");
            return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        endif;
		'reads fh% two bytes at a time, puts in WavTemp%[]
        n%:=breadsize(2,WavTemp%[]);
        StimPoints%[i%] := n% +  ((ISI[i%]*1000)/SampP[i%]);  'fill StimPoints%[]
        StimLength[i%] := n%;    'fill StimLength with points
        fileclose();  'Close fh1%, currently open file
    next;
    
    
	'If not all sampling rates are the same, this is an error (rate here is in period)
    for i%:=0 to stimN%-2 do
        if SampP[i%] <> SampP[i%+1] then
            message("Error!  Sampling rates differ across stimuli!");
            printlog("Error!  Sampling rates differ across stimuli!\n");
            view(HiddenLogHandle%).print("Error!  Sampling rates differ across stimuli!\r");
            return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        endif;
    next;
    
	'if sampling rates are not the same as the previous parameter file, this is an error
    if ParamsLoadedOnce% = 1 then
        if SampP[0] <> SampPOld then
            message("Error!  The sampling rate of the stimuli in this parameter file is different from the previous parameter file!");
            return 0;  'just return to the toolbar, which will continue running the script
        endif;
    else
        SampPOld := SampP[0];
    endif;
    
	'Calculate sampling rate from sampling period, one sampling rate for all stims
    SampleRate := 1000000/SampP[0];  
	'Calculate number of samples per ms
    SamplesPerMS% := SampleRate/1000;
	'Change StimLength to seconds
    ArrDiv(Stimlength,SampleRate);
    
    
    
	'Set a default value for SolenoidOpenDur just in case there is a programming error later we don't lock the solenoid
    'SolenoidOpenDur% := PayHVal;
    SolenoidOpenDur% := JuiceRewardMS%;  'allows us to use value from CONFIG - NOTE that the old solenoid type is not supported, but we don't have any of those left I don't think
    
	'check that TOFactors do not decrement
    if LazyTOFactor < 1 or ReleaseTOFactor < 1 then
        message("Warning!  A TO increment factor is less than 1, and will decrement!");
    endif;
    
	'check that Lazy/ReleaseTOMax is greater than Penalty
    if LazyTOMax < LazyTOPenalty or ReleaseTOMax < ReleaseTOPenalty then
        message("Warning!  Lazy/ReleaseTOMax is less than the original penalty!");
    endif;
    
	'Make sure that the PayVals (solenoid open durations) are not invalid - these are not used in the Usrey version
'    SOMax := max(PayHVal,PayCRVal,PayMVal,PayFAVal,PayPTVal,PayPNTVal);
'    SOMin := min(PayHVal,PayCRVal,PayMVal,PayFAVal,PayPTVal,PayPNTVal);
'    docase
'        case SOMin < 2 then
'		message("All solenoid open durations must be greater than 1 millisecond!");
'        printlog("All solenoid open durations must be greater than 1 millisecond!\n");
'        view(HiddenLogHandle%).print("All solenoid open durations must be greater than 1 millisecond!\r");
'		return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
'        case SOMax > 1999 then
'		message("All solenoid open durations must be less than 1 second!");
'        printlog("All solenoid open durations must be less than 1 second!\n");
'        view(HiddenLogHandle%).print("All solenoid open durations must be less than 1 second!\r");
'		return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
'    endcase;
    
    
	'calculate MPenalty and FAPenalty, etc., with respect to ITI
	'penalties will not include ITI, but must be at least ITI
    if MPenalty >= MinITI then
        MPenalty := MPenalty - MinITI;  'ITI will be added back in at the time of the penalty
    else
        MPenalty := 0;  'ITI will be the sum total of the penalty
    endif;
    '
    
    if MPenaltyTUp >= MinITI then
        MPenaltyTUp := MPenaltyTUp - MinITI;  'ITI will be added back in at the time of the penalty
    else
        MPenaltyTUp := 0;  'ITI will be the sum total of the penalty
    endif;
    if MPenaltyTDown >= MinITI then
        MPenaltyTDown := MPenaltyTDown - MinITI;  'ITI will be added back in at the time of the penalty
    else
        MPenaltyTDown := 0;  'ITI will be the sum total of the penalty
    endif;
    '
    '
    if CatchPenalty >= MinITI then
        CatchPenalty := CatchPenalty - MinITI;  'ITI will be added back in at the time of the penalty
    else
        CatchPenalty := 0;  'ITI will be the sum total of the penalty
    endif;
    if NRPenalty >= MinITI then
        NRPenalty := NRPenalty - MinITI;  'ITI will be added back in at the time of the penalty
    else
        NRPenalty := 0;  'ITI will be the sum total of the penalty
    endif;
    if FAPenalty >= MinITI then
        FAPenalty := FAPenalty - MinITI;  'ITI will be added back in at the time of the penalty
    else
        FAPenalty := 0;  'ITI will be the sum total of the penalty
    endif;
    if IntPenalty >= MinITI then
        IntPenalty := IntPenalty - MinITI;  'ITI will be added back in at the time of the penalty
    else
        IntPenalty := 0;  'ITI will be the sum total of the penalty
    endif;
    
    
    
    'Load Trials File(s)
    MaxTFLen% := NMaxTrials%/NTrialsFiles%;  'floor is built in to integer operations
    for i% := 1 to NTrialsFiles% do
        'Load Trials File - all testing of trials file is done inside ReadTrialFile% function
        TrialFileLoadSuccess% := ReadTrialFile%(i%);
        while TrialFileLoadSuccess% = 0 do
            ResetTrialFileVars%(i%);
            TrialFileLoadSuccess% := ReadTrialFile%(i%);
        wend;    
    next;
    
    'If we are trial wrapping, get the current trial indices
    if TrialWrap% = 1 then
        GetTrialIndices(MonkeyLetter$);
    endif;
    
    'Determine if there is more than one stim per trial, if so, use common attenuation
    if ConcatStim%[max(ConcatStim%[])] > 1 or ConcatStim2%[max(ConcatStim2%[])] > 1 then
        UseCommondB := 1;
    else
        UseCommondB := 0;
    endif;
    
    'Calculate the scaling factors (scaling with Spike2, not on the PA5) for normalizing the stims
    'Do this after loading the trials file.
    docase
    case PA5Absent% = 1 then  'if no PA5, do all possible attenuation on software, set each stim's initial scale factor to the calibrating attenuation
        for i% := 0 to StimN%-1 do
            ScaleFactor[i%] := NormAtten[i%];  'dB to scale
        next;
    case UseCommondB = 1 then
        CommondB := NormAtten[min(NormAtten[])];
        for i% := 0 to StimN%-1 do
            diff := NormAtten[i%] - CommondB;  'diff is the number of decibels less than a full power stim, always positive or zero
            ScaleFactor[i%] := diff;  'dB to scale, opportunity for fade-in still exists
        next;
    else
        CommondB := 0;  'set CommondB to 0
        ArrMul(ScaleFactor[],0);  'set ScaleFactor[] to 0 (in case this is second param file)
    endcase;
    
    
    if ParamsLoadedOnce% = 1 then
        TrialsFinished% := 0;  'Since we're not done, reset TrialsFinished% 
        CurrTrialIndex% := 0;  'reset CurrTrialIndex%
        FutureTrialIndex% := 0;  'reset FutureTrialIndex% too, needs to be 0
        ArrConst(CurrTrialIndexList%[],0);
        ArrConst(FutureTrialIndexList%[],0);
        iState% := StateLoadStimulus%;
        StimulusPlaying% := 0;  'forces StateLoadStimulus
		'will now return to toolbar and run main%(), which will be active as we are currently sampling
		'I guess technically it should return to main%() first, because it was called from main%().
    else
		'Enable Start on Toolbar, etc.  Only do the first time through
        ToolbarEnable(1,1);  'Enable Quit
        ToolbarSet(2,"LoadNewParam",PrepNewParam%);
        ToolbarEnable(2,0);  'Disable LoadNewParam for now, until stimuli start playing
        ToolbarEnable(3,1);  'Enable Start
        ToolbarEnable(6,0);  'Disable Solenoid Cleaning now that stims are loaded
        ToolbarEnable(7,0);  'Disable joystick calibration now that stims are loaded
        ToolbarEnable(8,0);  'Disable fixation parameters now that stims are loaded
        tbtext$ := "Stimuli loaded.  Start sampling data or Quit";
        toolbartext(tbtext$);
        
        ParamsLoadedOnce% := 1;  'note that parameters have been loaded (at least) once
    endif;
    
    
    return 1;  'Only return success if we get all the way through
    
end;



'=================================== Start Sampling ==================================
func StartSampling%()
    
    var q%;   							'for a Query function in case of error in the opening of the data file
    var mystr1$;    					'strings for the query box
    var mystr2$;
    var mystr3$;
    var FoundFile := 1;   			'checking to see if the filename is valid
    var NumOfFiles;
    var list$;
    var GodOpenDur:=0.2;				'God button open duration, in seconds
    var npoints%;						'how many points to pull solenoid high to get GodOpenDur
    var DAClist%[2];  				'an array to hold the DAC list for stereo output
    var TrialStartString$;
    var StartTrialList$[2];
    StartTrialList$[0] := "Use Default Starting Trial(s)";
    StartTrialList$[1] := "Set/View Starting Trial(s)";
    var StartTrialInd% := 0;
    var dlgLFPSampleRateList$[3];  'variables that allow for setting of sample rates, define later at dialog box
    var dlgWaveformSampleRateList$[2];
    var dlgJoystickSampleRateList$[2];
    var dlgLFPSampleRates%[3];
    var dlgWaveformSampleRates%[2];
    var dlgJoystickSampleRates%[2];
    var dlgLFPValue%;
    var dlgWaveformValue%;
    var dlgJoystickValue%;
    var ii%;  'looping
    var WMSize%;
    var WMPre%;
    var key$;
    
    DataCollected% := 1;  'note that we have collected data, for Quit%()
    
    
    ' Fetch information about whether we are going to be using two 1401s - for new version that uses CONFIG 
    UseTwo1401s% := DoWeUseTwo1401s%();
    if UseTwo1401s% = 1 then
        message("Use of two 1401s is not implemented for pres_engine_usrey!  Quitting!");
        halt
    endif;
    
    
    ' Get number of wavemark ports/continuous ports on the primary 1401
    ' Note that the info we gather here is basically used for display, which is only done on the primary 1401.  The
    ' secondary 1401 is kinda humming along passively collecting data and doing nothing else.
    ' The thing is, the Wavemark info here is used for spike plotting, the continuous info is unused.  OK, maybe it will be useful someday.
    ' Just freaking keep the "tun" prefix, it's probably easier
    GetPortsAndNumWMsWFs%(tunNWavemarks%,tunNContinuous%,tunWavemarkPorts%[],tunContinuousPorts%[]);
    
    'Since the maximum size of the PlayWave buffer is determined the first time we start sampling, there are 
    'issues for loading multiple parameter/trials files.  The problem lies in that later trials files may 
    'specify longer stim sequences than the first trials file, and then overrun the buffer.
    'Therefore, MaxPoint% is now being set in the dialog box below by the user, who must tell us how long
    'the longest stimulus ever to be loaded is.  Due to potential user error, here we find out what the minimum
    'duration needed is for the first trials file so we don't accidentally go too short
    
	'MaxPoint% must be reset to the maximum value in the task.
    MaxPoint% := TrialPoints%[max(TrialPoints%)];
    if NSpeakers% = 2 then  'if there are two speakers, check both stimulus lists
        MaxPoint2% := TrialPoints2%[max(TrialPoints2%)];
        MaxPoint% := max(MaxPoint%,MaxPoint2%);
    endif;
    if MaxPoint% > MaxPoint1401% then
        printlog("The trials file specifies stimuli which are longer than the 1401 can handle!\n");
        view(HiddenLogHandle%).print("The trials file specifies stimuli which are longer than the 1401 can handle!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    
    
    
    'Run a dialog box that allows setting of save file name, start trial, sampling rates, and verbose options
    'Re-run dialog in the event that the user tries to overwrite a file
    while FoundFile = 1 do 
        
		'Set MaxPointSec preliminarily
        MaxPointSec := MaxPoint%/SampleRate;
        
        'Set up variables to allow for dialog-based sample rates, right now there are two options, more could be added as needed
        dlgLFPSampleRateList$[0] := "2000";
        dlgLFPSampleRateList$[1] := "10000";
        dlgLFPSampleRateList$[2] := "25000";
        dlgWaveformSampleRateList$[0] := "25000";
        dlgWaveformSampleRateList$[1] := "50000";
        dlgJoystickSampleRateList$[0] := "2500";
        dlgJoystickSampleRateList$[1] := "5000";
        dlgLFPSampleRates%[0] := 2000;
        dlgLFPSampleRates%[1] := 10000;
        dlgLFPSampleRates%[2] := 25000;
        dlgWaveformSampleRates%[0] := 25000;
        dlgWaveformSampleRates%[1] := 50000;
        dlgJoystickSampleRates%[0] := 2500;
        dlgJoystickSampleRates%[1] := 5000;
        'And get most recent values from the registry
        configLFPSampleRate% := GetIntRegistryValue%("PresEngine\\", "LFPRate", configLFPSampleRate%); 'return configLFPSampleRate% if registry value does not exist
        configWaveformSampleRate% := GetIntRegistryValue%("PresEngine\\", "WaveformRate", configWaveformSampleRate%); 'return configWaveformSampleRate% if registry value does not exist
        configJoystickSampleRate% := GetIntRegistryValue%("PresEngine\\", "JoystickRate", configJoystickSampleRate%); 'return configJoystickSampleRate% if registry value does not exist
        'Determine default value for dialog box list based on most recent value (apparently no "break" keyword or equivalent in Spike2, it's short enough we can just not worry about writing a more complicated WHILE)
        'if for some reason the value saved in the registry is not in the appropriate sample rate list this will default to 0, so the first value in the string list
        for ii% := 0 to len(dlgLFPSampleRates%[])-1 do
            if configLFPSampleRate% = dlgLFPSampleRates%[ii%] then
                dlgLFPValue% := ii%;
            endif
        next
        for ii% := 0 to len(dlgWaveformSampleRates%[])-1 do
            if configWaveformSampleRate% = dlgWaveformSampleRates%[ii%] then
                dlgWaveformValue% := ii%;
            endif
        next
        for ii% := 0 to len(dlgJoystickSampleRates%[])-1 do
            if configJoystickSampleRate% = dlgJoystickSampleRates%[ii%] then
                dlgJoystickValue% := ii%;
            endif
        next
        
        
        
        'Open dialog box to change FilePrefix$, etc.
        DlgCreate("");
        DlgString(1,"Write Data To This File:",20,"a-zA-Z0-9");   'no filenames over 20 characters!, restrict entry to letters and numbers
        'DlgInteger(2,"Start with trial(s):",1,1000000);  'cannot be less than zero, must provide a cap so chose 1000000
        DlgList(2,35,StartTrialList$[]);  'gives option to use default start points
        DlgReal(3,"Maximum duration of stimulus, in seconds:",0.05,10);  'test out MaxPointSec and change as appropriate
        'note that MaxPointSec will presumably assume two buffers (one speaker) - for four buffers (two speakers) will have to change
        DlgList(4,"LFP Sampling Rate (Hz)",dlgLFPSampleRateList$[]);
        DlgList(5,"Waveform Sampling Rate (Hz)",dlgWaveformSampleRateList$[]);
        DlgList(6,"Joystick Sampling Rate (Hz)",dlgJoystickSampleRateList$[]);
        DlgCheck(7,"Verbose: Display Stimulus ID");
        DlgCheck(8,"Verbose: In-Depth Accuracy Display");
        DlgCheck(9,"Verbose: Display Increment Updates");
        DlgCheck(10,"Verbose: Display PA5 Settings");
        DlgCheck(11,"Verbose: Display Detailed Trial Timing Info");
        DlgCheck(12,"Verbose: Display Detailed Main Loop Info");
        DlgCheck(13,"Verbose: Display Super Detailed Main Loop Info (don't!)");
        DlgCheck(14,"Verbose: Display Detailed Stimulus Load Info");
        DlgCheck(15,"Verbose: Display Detailed Joystick/Lever Info");
        DlgAllow(0, 0, PresEngDialogChanged%);
        ok% := DlgShow(FilePrefix$,StartTrialInd%,MaxPointSec,dlgLFPValue%,dlgWaveformValue%,dlgJoystickValue%,VerboseStimID%,VerboseAccuracy%,
                       VerboseIncrements%,VerbosePA5%,VerboseTrialTiming%,VerboseMainLoop%,VerboseUberVerbose%, VerboseStimLoad%,VerboseJoyLev%);   
        'Dialog changes FilePrefix$, StartTrialInd%, MaxPointSec, etc.
        'If the user cancels opening the data file
        if ok%=0 then
            printlog("Quitting because the user has cancelled the creation of data file for writing.\n");
            view(HiddenLogHandle%).print("Quitting because the user has cancelled the creation of data file for writing.\r");
            Quit%();
        endif;  
        
        if VerboseMainLoop% = 1 then
            ToolbarSet(9, "Verbose is on", ToggleVerbose%);
        else
            ToolbarSet(9, "Verbose is off", ToggleVerbose%);
        endif;
        
        'MonkeyLetter$ := Left$(UCase$(FilePrefix$),1);  'monkey letter is always upper case
        MonkeyLetter$ := Left$(UCase$(dataCellName$),3);  'monkey letter is always upper case, this can be multiple letters, for Usrey, there may be multiple monkeys with one letter?
        
        'set the sampling rates, these will be unused
        configLFPSampleRate% := dlgLFPSampleRates%[dlgLFPValue%];
        configWaveformSampleRate% := dlgWaveformSampleRates%[dlgWaveformValue%];
        configJoystickSampleRate% := dlgJoystickSampleRates%[dlgJoystickValue%];
        'and write them to the registry
        SetIntRegistryValue("PresEngine\\", "LFPRate", configLFPSampleRate%);
        SetIntRegistryValue("PresEngine\\", "WaveformRate", configWaveformSampleRate%);
        SetIntRegistryValue("PresEngine\\", "JoystickRate", configJoystickSampleRate%);
        
        'get default starting trial(s)
        if TrialWrap% = 1 then 'in a trialwrap scenario, the default should come from the registry
            GetTrialIndices(MonkeyLetter$);
        else  'if not trialwrapping, default is zeros
            arrconst(CurrTrialIndexList%[],0);
            arrconst(FutureTrialIndexList%[],0);
        endif;
        
        TrialStartString$ := CreateStartTrialString$();
        
        if StartTrialInd% = 1 then 'open a new dialog for selecting the start trial(s)
            ok% := 0;
            while ok% < 1 do
                DlgCreate("Select Starting Trial(s)");
                DlgString(1,"Start with trial(s):",100,"0-9,");  'Allow numbers and comma
                DlgShow(TrialStartString$);
                ok% := InterpretStartTrialString%(TrialStartString$);
            wend;
        else
            ok% := InterpretStartTrialString%(TrialStartString$);  'even if we use the default value, we have to interpret the start trial string
        endif;
    
        'Set initial value for CurrTrialIndex%, FutureTrialIndex%
        CurrTrialIndex% := (MaxTFLen%*(SwitchCurrFile%-1)) + CurrTrialIndexList%[SwitchCurrFile%-1];  'get new current trial index
        FutureTrialIndex% := CurrTrialIndex%;
        
		'Check to make sure that the user hasn't accidentally blown it, despite the nice stuff we have above
        if MaxPointSec < MaxPoint%/SampleRate then
            MaxPointSec := MaxPoint%/SampleRate;  'Change it back, make them try again
            DlgCreate("");
            DlgReal(1,"Max duration entered is LESS THAN calculated max duration, try again or re-enter to confirm:",0.05,10);
            ok% := DlgShow(MaxPointSec);
        endif;
        
        
		'Set MaxPoint%
        MaxPoint% := round(MaxPointSec * SampleRate);  'Calculate MaxPoint%, round is necessary because if MaxPointSec is a multiple of 1.15, there is a weird math fail
        printlog("The max number of points in a stimulus is %d and the maximum duration is %f seconds\n",MaxPoint%,MaxPointSec);
        printlog("Data file prefix is now %s\n",dataCellName$);
        printlog("Starting with trial number %d:%d\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
        view(HiddenLogHandle%).print("The max number of points in a stimulus is %d and the maximum duration is %f seconds\r",MaxPoint%,MaxPointSec);
        view(HiddenLogHandle%).print("Data file prefix is now %s\r",dataCellName$);
        view(HiddenLogHandle%).print("Starting with trial number %d:%d\r",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
        
        
        'check for existence of online files, assume .idx and .spk files will exist together
'        FilePathSet(OnlineDir$);  'go to correct directory as FileList doesn't play nicely otherwise
'        NumOfFiles := filelist(list$,-1,dataCellName$+".idx");
'        
'        if NumOfFiles = 0 then 'files do not exist, we will create them later
'            FoundFile := 0;  'will break out of loop
'        endif;
'        if NumOfFiles < 0 then 'there is an error, presumably this must have been a problem once...?
'            message("Quitting due to an error in FileList while trying to locate online .idx files.\n\nThe error is:\n\n"+error$(NumOfFiles));
'            printlog(error$(NumOfFiles));
'            printlog("\nQuitting because FileList has thrown the above error trying to locate online .idx files!\n");
'            view(HiddenLogHandle%).print(error$(NumOfFiles));
'            view(HiddenLogHandle%).print("\rQuitting because FileList has thrown the above error trying to locate online .idx files!\r");
'            quit%();
'        endif;
'        if NumOfFiles > 1 then 'more than one match - try again
'            message("There must be a * wildcard in your file name.  Please try again.");
'            FoundFile := 1; 'stay in while loop
'        endif;
'        if NumOfFiles = 1 then 'files exist
'            message("A file of that name exists!  Please try again.");
'            FoundFile := 1;  'stay in while loop
    '        endif;
    FoundFile := 0;  'We are just getting out of the loop, not checking file names when we are autonaming
    wend;
    
    
    
    '''Start sampling configuration'''
    
    'Instead of opening a configuration file, we're going to manually create the configuration
    
    SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    'Always create a reward channel
    'SampleEvent(configRewardChannel%,configRewardPort%,2,1);   'this is dual-defined, using memchannel
	'SampleComment$(configRewardChannel%,"Reward");
	'SampleTitle$(configRewardChannel%,"Reward");
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    MyAutoName$ := SampleAutoName$(dataCellName$ + "_" + "audio" + "_000");  'NOTE: maximum of 13 characters!!!
    SampleAutoFile(1);
    
    SampleTextMark(200);  'Channel 30 is textmark channel
    
    docase
'    case tunDoOpto% = 1 then
'        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
'        'SampleTitle$(DigitalLaserChannel%,"Laser On");
'        SampleTitle$(32,"Laser On");  'Digital marker is by definition channel 32
    case RecordEyeTrackerOutputFile% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"EyeFilePulse");  'Digital marker is by definition channel 32
    endcase
    
    docase
    case tunButtonCollect% = 1 and UtilityPort% > -1 then  'use utility port for button
'        SampleWaveform(ButtonChannel%,ButtonPort%,10000);  'Giving 0.1 ms resolution for now
'        SampleComment$(ButtonChannel%,"Raw Button");
'        SampleTitle$(ButtonChannel%,"Raw Button");
        SampleWaveform(ButtonChannel%, UtilityPort%, 1000);
        SampleTitle$(ButtonChannel%,"Button");  'We ought to title the button channel something, right? -jj 9/22/16
    case tunButtonCollect% = 1 and UtilityPort% = -1 then  'if utility port is undefined, this is an error
        Message("You must set a UtilityPort in Config->DAQ to use the rivalry button!  Quitting!");
        halt
    case UtilityPort% > -1 then  'otherwise, utility port is a utility port
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);        
        SampleTitle$(UtilityChannel%,UtilityPortLabel$);   
    endcase;
    
    
    SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
    SampleTitle$(XChannel%,EyeXPortLabel$);
    SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
    SampleTitle$(YChannel%,EyeYPortLabel$);
    
    if JoystickPort% > -1 then
        printlog("Joy channel is %d and joystick port is %d\n", JoyChannel%, GetJoystickPort%());
        SampleWaveform(JoyChannel%, GetJoystickPort%(), 1000);
        SampleTitle$(JoyChannel%, JoystickPortLabel$);
    endif
    
    '----Set up "spiking" Electrode Channels----
    'This function will set up standard sampling as well as various pre-set samplings including the Plexon setups
    SetUpElectrodeConfiguration(numWavemarkPorts%,ExcludedChans%[]);
    
    DoSampleOptimise();
    
    SampleMode(1); 'Continuous sampling
    
    'Create an LFP (EEG) channel if requested
'    if CollectEEG% = 1 then
'        SampleWaveform(configLFPChannel%,configLFPPort%,configLFPSampleRate%);  'up from 2000, should give good values 
'        SampleComment$(configLFPChannel%,"LFP");
'        SampleTitle$(configLFPChannel%,"LFP");
'        if NTrodes% = 1 then
'            SampleWaveform(configTemporaryHighFrequencyLFPChannel%,configTemporaryHighFrequencyLFPPort%,configTemporaryHighFrequencyLFPSampleRate%);  'up from 2000, should give good values 
'            SampleComment$(configTemporaryHighFrequencyLFPChannel%,"HighFreqLFP");
'            SampleTitle$(configTemporaryHighFrequencyLFPChannel%,"HF-LFP");
'        endif;
'        if NTrodes% > 1 then
'            SampleWaveform(configLFPChannel2%,configLFPPort2%,configLFPSampleRate%); 
'            SampleComment$(configLFPChannel2%,"LFP2");
'            SampleTitle$(configLFPChannel2%,"LFP2");
'        endif;
'        if NTrodes% > 2 then
'            SampleWaveform(configLFPChannel3%,configLFPPort3%,configLFPSampleRate%); 
'            SampleComment$(configLFPChannel3%,"LFP3");
'            SampleTitle$(configLFPChannel3%,"LFP3");
'        endif;
'    endif;

    'Create spike waveform and wavemark channel if not behavioral
'    if NTrodes% > 0 then   'was if Behavioral = 0
'        SampleWaveform(configWaveformChannel%,configWaveMarkPort%,configWaveformSampleRate%); 
'        SampleComment$(configWaveformChannel%,"Raw");
'        SampleTitle$(configWaveformChannel%,"Raw");
'        
'        WMSize% := configWaveformSampleRate%/833;  'these will be automatically floored at the division (also assignment) step because of integer math, if rounding is preferred we'll need to set up a float math version
'        WMPre% := configWaveformSampleRate%/2900;
'        
'        SampleWaveMark(configWaveMarkChannel%,configWaveMarkPort%,2000,WMSize%,WMPre%,configWaveformSampleRate%); 
'        'SampleWaveMark(configWaveMarkChannel%,configWaveMarkPort%,2000,60,17,configWaveformSampleRate%);  'old version, with hardcode values
'        SampleComment$(configWaveMarkChannel%,"Units");
'        SampleTitle$(configWaveMarkChannel%,"Units");
'        
'        if NTrodes% > 1 then
'            SampleWaveform(configWaveformChannel2%,configWaveMarkPort2%,configWaveformSampleRate%); 
'            SampleComment$(configWaveformChannel2%,"Raw2");
'            SampleTitle$(configWaveformChannel2%,"Raw2");
'        
'            SampleWaveMark(configWaveMarkChannel2%,configWaveMarkPort2%,2000,WMSize%,WMPre%,configWaveformSampleRate%); 
'            SampleComment$(configWaveMarkChannel2%,"Units2");
'            SampleTitle$(configWaveMarkChannel2%,"Units2");
'        endif;
'        
'        if NTrodes% > 2 then
'            SampleWaveform(configWaveformChannel3%,configWaveMarkPort3%,configWaveformSampleRate%); 
'            SampleComment$(configWaveformChannel3%,"Raw3");
'            SampleTitle$(configWaveformChannel3%,"Raw3");
'        
'            SampleWaveMark(configWaveMarkChannel3%,configWaveMarkPort3%,2000,WMSize%,WMPre%,configWaveformSampleRate%); 
'            SampleComment$(configWaveMarkChannel3%,"Units3");
'            SampleTitle$(configWaveMarkChannel3%,"Units3");
'        endif;
'    endif;
    
    'Create joystick/lever channels...if joystick create God Button or Motion channels if appropriate
'    docase
'    case RespDevice% = 0 then  'create lever channel
'        SampleEvent(configLeverChannel%,configLeverPort%,2,10); 
'        SampleComment$(configLeverChannel%,"Lever");
'        SampleTitle$(configLeverChannel%,"Lever");
'    else  'create joystick channels
'        'X
'        SampleWaveform(configJoyXChannel%,configJoyXPort%,configJoystickSampleRate%); 
'        SampleComment$(configJoyXChannel%,"JoystikX");
'        SampleTitle$(configJoyXChannel%,"JoystikX");
'        'Y
'        SampleWaveform(configJoyYChannel%,configJoyYPort%,configJoystickSampleRate%); 
'        SampleComment$(configJoyYChannel%,"JoystikY");
'        SampleTitle$(configJoyYChannel%,"JoystikY");
'        'Read joystick offsets
'        GetJoystickOffsets(JoystickType%);
'        'Set additional info for joystick channels, notably offset
'        SampleCalibrate(configJoyXChannel%,"volt",1,joystickXOffset);
'        SampleCalibrate(configJoyYChannel%,"volt",1,joystickYOffset);
'        
'        
'        'Create XY view for joystick display
'        joyview% := FileNew(12);  'open an XY window
'        'Create a new channel in the XY view to display the fixation point
'        joydatachan% := XYSetChan(0);
'        XRange(-2.5,2.5);  'set XRange
'        YRange(-2,-2.5,2.5);  'set YRange, all visible channels
'        XYDrawMode(0,5,0);  'turns off automatic axis range mode
'        WindowVisible(1);  'make window visible
'        'Window(75, 55, 100, 100); 'set to lower 16th of screen
'        Window(0, 60, 40, 100); 'trying different position
'        XYColour(joydatachan%,16);  'set a colo(u)r for joydatachan%
'        XYSize(joydatachan%,-1); 'for channel joydatachan%, plot only one point at a time (-1)
'        
'        'draw X axis
'        xaxisdrawchan% := XYSetChan(0);  'create channel to hold data
'        XYColour(xaxisdrawchan%,13);    'set color
'        XYDrawMode(xaxisdrawchan%,2,0);  'set draw mode to make data points invisible
'        XYDrawMode(xaxisdrawchan%,3,1);  'set draw mode to dotted line
'        XYJoin(xaxisdrawchan%,1);   'set join mode to join with line
'        XYAddData(xaxisdrawchan%,-2.5,0);  'add data to extreme ends of X-axis
'        XYAddData(xaxisdrawchan%,2.5,0);
'        
'        'draw Y axis
'        yaxisdrawchan% := XYSetChan(0);  'create channel to hold data
'        XYColour(yaxisdrawchan%,13);    'set color
'        XYDrawMode(yaxisdrawchan%,2,0);  'set draw mode to make data points invisible
'        XYDrawMode(yaxisdrawchan%,3,1);  'set draw mode to dotted line
'        XYJoin(yaxisdrawchan%,1);   'set join mode to join with line
'        XYAddData(yaxisdrawchan%,0,-2.5);  'add data to extreme ends of Y-axis
'        XYAddData(yaxisdrawchan%,0,2.5);
'
'                
'        'check for potential non-lever devices
'        docase
'        case GodButtonExists% = 1 then
'            SampleEvent(configGodChannel%,configGodPort%,2,10); 
'            SampleComment$(configGodChannel%,"Shaping");
'            SampleTitle$(configGodChannel%,"Shaping");
'        case Motion% = 1 then
'            SampleEvent(configMotionChannel%,configMotionPort%,2,10); 
'            SampleComment$(configMotionChannel%,"Motion");
'            SampleTitle$(configMotionChannel%,"Motion");
'        endcase;
'    endcase;
    
    'For the pure behavioral case (lever, behavioral) set lower fundamental clock rate
'    if RespDevice% = 0 and Behavioral% = 1 then
'        SampleTimePerAdc(2);
'        SampleUsPerTime(50);
'    else  'for all other scenarios set a higher fundamental clock rate
'        SampleTimePerAdc(1);
'        SampleUsPerTime(5);
'    endif;
    
    'If monitoring fixation, create appropriate channels and window
'    if DoFixation% > 0 then
'        if configEyeXPort% = 1000 then
'            message("configEyeXPort and configEyeYPort need to be set to the appropriate input ports!  Quitting!");
'            view(HiddenLogHandle%).print("\rQuitting because configEyeXPort and configEyeYPort have not been set!\r");
'            quit%();
'        endif;
'        
'        SampleWaveform(configEyeXChannel%, configEyeXPort%, 1000);
'        SampleTitle$(configEyeXChannel%,"Eye X");
'        SampleWaveform(configEyeYChannel%, configEyeYPort%, 1000);
'        SampleTitle$(configEyeYChannel%, "Eye Y");
'        
'        'Open an XY view to display eye position
'        EyeXYWindow% := FileNew(12);
'        XRange(-15,15);
'        YRange(-2,-15,15);
'        XYDrawMode(0,5,0);
'        WindowVisible(1);
'        Window(0, 0, 50, 50);
'        XYSize(iEyePosChannel%, -1);
'        XYColour(iEyePosChannel%, 16);
'        
'        'Calcuate the fixation window
'        var index%;
'        var twopi;
'        twopi := 2.0*4.0*ATan(1.0);
'        
'        for index% := 0 to 35 do
'            FixWindowX[index%] := FixWindowRadius * Cos(index% * twopi/36.0);
'            FixWindowY[index%] := FixWindowRadius * Sin(index% * twopi/36.0);
'        next;
'        
'        'Create a new channel in the XY view to display the fixation window
'        iFixWindowChannel% := XYSetChan(0);
'        XYColour(iFixWindowChannel%, 13);
'        XYDrawMode(iFixWindowChannel%, 2, 1);
'        XYJoin(iFixWindowChannel%, 1);
'        
'        'Create a new channel in the XY view to display the fixation point
'        iFixChannel% := XYSetChan(0);
'        
'    endif;
    
    
    'Turn off optimization to mimic config files, because no optimization was being done
'    SampleOptimise(0,1,2);  'Set optimise mode (do this last)
'	SampleMode(1); 'Continuous sampling
    
    '''End sampling configuration'''
    
    
	'Clear play areas and add two play buffers on DAC 0
    PlayWaveDelete(); 
    if NSpeakers% = 1 then
        ok%:=PlayWaveAdd("S","Stim",0,SampleRate,maxpoint%);  'this must be done before calling FileNew.  If not, you
        'cannot change maxpoint% in an upward direction without either
        'quitting Spike2 or requesting more space than is available on
        'the 1401 to cause a crash.
        ok%:=PlayWaveAdd("T","Stim",0,SampleRate,maxpoint%);  'second buffer
    else 'if it's a stereo experiment, reserve two buffers to play on DACs 0 and 1
        DAClist%[0] := 0;
        DAClist%[1] := 1;
        ok%:=PlayWaveAdd("S","Stim",DAClist%,SampleRate,maxpoint%);  'first buffer - BOTH buffers play (through DAC0/DAC1) when triggered 
        ok%:=PlayWaveAdd("T","Stim",DAClist%,SampleRate,maxpoint%);  'second buffer
    endif;    
    
    
	'Open the correct Sequencer file
    ok% := samplesequencer(SeqFileName$);
    if ok% < 0 then
        message("The requested sequencer file %s\nwas not found!  Quitting!",SeqFileName$);
        printlog("Quitting because the requested sequencer file was not found!\n");
        view(HiddenLogHandle%).print("Quitting because the requested sequencer file was not found!\r");
        quit%();
    endif;    
    
    
    
    
    
	'Create new data window, name it and resize it
    ctview% := FileNew(0,1+2+4);
    
    
    'Let's do this easier  (if this fails replace with original two IFs from 1.3.19 or earlier)
    while ctview% < 0 do 'if ctview% is negative, no file was opened - we have to diagnose the problem
        printlog("The following error occurred while trying to open a new data file:\n"+error$(ctview%)+"\n");
        view(HiddenLogHandle%).print("The following error occurred while trying to open a new data file:\r"+error$(ctview%)+"\r");
        mystr1$ := "Error opening a new data file!|Error is: "+error$(ctview%)+"\n\nReset the Power1401 or flip the switches.";
        mystr2$ := "OK, I reset the Power1401, try again";
        mystr3$ := "Quit script";
        q% := query(mystr1$,mystr2$,mystr3$);
        if q% = 1 then
            printlog("Trying to open a new data file again after user fix!\n");
            view(HiddenLogHandle%).print("Trying to open a new data file again after user fix!\r");
            ctview% := FileNew(0,1+2+4); 'try again
        else
            printlog("Quitting because the user pressed the 'Quit Script' button after a Power1401 error in opening a new data file.\n");
            view(HiddenLogHandle%).print("Quitting because the user pressed the 'Quit Script' button after a Power1401 error in opening a new data file.\r");
            ctview% := 0;  'escape the dialog box
            quit%();
        endif;
    wend;
    
    Window(0,48,50,95);
    XRange(0, 30);
	View(ctview%).WindowVisible(1);
    
    'Open an XY view to display eye position
	EyeXYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
    'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;
    
    
    'Create a new channel in the XY view to display the fixation window
	iFixWindowChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);

	'Create a new channel in the XY view to display the fixation point
	iFixChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(4,13);
	XYDrawMode(4,3,1);
	XYJoin(4,2);
	XYAddData(4,-9,-7);
	XYAddData(4,9,-7);
	XYAddData(4,9,7);
	XYAddData(4,-9,7);
    
    
    
	'Get AD Conversion Rate, Seconds Per Sample
    TimePerADC := SampleTimePerAdc();
    UsPerTime := SampleUsPerTime();
    SecPerSample := TimePerADC*UsPerTime/1000000;
    
	'Title and resize data window
    WindowTitle$(MyAutoName$);  
    'Window(0,0,100,30);
    
    frontview(loghandle());  'bring logwindow to front and resize it
    if Behavioral% = 1 then
        'window(0,30,75,100);  'size logwindow large for behavioral experiments
        window(40,30,100,100);  'size logwindow large for behavioral experiments, trying different position
    else
        if CollectEEG% = 1 or Interleaved% = 0 then
            window(0,30,75,60);  'size logwindow medium for recording experiments where either histograms
            'overlap or EEG window is necessary
        else
            window(0,30,50,60);  'size logwindow small for recording experiments where we should show 4 histograms
        endif;
    endif;
    
    frontview(ctview%);		 'bring data window back to front
    
	'Show Sampling Controls only if we're collecting physiological data
    if tunNWavemarks%  > 0 then  
        view(SampleHandle(1)).WindowVisible(1); 'Sampling Controls take over system - nothing happens until
        'Sample Data is clicked on the Sampling Controls
    endif;
    
    
	'Create various other channels
    MemChanStim% := MemChan(8, 25);         'Create textmarker channel for stimname/frequency. 25 characters
    ChanTitle$(MemChanStim%, "Stimulus");   'Give it a title
    MemChanRw% := MemChan(5,0);             'Create marker channel for reward 
    ChanTitle$(MemChanRw%,"Reward");        'Give it a title
    MemChanStart% := MemChan(2,0);          'Create event channel for the start time of the trial
    ChanTitle$(MemChanStart%,"TrialStart"); 'Give it a title
    chanshow(MemChanStim%,MemChanRw%,MemChanStart%); 'show these three channels
    
    'Doesn't really matter how to set these up as the animal won't be responding - no Auditory task in Usrey lab!
    if RespDevice% = 0 then  'if physical device is lever
        MemChanLeverDebounce% := MemChan(8,25); 'Create textmark channel for debounced lever with attached lever value, 25 characters
        ChanTitle$(MemChanLeverDebounce%,"DBLever");  'Give it a title
        chanshow(MemChanLeverDebounce%);  'Show it    
    else  'if physical device is joystick
        MemChanJoystickRO% := MemChan(3,0);  'Create event channels for joystick transitions
        MemChanJoystickLO% := MemChan(3,0);
        MemChanJoystickUO% := MemChan(3,0);
        MemChanJoystickDO% := MemChan(3,0);
        MemChanJoystickRI% := MemChan(3,0);
        MemChanJoystickLI% := MemChan(3,0);
        MemChanJoystickUI% := MemChan(3,0);
        MemChanJoystickDI% := MemChan(3,0);
        MemChanJoystick% := MemChan(8,30);  'Channel to save joystick info, don't show?
        ChanTitle$(MemChanJoystick%,"JoyEvents");  'Give it a title
        if GodButtonExists% then  'start up lever channel if god button exists
            MemChanLeverDebounce% := MemChan(8,25); 'Create textmark channel for debounced lever with attached lever value, 25 characters
            ChanTitle$(MemChanLeverDebounce%,"DBLever");  'Give it a title
            chanshow(MemChanLeverDebounce%);  'Show it
        endif;    
    endif;
    
    'if Behavioral% = 0 then  'create channels to trigger histograms, only if recording, make these for up to three electrodes
    if tunNWavemarks% > 0 then
        MemChanHistTrigger% := MemChan(8, 25); 'Create textmarker channel for stimname/frequency, all trials
        ChanTitle$(MemChanHistTrigger%,"TestStimStart"); 'give it a title
        chanhide(MemChanHistTrigger%);  'hide it
        if Interleaved% = 1 or Passive% = 1 or PassiveAndActive% = 1 then  'prepare for passive histograms
            MemChanHistTriggerP% := MemChan(8, 25); 'Create textmarker channel for stimname/frequency, passive trials
            ChanTitle$(MemChanHistTriggerP%,"TestStimStartP"); 'give it a title
            chanhide(MemChanHistTriggerP%); 'hide it
            if OverallPSTHType% > 0 then
                MemChanHistTriggerPGroup% := MemChan(8, 25); 'Create textmarker channel for grouped stimname/frequency, passive trials
                ChanTitle$(MemChanHistTriggerPGroup%,"TestStimStartPGroup"); 'give it a title
                chanhide(MemChanHistTriggerPGroup%); 'hide it
            endif;
        endif;
        if Interleaved% = 1 or Passive% = 0 or PassiveAndActive% = 1 then  'prepare for active histograms
            MemChanHistTriggerA% := MemChan(8, 25); 'Create textmarker channel for stimname/frequency, active trials
            ChanTitle$(MemChanHistTriggerA%,"TestStimStartA"); 'give it a title
            chanhide(MemChanHistTriggerA%); 'hide it
            if OverallPSTHType% > 0 then
                MemChanHistTriggerAGroup% := MemChan(8, 25); 'Create textmarker channel for grouped stimname/frequency, passive trials
                ChanTitle$(MemChanHistTriggerAGroup%,"TestStimStartAGroup"); 'give it a title
                chanhide(MemChanHistTriggerAGroup%); 'hide it
            endif;
        endif;
    endif;
    
    if RespDevice% = 0 then  'if physical device is lever
        'ChanTitle$(30,"ResponseEvents");
    else  'if physical device is joystick
        ChanTitle$(MemChanJoystickRO%,"JoystickRight");
        ChanTitle$(MemChanJoystickLO%,"JoystickLeft");
        ChanTitle$(MemChanJoystickUO%,"JoystickUp");
        ChanTitle$(MemChanJoystickDO%,"JoystickDown");
        ChanTitle$(MemChanJoystickRI%,"JoystickRCenter");
        ChanTitle$(MemChanJoystickLI%,"JoystickLCenter");
        ChanTitle$(MemChanJoystickUI%,"JoystickUCenter");
        ChanTitle$(MemChanJoystickDI%,"JoystickDCenter");
    endif;
    
    
	'Show channels
    'chanshow(30);  'show channel 30 (textmark)
'    chanshow(configWaveMarkChannel%,configWaveMarkChannel2%,configWaveMarkChannel3%);  'always show spike channels
'    chanshow(configRewardChannel%,31);   'always show reward and keyboard
'    if RespDevice% = 0 then  'if physical device is lever
'        chanshow(configLeverChannel%);  'if it's a "lever" scenario, show lever channel 
'    else  'if physical device is joystick
'        chanshow(configJoyXChannel%,configJoyYChannel%);  'if it's a "joystick" scenario, show X and Y joystick channels
'    endif;
'    if CollectEEG% = 1 then 'If it's a recording EEG, show it
'        chanshow(configLFPChannel%,configLFPChannel2%,configLFPChannel2%);
'    endif;
'    chanhide(configWaveformChannel%,configWaveformChannel2%,configWaveformChannel3%);  'hide the waveform channels
'    Drawmode(configWaveMarkChannel%,2);   'sets drawing mode of WaveMark 1 (spikes) to Lines
'    Drawmode(configWaveMarkChannel2%,2);   'sets drawing mode of WaveMark 2 (spikes) to Lines
'    Drawmode(configWaveMarkChannel3%,2);   'sets drawing mode of WaveMark 3 (spikes) to Lines
    
	'Start sampling
    samplemode(1);   'sets continuous recording
    SampleStart();   'start sampling
    
    View(ctview%).XRange(-1,8);  'I think this will set the x-axis to scroll, with an 8-second width 
    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS    
    
	'Set Lights and solenoid, in case
    'SafeSampleKeySutter%("B");  'turn on LED and incandescent simultaneously
    SafeSampleKeySutter%("K");	'close solenoid if it's open!!
    if ContReinfDelay >= 0 then
        'SafeSampleKeySutter%("I");  'turn on incandescent if we're doing continuous reinforcement
    endif;
    
    'If we are asking the eyetracker to record an output file, open the file and start recording
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKeySutter%("I");  'Open the file (this is done by setting a DIGLOW bit), file name will be saved in a sampletext
        yield(0.5);
        SafeSampleKeySutter%("W");  'Begin recording the file
        yield(0.5);
        RecordEyeTrackerOutputFile% := 2;  'This allows us to easily run the timing pulses once
    endif
    
    
	'Open spike shape waveform window if physiological experiment
    if tunNWavemarks% > 0 then
        ssopen(1,1);  'opens a visible spike shape waveform window
        SSButton(12, 0);  'sets size of displayed templates to small
        window(0,60,50,100);  'resize new wavemark template window
    endif;
    
	'Bring data window back to front
    FrontView(ctview%);
    
	'create histogram windows if physiological experiment
    if tunNWavemarks% > 0 then
        HistTotal := HistPre + HistPost + StimLength[max(StimLength)];  'Maximum of StimLength should be the length of the longest stimulus
        HistBins% := HistTotal/HistBinWidth;
        ToolbarSet(10, "ClrRaster", ClearRasters%);  'create clear rasters button
        ToolbarEnable(10,1);  'enable clear rasters button
        
        if Interleaved% = 1 or Passive% = 0 or PassiveAndActive% = 1 then
            hApsthS%:=SetPsth(WavemarkPorts%[0],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerA%,3);
            WindowVisible(1);windowtitle$("Single");  'name gets changed later
            Window(75,30,100,65);
            FrontView(ctview%);
            if OverallPSTHType% = 0 then
                hApsthA%:=SetPsth(WavemarkPorts%[0],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerA%,3);
            else
                hApsthA%:=SetPsth(WavemarkPorts%[0],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerAGroup%,3);
            endif;
            WindowVisible(1);windowtitle$("Overall-Active");
            Window(75,65,100,100);
        endif;
        if Interleaved% = 1 or Passive% = 1 or PassiveAndActive% = 1 then
            hPpsthS%:=SetPsth(WavemarkPorts%[0],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerP%,3);
            WindowVisible(1);windowtitle$("Single");  'name gets changed later
            Window(75,30,100,65);
            FrontView(ctview%);
            if OverallPSTHType% = 0 then
                hPpsthA%:=SetPsth(WavemarkPorts%[0],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerP%,3);
            else
                hPpsthA%:=SetPsth(WavemarkPorts%[0],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerPGroup%,3);
            endif;
            WindowVisible(1);windowtitle$("Overall-Passive");
            Window(75,65,100,100);	
        endif;
        
        'for multiple electrodes, the windows will overlap
        if tunNWavemarks% > 1 then
            if Interleaved% = 1 or Passive% = 0 or PassiveAndActive% = 1 then
                hApsthS2%:=SetPsth(WavemarkPorts%[1],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerA%,3);
                WindowVisible(1);windowtitle$("Single");  'name gets changed later
                Window(75,30,100,65);
                FrontView(ctview%);
                if OverallPSTHType% = 0 then
                    hApsthA2%:=SetPsth(WavemarkPorts%[1],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerA%,3);
                else
                    hApsthA2%:=SetPsth(WavemarkPorts%[1],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerAGroup%,3);
                endif;
                WindowVisible(1);windowtitle$("Overall2-Active");
                Window(75,65,100,100);
            endif;
            if Interleaved% = 1 or Passive% = 1 or PassiveAndActive% = 1 then
                hPpsthS2%:=SetPsth(WavemarkPorts%[1],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerP%,3);
                WindowVisible(1);windowtitle$("Single");  'name gets changed later
                Window(75,30,100,65);
                FrontView(ctview%);
                if OverallPSTHType% = 0 then
                    hPpsthA2%:=SetPsth(WavemarkPorts%[1],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerP%,3);
                else
                    hPpsthA2%:=SetPsth(WavemarkPorts%[1],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerPGroup%,3);
                endif;
                WindowVisible(1);windowtitle$("Overall2-Passive");
                Window(75,65,100,100);	
            endif;
        endif
        
        if tunNWavemarks% > 2 then
            if Interleaved% = 1 or Passive% = 0 or PassiveAndActive% = 1 then
                hApsthS3%:=SetPsth(WavemarkPorts%[2],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerA%,3);
                WindowVisible(1);windowtitle$("Single");  'name gets changed later
                Window(75,30,100,65);
                FrontView(ctview%);
                if OverallPSTHType% = 0 then
                    hApsthA3%:=SetPsth(WavemarkPorts%[2],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerA%,3);
                else
                    hApsthA3%:=SetPsth(WavemarkPorts%[2],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerAGroup%,3);
                endif;
                WindowVisible(1);windowtitle$("Overall3-Active");
                Window(75,65,100,100);
            endif;
            if Interleaved% = 1 or Passive% = 1 or PassiveAndActive% = 1 then
                hPpsthS3%:=SetPsth(WavemarkPorts%[2],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerP%,3);
                WindowVisible(1);windowtitle$("Single");  'name gets changed later
                Window(75,30,100,65);
                FrontView(ctview%);
                if OverallPSTHType% = 0 then
                    hPpsthA3%:=SetPsth(WavemarkPorts%[2],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerP%,3);
                else
                    hPpsthA3%:=SetPsth(WavemarkPorts%[2],HistBins%,HistBinWidth,HistPre,MemChanHistTriggerPGroup%,3);
                endif;
                WindowVisible(1);windowtitle$("Overall3-Passive");
                Window(75,65,100,100);	
            endif;
        endif
        
        if CollectEEG% = 1 then
            'powspec%:=SetPower(22,2048,1);  'set up a result view for an EEG power spectrum
            'WindowVisible(1);windowtitle$("EEG Power Spectrum");Window(40,60,75,100);
            'ProcessTriggered(60,0,MemChanHistTrigger%,1,1);  'Update power spectrum anytime there's a stimulus
        else
            if Interleaved% = 1 or PassiveAndActive% = 1 then  'move Passive histograms into a nicer position so we can see all four
                if tunNWavemarks% > 0 then
                    FrontView(hPpsthS%);
                    Window(50,30,75,65);
                    Frontview(hPpsthA%);
                    Window(50,65,75,100);
                    FrontView(ctview%);
                endif;
                
                'for multiple electrodes, these will overlap, just as in original
                if tunNWavemarks% > 1 then
                    FrontView(hPpsthS2%);
                    Window(50,30,75,65);
                    Frontview(hPpsthA2%);
                    Window(50,65,75,100);
                    FrontView(ctview%);
                endif;
                
                if tunNWavemarks% > 2 then
                    FrontView(hPpsthS3%);
                    Window(50,30,75,65);
                    Frontview(hPpsthA3%);
                    Window(50,65,75,100);
                    FrontView(ctview%);
                endif;
                
            endif;
        endif;
    endif;
    
    ToolbarEnable(2,1);  'enable LoadNewParam button
    ToolbarEnable(3,0);  'disable Start button
    ToolbarEnable(6,0);  'disable Clean Solenoid button
    ToolbarEnable(4,1);  'enable Stop button
    ToolbarEnable(5,1);  'enable Pause button
    ToolbarEnable(7,0);  'disable joystick calibration
    ToolbarEnable(8,0);  'disable fixation params
    
    
    'Set iState for state loop
    docase
    case ContReinfDelay >= 0 then
        iState% := StateStartContinuousReinforcement%;
    else
        iState% := StateLoadStimulus%;
        StimulusPlaying% := 0;  'forces StateLoadStimulus
    endcase
    
    
    return 1;            'return to toolbar
    
end;



'============================ Prepare to Pause Sampling ==============================
func PrepPause%()
	iPause% := 1; 
	ToolbarEnable(5,0);  'Disable Pause Button to indicate it has been pressed
	return 1;
end;



'============================ Prepare to Load New Stimuli ==============================
func PrepNewParam%()
	ParamPause% := 1; 
    ToolbarEnable(2,0);  'Disable LoadNewParam Button to indicate it has been pressed
    PassiveToActive% := 1;  'indicate that we just switched from passive to active
	return 1;
end;



'================================ Stop Sampling ======================================
func StopSampling%()
    
    CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights
	SafeSampleKeySutter%("K");  'Close solenoid if it's open!!!
    
	SampleStop();
    Quit%();
    
	return 1;
    
end;


'======================= Clean Solenoid or Do Magazine Training ======================
'This function also takes over the functionality for magazine training because the 
'two functions are highly similar.
func CleanSolenoid%()
    
    var cleanormag%;	'clean solenoid or do magazine training?
    var solopendur;  	'seconds open duration of solenoid
    var solclosedur; 	'seconds close duration of solenoid
    var solrandmax; 	'seconds of additional random close time
    var solopendur%;  	'ms, integer, for sampleseqvar
    var randvalue;      'ms, changes on each trial
    var numrepeats%;	'number of solenoid pulses
    var numrepeats;     'need a non-integer version for calculation
    var loopvar% := 0; 	'number of loops
    var userpick% := 2;	'holds what the user picked from dialog box
    var buttontext$;    'holds button text
    var totaldur;       'holds total duration of solenoid/magazine session
    var dummyview%;     'just a dummy view
    var now;
    
    'Please note that there are very stupid issues in writing this function because ANY operation on
    'an integer data type comes out as an integer, even if it is being assigned into a float variable.  Grr.
    
    DlgCreate("Choose One",0,0,0,1.5);  'for some reason the default height is too short, use 1.5
    DlgButton(0,"Clean Solenoid");
    DlgButton(1,"Magazine Training");
    cleanormag% := DlgShow();
    
    'get values of solenoid open duration, etc., depending on type of action (clean, magazine) requested
    if cleanormag% = 0 then 'if we specified clean solenoid
        solopendur := 2;  'specify in seconds for now
        solclosedur := 1; 'specify in seconds for now
        solrandmax := 0;
        numrepeats% := 30;
        while userpick% > 1 do
            DlgCreate("Solenoid Cleaning: Select durations in seconds");
            DlgReal(1,"Solenoid Open Duration in Seconds",0.1,200);  'selected 0.1 as minimum, 200 as the maximum value
            DlgReal(2,"Solenoid Close Duration in Seconds",0.1,200);
            DlgInteger(3,"Number of Repeats",1,1000);
            numrepeats := numrepeats%;  'just put the integer into the float for calcs
            totaldur := numrepeats*(solopendur+solclosedur)/60;  'calculation in minutes
            buttontext$ := "Start: "+str$(totaldur)+" minutes";
            DlgButton(1,buttontext$);
            DlgButton(2,"Recalculate");
            userpick% := DlgShow(solopendur,solclosedur,numrepeats%);  'do not allow change of rand max (0)
        wend;
    else
        solopendur := 0.2;  'in seconds
        solclosedur := 5;  
        solrandmax := 10;
        numrepeats% := 200;
        while userpick% > 1 do
            DlgCreate("Magazine Training: Select durations in seconds");
            DlgReal(1,"Solenoid Open Duration in Seconds",0.01,2);  'selected 0.01 as minimum, 2 as the maximum value
            DlgReal(2,"Minimum Pause in Seconds",2,200);
            DlgReal(3,"Additional Random Value from 0 Seconds to:",0,100);
            DlgInteger(4,"Number of Repeats",1,10000);
            numrepeats := numrepeats%;  'just put the integer into the float for calcs
            totaldur := numrepeats*(solopendur+solclosedur+solrandmax)/60;  'calculation in minutes
            buttontext$ := "Start: "+str$(totaldur)+" minutes";
            DlgButton(1,buttontext$);
            DlgButton(2,"Recalculate");
            userpick% := DlgShow(solopendur,solclosedur,solrandmax,numrepeats%);
        wend; 
    endif;
    
    'get out if userpick% is 0 (user cancelled)
    if userpick% = 0 then
        return 1;
    endif;
    
    'change values to ms
    solopendur := solopendur*1000;
    solclosedur := solclosedur*1000;
    solrandmax := solrandmax*1000;
    'put these values into integer data types for sampleseqvar
    solopendur% := solopendur;
    
    
    FileOpen(ConfigFileNameBehav$,6);
    samplesequencer(SeqFileName$);  'Open the correct Sequencer file	
    ctview%:=FileNew(0,1);  'Create new data window, name it and resize it
    if ctview% < 0 then 'there was a failure to open the file, may as well bail out now!
        Message("The CED did not successfully open a data window!  Quitting!\nCheck the logfile for details, but typically\nturning off or power cycling the CED will fix this!");
        printlog("!\n!\n!\nThe CED did not successfully open a data window!\n");
        printlog("The error code says: %s\n!\n!\n!\n",Error$(ctview%));
        Halt; 
        return 1;  'in principle this does not execute after the Halt() which is OK by me
    endif;
    
    SampleStart();   'start sampling
    
    ToolbarEnable(4,1);  'enable Stop button
    
    while loopvar% < numrepeats% and SampleStatus() = 2 do
        loopvar% := loopvar% + 1;
        randvalue := rand(0.0)*solrandmax; 
        sampleseqvar(1,solopendur%-1);
        NumRewards% := NumRewards% + 1;  'increment number of times the solenoid is opened
        SafeSampleKeySutter%("R");  'Open solenoid
        
        now := maxtime();
        if cleanormag% = 1 then 'display number of water hits given for magazine training
            printlog("The number of water rewards given is %d\n",NumRewards%);
            view(HiddenLogHandle%).print("The number of water rewards given is %d\r",NumRewards%);
        endif;
        while maxtime() < now + ((solopendur+solclosedur+randvalue)/1000) and SampleStatus() = 2 do
            yield(.001);
        wend;
        
    wend;
    
    if SampleStatus() = 2 then
        SampleStop();  'Stop sampling
    endif;
    
    'Reset number of rewards if cleaning solenoid - sometimes solenoid clean is done *before* experiment
    if cleanormag% = 0 then
        NumRewards% := 0;
    endif;
    
    
    'Kill solenoid, because it will stay open if sampling is stopped while it's open
    dummyview%:=FileNew(0,1);  'Create new dummy data window, cannot restart sampling on old data window
    SampleStart();  'start sampling on dummy window
    SafeSampleKeySutter%("K");  'kill solenoid
    yield(0.1);  'give it time to actually stop, may not be necessary, but what's 1/10 of a second?
    SampleStop();  'stop sampling on dummy window
    view(dummyview%);  'bring dummy window to the front
    FileClose(0,-1);  'Close dummy window without saving
    
    view(ctview%);  'bring data window to front to close it
    FileClose(0,-1);  'Close data window without saving 
    
    Quit%(); 'Added at 1.4, user will have to reopen in order to perform another solenoid cleaning
    
    return 1;
end;



'============================= Toggle Verbose Mode ===============================
func ToggleVerbose%()
    printlog("Registered toggle!!!\n");
	if VerboseMainLoop% = 0 then
        VerboseMainLoop% := 1;
        ToolbarSet(9, "Verbose is on", ToggleVerbose%);
    else
        VerboseMainLoop% := 0;
        ToolbarSet(9, "Verbose is off", ToggleVerbose%);
    endif
	return 1;
end;

'================================ Main Idle Time Function ============================
func Main%()
    
    var Now;  'is used at top of main loop; is re-calculated before reward delivery
    var GBRew% := 0;  'indicates we're giving a God Button reward
    var XJoy;
    var YJoy;
    
    'Set up overarching structure of the new main loop's state logic.
    'The entire set of state logic is wrapped with a run-once-by-default
    'WHILE statement.  The state logic stepping is held in a DOCASE
    'statement, which will run once per WHILE iteration.  Individual states
    'in the DOCASE may ask the main loop to repeat immediately before 
    'handing control back to the OS.  These will typically be used when
    'there is a time-dependent relationship between two states, or when 
    'the exited state didn't do much (e.g. if a state simply checks to see
    'if the stimulus is done playing, when the stimulus is done it would
    'make sense to run the next state immediately rather than wait for the
    'OS to run the main loop again, as this will at times take as much as
    '50 ms.
    
    'Only run the main loop if we are actually sampling
    if samplestatus() = 2 then
        RepeatMainLoop% := 1;  'Run the main loop (at least) once
    else
        RepeatMainLoop% := 0;  'We are not sampling, do not run the main loop
    endif;
    
    while RepeatMainLoop% = 1 do
        RepeatMainLoop% := 0;  'By default, do not run the main loop twice.  We will have to explicitly ask to run it again.
        
        Now := view(ctview%).maxtime();  'Get current time, every time
        
        'Send eyetracker file pulses once
        if Now > 0.001 and RecordEyeTrackerOutputFile% = 2 then
            'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
            SafeSampleKeySutter%("1");
            yield(0.2);
            SafeSampleKeySutter%("1");
            yield(0.2);
            SafeSampleKeySutter%("1");
            yield(0.2);
            SafeSampleKeySutter%("1");
            yield(0.2);
            RecordEyeTrackerOutputFile% := 1;  'Don't send eyetracker file pulses again
        endif;
        
        'Update the joystick plot every 5 ms
        if RespDevice% <> 0 and Now-tLastJoyUpdate > .005 then
            XJoy := View(ctview%).ChanMeasure(configJoyXChannel%,2,Now-.001,Now-.006);
            YJoy := View(ctview%).ChanMeasure(configJoyYChannel%,2,Now-.001,Now-.006);
            View(joyview%).XYAddData(joydatachan%,-XJoy,-YJoy);  'both axes need to be "flipped" with negative values to display properly
            tLastJoyUpdate := Now;
        endif;
        
        'Main loop verbosity, useful for testing only
        if VerboseUberVerbose% = 1 then
            'This part is so verbose we only print to the hidden log even when debugging
            if .001 > Now-LastMainTime then
                view(HiddenLogHandle%).print("Main loop executed again within one millisecond\r");
            else            
                view(HiddenLogHandle%).print("The main loop last executed %f seconds ago\r",Now-LastMainTime);
                LastMainTime := Now;
            endif;
        endif;
        
        'Get lever/joystick/God button status if it is an active scenario
        if Passive% = 0 then
            if VerboseUberVerbose% = 1 then
                view(HiddenLogHandle%).print("Checking lever/joystick at %f\r",view(ctview%).maxtime());                
            endif;
            if RespDevice% = 0 then  'if physical device is lever
                DebounceLever%();
            else  'if physical device is joystick
                ReadJoystick%();
				'God Button will only exist if joystick is physical response device
                if GodButtonExists% = 1 then  'use lever channel as shaping input
                    DebounceLever%();
                    GodButton% := LeverPos%;
                    GodButtonTime := LeverTime;
					'if the button had been in a non-pressed state, and the state has changed (whether it's now pressed or not)
					'set reward
                    if GodButtonPrev% = 0 and GodButtonTime > GodButtonTimePrev then
                        RewardCount% := 1;  'Give one reward
                        GBRew% := 1; 'indicate God Button reward
                        RewardTime := GodButtonTime;  'and do it immediately
                        'SolenoidOpenDur% := PayHVal;  'and set it for delivery as specified by Hit value
                        SolenoidOpenDur% := JuiceRewardMS%;
                    endif;
                    GodButtonPrev% := GodButton%;              'Record current state/time of last press of God Button
                    GodButtonTimePrev := GodButtonTime;
                endif;
            endif;        
        endif;
        
        'Update eye position if in a fixation scenario
        'if DoFixation% > 0 then
            xEye := View(ctview%).ChanMeasure(configEyeXChannel%,2,Now-.006,Now-.001)*DegreesPerVoltX;
            yEye := View(ctview%).ChanMeasure(configEyeYChannel%,2,Now-.006,Now-.001)*DegreesPerVoltY;
            ' Don't update display every time. 
            if Now-tLastEyeUpdate > .005 then
                View(EyeXYWindow%).XYAddData(iEyePosChannel%, xEye, yEye);
                tLastEyeUpdate := Now;
            endif
        'endif
        
        
        
        '===================== Begin State Logic Loop ======================
        '
        '
        '===================== Begin State Logic Loop ======================
        
        'And, finally, the main DOCASE that actually does the STATE LOGIC!!!
        docase
        case iStatePause% = StatePauseContinuousReinforcement% then
            'The pause button has been pressed.  Circumvent the state logic loop without changing
            'iState%.  Jump back into state logic loop wherever we left off once Resume is pressed.
            if 1 then 'code folding
            if VerboseMainLoop% = 1 then  'on pauses, will only enter once so don't worry about repeating verbose entry
                view(HiddenLogHandle%).print("Entered StatePauseContinuousReinforcement% at %f\r",Now);
            endif;
            CueLights("off",CurrentCueLights$,"off");  'Turn off house light, cue lights should be off but it doesn't hurt to force them
            Interact("You may use the Analysis Menu, press Resume when finished", 64,0,"Resume");
            'Once "Resume" is pressed jump back into Continuous Reinforcement (will be either in
            'StateStartContinuousReinforcement% or StateWaitContinuousReinforcementInit%)
            iPause% := 0;  'reset iPause
            iStatePause% := 0; 'reset iStatePause
            ToolbarEnable(5,1);  'Re-enable pause button on toolbar
            'Turn on incandescent to indicate experiment is again running
            CueLights("on",CurrentCueLights$,"same");  'Turn on house light, leave cue lights (cue lights should already be off)
            endif;
            
        case iStatePause% = StatePause% then
            'The pause button has been pressed.  Circumvent the state logic loop without changing
            'iState%.  Jump back into state logic loop wherever we left off once Resume is pressed.
            if 1 then 'code folding
            if VerboseMainLoop% = 1 then
                view(HiddenLogHandle%).print("Entered StatePause% at %f\r",Now);
            endif;
            CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights
            Interact("You may use the Analysis Menu, press Resume when finished", 64,0,"Resume");
            'Once "Resume" is pressed jump back into Continuous Reinforcement (will be either in
            'StateStartContinuousReinforcement% or StateWaitContinuousReinforcementInit%)
            iPause% := 0;  'reset iPause
            iStatePause% := 0; 'reset iStatePause
            ToolbarEnable(5,1);  'Re-enable pause button on toolbar
            NextTrialTime := maxtime() + ITI;  'Reset NextTrialTime because otherwise we get stuck, wait one ITI to go
            'Turn on incandescent to indicate experiment is again running
            CueLights("on",CurrentCueLights$,"same");  'Turn on house light, leave cue lights (cue lights should already be off)
            endif;    
            
            
        case iStatePause% = StateParamPause% then
            'The LoadNewParam button has been pressed.  Circumvent the state logic loop without changing
            'iState%.  Jump back into state logic loop wherever we left off once Resume is pressed.
            if 1 then 'code folding
            if VerboseMainLoop% = 1 then
                view(HiddenLogHandle%).print("Entered StateParamPause% at %f\r",Now);
            endif;
            CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights
            'If we are trial wrapping, save the current trial indices
            if TrialWrap% = 1 then
                SaveTrialIndices(MonkeyLetter$);
            endif;
            NewParamLoad% := LoadParam%();  'just run LoadParam, same function will work for both original and new loadings
            if NewParamLoad% > 0 then  'on success, otherwise we'll try loading again
                paramPause% := 0;  'reset iPause
                iStatePause% := 0; 'reset iStatePause
                ToolbarEnable(2,1);  'Re-enable LoadNewParam button 
                NextTrialTime := maxtime() + ITI;  'Reset NextTrialTime because otherwise we get stuck, wait one ITI to go
                'Turn on incandescent to indicate experiment is again running
                CueLights("on",CurrentCueLights$,"same");  'Turn on house light, leave cue lights (cue lights should already be off)
            endif;
            endif;  
            

        case iState% = StateStartContinuousReinforcement% then
            'Make sure that it's time to start a CR trial and the response device is in the origin
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateStartContinuousReinforcement at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this    
            endif;
            
            if InOrigin% = 1 and NextReinfTime < Now then
                ChangeStateTo(StateWaitContinuousReinforcementInit%, Now, 1);
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("Beginning Continuous Reinforcement trial!\r");
                endif;
            endif;
            'Allow pause here
            if iPause% = 1 then
                iStatePause% := StatePauseContinuousReinforcement%;
            endif;
            endif;


        case iState% = StateWaitContinuousReinforcementInit% then
            'Wait for movement of joystick, check for initiation in correct direction or "interrupt" in wrong direction
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateWaitContinuousReinforcementInit at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            Interrupt% := 0;  'Assert no interrupt yet
			'Check for on-axis initiation, while checking for off-axis interrupt
            if CRinit%(ContReinfInit$) = -1 then 'if there's an interrupt before the initiation movement
                Interrupt% := 1;
                NumCRInterrupt% := NumCRInterrupt% + 1;  'count interrupts, both off-axis and on-axis in wrong direction
                if CRintoffaxis%(ContReinfInit$) = 1 then 'if the interrupt is off-axis
                    if CRaxis$ = "y" then
                        ChangeThresh(0,0,1,1);  'make off-axis (y) harder to cross, do not change on-axis (x)
                    else
                        ChangeThresh(1,1,0,0);  'make off-axis (x) harder to cross, do not change on-axis (y)
                    endif;
                    printlog("Found off-axis movement before correct movement!\n");
                    view(HiddenLogHandle%).print("Found off-axis movement before correct movement!\r");
                else 'if the interrupt is on-axis (wrong direction)
                    docase
                        case ContReinfInit$ = "right" then
                        ChangeThresh(0,0,0,-1);  'make correct direction easier to cross
                        case ContReinfInit$ = "left" then
                        ChangeThresh(0,0,-1,0);
                        case ContReinfInit$ = "up" then
                        ChangeThresh(-1,0,0,0);
                        case ContReinfInit$ = "down" then
                        ChangeThresh(0,-1,0,0);
                    endcase;
                    printlog("Found on-axis movement in the wrong direction!\n");
                    view(HiddenLogHandle%).print("Found on-axis movement in the wrong direction!\r");
                endif;
                'On an interrupt, turn off the house light and go to timeoout
                CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off) 
                ChangeStateTo(StateContinuousReinforcementTO%, Now, 0);  'go to timeout 
                'if there is an interrupt, do not allow pause                
            else
                if CRinit%(ContReinfInit$) = 1 then 'if the joystick is in the correct position
                    ChangeStateTo(StateContinuousReinforcementDelay%, Now, 0);  'advance to next stage!
                    docase
                        case ContReinfInit$ = "right" then
                        BeginReinfTime := XTime;
                        case ContReinfInit$ = "left" then
                        BeginReinfTime := XTime;
                        case ContReinfInit$ = "x" then
                        BeginReinfTime := XTime;
                        case ContReinfInit$ = "up" then
                        BeginReinfTime := YTime;
                        case ContReinfInit$ = "down" then
                        BeginReinfTime := YTime;
                        case ContReinfInit$ = "y" then
                        BeginReinfTime := YTime;
                    endcase;
                    'Because there might be a second motion, we need to increment the threshold
                    'for the first motion if it's correct (unless there is no second motion or
                    'the second motion is to return)  Changed for 1.2.2 10-26-09; fixed 3-31-11
                    if ContReinfEnd$ <> "same" and ContReinfEnd$ <> "return" then
                        docase
                            case ContReinfInit$ = "right" then
                            ChangeThresh(0,0,0,1);  'make correct direction harder to cross
                            case ContReinfInit$ = "left" then
                            ChangeThresh(0,0,1,0);
                            case ContReinfInit$ = "x" then
                            ChangeThresh(0,0,1,1);  'make both x directions harder to cross
                            case ContReinfInit$ = "up" then
                            ChangeThresh(1,0,0,0);
                            case ContReinfInit$ = "down" then
                            ChangeThresh(0,1,0,0);
                            case ContReinfInit$ = "y" then
                            ChangeThresh(1,1,0,0);
                        endcase;
                    endif;
                    'if the CR trial has begun, do not allow pause
                else
                    'Allow pause here
                    if iPause% = 1 then
                        iStatePause% := StatePauseContinuousReinforcement%;
                    endif;
                endif;            
            endif;
            endif;
            

        case iState% = StateContinuousReinforcementDelay% then 
            'Wait through CR delay before reward; check for interrupt during this delay
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateContinuousReinforcementDelay at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            'While delay is not over, check for delay interrupt
            if Now < BeginReinfTime + ContReinfDelay then
                Interrupt% := 0;  'Assert no interrupt yet
                if CRend%(ContReinfInit$,ContReinfEnd$,1) <> 0  then 'this is an interrupt, either correct movement too fast, or incorrect at all
                    Interrupt% := 1;
                    if VerboseJoyLev% = 1 then  
                        view(HiddenLogHandle%).print("xpos = %d, ypos = %d\r",XPos%,YPos%);
                    endif;
                    if CRend%(ContReinfInit$,ContReinfEnd$,0) = 1 then  'Make required delay shorter if correct movement is too early
                        ContReinfDelay := ContReinfDelay - ContReinfDelayDec;
                        if ContReinfDelay < ContReinfDelayMin then
                            ContReinfDelay := ContReinfDelayMin;  'Don't let it get too low
                        endif;	
                        NumDelayInterrupt% := NumDelayInterrupt% + 1;  'count delay interrupts
                        printlog("Found early-response interrupt during delay!\n");
                        view(HiddenLogHandle%).print("Found early-response interrupt during delay!\r");
                    else  'if movement was in wrong direction
                        'NOTE THAT THIS IS AD-HOC and only applies to x-axis CR AND MUST BE FIXED
                        if YPos% <> 0 then
                            NumCRInterrupt% := NumCRInterrupt% + 1;  'count position interrupts
                            printlog("Found wrong-axis interrupt during delay!\n");
                            view(HiddenLogHandle%).print("Found wrong-axis interrupt during delay!\r");
                        else
                            NumDelayInterrupt% := NumDelayInterrupt% + 1;  'count delay interrupts
                            printlog("Found early-response interrupt during delay!\n");
                            view(HiddenLogHandle%).print("Found early-response interrupt during delay!\r");
                        endif;
                    endif;
                    'On an interrupt, turn off the house light and go to timeoout
                    CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off) 
                    ChangeStateTo(StateContinuousReinforcementTO%, Now, 0);  'go to timeout 
                endif;
            else
                'Delay over, go to state awaiting response
                ChangeStateTo(StateContinuousReinforcementWaitResponse%, Now, 0);
            endif;
            'Do not allow pause during CR delay
            endif;
            
            
        case iState% = StateContinuousReinforcementWaitResponse% then
            'When CR delay period is over, check for return to X center
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateContinuousReinforcementWaitResponse at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if CRend%(ContReinfInit$,ContReinfEnd$,0) = -1 then 'yet another possiblity for off-axis interrupt
                Interrupt% := 1;
                'AGAIN AD-HOC, MUST BE FIXED, NOTE THAT THRESHOLD CHANGES ARE NOT SPECIFIC AS OF NOW...
                if YPos% <> 0 then
                    NumCRInterrupt% := NumCRInterrupt% + 1;  'count interrupts
                    printlog("Found wrong-axis movement after delay!\n");
                    view(HiddenLogHandle%).print("Found wrong-axis movement after delay!\r");
                else
                    NumDelayInterrupt% := NumDelayInterrupt% + 1;  'count delay interrupts
                    printlog("Found early-response interrupt during delay!\n");
                    view(HiddenLogHandle%).print("Found early-response interrupt during delay!\r");
                endif;
                docase
                case ContReinfEnd$ = "up" then  'on interrupt, make crossing threshold for correct motion (or axis) easier, make crossing on wrong axis harder
                    ChangeThresh(-1,0,1,1);
                case ContReinfEnd$ = "down" then
                    ChangeThresh(0,-1,1,1); 
                case ContReinfEnd$ = "left" then
                    ChangeThresh(1,1,-1,0); 
                case ContReinfEnd$ = "right" then
                    ChangeThresh(1,1,0,-1);
                case ContReinfEnd$ = "same" and ContReinfInit$ = "x" then
                    ChangeThresh(1,1,-1,-1);
                case ContReinfEnd$ = "same" and ContReinfInit$ = "y" then
                    ChangeThresh(-1,-1,1,1);
                case ContReinfEnd$ = "return" and ContReinfInit$ = "x" then
                    ChangeThresh(1,1,-1,-1);
                case ContReinfEnd$ = "return" and ContReinfInit$ = "y" then
                    ChangeThresh(-1,-1,1,1);
                endcase;
                'On an interrupt, turn off the house light and go to timeoout
                CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off) 
                ChangeStateTo(StateContinuousReinforcementTO%, Now, 0);  'go to timeout 
            else   'Wait for joystick return to final location 
                if CRend%(ContReinfInit$,ContReinfEnd$,0) = 1 then 'Joystick has gone to final location 
                    'give reward, update thresh and delay
                    RewardCount% := 1; 'Set it to give a reward, only one reward hit for Cont. Reinf.
                    ChangeStateTo(StateReward%, Now, 1);
                    docase
                    case ContReinfEnd$ = "up" then
                        RewardTime := YTime;  'Set it to give the reward now
                        ChangeThresh(1,0,0,0);  'increase up thresh 
                    case ContReinfEnd$ = "down" then
                        RewardTime := YTime;  'Set it to give the reward now
                        ChangeThresh(0,1,0,0); 
                    case ContReinfEnd$ = "left" then
                        RewardTime := XTime;  'Set it to give the reward now
                        ChangeThresh(0,0,1,0); 
                    case ContReinfEnd$ = "right" then
                        RewardTime := XTime;  'Set it to give the reward now
                        ChangeThresh(0,0,0,1); 
                    case ContReinfEnd$ = "same" and ContReinfInit$ = "x" then
                        RewardTime := XTime;
                        ChangeThresh(0,0,1,1);  'just increase thresh for both directions on the x-axis
                    case ContReinfEnd$ = "same" and ContReinfInit$ = "y" then
                        RewardTime := YTime;
                        ChangeThresh(1,1,0,0); 
                    case ContReinfEnd$ = "return" and ContReinfInit$ = "x" then
                        RewardTime := XTime;
                        ChangeThresh(0,0,1,1);  'just increase thresh for both directions on the x-axis
                    case ContReinfEnd$ = "return" and ContReinfInit$ = "y" then
                        RewardTime := YTime;
                        ChangeThresh(1,1,0,0);        
                    endcase;
                    NextReinfTime := RewardTime + ITI + PayHVal/1000;  'Calculate time next trial should start
                    'SolenoidOpenDur% := PayHVal;  'and set it for delivery as specified by Hit value
                    SolenoidOpenDur% := JuiceRewardMS%;
                    ContReinfDelay := ContReinfDelay + ContReinfDelayInc;  'Extend delay on correct trial
                    UpdateITI();
                    if ContReinfDelay > ContReinfDelayMax then
                        ContReinfDelay := ContReinfDelayMax;
                    endif;
                    if VerboseIncrements% = 1 then
                        printlog("New Delay = %f seconds\n",ContReinfDelay);
                        view(HiddenLogHandle%).print("New Delay = %f seconds\r",ContReinfDelay);
                    endif;
                    if VerboseAccuracy% = 1 then
                        printlog("Number of wrong-axis Interrupts is %d and number of Delay Interrupts is %d\n",NumCRInterrupt%,NumDelayInterrupt%);
                        view(HiddenLogHandle%).print("Number of wrong-axis Interrupts is %d and number of Delay Interrupts is %d\r",NumCRInterrupt%,NumDelayInterrupt%);
                    endif;
                endif;
            endif;	
            'Do not allow pause while awaiting continuous reinforcement results
            endif;
            
            
            
        case iState% = StateContinuousReinforcementTO% then 
            'If in CR timeout, wait for timeout to be over, turn house light back on
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateContinuousReinforcementTO at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if tStateStart + ContReinfTO > Now then
                ChangeStateTo(StateStartContinuousReinforcement%, Now, 0);
                'Allow pause here
                if iPause% = 1 then
                    'Putting the pause here prevents us from "flashing" the house light before pausing in
                    'StateStartContinuousReinforcement on the next run of the main loop.
                    iStatePause% := StatePauseContinuousReinforcement%;
                else
                    'turn house light back on and resume continuous reinforcement
                    CueLights("on",CurrentCueLights$,"same");  'Turn on house light, leave cue lights (cue lights should already be off)
                endif;
            endif;
            endif;
            
        case iState% = StateLoadStimulus% then
            if 1 then 'code folding
            if VerboseMainLoop% = 1 then 'always changes state, don't worry about AllowMainLoopVerbose
                view(HiddenLogHandle%).print("Entered StateLoadStimulus% at %f\r",Now);
            endif;
            PrevEOS := EndOfStandards;  'Maintain previous EndOfStandards for MemChanHistTrigger%
            PrevEOS2 := EndOfStandards2;
            
            'check to see if we need to switch trials files
            if SwitchToTF% > 0 then 
                SwitchFutureFile% := SwitchToTF%;  'switch TF
                FutureTrialIndex% := (MaxTFLen%*(SwitchFutureFile%-1)) + CurrTrialIndexList%[SwitchFutureFile%-1];  'get new current trial index
            else
                SwitchFutureFile% := SwitchCurrFile%;
            endif;
            
            'If we're wrapping we need to reset later, but load the appropriate stim
            docase
            case FutureTrialIndexList%[SwitchFutureFile%-1] >= TotalTrialsSutter%[SwitchFutureFile%-1] and TrialWrap% = 1 then
                FutureTrialIndex% := MaxTFLen%*(SwitchFutureFile%-1);  'set to virtual zero
                FutureTrialIndexList%[SwitchFutureFile%-1] := 0;  'and reset current index - maybe not?  Worried about decrementing on interrupt?
                    'I think the answer may be that you don't decrement!  There may be no need
            case FutureTrialIndexList%[SwitchFutureFile%-1] >= TotalTrialsSutter%[SwitchFutureFile%-1] and TrialWrap% = 0 then
                NothingToLoad% := 1;
            else
                'actually, I think the FutureTrialIndex% we already calculated is right, if no need to wrap
                'FutureTrialIndex% := CurrTrialIndex%;
            endcase;  
            
            'Now that SwitchToTF% is done being used, check to see if the trial was an interrupt when
            'we ought to have been switching
            if SwitchToTFInterrupt% > 0 then 
                SwitchToTF% := SwitchToTFInterrupt%;  'restore switch-to TF for next trial
                SwitchToTFInterrupt% := 0;
            endif;
            
            if NothingToLoad% = 0 then
            'load next stimulus
                LoadStim%(FutureTrialIndex%);  
            
                frontview(ctview%);
                StimLoadTime := maxtime();
                StimulusLoaded% := 1;
                if Passive% = 1 then
                    ITI := MinITI + (rand(0.0)*AddITIpassive);  'rand(0.0) seeds with system time
                else
                    ITI := MinITI + (rand(0.0)*AddITIactive);
                endif;
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("ITI is %f\r",ITI);
                    view(HiddenLogHandle%).print("StimLoadTime is %f and TrialBeginTime is %f\r",StimLoadTime,TrialBeginTime);
                    view(HiddenLogHandle%).print("Next Stim Loaded %f\r",StimLoadTime);
                endif;
            endif;
            'Where to go next?  Typically this function is called during the presentation of a stimulus
            'to load up the next one, so we should go back to waiting for the sound to be over.  But on
            'the first trial there is no sound playing and we should skip directly to SetPA5 and get
            'things started.
            docase
            case StimulusPlaying% = 0 then 'if no sound is playing, go directly to setting PA5
                ChangeStateTo(StateSetPA5%, Now, 0);
            case Passive% = 0 then
                ChangeStateTo(StateWaitActiveStimEnd%, Now, 0);  'waiting for the end of the trial
            case Passive% = 1 then
                ChangeStateTo(StateWaitPassiveStimEnd%, Now, 0);  'waiting for the end of the trial
            endcase
            endif;
            
            
        case iState% = StateSetPA5% then
            if 1 then 'code folding
            if VerboseMainLoop% = 1 then  'always changes state, do not worry about AllowVerboseMainLoop
                view(HiddenLogHandle%).print("Entered StateSetPA5% at %f\r",Now);
            endif;
            'next trial is beginning
            'update CurrTrialIndex%, etc.
            CurrTrialIndex% := FutureTrialIndex%;
            SwitchCurrFile% := SwitchFutureFile%;
            arrconst(CurrTrialIndexList%[],FutureTrialIndexList%[]);
            
            if FadedBInc > 0 then  'just display this on every trial where we're fading in 
                printlog("Current Fade-In Attenuation is %.1f dB\n",FadedBInit);
                view(HiddenLogHandle%).print("Current Fade-In Attenuation is %.1f dB\r",FadedBInit);
            endif;
                
            if PA5Absent% = 0 then
                if UseCommondB = 1 then
                    if NSpeakers% = 1 then
                        SetPA5(Atten[CurrTrialIndex%]+CommondB,0);
                        if VerbosePA5% = 1 then
                            printlog("Current PA5 attenuation is %.1f dB\n",Atten[CurrTrialIndex%]+CommondB);
                            view(HiddenLogHandle%).print("Current PA5 attenuation is %.1f dB\r",Atten[CurrTrialIndex%]+CommondB);
                        endif;
                    else 'NSpeakers% = 2
                        if TargVar%[CurrTrialIndex%] > 0 then  'if the target/probe is on speaker 1
                            SetPA5(Atten[CurrTrialIndex%]+CommondB,Atten2[CurrTrialIndex%]+FadedBInit+CommondB);
                            if VerbosePA5% = 1 then
                                printlog("Current PA5 attenuation is %.1f (speaker 1) and %.1f (speaker 2) dB\n",Atten[CurrTrialIndex%]+CommondB,Atten2[CurrTrialIndex%]+FadedBInit+CommondB);
                                view(HiddenLogHandle%).print("Current PA5 attenuation is %.1f (speaker 1) and %.1f (speaker 2) dB\r",Atten[CurrTrialIndex%]+CommondB,Atten2[CurrTrialIndex%]+FadedBInit+CommondB);
                            endif;
                        else 'just assume target/probe is on speaker 2
                            SetPA5(Atten[CurrTrialIndex%]+FadedBInit+CommondB,Atten2[CurrTrialIndex%]+CommondB);
                            if VerbosePA5% = 1 then
                                printlog("Current PA5 attenuation is %.1f (speaker 1) and %.1f (speaker 2) dB\n",Atten[CurrTrialIndex%]+FadedBInit+CommondB,Atten2[CurrTrialIndex%]+CommondB);
                                view(HiddenLogHandle%).print("Current PA5 attenuation is %.1f (speaker 1) and %.1f (speaker 2) dB\r",Atten[CurrTrialIndex%]+FadedBInit+CommondB,Atten2[CurrTrialIndex%]+CommondB);
                            endif;
                        endif;
                    endif;
                else  'UseCommondB is 0, this means only one stimulus per speaker, use NormAtten value
                    if NSpeakers% = 1 then
                        SetPA5(Atten[CurrTrialIndex%]+NormAtten[StimOrder%[CurrTrialIndex%][0]],0);
                        if VerbosePA5% = 1 then
                            printlog("Current PA5 attenuation is %.1f dB\n",Atten[CurrTrialIndex%]+NormAtten[StimOrder%[CurrTrialIndex%][0]]);
                            view(HiddenLogHandle%).print("Current PA5 attenuation is %.1f dB\r",Atten[CurrTrialIndex%]+NormAtten[StimOrder%[CurrTrialIndex%][0]]);
                        endif;
                    else 'NSpeakers% = 2
                        if TargVar%[CurrTrialIndex%] > 0 then  'if the target/probe is on speaker 1, this is for fade-in of target
                            SetPA5(Atten[CurrTrialIndex%]+NormAtten[StimOrder%[CurrTrialIndex%][0]],Atten2[CurrTrialIndex%]+FadedBInit+NormAtten[StimOrder2%[CurrTrialIndex%][0]]);
                            if VerbosePA5% = 1 then
                                printlog("Current PA5 attenuation is %.1f (speaker 1) ",Atten[CurrTrialIndex%]+NormAtten[StimOrder%[CurrTrialIndex%][0]]);
                                printlog("and %.1f (speaker 2) dB\n",Atten2[CurrTrialIndex%]+FadedBInit+NormAtten[StimOrder2%[CurrTrialIndex%][0]]);
                                view(HiddenLogHandle%).print("Current PA5 attenuation is %.1f (speaker 1) ",Atten[CurrTrialIndex%]+NormAtten[StimOrder%[CurrTrialIndex%][0]]);
                                view(HiddenLogHandle%).print("and %.1f (speaker 2) dB\r",Atten2[CurrTrialIndex%]+FadedBInit+NormAtten[StimOrder2%[CurrTrialIndex%][0]]);
                            endif;
                        else 'just assume target/probe is on speaker 2, this will also work for two-speaker passive scenarios, like two-speaker Search BMF
                            SetPA5(Atten[CurrTrialIndex%]+FadedBInit+NormAtten[StimOrder%[CurrTrialIndex%][0]],Atten2[CurrTrialIndex%]+NormAtten[StimOrder2%[CurrTrialIndex%][0]]);
                            if VerbosePA5% = 1 then
                                printlog("Current PA5 attenuation is %.1f (speaker 1) ",Atten[CurrTrialIndex%]+FadedBInit+NormAtten[StimOrder%[CurrTrialIndex%][0]]);
                                printlog("and %.1f (speaker 2) dB\n",Atten2[CurrTrialIndex%]+NormAtten[StimOrder2%[CurrTrialIndex%][0]]);
                                view(HiddenLogHandle%).print("Current PA5 attenuation is %.1f (speaker 1) ",Atten[CurrTrialIndex%]+FadedBInit+NormAtten[StimOrder%[CurrTrialIndex%][0]]);
                                view(HiddenLogHandle%).print("and %.1f (speaker 2) dB\r",Atten2[CurrTrialIndex%]+NormAtten[StimOrder2%[CurrTrialIndex%][0]]);
                            endif;
                        endif;
                    endif;
                endif;
            else
                'Actually, let's not continually print to the hidden log that we're not doing anything
            endif;
                
            
            'This is also the appropriate time to set passive/active state in interleaved scenarios
            if Interleaved% = 1 then
                Passive% := ActivePassive%[CurrTrialIndex%];  'that's easy!
            endif;
            PA5SetTime := view(ctview%).maxtime();
            StimulusReady% := 1;
            if VerboseTrialTiming% = 1 then
                view(HiddenLogHandle%).print("Stim ready to present %f, LED on time %f\r",PA5SetTime,NextTrialTime);
            endif;
            'And move on to the next state, which is always waiting for the time of the next trial (passive or active)
            docase
            case Passive% = 0 then
                ChangeStateTo(StateWaitActiveTrial%, Now, 0);
            case Passive% = 1 then
                ChangeStateTo(StateWaitPassiveTrial%, Now, 0);
            endcase
            'Allow pause here
            if iPause% = 1 then
                iStatePause% := StatePause%;
            else
                if paramPause% = 1 then
                    iStatePause% := StateParamPause%;
                endif;
            endif;
            endif;
            
            
        case iState% = StateWaitPassiveTrial% then
            'Wait for passive trial
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateWaitPassiveTrial% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if Now >= NextTrialTime then 'if it is time for the next trial, begin trial
                 'put timing marker in both eyetracker file, smr file
                    if RecordEyeTrackerOutputFile% = 1 then
                        'SafeSampleKey("1");
                        docase
                        case HBCycle% = 1 then
                            SafeSampleKey("1");
                        case HBCycle% = 2 then
                            SafeSampleKey("2");
                        case HBCycle% = 3 then
                            SafeSampleKey("3");
                        case HBCycle% = 4 then
                            SafeSampleKey("4");
                        case HBCycle% = 5 then
                            SafeSampleKey("5");
                        case HBCycle% = 6 then
                            SafeSampleKey("6");
                        case HBCycle% = 7 then
                            SafeSampleKey("7");
                        endcase
                        HBCycle% += 1;  'increment HBCycle%
                        if HBCycle% = 8 then  'and cycle when necessary
                            HBCycle% := 1;
                        endif
                        yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
                    endif;   
                ChangeStateTo(StateBeginPassiveTrial%, Now, 0);
            endif; 
            'Allow pause here
            if iPause% = 1 then
                iStatePause% := StatePause%;
            else
                if paramPause% = 1 then
                    iStatePause% := StateParamPause%;
                endif;
            endif;            
            endif;
            
            
        case iState% = StateBeginPassiveTrial% then
            'Update cue lights (not common for passive, but possible) and note time that trial began
            if 1 then 'code folding
            if VerboseMainLoop% = 1 then 'always changes state, don't worry about AllowVerboseMainLoop
                view(HiddenLogHandle%).print("Entered StateBeginPassiveTrial% at %f\r",Now);
            endif;
            TrialBeginTime := Now;
            TrialBeginLate := TrialBeginTime - NextTrialTime;  'How late was the trial starting, for log info
            if CueLightEachTrial% = 1 then  'If we are changing cue lights, passive scenarios should only use 0/1
                CurrentCueLights$ := NextCueLights$;  'Update which cue lights to use
                CueLights("on",CurrentCueLights$,"on");  'Turn on house light, turn on cue lights - this is expected to be used for "silent" trials that temporally separate the cue from the active trial
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("\r\rLED on to wait for trial\r");
                endif;
            else
                if CuelightOverride$ = "" then
                    CurrentCueLights$ := "y";  'Otherwise, it's the yellow cue light by default
                else
                    CurrentCueLights$ := CueLightOverride$;  'unless specifically overriden
                endif;
                CueLights("on",CurrentCueLights$,"off");  'Turn on house light, turn off cue lights
                'This is a bit confusing.  I think that this is really intended to make sure the cue light is OFF for
                'passive trials if we are switching between active and passive
            endif;
            ChangeStateTo(StatePresentPassiveStimulus%, Now, 1);
            if VerboseTrialTiming% = 1 then
                view(HiddenLogHandle%).print("\r\rTrial can begin at absolute time %f, %f seconds late\r",TrialBeginTime,TrialBeginLate);
            endif;
            endif;
            
            
            
        case iState% = StatePresentPassiveStimulus% then
            'Start playing sound in Passive case
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StatePresentPassiveStimulus% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            CueLights("same",CurrentCueLights$,"off");  'Leave on house light, turn off cue lights, if any
            LeverPressTime := Now;  'Note there is not an actual lever press
            view(ctview%).MemSetItem(MemChanStart%, 0, LeverPressTime);
			'calculate when to present stimulus
            StimOn := LeverPressTime + TrialOnsetDelay;  'Here StimOn holds the expected presentation time
            StimDur := NextStimDur;
            if VerboseTrialTiming% = 1 then
                view(HiddenLogHandle%).print("Trial begins %f, trial should present at %f\r",LeverPressTime,StimOn);
            endif;
            
            
			'Aggressively wait until time to present stimulus
            while view(ctview%).maxtime() < StimOn do
                if samplestatus()<0 then 'if recording has been stopped, maxtime() will never change 
                    StimOn := -1;  'force out of this while loop
                    SkipStim% := 1;  'cancel presentation of current stimulus, as we've stopped recording
                    RecordStopTime := view(ctview%).maxtime();
                    printlog("Noticed recording has been stopped at %f\n",RecordStopTime);
                    view(HiddenLogHandle%).print("Noticed recording has been stopped at %f\r",RecordStopTime);
                endif;
                yield(.001,1023);   'yield if it is not time to present stimulus
            wend;
            
            'present stimulus
            if SkipStim% = 0 then  'cancels presentation if recording has been stopped
				'Play the stimulus in the current buffer, current buffer changed when stim loaded
                if BufferToPlay% = 1 then
                    SafeSampleKeySutter%("S");
                else
                    SafeSampleKeySutter%("T");
                endif;
                
                StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Now, StimOn holds actual presentation time, usually
                while StimOn = PrevStimOn do  'This will happen if the above line occurs before the stim starts
                    yield(.001,1023);  'yield a millisecond until the stimulus starts playing
                    StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Keep checking until StimOn is updated
                wend          
                PrevStimOn := StimOn;  'keep track of most recent StimOn
                
                if VerboseStimID% = 1 then
                    printlog("Trial #%d:%d (%s) ready!\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,StimName$[TestStim%[CurrTrialIndex%]]);
                else
                    printlog("Trial #%d:%d\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                endif;
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("Playing stimulus %f, stimulus over at %f\r",StimOn,StimOn+StimDur);
                endif;
                
				'update text marker channel
                StimCodes%[0]:=TargVar%[CurrTrialIndex%];  'Holds target status of trial
                view(ctview%).MemSetItem(MemChanStim%, 0, StimOn,StimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
				
'                RewardCount% := -1;  'Waiting to determine reward
'                StimulusPlaying% := 1;
'                StimulusReady% := 0;
'                StimulusLoaded% := 0;
                FutureTrialIndex% := CurrTrialIndex% + 1; 'increment future trial, for loading purposes
                FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1] + 1; 'increment list as well
                TrialCount% := TrialCount% + 1;  'increment trial count
                ChangeStateTo(StateLoadStimulus%, view(ctview%).maxtime(), 1);  'Once stimulus has begun playing, load the next stimulus immediately
                StimulusPlaying% := 1;
            else
                'If recording has stopped for some reason, just quit
                ChangeStateTo(StateDone%, view(ctview%).maxtime(), 1);
            endif;
            endif;
            
            
        case iState% = StateWaitPassiveStimEnd% then
            'Wait for passive stimulus to complete
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateWaitPassiveStimEnd% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if Now > StimOn + StimDur then
                StimDoneTime := Now;
                NextTrialTime := StimDoneTime + ITI;
                ResponseTime2 := StimOn + StimDur;
                StimulusPlaying% := 0;
                UpdatePSTHNow% := 1;  'Ready to update PSTH if there was no interrupt regardless of correct/incorrect status
                'Also updates online files - used even if there are no histograms
                TrialResult$ := "Passive";
                'Put code onto MemChanHistTrigger% indicating the beginning of the test portion of this trial
                'note that this should be a different histogram than the active one!
                if behavioral% = 0 then
                    SetStimCodes%(StimCodes%[],TestStim%[CurrTrialIndex%]);
                    'StimCodes%[0]:=TestStim%[CurrTrialIndex%]; 
                    view(ctview%).MemSetItem(MemChanHistTriggerP%,0,StimOn+min(PrevEOS,PrevEOS2),StimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
                    view(ctview%).MemSetItem(MemChanHistTrigger%,0,StimOn+min(PrevEOS,PrevEOS2),StimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
                    if OverallPSTHType% > 0 then
                        SetStimCodes%(GroupStimCodes%[],StimGroup%[TestStim%[CurrTrialIndex%]]);
                        view(ctview%).MemSetItem(MemChanHistTriggerPGroup%,0,StimOn+min(PrevEOS,PrevEOS2),GroupStimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
                    endif;       
                endif;
                
                'assign reward
                RandReward(PayPassProb,1);  'only give one reward on passive trials
                RewardTime := StimDoneTime + RewardDelay;
                if RewardCount% > 0 then 'add RewardDelay to NextTrialTime if reward will be given
                    NextTrialTime := NextTrialTime + RewardDelay;
                    'SolenoidOpenDur% := PayPassVal;
                    SolenoidOpenDur% := JuiceRewardMS%;
                    ChangeStateTo(StateReward%, StimDoneTime, 1);
                else
                    if NothingToLoad% = 1 then  'if all stimuli are finished, get ready to quit
                        ChangeStateTo(StateDone%,StimDoneTime,1);
                    else  'Otherwise we're presenting sounds, so set the PA5
                        ChangeStateTo(StateSetPA5%,StimDoneTime,0);
                    endif;
                endif;
                
            endif;
            endif;
            
        case iState% = StateWaitActiveTrial% then
            'Wait for active trial, check that lever is in origin until stimulus starts
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateWaitActiveTrial% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if InOrigin% = 0 then  'if the lever is out of the origin , do not start next trial
                if ReleaseTO > 0 then  'if there is a release penalty set, begin penalty procedure
                    ChangeStateTo(StateMustReleaseLever%, Now, 0);
                    HoldLeverBegin := Now;  'Will determine how long monkey can hold lever until penalty instituted
                    if VerboseTrialTiming% = 1 then
                        view(HiddenLogHandle%).print("The monkey began holding the lever at %f\r",HoldLeverBegin);
                    endif;
                    CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off)
                endif;
            else
                    if Now >= NextTrialTime then 'if it is time for the next trial, begin trial
                        'put timing marker in both eyetracker file, smr file
                        if RecordEyeTrackerOutputFile% = 1 then
                            'SafeSampleKey("1");
                            docase
                            case HBCycle% = 1 then
                                SafeSampleKey("1");
                            case HBCycle% = 2 then
                                SafeSampleKey("2");
                            case HBCycle% = 3 then
                                SafeSampleKey("3");
                            case HBCycle% = 4 then
                                SafeSampleKey("4");
                            case HBCycle% = 5 then
                                SafeSampleKey("5");
                            case HBCycle% = 6 then
                                SafeSampleKey("6");
                            case HBCycle% = 7 then
                                SafeSampleKey("7");
                            endcase
                            HBCycle% += 1;  'increment HBCycle%
                            if HBCycle% = 8 then  'and cycle when necessary
                                HBCycle% := 1;
                            endif
                            yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
                        endif;
                    ChangeStateTo(StateBeginActiveTrial%, Now, 1);
                endif;
            endif;
            'Allow pause here
            if iPause% = 1 then
                iStatePause% := StatePause%;
            else
                if paramPause% = 1 then
                    iStatePause% := StateParamPause%;
                endif;
            endif;
            endif;
            
            
            
        case iState% = StateBeginActiveTrial% then
            'Update cue lights and note time that trial began, begin looking for interrupt
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateBeginActiveTrial% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;     
            
            'If we are changing the cue light (typically this is done in blocks), we need to flash
            'to indicate the new contingency.  Start flash and return to StateWaitActiveTrial, while
            'skipping the remainder of this loop.  Otherwise if the cue light is the same, move
            'forward with the trial.
            docase
            case CueLightOverride$ <> "" then
                CurrentCueLights$ :=  CueLightOverride$;  'override rules all
                
            case CueLightEachTrial% = 2 then    'Cue lights for MonoJoystickFRUD are determined by CueLightFRUDUp
                'This statement covers MonoJoystickFRUD, for this condition we use CueLightFRUDUp to determine which cue light (red, green) is for
                'upwards target motion, and the opposite will be for down
                'printlog("current cue light is %s and current target motion is %d\n",CurrentCueLights$,TargetMotion%);
                docase
                case CurrentCueLights$ <> CueLightFRUDUp$ and TargetMotion% = 1 then  'if requested response is UP and cue is NOT CueLightFRUDUp$
                    CurrentCueLights$ := CueLightFRUDUp$;  'change cue to CueLightFRUDUp$, and flash the change below
                case CurrentCueLights$ <> CueLightFRUDDown$ and TargetMotion% = 0 then  'if requested response is UP and cue is NOT CueLightFRUDDown$
                    CurrentCueLights$ := CueLightFRUDDown$;  'change cue to red, and flash the change below
                endcase;
                FlashOn(Left$(CurrentCueLights$,1),FlashLEDCCDur*1000,500/FlashLEDFrequency);   'Flashdur in ms, convert FlashFreq to ms and get half-period
                SkipLoop% := 1;
                NextTrialTime := Now + FlashLEDCCDur;
            case CueLightEachTrial% = 1 then  'This statement covers parameter-file-based cue lighting
                if CurrentCueLights$ <> NextCueLights$ then  'if cue light changes this trial
                    CurrentCueLights$ := NextCueLights$;  'Update which cue lights to use
                    printlog("cue light updated to %s\n",CurrentCueLights$);
                    if FlashLEDOnCueChange% = 1 and FlashLEDCCDur > 0 then
                        FlashOn(Left$(CurrentCueLights$,1),FlashLEDCCDur*1000,500/FlashLEDFrequency);   'Flashdur in ms, convert FlashFreq to ms and get half-period
                        SkipLoop% := 1;
                        NextTrialTime := Now + FlashLEDCCDur;
                    endif;
                endif;
                
            else 'this statement covers everything else, which is just the default
                CurrentCueLights$ := "y";  'Otherwise, it's the yellow cue light by default
            endcase;
            
            
            if SkipLoop% = 0 then
                CueLights("on",CurrentCueLights$,"on");  'Turn on house light, turn on cue lights
                TrialBeginTime := Now;
                TrialBeginLate := TrialBeginTime - NextTrialTime;  'How late was the trial starting, for log info
                MustReleaseLever% := 0;  'reset
                Interrupt% := 0;   'reset
                UpdateSPKFile% := 0;   'reset, even if an update request didn't get done
                if NSpeakers% = 1 then
                    if VerboseStimID% = 1 then
                        printlog("Trial #%d:%d (%s) ready!\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,StimName$[TestStim%[CurrTrialIndex%]]);
                    else
                        printlog("Trial #%d:%d\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                    endif;
                    if VerboseTrialTiming% = 1 then
                        view(HiddenLogHandle%).print("Trial #%d:%d (%s) ready at %f!\r",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,StimName$[TestStim%[CurrTrialIndex%]],Now);
                        view(HiddenLogHandle%).print("LED on to wait for trial, absolute time %f, %f seconds late\r",TrialBeginTime,TrialBeginLate);
                    else
                        view(HiddenLogHandle%).print("Trial #%d:%d (%s) ready!\r",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,StimName$[TestStim%[CurrTrialIndex%]]);
                    endif;
                else
                    if VerboseStimID% = 1 then
                        printlog("Trial #%d:%d (Up/A: %s, Down/B: %s) ready!\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,StimName$[TestStim%[CurrTrialIndex%]],StimName$[TestStim2%[CurrTrialIndex%]]);
                    else
                        printlog("Trial #%d:%d\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                    endif;
                    if VerboseTrialTiming% = 1 then
                        view(HiddenLogHandle%).print("Trial #%d:%d (Up/A: %s, Down/B: %s)",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,StimName$[TestStim%[CurrTrialIndex%]],StimName$[TestStim2%[CurrTrialIndex%]]);
                        view(HiddenLogHandle%).print(" ready at %f!\r",Now);
                        view(HiddenLogHandle%).print("LED on to wait for trial, absolute time %f, %f seconds late\r",TrialBeginTime,TrialBeginLate);
                    else
                        view(HiddenLogHandle%).print("Trial #%d:%d (Up/A: %s, Down/B: %s) ready!\r",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,StimName$[TestStim%[CurrTrialIndex%]],StimName$[TestStim2%[CurrTrialIndex%]]);
                    endif;
                    docase
                        case TargVar%[CurrTrialIndex%] > 0 and TargVar%[CurrTrialIndex%] < 8 and Targvar2%[CurrTrialIndex%] = 0 then
                        printlog("Target Up, noise attenuation = %f\n",FadedBInit);
                        view(HiddenLogHandle%).print("Target Up, noise attenuation = %f\r",FadedBInit);
                        case TargVar%[CurrTrialIndex%] = 0 and TargVar2%[CurrTrialIndex%] > 0 and TargVar2%[CurrTrialIndex%] < 8 then
                        printlog("Target Down, noise attenuation = %f\n",FadedBInit);
                        view(HiddenLogHandle%).print("Target Down, noise attenuation = %f\r",FadedBInit);
                        case TargVar%[CurrTrialIndex%] >= 8 and Targvar2%[CurrTrialIndex%] = 0 then
                        printlog("Probe Up\n");
                        view(HiddenLogHandle%).print("Probe Up\r");
                        case TargVar%[CurrTrialIndex%] = 0 and Targvar2%[CurrTrialIndex%] >= 8 then
                        printlog("Probe Down\n");
                        view(HiddenLogHandle%).print("Probe Down\r");
                        case TargVar%[CurrTrialIndex%] = 0 and Targvar2%[CurrTrialIndex%] = 0 then
                        printlog("Catch Trial\n");
                        view(HiddenLogHandle%).print("Catch Trial\r");
                    endcase;		
                endif;
                ChangeStateTo(StatePresentActiveStimulus%, Now, 0);
            else   'reset SkipLoop% so next time we enter this state we can get somewhere            
                SkipLoop% := 0;
                ChangeStateTo(StateWaitActiveTrial%, Now, 0); 'and go back one step, wait for flash to finish
            endif;
            'Allow pause here
            if iPause% = 1 then
                iStatePause% := StatePause%;
            else
                if paramPause% = 1 then
                    iStatePause% := StateParamPause%;
                endif;
            endif;
            endif;
            
            
        case iState% = StatePresentActiveStimulus% then
            'Wait for animal to initiate trial, if joystick is moved off axis or animal waits too long, go to timeout
            'If trial is initiated, present stimulus
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StatePresentActiveStimulus% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            docase
            case OffAxis% > 0 then 'if off-axis interrupt
                printlog("Off-Axis interrupt detected at %f\n",Now);
                view(HiddenLogHandle%).print("Off-Axis interrupt detected at %f\r",Now);	
                'Interrupt% := 1;  '?? remove?
                NumInterrupt% += 1;  'Increment interrupt count
                CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights
                NextTrialTime := YTime + IntPenalty + ITI;  'Institute interrupt penalty
                UpdateSPKFile% := 1;  'update SPK file during penalty
                ChangeStateTo(StateWaitActiveTrial%, Now, 0);  'And take a step back
                'note that this will immediately put the animal in danger of a "hold" penalty, so just another reason for ReleaseTO to be large
            case InOrigin% = 1 and Now > TrialBeginTime + LazyTO then  'if animal waited too long
                printlog("Lazy penalty being enforced af %f\n",Now);
                view(HiddenLogHandle%).print("Lazy penalty being enforced at %f\r",Now);
                CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights
                NextTrialTime := Now + LazyTOPenalty;  'institute Lazy Monkey Penalty
                UpdateSPKFile% := 1;  'update SPK file during penalty
                'increment LazyTOPenalty and fix if it is above the maximum allowed value
                LazyTOPenalty := LazyTOPenalty*LazyTOFactor;
                if LazyTOPenalty > LazyTOMax then
                    LazyTOPenalty := LazyTOMax;
                endif;
                ChangeStateTo(StateWaitActiveTrial%, Now, 0);  'And take a step back
                'note that this will immediately put the animal in danger of a "hold" penalty, so just another reason for ReleaseTO to be large
            case TrialInit% = 1 then  'present stimulus		
                CueLights("same",CurrentCueLights$,"off");  'Leave on house light, turn off cue lights
                docase  'assign LeverPressTime individually in a case statement
                case RespDevice% = 0 then  'if RespDevice is Lever
                    LeverPressTime := LeverTime;
                case RespDevice% = 1 then  'if RespDevice is Joystick
                    LeverPressTime := XTime;
                case RespDevice% = -1 then 'if RespDevice is JoystickAsLever
                    LeverPressTime := YTime;
                case RespDevice% = -2 then 'if RespDevice is DownUpJoystick
                    LeverPressTime := YTime;
                case RespDevice% = 2 then 'if RespDevice is JoystickYX
                    LeverPressTime := YTime;
                case RespDevice% = -3 then 'if RespDevice is JoystickAsLeverLR
                    LeverPressTime := XTime;
                case RespDevice% = -4 then 'if RespDevice is MonoJoystickFRUD
                    LeverPressTime := XTime;
                endcase;
                view(ctview%).MemSetItem(MemChanStart%, 0, LeverPressTime);  'add the time the trial started to the end of MemChanStart
                'calculate when to present stimulus
                StimOn := LeverPressTime + TrialOnsetDelay;  'Here StimOn holds the expected presentation time
                StimDur := NextStimDur;
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("Lever pressed to start trial %f, trial should present at %f\r",LeverPressTime,StimOn);
                endif;
                
                'Aggressively wait until time to present stimulus, checking for interrupt
                Now := view(ctview%).maxtime();
                while Now < StimOn  and Interrupt% = 0 do
                    if samplestatus()<0 then 'if recording has been stopped, maxtime() will never change 
                        StimOn := -1;  'force out of this while loop
                        SkipStim% := 1;  'cancel presentation of current stimulus, as we've stopped recording
                        RecordStopTime := Now;
                        printlog("Noticed recording has been stopped at %f\n",RecordStopTime);
                        view(HiddenLogHandle%).print("Noticed recording has been stopped at %f\r",RecordStopTime);
                    endif;
                    'Check for interrupt, if not calibration mode
                    if CalibrationMode = 0 then
                        if RespDevice% = 0 then  'if physical device is lever
                            DebounceLever%();
                        else  'if physical device is joystick
                            ReadJoystick%();
                        endif;
                        if TrialInit% = 0 or OffAxis% > 0 then  'if lever is released, or joystick is moved in off-axis (Y for Joystick, X for JoystickAsLever)
                            Interrupt% := 1;
                            NumInterrupt% := NumInterrupt% + 1;
                            if TrialInit% = 0 then  'if response device is moved out of trial initiation position before stimulus starts
                                UpdateTrialOnset("dec");  'shorten trial onset delay on interrupt before stimulus, but only for on-axis
                                docase
                                case RespDevice% = 0 then 'RespDevice is Lever
                                    InterruptTime := LeverTime;
                                case RespDevice% = 1 then 'if RespDevice is Joystick
                                    InterruptTime := XTime;
                                case RespDevice% = -1 then 'RespDevice is JoystickAsLever
                                    InterruptTime := YTime;
                                case RespDevice% = -2 then 'RespDevice is DownUpLever
                                    InterruptTime := YTime;
                                case RespDevice% = 2 then 'RespDevice is JoystickYX
                                    InterruptTime := YTime;
                                case RespDevice% = -3 then 'RespDevice is JoystickAsLeverLR
                                    InterruptTime := XTime;
                                case RespDevice% = -4 then 'RespDevice is MonoJoystickFRUD
                                    InterruptTime := XTime;                            
                                endcase;
                            else  'Interrupt is in the off axis, before stimulus is begun
                                docase
                                case RespDevice% = 1 then  'if RespDevice is Joystick, off axis is Y
                                    InterruptTime := YTime;
                                case RespDevice% = -1 then  'if RespDevice is JoystickAsLever, off axis is X
                                    InterruptTime := XTime;
                                case RespDevice% = -2 then  'if RespDevice is DownUpJoystick, off axis is X
                                    InterruptTime := XTime;   
                                case RespDevice% = 2 then  'if RespDevice is JoystickYX, off axis is X
                                    InterruptTime := XTime;
                                case RespDevice% = -3 then 'RespDevice is JoystickAsLeverLR
                                    InterruptTime := XTime;
                                case RespDevice% = -4 then 'RespDevice is MonoJoystickFRUD
                                    InterruptTime := YTime;    
                                endcase;
                            endif;
                            printlog("Interrupt before stimulus!\n");
                            if VerboseTrialTiming% = 1 then
                                view(HiddenLogHandle%).print("Interrupt detected before stimulus presented %f\r",InterruptTime);
                            endif;
                        endif;
                    endif;
                    'Update the joystick plot every 5 ms during aggressive waiting
                    if RespDevice% <> 0 and Now-tLastJoyUpdate > .005 then
                        XJoy := View(ctview%).ChanMeasure(configJoyXChannel%,2,Now-.001,Now-.006);
                        YJoy := View(ctview%).ChanMeasure(configJoyYChannel%,2,Now-.001,Now-.006);
                        View(joyview%).XYAddData(joydatachan%,-XJoy,-YJoy);  'both axes need to be "flipped" with negative values to display properly
                        tLastJoyUpdate := Now;
                    endif;
                    yield(.001,1023);   'yield if it is not time to present stimulus
                    Now := view(ctview%).maxtime();
                wend;
                
                'If interrupt, do interrupt penalty, otherwise present stimulus
                if Interrupt% = 1 then              
                    CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights (cue lights should already be off)
                    'same stimulus will be played, so no load/attenuation set necessary
                    NextTrialTime := InterruptTime + IntPenalty + ITI;
                    printlog("Prestimulus interrupt TO begun %f, next LED at %f\n",InterruptTime,NextTrialTime);
                    view(HiddenLogHandle%).print("Prestimulus interrupt TO begun %f, next LED at %f\r",InterruptTime,NextTrialTime);
                    UpdateSPKFile% := 1;  'update SPK file during penalty
                    ChangeStateTo(StateWaitActiveTrial%, Now, 0);  'And take a step back
                else
                    if SkipStim% = 0 then  'cancels presentation if recording has been stopped
                        'present current stimulus
                        'Play the stimulus in the current buffer, current buffer changed when stim loaded
                        if BufferToPlay%=1 then
                            SafeSampleKeySutter%("S");  'each buffer will play BOTH stimuli for a stereo stimulus
                        else
                            SafeSampleKeySutter%("T");
                        endif;
                        StimulusPlaying% := 1;
                        StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Now, StimOn holds actual presentation time, usually
                        while StimOn = PrevStimOn do  'This will happen if the above line occurs before the stim starts
                            yield(.001,1023);  'yield a millisecond until the stimulus starts playing
                            StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Keep checking until StimOn is updated
                        wend;          
                        PrevStimOn := StimOn;  'keep track of most recent StimOn
                        
                        if VerboseTrialTiming% = 1 then
                            view(HiddenLogHandle%).print("Playing stimulus %f, stimulus over at %f\r",StimOn,StimOn+StimDur);
                        endif;
                        
                        'update text marker channel
                        StimCodes%[0]:=TargVar%[CurrTrialIndex%];  'Holds target status of trial
                        view(ctview%).MemSetItem(MemChanStim%, 0, StimOn,StimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
                        
                        UpdateTrialOnset("inc");  'lengthen trial onset delay if monkey successfully waits through delay
                        
                        FutureTrialIndex% := CurrTrialIndex% + 1; 'increment future trial, for load purposes
                        FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1] + 1;  'increment future trial list
                        TrialCount% := TrialCount% + 1;  'increment trial count
                        if Errorless% = 1 then
                            ChangeStateTo(StateWaitActiveStimEnd%, view(ctview%).maxtime(), 1);  'waiting for the end of the trial on errorless
                        else  'Regularly, let the loop know it's time to load the next stimulus
                            ChangeStateTo(StateLoadStimulus%, view(ctview%).maxtime(), 1);  'Once stimulus has begun playing, load the next stimulus immediately
                        endif;
                    else
                        'If recording has stopped for some reason, just quit
                        ChangeStateTo(StateDone%, view(ctview%).maxtime(), 1);
                    endif;
                endif;
            else
                'If trial has not yet been initialized, allow pause here
                if iPause% = 1 then
                    iStatePause% := StatePause%;
                else
                    if paramPause% = 1 then
                        iStatePause% := StateParamPause%;
                    endif;
                endif;
            endcase
            endif;
            
            
        case iState% = StateWaitActiveStimEnd% then
            'Wait for stimulus to end, checking for interrupt
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateWaitActiveStimEnd% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            'Check for interrupts while stimulus is still playing
            docase
                'If there is an early response
            case TrialResponse% = 1 and ResponseTime < StimOn + StimDur + RespWindowDelay and CalibrationMode = 0 then
                PlayWaveStop();  'stop playing stimulus
                CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights (cue lights should already be off)
                InterruptTime := ResponseTime;
                NextTrialTime := InterruptTime + IntPenalty + ITI;
                RewardCount% := 0;  'No reward
                Interrupt% := 1;  '??
                NumInterrupt% := NumInterrupt% + 1;
                UpdateSPKFile% := 1;  'update SPK file during penalty
                FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
                FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
                TrialCount% := TrialCount% - 1;  'decrement trial count as well
                if SwitchToTF% > 0 then  'on interrupt, if switching, delay switch until interrupted stim is finished
                    SwitchToTFInterrupt% := SwitchToTF%;
                    SwitchToTF% := 0;
                endif; 
                if NSpeakers% = 1 then
                    SimpleStepdB(-2);  'decrement volume of fade-in stimulus on interrupt
                endif;
                printlog("Interrupt during stimulus!\n");
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("Interrupt detected before response window, penalty TO begun %f, next LED at %f\r",InterruptTime,InterruptTime+IntPenalty+ITI);
                endif;
                StimulusPlaying% := 0;  'This will tell StateLoadStimulus to go directly to StateSetPA5
                ChangeStateTo(StateLoadStimulus%,Now,0);  'we need to load this stimulus again
            'For Response Device Joystick or JoystickFRUD, check for early release on the X-axis 
            case TrialInit% = 0 and XTime < StimOn + StimDur + RespWindowDelay and (RespDevice% = 1 or RespDevice% = -4) then
                PlayWaveStop();  'stop playing stimulus
                CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights (cue lights should already be off)
                InterruptTime := XTime;
                NextTrialTime := InterruptTime + IntPenalty+ITI;
                Interrupt% := 1; 
                NumInterrupt% := NumInterrupt% + 1;
                UpdateSPKFile% := 1;  'update SPK file during penalty
                FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
                FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
                TrialCount% := TrialCount% - 1;  'decrement trial count as well
                if SwitchToTF% > 0 then  'on interrupt, if switching, delay switch until interrupted stim is finished
                    SwitchToTFInterrupt% := SwitchToTF%;
                    SwitchToTF% := 0;
                endif;
                printlog("Interrupt (x-axis) during stimulus!\n");
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("Interrupt (x-axis) detected before response window, penalty TO begun %f, next LED at %f\r",InterruptTime,InterruptTime+IntPenalty+ITI);
                endif;
                StimulusPlaying% := 0;  'This will tell StateLoadStimulus to go directly to StateSetPA5
                ChangeStateTo(StateLoadStimulus%,Now,0);  'we need to load this stimulus again
            'Catch y-axis "early release" interrupts for the Response Device DownUpJoystick/JoystickYX only.
            case TrialInit% = 0 and YTime < StimOn + StimDur + RespWindowDelay and (RespDevice% = -2 or RespDevice% = 2) then
                PlayWaveStop();  'stop playing stimulus
                CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights (cue lights should already be off)
                InterruptTime := YTime;
                NextTrialTime := InterruptTime + IntPenalty+ITI;
                Interrupt% := 1; 
                NumInterrupt% := NumInterrupt% + 1;
                UpdateSPKFile% := 1;  'update SPK file during penalty
                FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
                FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
                TrialCount% := TrialCount% - 1;  'decrement trial count as well
                if SwitchToTF% > 0 then  'on interrupt, if switching, delay switch until interrupted stim is finished
                    SwitchToTFInterrupt% := SwitchToTF%;
                    SwitchToTF% := 0;
                endif;
                if NSpeakers% = 1 then
                    SimpleStepdB(-2);  'decrement volume of fade-in stimulus on interrupt
                endif;
                printlog("Interrupt (y-axis) during stimulus!\n");
                if VerboseTrialTiming% = 1 then
                    view(HiddenLogHandle%).print("Interrupt (y-axis) detected before response window, penalty TO begun %f, next LED at %f\r",InterruptTime,InterruptTime+IntPenalty+ITI);
                endif;
                StimulusPlaying% := 0;  'This will tell StateLoadStimulus to go directly to StateSetPA5
                ChangeStateTo(StateLoadStimulus%,Now,0);  'we need to load this stimulus again
            'If stimulus is done playing, move on
            case Now >= StimOn + StimDur + RespWindowDelay then
                'Final check for interrupt, do not check in calibration mode
                'Debounce lever/read joystick to check for interrupt one last time.
                if RespDevice% = 0 then  'if physical response device is lever
                    DebounceLever%();
                else  'if physical response device is joystick
                    ReadJoystick%();
                endif;
                
                'Final check for interrupt
                'PLEASE NOTE THE FOLLOWING LINE IS ALMOST TOO LONG (255 CHARACTER LIMIT), DO NOT EXTEND WITHOUT CHECKING, DO NOT ADD COMMENT   
                if ((TrialResponse%=1 and ResponseTime<StimDoneTime) or (TrialInit%=0 and (RespDevice%=1 or RespDevice%=-4) and XTime<StimDoneTime) or (TrialInit%=0 and RespDevice%=2 and YTime<StimDoneTime)) and CalibrationMode = 0 then
                    'PLEASE NOTE THE PREVIOUS LINE IS ALMOST TOO LONG (255 CHARACTER LIMIT), DO NOT EXTEND WITHOUT CHECKING, DO NOT ADD COMMENT
                    CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights (cue lights should already be off)
                    docase
                    case TrialResponse% = 1 and ResponseTime < StimDoneTime then
                        InterruptTime := ResponseTime;
                    case TrialInit%=0 and RespDevice%=2 and YTime<StimDoneTime then
                        InterruptTime := YTime;
                    else
                        InterruptTime := XTime;
                    endcase;
                    NextTrialTime := InterruptTime + IntPenalty + ITI;
                    Interrupt% := 1; 
                    NumInterrupt% := NumInterrupt% + 1;
                    
                    UpdateSPKFile% := 1;  'update SPK file during penalty
                    FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
                    FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
                    TrialCount% := TrialCount% -1;  'decrement trial count as well
                    if SwitchToTF% > 0 then  'on interrupt, if switching, delay switch until interrupted stim is finished
                        SwitchToTFInterrupt% := SwitchToTF%;
                        SwitchToTF% := 0;
                    endif;
                    if NSpeakers% = 1 then
                        SimpleStepdB(-2);  'decrement volume of fade-in stimulus on interrupt
                    endif;
                    printlog("Interrupt during stimulus!\n");
                    if VerboseTrialTiming% = 1 then
                        view(HiddenLogHandle%).print("Interrupt detected before response window, penalty TO begun %f, next LED at %f\r",InterruptTime,InterruptTime+IntPenalty+ITI);
                    endif;
                    StimulusPlaying% := 0;  'This will tell StateLoadStimulus to go directly to StateSetPA5
                    ChangeStateTo(StateLoadStimulus%,Now,0);  'we need to load this stimulus again
                else 'no interrupt, move forward
                    StimulusPlaying% := 0;
                    StimDoneTime := StimOn + StimDur + RespWindowDelay;
                    if VerboseTrialTiming% = 1 then
                        view(HiddenLogHandle%).print("Stimulus began at %f, ended at %f, and entered test phase at %f\r",StimOn,StimOn+StimDur,StimDoneTime);
                        view(HiddenLogHandle%).print("Noticed entrance of test phase at %f\r",Now);
                    endif;
                    if Errorless% = 0 then
                        ChangeStateTo(StateActiveResponseWindow%,Now,0);
                    else
                        ChangeStateTo(StateErrorlessResponseWindow%,Now,0);
                        TempErrors% := 0;  'reset TempErrors% when we enter the response window
                    endif;
                endif;
                
            endcase;
            endif;
                
                    
                    
            
            
        case iState% = StateActiveResponseWindow% then
            'Wait for response
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateActiveResponseWindow% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            UpdatePSTHNow% := 1;  'Ready to update PSTH if there was no interrupt regardless of correct/incorrect status
            'Put code onto MemChanHistTrigger% indicating the beginning of the test portion of this trial
            if behavioral% = 0 then
                SetStimCodes%(StimCodes%[],TestStim%[CurrTrialIndex%]);
                'StimCodes%[0]:=TestStim%[CurrTrialIndex%]; 
                view(ctview%).MemSetItem(MemChanHistTriggerA%,0,StimOn+min(PrevEOS,PrevEOS2),StimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
                view(ctview%).MemSetItem(MemChanHistTrigger%,0,StimOn+min(PrevEOS,PrevEOS2),StimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
                if OverallPSTHType% > 0 then
                    SetStimCodes%(GroupStimCodes%[],StimGroup%[TestStim%[CurrTrialIndex%]]);
                    view(ctview%).MemSetItem(MemChanHistTriggerAGroup%,0,StimOn+min(PrevEOS,PrevEOS2),GroupStimCodes%[],StimName$[TestStim%[CurrTrialIndex%]]);
                endif;
            endif;
            
            TargetResponse% := 0;  'Assert no target response yet
            
            if CalibrationMode = 1 and InOrigin% = 1 then 'if there was a "calibration" interrupt, use end of stimulus as response time, do not wait through response window
                ResponseTime2 := StimOn + StimDur;
            else 'this is the normal state
                'wait through response window, get lever status
                'if the lever is still down and we're in response window, wait
                Now := view(ctview%).maxtime();
                while TrialResponse% = 0 and Now < StimOn + StimDur + RespWindowDelay + ResponseWindow do
                    'read joystick/lever position
                    if RespDevice% = 0 then  'if physical device is lever
                        DebounceLever%();
                    else  'if physical device is joystick
                        ReadJoystick%();
                    endif;
                    'Update the joystick plot every 5 ms during aggressive waiting
                    if RespDevice% <> 0 and Now-tLastJoyUpdate > .005 then
                        XJoy := View(ctview%).ChanMeasure(configJoyXChannel%,2,Now-.001,Now-.006);
                        YJoy := View(ctview%).ChanMeasure(configJoyYChannel%,2,Now-.001,Now-.006);
                        View(joyview%).XYAddData(joydatachan%,-XJoy,-YJoy);  'both axes need to be "flipped" with negative values to display properly
                        tLastJoyUpdate := Now;
                    endif;
                    'if there's a response, check to see that the response is held for the minimum time
                    if TrialResponse% = 1  and MinRespTime = 0 then 'if there's no minimum response time
                        docase
                        case RespDevice% = -4 then  'For MonoJoystickFRUD, this is forced response masquerading as go/no-go
                            TargetResponse% := YPos%;
                            if TargetMotion% = 1 then 'If correct response on target is up
                                if TargetResponse% = 2 then  'If joystick is down, change YPos% of 2 (down) to 0, leave 1 as 1
                                    TargetResponse% := 0;  'indicates non-target response
                                endif
                            else  'TargetMotion% = 0, correct response on target is down
                                if TargetResponse% = 1 then  'If joystick is up, change YPos% of 1 (up) to 0
                                    TargetResponse% := 0;  'indicates non-target response
                                else
                                    if TargetResponse% = 2 then 'If Joystick is down, change YPos of 2 (down) to 1
                                        TargetResponse% := 1;  'indicates target response
                                    endif
                                endif
                            endif
                        case RespDevice% <= 0 then  'For all go/no-go devices the only response is 1
                            TargetResponse% := 1;  
                        case RespDevice% = 1 then 'If we're using the joystick(up/down response), set response to Y position
                            TargetResponse% := YPos%; 
                        case RespDevice% = 2 then 'If we're using the JoystickYX(left/right response), set response to X position
                            TargetResponse% := XPos%;    
                        endcase;
                        ResponseTime2 := ResponseTime;  'response time should be the latest value
                        if VerboseTrialTiming% = 1 then 'get this out once done with it
                            view(HiddenLogHandle%).print("Response believed to occur at %f\r",ResponseTime2);
                        endif;
                    else
                        'wait for the minimum response duration to signal a response
                        'Note that if the minimum response duration is NOT held, the trial continues as long as
                        'the response window is still open, it does not interrupt. If TrialResponse% becomes 0,
                        'the larger WHILE loop will repeat so long as the response window is still open
                        ResponseTime3 := ResponseTime;  'Get initial response time
                        Now := view(ctview%).maxtime();
                        while TrialResponse% = 1 and Now < ResponseTime3 + MinRespTime do  
                            if RespDevice% = 0 then 'read joystick/lever position
                                DebounceLever%();
                            else  'if physical device is joystick
                                ReadJoystick%();
                            endif;
                            'Update the joystick plot every 5 ms during aggressive waiting
                            if RespDevice% <> 0 and Now-tLastJoyUpdate > .005 then
                                XJoy := View(ctview%).ChanMeasure(configJoyXChannel%,2,Now-.001,Now-.006);
                                YJoy := View(ctview%).ChanMeasure(configJoyYChannel%,2,Now-.001,Now-.006);
                                View(joyview%).XYAddData(joydatachan%,-XJoy,-YJoy);  'both axes need to be "flipped" with negative values to display properly
                                tLastJoyUpdate := Now;
                            endif;
                            yield(.001,1023);
                            Now := view(ctview%).maxtime();
                        wend;
                        if TrialResponse% = 1 then
                            docase
                            case RespDevice% = -4 then  'For MonoJoystickFRUD, this is forced response masquerading as go/no-go
                                TargetResponse% := YPos%;
                                if TargetMotion% = 1 then 'If correct response on target is up
                                    if TargetResponse% = 2 then  'If joystick is down, change YPos% of 2 (down) to 0, leave 1 as 1
                                        TargetResponse% := 0;  'indicates non-target response
                                    endif
                                else  'TargetMotion% = 0, correct response on target is down
                                    if TargetResponse% = 1 then  'If joystick is up, change YPos% of 1 (up) to 0
                                        TargetResponse% := 0;   'indicates non-target response
                                    else
                                        if TargetResponse% = 2 then 'If Joystick is down, change YPos of 2 (down) to 1
                                            TargetResponse% := 1;  'indicates target response
                                        endif
                                    endif
                                endif
                            case RespDevice% <= 0 then  'For all go/no-go devices the only response is 1
                                TargetResponse% := 1;  
                            case RespDevice% = 1 then 'If we're using the joystick(up/down response), set response to Y position
                                TargetResponse% := YPos%; 
                            case RespDevice% = 2 then 'If we're using the JoystickYX(left/right response), set response to X position
                                TargetResponse% := XPos%;
                            endcase;
                            ResponseTime2 := ResponseTime;  'response time should be the latest value
                        endif;
                    endif;
                    'wait one increment
                    yield(.001,1023);
                    Now := view(ctview%).maxtime();
                wend;
                
                
                if TrialResponse% = 0 then  'if we never got a response, set response time to end of response window
                    ResponseTime2 := StimOn + StimDur + RespWindowDelay + ResponseWindow;
                    if RespDevice% = -4 then  'if we're using the MonoJoystickFRUD, no response is NOT equivalent to "nontarget" response
                        TargetResponse% := 100;  'So if there's no response, set TargetResponse to 100 for TrialResultGoNoGo()
                    endif;
                endif;
            endif;
            
            
            if VerboseTrialTiming% = 1 then
                view(HiddenLogHandle%).print("Response recorded or response window over %f\r",ResponseTime2);
            endif;
            
            'determine reward, simple version, note CurrTrialIndex% has already been incremented
            TrialStatusTime := ResponseTime2;
            if VerboseTrialTiming% = 1 then 'get rid of this when done
                view(HiddenLogHandle%).print("TrialStatusTime set to %f\r",TrialStatusTime);
            endif;
            docase  'The big ol' case statement for response evaluation
            case RespDevice% <= 0 then 'Do behavioral data and rewards for go/no-go
                
                'Get trial result
                TrialResultGoNoGo();
                if VerboseTrialTiming% = 1 then 'get rid of this when done
                    view(HiddenLogHandle%).print("After getting trial result, TrialStatusTime is %f and Reward status is %d\r",TrialStatusTime,RewardCount%);
                endif;	
            case RespDevice% > 0 then 'we're using the Joystick, do behavioral data and reward for forced-choice
                'determine expected response
                if NSpeakers% = 2 then  'if we're using stereo stimuli, calculate expected response
                    docase
                    case TargVar%[CurrTrialIndex%] > 0 and TargVar%[CurrTrialIndex%] < 8 and Targvar2%[CurrTrialIndex%] = 0 then
                        ExpectedResponse% := 1;  'Response should be up/right
                    case TargVar%[CurrTrialIndex%] = 0 and TargVar2%[CurrTrialIndex%] > 0 and TargVar2%[CurrTrialIndex%] < 8 then
                        ExpectedResponse% := 2;  'Response should be down/left
                    case TargVar%[CurrTrialIndex%] = 8 and Targvar2%[CurrTrialIndex%] = 0 then
                        ExpectedResponse% := 18;  'Probe 1 trial is up/right
                    case TargVar%[CurrTrialIndex%] = 0 and Targvar2%[CurrTrialIndex%] = 8 then
                        ExpectedResponse% := 28;  'Probe 1 trial is down/left
                    case TargVar%[CurrTrialIndex%] = 9 and Targvar2%[CurrTrialIndex%] = 0 then
                        ExpectedResponse% := 19;  'Probe 2 trial is up/right
                    case TargVar%[CurrTrialIndex%] = 0 and Targvar2%[CurrTrialIndex%] = 9 then
                        ExpectedResponse% := 29;  'Probe 2 trial is down/left
                    case TargVar%[CurrTrialIndex%] = 0 and Targvar2%[CurrTrialIndex%] = 0 then
                        ExpectedResponse% := 0;  'Catch Trial
                    else
                        printlog("Error on trial %d:%d, unrecognized target value combination!\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                        printlog("Up speaker target value is %d and down speaker target value is %d\n",TargVar%[CurrTrialIndex%],TargVar2%[CurrTrialIndex%]);
                        printlog("Assuming proper response is no response!\n");
                        view(HiddenLogHandle%).print("Error on trial %d:%d, unrecognized target value combination!\r",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                        view(HiddenLogHandle%).print("Up speaker target value is %d and down speaker target value is %d\r",TargVar%[CurrTrialIndex%],TargVar2%[CurrTrialIndex%]);
                        view(HiddenLogHandle%).print("Assuming proper response is no response!\r");
                        ExpectedResponse% := 0;  'Just give up, assume no expected response
                    endcase;
                else
                    ExpectedResponse% := TargVar%[CurrTrialIndex%];  'just take the value for this trial straight from the file
                endif;
                
                'Get Trial Result
                docase
                case RespDevice% = 1 then
                    TrialResultForcedChoiceUD(TargVar%[CurrTrialIndex%],TargVar2%[CurrTrialIndex%]);   
                case RespDevice% = 2 then
                    TrialResultForcedChoiceLR(TargVar%[CurrTrialIndex%],TargVar2%[CurrTrialIndex%]);
                endcase;
                
            endcase;
            
            'Print behavioral stats to the log, avoiding divide by zero errors
            PrintBehavStats();  'note that the bias caluclation is also done here; that's kind of counterintuitive, but it actually works out for the best
            'Check for change in target motion, if applicable
            UpdateTargetMotion();
            'Do stairstep, if applicable
            if FadedBInc > 0 or FadedBDec > 0 then  'Don't bother with a stairstep if there isn't a chance to inc/dec
                if StairTargAcc > 0 then
                    StaircasedB();  'use Staircase method on fade-in if StairTargAcc exists
                else 
                    SimpleStepdB(LastResult%);  'otherwise use simple step-up/step-down
                endif;
            endif;
            'Check for perseverance
            CheckPerseverance();
            'Change StimIsRepeating% and StimulusLoaded% if applicable (we're repeating on error and the last result was an error)
            if RepeatOnError% = 1 and LastResult% = -1 then  
                StimIsRepeating% := 1;
                StimulusLoaded% := 0;
            else
                if LastResult% >= 0 then '1 is correct, 0 is for probe responses
                    StimIsRepeating% := 0;
                endif;
            endif;
            
            
            if FeedbackOff% = 0 then  'if accuracy feedback has not been turned off   
                'RewardCount% is assigned by RandReward() in the TrialResult... functions
                if RewardCount% > 0 then
                    Miss% := 0;  'Reset - even if it is a miss, if we are giving a reward do not penalize
                    FalseAlarm% := 0;  'Reset - even if it is a FA, if we are giving a reward do not penalize
                    RewardTime := TrialStatusTime + RewardDelay;
                    SolenoidOpenDurFloat := SolenoidOpenDur%;  'have to convert to a float 
                    NextTrialTime := RewardTime + SolenoidOpenDurFloat/1000 + ITI;
                    PenaltyDoneTime := 0;  'No penalty
                    if VerboseTrialTiming% = 1 then
                        view(HiddenLogHandle%).print("Reward earned at %f, reward to be given at %f\r",TrialStatusTime,RewardTime);
                    endif;
                else
                    docase
                    case Miss% = 1 then
                        Miss% := 0;
                        if VerboseTrialTiming% = 1 then
                            view(HiddenLogHandle%).print("Reward denied (miss), penalty begun %f, next LED at %f\r",TrialStatusTime,TrialStatusTime+MPenaltyTemp+ITI);
                        endif;
                        'NextTrialTime := TrialStatusTime + MPenaltyTemp + ITI + FlashDur;
                        PenaltyDoneTime := TrialStatusTime + MPenaltyTemp + FlashDur;
                        'turn house light off in all incorrect cases
                        CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off)
                        'Start flashing if required
                        if FlashDur > 0 and FlashLEDOnMiss% > 0 then
                            if FlashLEDOnError$ = "c" then
                                FlashOn(Left$(CurrentCueLights$,1),FlashDur*1000,500/FlashLEDFrequency);   'Flashdur in ms, convert FlashFreq to ms and get half-period
                            else
                                FlashOn(Left$(FlashLEDOnError$,1),FlashDur*1000,500/FlashLEDFrequency);   'Flashdur in ms, convert FlashFreq to ms and get half-period
                            endif;
                            'CED does not wait through flash, just starts and moves on
                        endif;                            
                    case FalseAlarm% = 1 then
                        FalseAlarm% := 0;
                        if VerboseTrialTiming% = 1 then
                            view(HiddenLogHandle%).print("Reward denied (FA), penalty begun %f, next LED at %f\r",TrialStatusTime,TrialStatusTime+FAPenalty+ITI);
                        endif;
                        'NextTrialTime := TrialStatusTime + FAPenalty + ITI + FlashDur;
                        PenaltyDoneTime := TrialStatusTime + FAPenalty + FlashDur;
                        'turn incandescent off in all incorrect cases
                        CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off)
                        'Start flashing if required
                        if FlashDur > 0 and FlashLEDOnFA% > 0 then
                            if FlashLEDOnError$ = "c" then
                                FlashOn(Left$(CurrentCueLights$,1),FlashDur*1000,500/FlashLEDFrequency);   'Flashdur in ms, convert FlashFreq to ms and get half-period
                            else
                                FlashOn(Left$(FlashLEDOnError$,1),FlashDur*1000,500/FlashLEDFrequency);   'Flashdur in ms, convert FlashFreq to ms and get half-period
                            endif;                                
                            'CED does not wait through flash, just starts and moves on
                        endif;                            
                    else 'it must be a probe, or a correct trial not rewarded, do what?
                        'Something here?  Change NextTrialTime to include a penalty?
                        NextTrialTime := TrialStatusTime + ITI;
                        PenaltyDoneTime := 0;  'No penalty
                        'turn incandescent off???  For now, no - this functionality is not being used
                        'CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off)
                    endcase;				
                endif;
            else 'if feedback has been turned off
                Miss% := 0;  'reset
                FalseAlarm% := 0;
                RewardCount% := 0;  'set for no reward
                NextTrialTime := TrialStatusTime + ITI;  'time for next trial
                PenaltyDoneTime := 0;  'no penalty
            endif;
            
            if NTrialsFiles% > 1 then
                SwitchToTF% := 0;  'reset SwitchToTF% - if we get here, we are past any interrupts that will force the stimulus to repeat
                TrialsInSwitchWindow% += 1;  'increment number of trials in switch window
                if TrialsInSwitchWindow% >= SwitchWindow% then  'should never be > but just in case
                    arrconst(Correct%[],0);  'clear Correct
                    docase  'Add in all correct responses, case statement is actually unnecessary as only one pair of variables will be filled, could just add all, but it's cleaner
                    case RespDevice% <= 0 then    
                        arradd(Correct%[0:SwitchWindow%],Hits%[TrialCount%-SwitchWindow%:SwitchWindow%]);  
                        arradd(Correct%[0:SwitchWindow%],CRs%[TrialCount%-SwitchWindow%:SwitchWindow%]); 
                        floatHits := arrsum(Hits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatCRs := arrsum(CRs%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatMisses := arrsum(Misses%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatFAs := arrsum(FAs%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                    case RespDevice% = 1 then
                        arradd(Correct%[0:SwitchWindow%],UpHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        arradd(Correct%[0:SwitchWindow%],DownHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatHits := arrsum(UpHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatCRs := arrsum(DownHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatMisses := arrsum(UpMisses%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatFAs := arrsum(DownMisses%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                    case RespDevice% = 2 then
                        arradd(Correct%[0:SwitchWindow%],LeftHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        arradd(Correct%[0:SwitchWindow%],RightHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatHits := arrsum(LeftHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatCRs := arrsum(RightHits%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatMisses := arrsum(LeftMisses%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                        floatFAs := arrsum(RightMisses%[TrialCount%-SwitchWindow%:SwitchWindow%]);
                    endcase;
                    'Check against criteria for switching trials files
                    if CriteriaIndPrime% = 0 then
                        SwitchWindowAcc := arrsum(Correct%[0:SwitchWindow%])/SwitchWindow;  'use float version to get a float
                    else
                        SwitchWindowAcc := dPrime(floatHits/max(floatHits+floatMisses,1),floatFAs/max(floatCRs+floatFAs,1));
                    endif;
                    docase
                    case SwitchWindowAcc >= SwitchHarder then
                        TrialsInSwitchWindow% := -1;  'reset, this will allow us to leave the upcoming trial, which comes from the non-updated trials file, from the next accuracy window
                        if SwitchCurrFile% < NTrialsFiles% then  'if it is possible to get harder
                            SwitchToTF% := SwitchCurrFile% + 1;
                            printlog("Accuracy in switch window is %d percent, changing to harder/next Trial File number %d, (%s)\n",SwitchWindowAcc*100,SwitchToTF%,TrialFileList$[SwitchToTF%-1]);
                            view(HiddenLogHandle%).print("Accuracy in switch window is %d percent, changing to harder/next Trial File number %d, (%s)\r",SwitchWindowAcc*100,SwitchToTF%,TrialFileList$[SwitchToTF%-1]);
                        else
                            if SwitchEasier < 0 then
                                SwitchToTF% := 1;
                                printlog("Accuracy in switch window is %d percent, wrapping to Trial File number %d, (%s)\n",SwitchWindowAcc*100,SwitchToTF%,TrialFileList$[SwitchToTF%-1]);
                                view(HiddenLogHandle%).print("Accuracy in switch window is %d percent, wrapping to Trial File number %d, (%s)\r",SwitchWindowAcc*100,SwitchToTF%,TrialFileList$[SwitchToTF%-1]);
                            else
                                printlog("Accuracy in switch window is %d percent, already on hardest trial file\n",SwitchWindowAcc*100);
                                view(HiddenLogHandle%).print("Accuracy in switch window is %d percent, already on hardest trial file\r",SwitchWindowAcc*100);
                            endif;
                        endif;
                    case SwitchWindowAcc <= SwitchEasier then
                        TrialsInSwitchWindow% := -1;  'reset, this will allow us to leave the upcoming trial, which comes from the non-updated trials file, from the next accuracy window
                        if SwitchCurrFile% > 1 then  'if it is possible to get easier
                            SwitchToTF% := SwitchCurrFile% - 1;
                            printlog("Accuracy in switch window is %d percent, changing to easier Trial File number %d, (%s)\n",SwitchWindowAcc*100,SwitchToTF%,TrialFileList$[SwitchToTF%-1]);
                            view(HiddenLogHandle%).print("Accuracy in switch window is %d percent, changing to easier Trial File number %d, (%s)\r",SwitchWindowAcc*100,SwitchToTF%,TrialFileList$[SwitchToTF%-1]);
                        else
                            printlog("Accuracy in switch window is %d percent, already on easiest trial file\n",SwitchWindowAcc*100);
                            view(HiddenLogHandle%).print("Accuracy in switch window is %d percent, already on easiest trial file\r",SwitchWindowAcc*100);
                        endif; 
                    else
                        TrialsInSwitchWindow% := -1;  'reset, this will allow us to skip the current trial, which comes from the non-updated trials file
                        printlog("Accuracy in switch window is %d percent, remaining with Trial File %d\n",SwitchWindowAcc*100,SwitchCurrFile%);
                        view(HiddenLogHandle%).print("Accuracy in switch window is %d percent, remaining with Trial File %d\r",SwitchWindowAcc*100,SwitchCurrFile%);
                    endcase                        
                endif;  
            endif;
                
            'finally, decide what to do next
            docase
            case RewardCount% > 0 then
                ChangeStateTo(StateReward%, view(ctview%).maxtime(), 1);  'There's been enough happening we don't really know what time it is, get it again
            case PenaltyDoneTime > 0 then
                ChangeStateTo(StateMissFAPenalty%,StimDoneTime,0);
            else
                if NothingToLoad% = 1 then  'if all stimuli are finished, get ready to quit
                    ChangeStateTo(StateDone%,StimDoneTime,1);
                else  'Otherwise we're presenting sounds, so set the PA5
                    ChangeStateTo(StateSetPA5%,StimDoneTime,0);
                endif;
            endcase;
            endif;
            
        case iState% = StateMissFAPenalty% then
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateMissFAPenalty% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if Now > PenaltyDoneTime then
                NextTrialTime := Now + ITI;
                ChangeStateTo(StateSetPA5%,Now,0);  'StateSetPA5 will get back on the active/passive track
            endif;
            endif
            
        case iState% = StateErrorlessResponseWindow% then
            'Wait for response, this version of Errorless will only work for up/down responses
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateErrorlessResponseWindow% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if ExpectedResponseSet% = 0 then  'only set Expected Response the first time through for each trial		
                if TargVar%[CurrTrialIndex%] > 0 then 'for errorless, should be no probes
                    docase
                    case TargetMotion% = 2 then
                        ExpectedResponse% := 1;  'response should be up
                        printlog("Target Up\n");
                        view(HiddenLogHandle%).print("Target Up\r");
                    case TargetMotion% = 1 then
                        ExpectedResponse% := 1;  'response should be up
                        printlog("Target, expected response Up\n");
                        view(HiddenLogHandle%).print("Target, expected response Up\r");
                    case TargetMotion% = 0 then
                        ExpectedResponse% := 2;  'response to a target should be down if TargetMotion is 0
                        printlog("Target, expected response Down\n");
                        view(HiddenLogHandle%).print("Target, expected response Down\r");
                    endcase;
                    ExpectedResponseSet% := 1;
                else
                    docase
                    case TargetMotion% = 2 then
                        ExpectedResponse% := 2;  'response should be down
                        printlog("Target Down\n");
                        view(HiddenLogHandle%).print("Target Down\r");
                    case TargetMotion% = 1 then
                        ExpectedResponse% := 2;  'response should be down
                        printlog("Nontarget, expected response Down\n");
                        view(HiddenLogHandle%).print("Nontarget, expected response Down\r");
                    case TargetMotion% = 0 then
                        ExpectedResponse% := 1;  'response to a non-target should be up if TargetMotion is 0
                        printlog("Nontarget, expected response Up\n");
                        view(HiddenLogHandle%).print("Nontarget, expected response Up\r");
                    endcase;
                    ExpectedResponseSet% := 1;
                endif;
            endif;
            
            if Now >= StimOn + StimDur + RespWindowDelay + ResponseWindow + MinRespTime then  'we have exited response window
                StimDoneTime := Now;
                StimulusPlaying% := 0;
                TrialResult$ := "M";  'Note that the trial was a miss
                ResponseTime2 := StimDoneTime;  'Note time that trial was completed
                UpdatePSTHNow% := 1;
                ExpectedResponseSet% := 0; 'reset
                'incandescent off until next trial begins
                CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off)
                NextTrialTime := StimDoneTime + ITI;
                RewardCount% := 0;  'do not give reward
                if ExpectedResponse% = 1 then  'count no-responses
                    UpNR := UpNR + 1;
                    TotalErrorsUp% := TotalErrorsUp% + TempErrors%;
                else
                    DownNR := DownNR + 1;
                    TotalErrorsDown% := TotalErrorsDown% + TempErrors%;
                endif;
                printlog("No Reponse on stimulus #%d:%d\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                printlog("Total hits = %d, (up = %d, down = %d), Total No Response = %d (up = %d, down = %d), Total errors = %d\n",UpHits+DownHits,UpHits,DownHits,UpNR+DownNR,UpNR,DownNR);
                printlog("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
                printlog("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\n",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
                view(HiddenLogHandle%).print("No Reponse on stimulus #%d:%d.\rTotal hits = %d, (up = %d, down = %d), Total No Response = %d ",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,UpHits+DownHits,UpHits,DownHits);
                view(HiddenLogHandle%).print("(up = %d, down = %d), Total errors = %d\r",UpNR+DownNR,UpNR,DownNR);
                view(HiddenLogHandle%).print("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
                view(HiddenLogHandle%).print("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\r",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
                'Finally, decide what to do once the trial is over
                if NothingToLoad% = 1 then  'if all stimuli are finished, get ready to quit
                    ChangeStateTo(StateDone%,StimDoneTime,1);
                else  'Otherwise we're presenting sounds, so set the PA5
                    ChangeStateTo(StateSetPA5%,StimDoneTime,0);
                endif;
            else 'response window is still open
                'If we left the last iteration in "error" state, check to see if joystick is still in "error" position
                if IsError% = 1 and (YPos% = 0 or YPos% = ExpectedResponse%) then
                    IsError% := 0;  'the previous error is over
                endif;
                'Check joystick position using position calculated in IF #0 - won't enter any other IFs until we're done here
                if YPos% <> PrevPos% then 'if joystick has changed position, get time of change
                    ResponseTime3 := ResponseTime;
                endif;
                if YPos% = ExpectedResponse% and (MinRespTime = 0 or (YPos% = PrevPos% and (Now > ResponseTime3 + MinRespTime))) then
                    'Correct response
                    StimDoneTime := Now;
                    StimulusPlaying% := 0;
                    TrialResult$ := "H";  'Note that the trial was a hit
                    if YPos% = 1 then
                        ChangeThresh(1,0,1,1); 'increment up threshold on up hit, increment x threshold on hit
                    else
                        ChangeThresh(0,1,1,1); 'increment down threshold on down hit, increment x threshold on hit
                    endif;
                    UpdateITI();
                    ResponseTime2 := StimDoneTime;  'Note time that trial was completed
                    UpdatePSTHNow% := 1;
                    ExpectedResponseSet% := 0;  'Reset
                    NextTrialTime := StimDoneTime + ITI;
                    if VerboseTrialTiming% = 1 then
                        view(HiddenLogHandle%).print("Next trial should occur at %f, Stim was done at %f and ITI is %f\r",NextTrialTime,StimDoneTime,ITI);
                    endif;
                    if Errorless% = 1 then
                        if ExpectedResponse% = 1 then
                            RewardCount% := TargVar%[CurrTrialIndex%];  'give reward, according to number of hits requested on top speaker
                        else
                            RewardCount% := TargVar2%[CurrTrialIndex%];  'give reward, according to number of hits requested on bottom speaker
                        endif;
                    else  'Errorless% = 2, no good way to change reward size
                        RewardCount% := 1;
                    endif;
                    RewardTime := StimDoneTime + RewardDelay;
                    'SolenoidOpenDur% := PayHVal;  'Just set the open duration to the hit value
                    SolenoidOpenDur% := JuiceRewardMS%;
                    SolenoidOpenDurFloat := SolenoidOpenDur%;  'have to convert to a float 
                    NextTrialTime := RewardTime + SolenoidOpenDurFloat/1000 + ITI;
                    StimulusLoaded% := 0; 'Now indicate that the stimulus must be loaded (here we load during the ITI rather than the stim.
                    if YPos% = 1 then  'count hits
                        UpHits := UpHits + 1;
                        if TempErrors% = 0 then
                            TotalCorrectNoErrorsUp% := TotalCorrectNoErrorsUp% + 1;
                        endif;
                        TotalErrorsUp% := TotalErrorsUp% + TempErrors%;  'Total errors on up trials
                    else
                        DownHits := DownHits + 1;
                        if TempErrors% = 0 then
                            TotalCorrectNoErrorsDown% := TotalCorrectNoErrorsDown% + 1;
                        endif;
                        TotalErrorsDown% := TotalErrorsDown% + TempErrors%;  'Total errors on down trials
                    endif;
                    'Errorless trials are not compatible with a stairstep, so do simple incrementing only
                    FadedBLast := FadedBInit;  'Hold value of most recent FadedB
                    FadedBInit := FadedBInit - FadedBInc;  'Update value in FadedB
                    if FadedBInit < 0 then
                        FadedBInit := 0;
                    endif;
                    PrevPos% := 0;  'reset Previous Y Position for next stimulus
                    printlog("Hit on stimulus #%d:%d\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                    printlog("Total hits = %d, (up = %d, down = %d), Total No Response = %d (up = %d, down = %d)\n",UpHits+DownHits,UpHits,DownHits,UpNR+DownNR,UpNR,DownNR);
                    printlog("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
                    printlog("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\n",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
                    view(HiddenLogHandle%).print("Hit on stimulus #%d:%d\r",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                    view(HiddenLogHandle%).print("Total hits = %d, (up = %d, down = %d), Total No Response = %d (up = %d, down = %d)\r",UpHits+DownHits,UpHits,DownHits,UpNR+DownNR,UpNR,DownNR);
                    view(HiddenLogHandle%).print("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
                    view(HiddenLogHandle%).print("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\r",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
                    'Finally, decide what to do once the trial is over
                    if RewardCount% > 0 then
                        ChangeStateTo(StateReward%, Now, 1);  'I expect a reward, but in case number of hits requested is zero, should have alternate option
                    else
                        if NothingToLoad% = 1 then  'if all stimuli are finished, get ready to quit
                            ChangeStateTo(StateDone%,StimDoneTime,1);
                        else  'Otherwise we're presenting sounds, so set the PA5
                            ChangeStateTo(StateSetPA5%,StimDoneTime,0);
                        endif;
                    endif;
                else  'error response, response window remains open, trial is not over
                    if IsError% = 0 and YPos% <> ExpectedResponse% and YPos% <> 0 and (MinRespTime = 0 or (YPos% = PrevPos% and (maxtime() > ResponseTime3 + MinRespTime))) then
                        IsError% := 1;
                        TempErrors% := TempErrors% + 1;  'Could use ErrorCount but don't want to think about CurrTrialIndex% increments
                        printlog("Error on stimulus #%d:%d, trial continues.\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                        printlog("Total hits = %d, (up = %d, down = %d), Total No Response = %d (up = %d, down = %d)\n",UpHits+DownHits,UpHits,DownHits,UpNR+DownNR,UpNR,DownNR);
                        printlog("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
                        printlog("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\n",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
                        view(HiddenLogHandle%).print("Error on stimulus #%d:%d, trial continues.\r",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                        view(HiddenLogHandle%).print("Total hits = %d, (up = %d, down = %d), Total No Response = %d (up = %d, down = %d)\r",UpHits+DownHits,UpHits,DownHits,UpNR+DownNR,UpNR,DownNR);
                        view(HiddenLogHandle%).print("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
                        view(HiddenLogHandle%).print("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\r",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
                        'Turn off house light for "error"
                        CueLights("off",CurrentCueLights$,"same");  'Turn off house light, leave cue lights (cue lights should already be off)
                        yield(0.1,1023);  'wait 100 ms
                        'Turn house light back on
                        CueLights("on",CurrentCueLights$,"same");  'Turn on house light, leave cue lights (cue lights should already be off)
                        'otherwise this is not a "new" error but the continuation of the same error, don't count it
                    endif;
                    PrevPos% := YPos%;  'update Y position every time through
                endif;
            endif;
            endif;
            
            
        case iState% = StateMustReleaseLever% then
            'Wait for lever release if lever is pressed prior to the next trial time
            'If lever is not released in time, institute penalty
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateMustReleaseLever% at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if InOrigin% = 1 then 'if lever has been released
                CueLights("on",CurrentCueLights$,"same");  'Turn on house light, leave cue lights (cue lights should already be off)
                NextTrialTime := max(Now+ITI, NextTrialTime);  'Reset NextTrialTime, don't skip any FA/Miss penalty
                ChangeStateTo(StateWaitActiveTrial%, Now, 0);
                view(HiddenLogHandle%).print("Monkey has released lever from early press, next stim will start at %f\r",NextTrialTime);
            else
                if (Now > HoldLeverBegin + ReleaseTO) and ReleaseTO > 0 then
                    'The monkey has held the lever too long, institute penalty
                    NextTrialTime := max(Now+ReleaseTOPenalty, NextTrialTime);  'just use NextTrialTime as the penalty variable rather than create a new one, don't skip any FA/Miss penalty
                    UpdateSPKFile% := 1;   'tell program to update the SPK file during penalty
                    printlog("Release penalty imposed!\n");
                    view(HiddenLogHandle%).print("Release Timeout imposed, penalty will end at %f\r",NextTrialTime);
                    'Increment ReleaseTOPenalty and check that it is below maximum allowed
                    ReleaseTOPenalty := ReleaseTOPenalty*ReleaseTOFactor;
                    if ReleaseTOPenalty > ReleaseTOMax then
                        ReleaseTOPenalty := ReleaseTOMax;
                    endif;
                    ChangeStateTo(StateReleaseTOPenalty%, Now, 0);
                endif;
            endif;
            endif;
            
            
        case iState% = StateReleaseTOPenalty% then
            'Wait through release penalty before returning to StateMustReleaseLever
            if 1 then 'code folding
            if Now > NextTrialTime then
                ChangeStateTo(StateMustReleaseLever%, Now, 0);
                HoldLeverBegin := Now;  'Reset HoldLeverBegin
            endif;
            endif;
            
            
        case iState% = StateReward% then
            'Give reward
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1  then
                view(HiddenLogHandle%).print("Entered StateReward at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            if Now > RewardTime then
                
                'do all of this on every reward
                if VerboseMainLoop% = 1 then
                    view(HiddenLogHandle%).print("Giving reward at %f\r",Now);
                endif;
                if Passive% = 1 then
                    NextTrialTime := NextTrialTime + 2;  'Add 2 second delay for next stim on top of ITI if giving reward in passive scenario
                endif;
                SolenoidKilled% := 0;  'Indicate that solenoid has not been killed
                if TaperRew% = 1 and Now < TapRewSec% then
                    RewFac := 1 + ((TapRewFac-1)*(((TapRewSec%-Now)/TapRewSec%)));
                else
                    RewFac := 1;
                endif;
                sampleseqvar(1,(SolenoidOpenDur%*RewFac)-1);  'Note: SolenoidOpenDur% must be at least 2, do not pass a zero to Sequence Control Script.
                docase
                case GBRew% = 0 then
                    NumRewards% := NumRewards% + 1;  'Count number of rewards given
                case GBRew% = 1 then
                    NumGBRewards% := NumGBRewards% + 1;  'Count number of God Button rewards given
                endcase;
                SafeSampleKeySutter%("R");  'Give reward
                RewardGivenTime := Now; 
                'do only on first reward (if multiple rewards for one trial)
                if FirstReward% = 1 then 'set time of reward as time of first reward, even if there are multiple rewards
                    FirstReward% := 0;  'indicate that it's no longer the first reward       
                    view(ctview%).MemSetItem(MemChanRw%,0,RewardGivenTime,RewardCodes%[]);
                endif;
                if VerboseIncrements% = 1 and TaperRew% = 1 and Now < TapRewSec% then  'even in verbose, only verbose this while reward is changing
                    printlog("The reward factor was %f and the solenoid open duration was %d\n",RewFac,SolenoidOpenDur%*RewFac);
                    view(HiddenLogHandle%).print("The reward factor was %f and the solenoid open duration was %d\r",RewFac,SolenoidOpenDur%*RewFac);
                endif
                RewardCount% := RewardCount% - 1;  'decrement number of remaining rewards
                
                'increment NextTrialTime, RewardTime if there are any remaining rewards
                if RewardCount% > 0 then
                    SolenoidOpenDurFloat := SolenoidOpenDur%*RewFac;  'have to convert to a float, keep reward factor
                    NextTrialTime := NextTrialTime + SolenoidOpenDurFloat/1000;
                    RewardTime := Now + .25 + SolenoidOpenDurFloat/1000;  'put minimum .25 seconds between rewards
                else  'do only after final reward (again if multiple rewards on one trial)
                    FirstReward% := 1;  'reset FirstReward
                    changeStateTo(StateRewardDeliveryWait%,Now,1);   
                    if VerboseTrialTiming% = 1 then  'do printlogging
                        view(HiddenLogHandle%).print("Reward completed %f, next LED at %f (absolute)\r",RewardGivenTime,NextTrialTime);
                    endif;
                    if GodButtonExists% = 0 then
                        printlog("Number of rewards given is %d\n",NumRewards%);
                        view(HiddenLogHandle%).print("Number of rewards given is %d\r",NumRewards%);
                    else
                        printlog("Number of rewards given (Program/God Button/Total) is: %d / %d / %d\n",NumRewards%,NumGBRewards%,NumRewards%+NumGBRewards%);
                        view(HiddenLogHandle%).print("Number of rewards given (Program/God Button/Total) is: %d / %d / %d\r",NumRewards%,NumGBRewards%,NumRewards%+NumGBRewards%);
                    endif;
                endif;
            endif;
            endif;    
            
            
        case iState% = StateRewardDeliveryWait% then
            'Wait for (final) reward to finish
            if 1 then 'code folding
            if VerboseMainLoop% = 1 and AllowMainLoopVerbose% = 1 then
                view(HiddenLogHandle%).print("Entered StateRewardDeliveryWait at %f\r",Now);
                AllowMainLoopVerbose% := 0;  'Don't repeat this 
            endif;
            'Once the reward is over
            if Now > RewardGivenTime + (SolenoidOpenDur%*RewFac/1000) then
                'This state is one of the states that has to decide what to do next
                docase
                case ContReinfDelay >= 0 then  'If we are in a continuous reinforcement scenario, skip back to that
                    ChangeStateTo(StateStartContinuousReinforcement%,Now,0); 
                case NothingToLoad% = 1 then  'if all stimuli are finished, get ready to quit
                    ChangeStateTo(StateDone%,Now,1);
                else  'Otherwise we're presenting sounds, so set the PA5
                    ChangeStateTo(StateSetPA5%,Now,0);
                endcase;
            endif;    
            endif;
            
            
        case iState% = StateDone% then
            'When there are no more trials, decide whether to load more or to quit
            if 1 then 'code folding
            if VerboseMainLoop% = 1 then
                view(HiddenLogHandle%).print("Entered StateDone at %f\r",Now);
            endif;
            'turn off LED, incandescent, SafeSampleKeySutter% won't let it happen until reward is given.
            CueLights("off",CurrentCueLights$,"off");  'Turn off house light, turn off cue lights
            SafeSampleKeySutter%("K");  'Kill the solenoid, just in case
            if ExpectNewStim% = 1 then
                LoadParam%();  
            else
                printlog("Quitting because all trials are complete and we do not expect any more stimuli.\n");
                view(HiddenLogHandle%).print("Quitting because all trials are complete and we do not expect any more stimuli.\r");
                quit%();
            endif;
            endif;
            
            
        else
            'Unknown state!  This should never happen except as a bug during development
            Message("QUITTING!  Tell Jeff - Unknown State: " + str$(iState%));
            Quit%();
        endcase
        
        '==================== End of State Logic Loop ======================
        '
        '
        '==================== End of State Logic Loop ======================
        
        
        'Update PSTHs and online files if requested (IDX file will not include interrupts!)
        if UpdatePSTHNow% = 1 then
            if VerboseMainLoop% = 1 then
                view(HiddenLogHandle%).print("Updating PSTH at %f\r",view(ctview%).maxtime());
            endif;
            UpdatePSTH();
            UpdatePSTHNow% := 0;
        endif;
        
        
        'Normally SPKAppend() is run by UpdatePSTH(), however during penalties UpdatePSTH()
        'does not run.  Append SPK file during penalty to avoid backlog of spikes, otherwise
		'the script might slow down while trying to update at the normal time.  Doing this
		'between 1-2 seconds before next trial will begin to avoid timing problems but give enough
		'time to get a lot of the intervening spikes
        if UpdateSPKFile% = 1 and view(ctview%).maxtime() > NextTrialTime - 2 and view(ctview%).maxtime() < NextTrialTime - 1 then
            if VerboseMainLoop% = 1 then
                view(HiddenLogHandle%).print("Updating SPK file during penalty at %f\r",view(ctview%).maxtime());
            endif;
            SPKappend();
            if VerboseTrialTiming% = 1 then
                view(HiddenLogHandle%).print("Updating SPK file during penalty, %f\r",view(ctview%).maxtime());
            endif;
            UpdateSpkFile% := 0;
        endif;
        
        
    wend;
    

	return 1;  'Return to toolbar
    
end;
'================================ ChangeStateTo ============================
proc ChangeStateTo(stateTo%, tStart, runImmediately)
	iState% := stateTo%;
	if tStart >= 0 then 
        tStateStart := tStart; 'for values > 0 in tStart, use given value for tStateStart
    else 
        tStateStart := view(ctview%).maxtime();  'use -1 in tStart to get current sampling time for tStateStart
    endif;
    if runImmediately > 0 then 
        RepeatMainLoop% := 1; 
    else
        RepeatMainLoop% := 0; 
    endif;
    AllowMainLoopVerbose% := 1;  'if we've changed state, we want to see the new state once in the log file
end;
'================================ UpdatePSTH ============================
proc UpdatePSTH()
	'determine which IDX type to output, IDXTYPE must ALWAYS be a single character to allow
    'proper function of Matlab's READIDXSPK!!!
    if IsSearchBMF% = 1 then
        if Passive% = 0 then
            IDXType$ := "w";  'code for active ("working") during BMF Search, this is new
            UpdateSuccess%[3] := 0;  'use UpdateSuccess% to get SafeUpdate to update the right IDX files 
        else
            IDXType$ := "m";  'code for BMF Search
            UpdateSuccess%[2] := 0;
        endif;
    else
        if Passive% = 0 then
            IDXType$ := "a";  'code for active
            UpdateSuccess%[0] := 0;
        else
            IDXType$ := "p";  'code for passive
            UpdateSuccess%[1] := 0;
        endif;
    endif; 
    IDXupdate(IDXType$);  'update IDX files, does one type-specific and one overall file;
    WriteLightLog();  'write data to the light log
    SPKappend();  'append SPK file
    SafeUpdate(UpdateSuccess%[]);  'update secondary files, if they're not in use
    'Update PSTHs if they exist   
    if tunNWavemarks% > 0 then
        if Passive% = 0 then
            MarkMask4(MemChanHistTriggerA%,StimCodes%[]); 'Set the marker filter for hist trigger channel to one specific StimCode 
            view(hApsthS%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);  'Update single-stim histogram, use marker filter instead of single code
            view(hApsthS%).windowtitle$("A-"+str$(TestStim%[CurrTrialIndex%]) + "-" + StimName$[TestStim%[CurrTrialIndex%]]);  'Rename single-stim histogram
            if OverallPSTHType% > 0 then
                MarkMask4(MemChanHistTriggerAGroup%,GroupStimCodes%[]); 'Set the marker filter for hist trigger channel to the group StimCode
                view(hApsthA%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerAGroup%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                if OverallPSTHType% = 1 then
                    view(hApsthA%).windowtitle$("AM-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                else
                    view(hApsthA%).windowtitle$("BW-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                endif;
            else
                MarkMask(MemChanHistTriggerA%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                view(hApsthA%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);   'Update all spikes histogram, no gate
            endif;
        else
            MarkMask4(MemChanHistTriggerP%,StimCodes%[]); 'Set the marker filter for hist trigger channel to one specific StimCode 
            view(hPpsthS%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);  'Update single-stim histogram, use marker filter instead of single code
            view(hPpsthS%).windowtitle$("P-"+str$(TestStim%[CurrTrialIndex%]) + "-" + StimName$[TestStim%[CurrTrialIndex%]]);  'Rename single-stim histogram
            if OverallPSTHType% > 0 then
                MarkMask4(MemChanHistTriggerPGroup%,GroupStimCodes%[]); 'Set the marker filter for hist trigger channel to the group StimCode
                view(hPpsthA%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerPGroup%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                if OverallPSTHType% = 1 then
                    view(hPpsthA%).windowtitle$("AM-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                else
                    view(hPpsthA%).windowtitle$("BW-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                endif;
            else
                MarkMask(MemChanHistTriggerP%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                view(hPpsthA%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);   'Update all spikes histogram, no gate
            endif;
            'MarkMask(MemChanHistTriggerP%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
            'view(hPpsthA%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);   'Update all spikes histogram, no gate
        endif;
        
        if tunNWavemarks% > 1 then
            if Passive% = 0 then
                MarkMask4(MemChanHistTriggerA%,StimCodes%[]); 'Set the marker filter for hist trigger channel to one specific StimCode 
                view(hApsthS2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);  'Update single-stim histogram, use marker filter instead of single code
                view(hApsthS2%).windowtitle$("A2-"+str$(TestStim%[CurrTrialIndex%]) + "-" + StimName$[TestStim%[CurrTrialIndex%]]);  'Rename single-stim histogram
                if OverallPSTHType% > 0 then
                    MarkMask4(MemChanHistTriggerAGroup%,GroupStimCodes%[]); 'Set the marker filter for hist trigger channel to the group StimCode
                    view(hApsthA2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerAGroup%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                    if OverallPSTHType% = 1 then
                        view(hApsthA2%).windowtitle$("AM2-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    else
                        view(hApsthA2%).windowtitle$("BW2-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    endif;
                else
                    MarkMask(MemChanHistTriggerA%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                    view(hApsthA2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                endif;
                'MarkMask(MemChanHistTriggerA%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                'view(hApsthA2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);   'Update all spikes histogram, no gate
            else
                MarkMask4(MemChanHistTriggerP%,StimCodes%[]); 'Set the marker filter for hist trigger channel to one specific StimCode 
                view(hPpsthS2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);  'Update single-stim histogram, use marker filter instead of single code
                view(hPpsthS2%).windowtitle$("P2-"+str$(TestStim%[CurrTrialIndex%]) + "-" + StimName$[TestStim%[CurrTrialIndex%]]);  'Rename single-stim histogram
                if OverallPSTHType% > 0 then
                    MarkMask4(MemChanHistTriggerPGroup%,GroupStimCodes%[]); 'Set the marker filter for hist trigger channel to the group StimCode
                    view(hPpsthA2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerPGroup%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                    if OverallPSTHType% = 1 then
                        view(hPpsthA2%).windowtitle$("AM2-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    else
                        view(hPpsthA2%).windowtitle$("BW2-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    endif;
                else
                    MarkMask(MemChanHistTriggerP%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                    view(hPpsthA2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                endif;
                'MarkMask(MemChanHistTriggerP%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                'view(hPpsthA2%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);   'Update all spikes histogram, no gate
            endif;
        endif;
        
        if tunNWavemarks% > 2 then
            if Passive% = 0 then
                MarkMask4(MemChanHistTriggerA%,StimCodes%[]); 'Set the marker filter for hist trigger channel to one specific StimCode 
                view(hApsthS3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);  'Update single-stim histogram, use marker filter instead of single code
                view(hApsthS3%).windowtitle$("A3-"+str$(TestStim%[CurrTrialIndex%]) + "-" + StimName$[TestStim%[CurrTrialIndex%]]);  'Rename single-stim histogram
                if OverallPSTHType% > 0 then
                    MarkMask4(MemChanHistTriggerAGroup%,GroupStimCodes%[]); 'Set the marker filter for hist trigger channel to the group StimCode
                    view(hApsthA3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerAGroup%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                    if OverallPSTHType% = 1 then
                        view(hApsthA3%).windowtitle$("AM3-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    else
                        view(hApsthA3%).windowtitle$("BW3-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    endif;
                else
                    MarkMask(MemChanHistTriggerA%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                    view(hApsthA3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                endif;
                'MarkMask(MemChanHistTriggerA%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                'view(hApsthA3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerA%,HistTotal,HistPre);   'Update all spikes histogram, no gate
            else
                MarkMask4(MemChanHistTriggerP%,StimCodes%[]); 'Set the marker filter for hist trigger channel to one specific StimCode 
                view(hPpsthS3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);  'Update single-stim histogram, use marker filter instead of single code
                view(hPpsthS3%).windowtitle$("P3-"+str$(TestStim%[CurrTrialIndex%]) + "-" + StimName$[TestStim%[CurrTrialIndex%]]);  'Rename single-stim histogram
                if OverallPSTHType% > 0 then
                    MarkMask4(MemChanHistTriggerPGroup%,GroupStimCodes%[]); 'Set the marker filter for hist trigger channel to the group StimCode
                    view(hPpsthA3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerPGroup%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                    if OverallPSTHType% = 1 then
                        view(hPpsthA3%).windowtitle$("AM3-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    else
                        view(hPpsthA3%).windowtitle$("BW3-"+StimGroupLabel$[TestStim%[CurrTrialIndex%]]);  'Rename group histogram
                    endif;
                else
                    MarkMask(MemChanHistTriggerP%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                    view(hPpsthA3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);   'Update all spikes histogram, no gate
                endif;
                'MarkMask(MemChanHistTriggerP%,-1,1,-1);  'this resets the marker filter for hist trigger channel for overall histogram
                'view(hPpsthA3%).process(PSTHBeginTime,view(-1).maxtime(),1,1,0,MemChanHistTriggerP%,HistTotal,HistPre);   'Update all spikes histogram, no gate
            endif;
        endif;
        
    endif;
end;

'======================= Test File For Parameter/Trial File Status ======================
'This function checks an input file to determine if it is a parameter or a trials file, should be relatively reliable
'File to test must be closed, this function will open and close the file.
'Returns 1 for old parameter file, 2 for new parameter file, 3 for trials file
'May be slow-ish on long trials files, as there's not an "easy" way to be sure without reading the whole file
func TestParamTrialFile%(TestFile$)
    
    var ReadLine1$;
    var ReadLine2$;
    var Output%;
    var temp%;
    var temp2%;
    var KeepGoing% := 1;
    var LoopedOnce%;
    
    'Open the file in question
    fh0%:=FileOpen(TestFile$,8,0);
    
	'Reading File
    readsetup(""," ","","","	"); 'OK, so here we set the hard separator to nothing (default is tab or comma)
    'The soft separator is set to a space (don't know if that's important)
    'No delimiter is set for the start of a string
    'No delimiter is set for the end of a string
    'The hard separator character for strings that have no start delimiter is set to a tab
    'This combo actually works!
    
    while KeepGoing% do
        
        temp2% := read(ReadLine1$,ReadLine2$);  'Get two entries from parameter/trial file and a temp return value
        
        if LoopedOnce% = 0 then
            temp% := val(ReadLine1$); 'convert to number, will be zero if non-numerical string
            if temp% <> 0 then  'indicates old-style parameter file
                Output% := 1;  'return old-style parameter file
                KeepGoing% := 0;  'Don't keep reading
            else
                LoopedOnce% := 1;  'don't check for old-style parameter file after first line
            endif;
        endif;
        
        if LCase$(ReadLine1$) = "end" then  'will only occur in new-style parameter file
            Output% := 2; 'return new-style parameter file
            KeepGoing% := 0; 'Don't keep reading
        else
            if temp2% < 0 then  'indicates end of file
                KeepGoing% := 0; 'Don't keep reading
                Output% := 3; 'return trials file
            endif;
        endif;
    wend;
    
    fileclose();  'close fh0%, the currently open file
    
    return Output%;
    
end;
'============================== Read New Parameter File ==============================
func ReadParamFile%(ParamFile$)		'ReadParamFile%() loads the new-style parameter files
    
    var DummyA%, DummyB%;  '(Useless) variables in current parameter file format
    var Line1$, Line2$;    'Temporary variables
    var Finished%:=0;      'Keep reading until we are finished
    var TempStimPath%[NMaxStim%];  'A temporary copy of WhichStimPath%[]
    ArrConst(TempStimPath%[],1);  'Fill it with ones just like WhichStimPath%[]
    var TempFdB;            'Temporary var for fixing FadedBMin/Max errors
    var NumRead%;           'Holds number of columns read for each stimulus in the stimulus section
    var TempSPI%;           'Temporary stim path index variable
    var HighStimPath%:=1;      'Holds the highest stimpath specified
    var vdcon;              'Voltage-to-degree conversion factor
    var FourJoy%:=0;        'determines if the program uses an 4-thresh joystick (used in setting default Grow%)
    var GrowSet%:=0;        'keeps track of whether Grow% was set - don't want to automatically change something
    'that was deliberately set
    var PayCRValSet%:=0;
    var PayCRProbSet%:=0;
    var UsedDataMode%:=0;
    var UsedNTrodes%:=0;
    
    'open parameter file again
    fh0%:=FileOpen(ParamFile$,8,0);  
    
    'in case the file open does not work, return
    'this is unexpected because we require a previous open just to get here
    if fh0%<0 then
        message("Warning Message | Unexpected failure to load the Parameter file in ReadParamFile%, please note and tell Jeff!");
        printlog("Unexpected failure to load the Parameter file in LoadNewParam!\n");
        view(HiddenLogHandle%).print("Unexpected failure to load the Parameter file in LoadNewParam!\r");
        return;
    endif;
    
	'Reading Parameter File, Header Variables
    'readsetup(""," ","","","	"); 'OK, so here we set the hard separator to nothing (default is tab or comma), however empty string may default to tab/comma
    'The soft separator is set to a space (don't know if that's important)
    'No delimiter is set for the start of a string
    'No delimiter is set for the end of a string
    'The hard separator character for strings that have no start delimiter is set to a tab
    'This combo actually works!
    'Here is what I've gathered about the read setup.  We are reading all of our variables as strings because we can't predict
    'whether they will be a string or a value.  Fine.  But we don't want to have to put everything in delimiters so we have no
    'string delimiters whatsoever.  As a result, all lines would read as a single string without the fifth argument, the hard
    'separator for non-delimited strings.  We set this to "tab" only, so when we're reading a string, a tab indicates to stop.
    'The tab is also a hard separator by default - it indicates the end of a variable.  The space is a soft separator.  Soft
    'separators are skipped over at the beginning of a read, but allowed as "real" thereafter.  With the space as a soft
    'separator, leading spaces are cut but intermediate (and ending?) spaces are kept, allowing us to, for instance, read in
    'the name of a folder that has spaces in it.  A space cannot be a hard string separator without removing the ability to
    'use folder names containing spaces.  If we make the tab a soft separator instead of a hard separator, multiple successive
    'tabs will not be interpreted as empty variables but will be skipped by the soft separator mechanism.  This allows us to 
    'skip multiple tabs.  However, since spaces must be reserved from being hard string separators, we cannot willy-nilly
    'insert spaces.  Multiple tabs are parsed gracefully, but (trailing) spaces are still killers.
    
    readsetup(",","	 ","","","	"); 'Hard separator is a comma
    'Soft separators are spaces and tabs
    'No delimiter is set for the start of a string
    'No delimiter is set for the end of a string
    'The hard separator character for strings that have no start delimiter is set to a tab
    'This combo will gracefully deal with multiple tabs anywhere and any number
    'of leading (but NOT trailing) spaces
    
    
    'we need an indicator that we're at the end of the variables, say "END" or something
    view(HiddenLogHandle%).print("Parameters used are recorded below\r\r");
    while Finished% = 0 do
        read(Line1$,Line2$);
        view(HiddenLogHandle%).print("%s\t%s\r",Line1$,Line2$);  'reprint line to hidden log window
        docase
            case LCase$(Line1$) = "end" then
            Finished% := 1;
            view(HiddenLogHandle%).print("\r\r");  'put a couple line is after parameters
            case LCase$(Line1$) = "nstim" then
            'stimN% := val(Line2$);  'Now, do nothing!  stimN% will be calculated later from the param file
            case instr(LCase$(Line1$),"stimpath") then    
            if len(Line1$) = 8 then
                StimPath$[0] := Line2$;
            else
                TempSPI% := val(Delstr$(Line1$,0,8));
                HighStimPath% := max(TempSPI%,HighStimPath%); 'keep a record of the highest stimpath assigned
                StimPath$[TempSPI%-1] := Line2$;
            endif;
            case LCase$(Line1$) = "respmode" then
            if LCase$(Line2$) = "passive" then
                Passive% := 1;
            else
                if LCase$(Line2$) = "active" then
                    Passive% := 0;
                else
                    message("Error! The designation "+Line2$+" is not recognized!");
                    printlog("Error! The designation "+Line2$+" is not recognized!\n");
                    view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                    return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
                endif;
            endif;
            case LCase$(Line1$) = "datamode" then
            if LCase$(Line2$) = "behavioral" then
                Behavioral% := 1;
            else
                if LCase$(Line2$) = "recording" then
                    Behavioral% := 0;
                else
                    message("Error! The designation "+Line2$+" is not recognized!");
                    printlog("Error! The designation "+Line2$+" is not recognized!\n");
                    view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                    return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
                endif;
            endif;
            UsedDataMode% := 1;
            case LCase$(Line1$) = "ntrodes" then  'this is incompatible with DATAMODE above, will check below to make sure both are not selected
            NTrodes% := val(Line2$);
            UsedNTrodes% := 1;
            case LCase$(Line1$) = "respdevice" then  'add cases as necessary
            docase
                case LCase$(Line2$) = "lever" then
                RespDevice% := 0;
                case LCase$(Line2$) = "joystick" then  'this is forced choice, on the up-down axis
                RespDevice% := 1;
                case LCase$(Line2$) = "joystickaslever" then
                RespDevice% := -1;
                case LCase$(Line2$) = "downupjoystick" then  'this is go/no-go, down to initiate, up to respond
                RespDevice% := -2;
                case LCase$(Line2$) = "joysticklr" then  'this is forced choice, on the left-right axis
                RespDevice% := 2;
                case LCase$(Line2$) = "joystickasleverlr" then
                RespDevice% := -3;
                case LCase$(Line2$) = "monojoystickfrud" then  'forced response up/down joystick with mono stimulus
                RespDevice% := -4;
            else
                message("Error! The designation "+Line2$+" is not recognized!");
                printlog("Error! The designation "+Line2$+" is not recognized!\n");
                view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
            endcase;
            case LCase$(Line1$) = "speaker" then
            if LCase$(Line2$) = "mono" then
                NSpeakers% := 1;
            else
                if LCase$(Line2$) = "stereo" then
                    NSpeakers% := 2;
                else
                    message("Error! The designation "+Line2$+" is not recognized!");
                    printlog("Error! The designation "+Line2$+" is not recognized!\n");
                    view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                    return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
                endif;
            endif;
            case LCase$(Line1$) = "joysticktype" then
            if LCase$(Line2$) = "human" then
                JoystickType% := 1;
            else
                if LCase$(Line2$) = "monkey" then
                    JoystickType% := 0;
                else
                    message("Error! The designation "+Line2$+" is not recognized!");
                    printlog("Error! The designation "+Line2$+" is not recognized!\n");
                    view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                    return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
                endif;
            endif;
            case LCase$(Line1$) = "groworshift" then
            if LCase$(Line2$) = "grow" then
                Grow% := 1;
                GrowSet% := 1;
            else
                if LCase$(Line2$) = "shift" then
                    Grow% := 0;
                    GrowSet% := 1;
                else
                    message("Error! The designation "+Line2$+" is not recognized!");
                    printlog("Error! The designation "+Line2$+" is not recognized!\n");
                    view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                    return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
                endif;
            endif;
            case LCase$(Line1$) = "targetmotion" then  'add cases as necessary
            if LCase$(Line2$) = "up" then
                TargetMotion% := 1;
            else
                if LCase$(Line2$) = "down" then  'this is forced choice, on the up-down axis
                    TargetMotion% := 0;
                else
                    message("Error! The designation "+Line2$+" is not recognized!");
                    printlog("Error! The designation "+Line2$+" is not recognized!\n");
                    view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                    return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
                endif;
            endif;
            case LCase$(Line1$) = "psthtype" then
            docase
            case LCase$(Line2$) = "all" then
                OverallPSTHType% := 0;
            case LCase$(Line2$) = "am" then
                OverallPSTHType% := 1;
            case LCase$(Line2$) = "bw" then
                OverallPSTHType% := 2;
            else
                message("Error! The designation "+Line2$+" is not recognized!");
                printlog("Error! The designation "+Line2$+" is not recognized!\n");
                view(HiddenLogHandle%).print("Error! The designation "+Line2$+" is not recognized!\r");
                return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
            endcase
            case LCase$(Line1$) = "miniti" then
            MinITI := val(Line2$);
            case LCase$(Line1$) = "respwindow" then
            ResponseWindow := val(Line2$);
            case LCase$(Line1$) = "respwindowdelay" then
            RespWindowDelay := abs(val(Line2$));
            case LCase$(Line1$) = "respwindowdec" then
            RespWindowDec := abs(val(Line2$));  'absolute value prevents negative inc/dec error throughout
            case LCase$(Line1$) = "respwindowinc" then
            RespWindowInc := abs(val(Line2$));
            case LCase$(Line1$) = "respwindowmin" then
            RespWindowMin := val(Line2$);
            case LCase$(Line1$) = "respwindowmax" then
            RespWindowMax := val(Line2$);
            case LCase$(Line1$) = "intpenalty" then
            IntPenalty := val(Line2$);
            case LCase$(Line1$) = "fapenalty" then
            FAPenalty := val(Line2$);
            case LCase$(Line1$) = "mpenalty" then  'generic mpenalty sets all miss penalties
            MPenalty := val(Line2$);
            MPenaltyTUp := val(Line2$);
            MPenaltyTDown := val(Line2$);
            case LCase$(Line1$) = "mpenaltytup" then
            MPenaltyTUp := val(Line2$);   
            case LCase$(Line1$) = "mpenaltytdown" then
            MPenaltyTDown := val(Line2$);    
            case LCase$(Line1$) = "mpenaltytright" then  'this is a cheat, but an easy one
            MPenaltyTUp := val(Line2$);   
            case LCase$(Line1$) = "mpenaltytleft" then  'this is a cheat, but an easy one
            MPenaltyTDown := val(Line2$);    
            case LCase$(Line1$) = "catchpenalty" then
            CatchPenalty := val(Line2$);
            case LCase$(Line1$) = "nrpenalty" then
            NRPenalty := val(Line2$);        
            case LCase$(Line1$) = "lazytime" then
            LazyTO := val(Line2$);
            case LCase$(Line1$) = "lazypenalty" then
            LazyTOPenalty := val(Line2$);
            case LCase$(Line1$) = "lazyfactor" then
            LazyTOFactor := val(Line2$);
            case LCase$(Line1$) = "lazymax" then
            LazyTOMax := val(Line2$);
            case LCase$(Line1$) = "releasetime" then
            ReleaseTO := val(Line2$);
            case LCase$(Line1$) = "releasepenalty" then
            ReleaseTOPenalty := val(Line2$);
            case LCase$(Line1$) = "releasefactor" then
            ReleaseTOFactor := val(Line2$);
            case LCase$(Line1$) = "releasemax" then
            ReleaseTOMax := val(Line2$);
            case LCase$(Line1$) = "rewarddelay" then
            RewardDelay := val(Line2$);
            case LCase$(Line1$) = "trialonsetdelay" then
            TrialOnsetDelay := val(Line2$);
            case LCase$(Line1$) = "trialonsetinc" then
            TrialOnsetInc := abs(val(Line2$));  'absolute value prevents negative inc/dec error throughout
            case LCase$(Line1$) = "trialonsetmax" then
            TrialOnsetMax := val(Line2$);        
            case LCase$(Line1$) = "trialonsetdec" then
            TrialOnsetDec := abs(val(Line2$));
            case LCase$(Line1$) = "trialonsetmin" then
            TrialOnsetMin := val(Line2$);
            case LCase$(Line1$) = "payhprob" then
            PayHProb := val(Line2$);
            PayHUProb := val(Line2$);  'Generic "payhprob" resets all PayH*Probs
            PayHDProb := val(Line2$);
            PayHRProb := val(Line2$);
            PayHLProb := val(Line2$);
            case LCase$(Line1$) = "payhuprob" then
            PayHUProb := val(Line2$);
            case LCase$(Line1$) = "payhdprob" then
            PayHDProb := val(Line2$);
            case LCase$(Line1$) = "payhrprob" then
            PayHRProb := val(Line2$);
            case LCase$(Line1$) = "payhlprob" then
            PayHLProb := val(Line2$);
            case LCase$(Line1$) = "paycrprob" then
            PayCRProb := val(Line2$);
            PayCRProbSet% := 1;
            case LCase$(Line1$) = "paymprob" then
            PayMProb := val(Line2$);
            PayMUProb := val(Line2$);  'Generic "paymprob" resets all PayM*Probs
            PayMDProb := val(Line2$);
            PayMRProb := val(Line2$);
            PayMLProb := val(Line2$);
            case LCase$(Line1$) = "paymuprob" then
            PayMUProb := val(Line2$);
            case LCase$(Line1$) = "paymdprob" then
            PayMDProb := val(Line2$);
            case LCase$(Line1$) = "paymrprob" then
            PayMRProb := val(Line2$);
            case LCase$(Line1$) = "paymlprob" then
            PayMLProb := val(Line2$);
            case LCase$(Line1$) = "payfaprob" then
            PayFAProb := val(Line2$);
            case LCase$(Line1$) = "payptprob" then
            PayPTProb := val(Line2$);
            case LCase$(Line1$) = "paypntprob" then
            PayPNTProb := val(Line2$);
            case LCase$(Line1$) = "paynrprob" then
            PayNRProb := val(Line2$);
            case LCase$(Line1$) = "paycatchprob" then
            PayCatchProb := val(Line2$);
            case LCase$(Line1$) = "payhvalue" then
            PayHVal := val(Line2$);
            PayHUVal := val(Line2$);  'Generic "payhvalue" resets all PayH*Vals
            PayHDVal := val(Line2$);
            PayHLVal := val(Line2$);
            PayHRVal := val(Line2$);
            case LCase$(Line1$) = "payhuvalue" then
            PayHUVal := val(Line2$);
            case LCase$(Line1$) = "payhdvalue" then
            PayHDVal := val(Line2$);
            case LCase$(Line1$) = "payhrvalue" then
            PayHRVal := val(Line2$);
            case LCase$(Line1$) = "payhlvalue" then
            PayHLVal := val(Line2$);
            case LCase$(Line1$) = "paycrvalue" then
            PayCRVal := val(Line2$);
            PayCRValSet% := 1;
            case LCase$(Line1$) = "paynrvalue" then
            PayNRVal := val(Line2$);
            case LCase$(Line1$) = "paymvalue" then
            PayMVal := val(Line2$);
            PayMUVal := val(Line2$);  'Generic "paymvalue" resets all PayM*Vals
            PayMDVal := val(Line2$);
            PayMLVal := val(Line2$);
            PayMRVal := val(Line2$);
            case LCase$(Line1$) = "paymuvalue" then
            PayMUVal := val(Line2$);
            case LCase$(Line1$) = "paymdvalue" then
            PayMDVal := val(Line2$);
            case LCase$(Line1$) = "paymrvalue" then
            PayMRVal := val(Line2$);
            case LCase$(Line1$) = "paymlvalue" then
            PayMLVal := val(Line2$);
            case LCase$(Line1$) = "payfavalue" then
            PayFAVal := val(Line2$);
            case LCase$(Line1$) = "payptvalue" then
            PayPTVal := val(Line2$);
            case LCase$(Line1$) = "paypntvalue" then
            PayPNTVal := val(Line2$);
            case LCase$(Line1$) = "paycatchvalue" then
            PayCatchVal := val(Line2$);
            case LCase$(Line1$) = "xthresh" then  'XTHRESH is generic, set all x thresholds identical
            LeftThreshInner := val(Line2$);
            RightThreshInner := val(Line2$);
            LeftThreshOuter := val(Line2$);
            RightThreshOuter := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "ythresh" then  'YTHRESH is generic, set all Y thresholds identical
            UpThreshInner := val(Line2$);
            DownThreshInner := val(Line2$);
            UpThreshOuter := val(Line2$);
            DownThreshOuter := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "xthreshinc" then  'XTHRESHINC is generic, INC/DEC is used for shifting
            LeftThreshInnerInc := abs(val(Line2$));  'absolute value prevents "negative" errors for inc/dec
            RightThreshInnerInc := abs(val(Line2$)); 'throughout this section
            LeftThreshOuterInc := abs(val(Line2$));
            RightThreshOuterInc := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "ythreshinc" then  'etc.
            UpThreshInnerInc := abs(val(Line2$));
            DownThreshInnerInc := abs(val(Line2$));
            UpThreshOuterInc := abs(val(Line2$));
            DownThreshOuterInc := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "xthreshdec" then
            LeftThreshInnerDec := abs(val(Line2$));
            RightThreshInnerDec := abs(val(Line2$));
            LeftThreshOuterDec := abs(val(Line2$));
            RightThreshOuterDec := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "ythreshdec" then
            UpThreshInnerDec := abs(val(Line2$));
            DownThreshInnerDec := abs(val(Line2$));
            UpThreshOuterDec := abs(val(Line2$));
            DownThreshOuterDec := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "xthreshmax" then  'XTHRESHMAX is generic, but should only be used for back-compatibility
            LeftThreshInnerMax := val(Line2$);   'with 4-thresh version, where inner and outer thresh are identical
            RightThreshInnerMax := val(Line2$);
            LeftThreshOuterMax := val(Line2$);
            RightThreshOuterMax := val(Line2$);
            FourJoy% := 1;  'these may be redundant, but are useful if default values are usedin the param file
            case LCase$(Line1$) = "ythreshmax" then  'etc.
            UpThreshInnerMax := val(Line2$);
            DownThreshInnerMax := val(Line2$);
            UpThreshOuterMax := val(Line2$);
            DownThreshOuterMax := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "xthreshmin" then  'Same for XTHRESHMIN
            LeftThreshInnerMin := val(Line2$);
            RightThreshInnerMin := val(Line2$);
            LeftThreshOuterMin := val(Line2$);
            RightThreshOuterMin := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "ythreshmin" then  'etc.
            UpThreshInnerMin := val(Line2$);
            DownThreshInnerMin := val(Line2$);
            UpThreshOuterMin := val(Line2$);
            DownThreshOuterMin := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "upthresh" then  'Again, all of these values will apply to BOTH inner and outer and
            UpThreshInner := val(Line2$);      'thus correspond to the "old" style with no gaps, for back-compatibility
            UpThreshOuter := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "downthresh" then
            DownThreshInner := val(Line2$);
            DownThreshOuter := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "leftthresh" then
            LeftThreshInner := val(Line2$);
            LeftThreshOuter := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "rightthresh" then
            RightThreshInner := val(Line2$);
            RightThreshOuter := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "upthreshinc" then
            UpThreshInnerInc := abs(val(Line2$));
            UpThreshOuterInc := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "downthreshinc" then
            DownThreshInnerInc := abs(val(Line2$));
            DownThreshOuterInc := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "leftthreshinc" then
            LeftThreshInnerInc := abs(val(Line2$));
            LeftThreshOuterInc := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "rightthreshinc" then
            RightThreshInnerInc := abs(val(Line2$));
            RightThreshOuterInc := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "upthreshdec" then
            UpThreshInnerDec := abs(val(Line2$));
            UpThreshOuterDec := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "downthreshdec" then
            DownThreshInnerDec := abs(val(Line2$));
            DownThreshOuterDec := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "leftthreshdec" then
            LeftThreshInnerDec := abs(val(Line2$));
            LeftThreshOuterDec := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "rightthreshdec" then
            RightThreshInnerDec := abs(val(Line2$));
            RightThreshOuterDec := abs(val(Line2$));
            FourJoy% := 1;
            case LCase$(Line1$) = "upthreshmax" then
            UpThreshInnerMax := val(Line2$);
            UpThreshOuterMax := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "downthreshmax" then
            DownThreshInnerMax := val(Line2$);
            DownThreshOuterMax := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "leftthreshmax" then
            LeftThreshInnerMax := val(Line2$);
            LeftThreshOuterMax := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "rightthreshmax" then
            RightThreshInnerMax := val(Line2$); 
            RightThreshOuterMax := val(Line2$); 
            FourJoy% := 1;
            case LCase$(Line1$) = "upthreshmin" then
            UpThreshInnerMin := val(Line2$);
            UpThreshOuterMin := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "downthreshmin" then
            DownThreshInnerMin := val(Line2$);
            DownThreshOuterMin := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "leftthreshmin" then
            LeftThreshInnerMin := val(Line2$);
            LeftThreshOuterMin := val(Line2$);
            FourJoy% := 1;
            case LCase$(Line1$) = "rightthreshmin" then
            RightThreshInnerMin := val(Line2$);  
            RightThreshOuterMin := val(Line2$);  
            FourJoy% := 1;              
            case LCase$(Line1$) = "upthreshinner" then  'Now use new names to assign new variables individually
            UpThreshInner := val(Line2$); 
            case LCase$(Line1$) = "upthreshouter" then        
            UpThreshOuter := val(Line2$);
            case LCase$(Line1$) = "downthreshinner" then
            DownThreshInner := val(Line2$);
            case LCase$(Line1$) = "downthreshouter" then
            DownThreshOuter := val(Line2$);
            case LCase$(Line1$) = "leftthreshinner" then
            LeftThreshInner := val(Line2$);
            case LCase$(Line1$) = "leftthreshouter" then
            LeftThreshOuter := val(Line2$);
            case LCase$(Line1$) = "rightthreshinner" then
            RightThreshInner := val(Line2$);
            case LCase$(Line1$) = "rightthreshouter" then
            RightThreshOuter := val(Line2$);
            case LCase$(Line1$) = "upthreshinnerinc" then
            UpThreshInnerInc := abs(val(Line2$));
            case LCase$(Line1$) = "upthreshouterinc" then
            UpThreshOuterInc := abs(val(Line2$));
            case LCase$(Line1$) = "downthreshinnerinc" then
            DownThreshInnerInc := abs(val(Line2$));
            case LCase$(Line1$) = "downthreshouterinc" then
            DownThreshOuterInc := abs(val(Line2$));
            case LCase$(Line1$) = "leftthreshinnerinc" then
            LeftThreshInnerInc := abs(val(Line2$));
            case LCase$(Line1$) = "leftthreshouterinc" then
            LeftThreshOuterInc := abs(val(Line2$));
            case LCase$(Line1$) = "rightthreshinnerinc" then
            RightThreshInnerInc := abs(val(Line2$));
            case LCase$(Line1$) = "rightthreshouterinc" then
            RightThreshOuterInc := abs(val(Line2$));
            case LCase$(Line1$) = "upthreshinnerdec" then
            UpThreshInnerDec := abs(val(Line2$));
            case LCase$(Line1$) = "upthreshouterdec" then
            UpThreshOuterDec := abs(val(Line2$));
            case LCase$(Line1$) = "downthreshinnerdec" then
            DownThreshInnerDec := abs(val(Line2$));
            case LCase$(Line1$) = "downthreshouterdec" then
            DownThreshOuterDec := abs(val(Line2$));
            case LCase$(Line1$) = "leftthreshinnerdec" then
            LeftThreshInnerDec := abs(val(Line2$));
            case LCase$(Line1$) = "leftthreshouterdec" then
            LeftThreshOuterDec := abs(val(Line2$));
            case LCase$(Line1$) = "rightthreshinnerdec" then
            RightThreshInnerDec := abs(val(Line2$));
            case LCase$(Line1$) = "rightthreshouterdec" then
            RightThreshOuterDec := abs(val(Line2$));
            case LCase$(Line1$) = "upthreshinnermax" then
            UpThreshInnerMax := val(Line2$);
            case LCase$(Line1$) = "upthreshoutermax" then
            UpThreshOuterMax := val(Line2$);
            case LCase$(Line1$) = "downthreshinnermax" then
            DownThreshInnerMax := val(Line2$);
            case LCase$(Line1$) = "downthreshoutermax" then
            DownThreshOuterMax := val(Line2$);
            case LCase$(Line1$) = "leftthreshinnermax" then
            LeftThreshInnerMax := val(Line2$);
            case LCase$(Line1$) = "leftthreshoutermax" then
            LeftThreshOuterMax := val(Line2$);
            case LCase$(Line1$) = "rightthreshinnermax" then
            RightThreshInnerMax := val(Line2$);
            case LCase$(Line1$) = "rightthreshoutermax" then
            RightThreshOuterMax := val(Line2$); 
            case LCase$(Line1$) = "upthreshinnermin" then
            UpThreshInnerMin := val(Line2$);
            case LCase$(Line1$) = "upthreshoutermin" then
            UpThreshOuterMin := val(Line2$);
            case LCase$(Line1$) = "downthreshinnermin" then
            DownThreshInnerMin := val(Line2$);
            case LCase$(Line1$) = "downthreshoutermin" then
            DownThreshOuterMin := val(Line2$);
            case LCase$(Line1$) = "leftthreshinnermin" then
            LeftThreshInnerMin := val(Line2$);
            case LCase$(Line1$) = "leftthreshoutermin" then
            LeftThreshOuterMin := val(Line2$);
            case LCase$(Line1$) = "rightthreshinnermin" then
            RightThreshInnerMin := val(Line2$);  
            case LCase$(Line1$) = "rightthreshoutermin" then
            RightThreshOuterMin := val(Line2$);  
            case LCase$(Line1$) = "xthreshinner" then  'Now, new generic names to set variables the same for each axis!
            LeftThreshInner := val(Line2$);
            RightThreshInner := val(Line2$);
            case LCase$(Line1$) = "xthreshouter" then  
            LeftThreshOuter := val(Line2$);
            RightThreshOuter := val(Line2$);
            case LCase$(Line1$) = "ythreshinner" then
            UpThreshInner := val(Line2$);
            DownThreshInner := val(Line2$);
            case LCase$(Line1$) = "ythreshouter" then  
            UpThreshOuter := val(Line2$);
            DownThreshOuter := val(Line2$);
            case LCase$(Line1$) = "xthreshinnerinc" then
            LeftThreshInnerInc := abs(val(Line2$));
            RightThreshInnerInc := abs(val(Line2$));
            case LCase$(Line1$) = "xthreshouterinc" then  
            LeftThreshOuterInc := abs(val(Line2$));
            RightThreshOuterInc := abs(val(Line2$));
            case LCase$(Line1$) = "ythreshinnerinc" then
            UpThreshInnerInc := abs(val(Line2$));
            DownThreshInnerInc := abs(val(Line2$));
            case LCase$(Line1$) = "ythreshouterinc" then  
            UpThreshOuterInc := abs(val(Line2$));
            DownThreshOuterInc := abs(val(Line2$));
            case LCase$(Line1$) = "xthreshinnerdec" then
            LeftThreshInnerDec := abs(val(Line2$));
            RightThreshInnerDec := abs(val(Line2$));
            case LCase$(Line1$) = "xthreshouterdec" then  
            LeftThreshOuterDec := abs(val(Line2$));
            RightThreshOuterDec := abs(val(Line2$));
            case LCase$(Line1$) = "ythreshinnerdec" then
            UpThreshInnerDec := abs(val(Line2$));
            DownThreshInnerDec := abs(val(Line2$));
            case LCase$(Line1$) = "ythreshouterdec" then  
            UpThreshOuterDec := abs(val(Line2$));
            DownThreshOuterDec := abs(val(Line2$));
            case LCase$(Line1$) = "xthreshinnermax" then
            LeftThreshInnerMax := val(Line2$);
            RightThreshInnerMax := val(Line2$);
            case LCase$(Line1$) = "xthreshoutermax" then  
            LeftThreshOuterMax := val(Line2$);
            RightThreshOuterMax := val(Line2$);
            case LCase$(Line1$) = "ythreshinnermax" then
            UpThreshInnerMax := val(Line2$);
            DownThreshInnerMax := val(Line2$);
            case LCase$(Line1$) = "ythreshoutermax" then  
            UpThreshOuterMax := val(Line2$);
            DownThreshOuterMax := val(Line2$);
            case LCase$(Line1$) = "xthreshinnermin" then
            LeftThreshInnerMin := val(Line2$);
            RightThreshInnerMin := val(Line2$);
            case LCase$(Line1$) = "xthreshoutermin" then  
            LeftThreshOuterMin := val(Line2$);
            RightThreshOuterMin := val(Line2$);
            case LCase$(Line1$) = "ythreshinnermin" then
            UpThreshInnerMin := val(Line2$);
            DownThreshInnerMin := val(Line2$);
            case LCase$(Line1$) = "ythreshoutermin" then  
            UpThreshOuterMin := val(Line2$);
            DownThreshOuterMin := val(Line2$);
            case LCase$(Line1$) = "godbutton" then
            GodButtonExists% := val(Line2$);
            case LCase$(Line1$) = "contreinfdelay" then
            ContReinfDelay := val(Line2$);    
            case LCase$(Line1$) = "contreinfdelayinc" then
            ContReinfDelayInc := abs(val(Line2$));   'absolute value prevents negative increments/decrements throughout
            case LCase$(Line1$) = "contreinfdelaydec" then
            ContReinfDelayDec := abs(val(Line2$));
            case LCase$(Line1$) = "contreinfdelaymax" then
            ContReinfDelayMax := val(Line2$);
            case LCase$(Line1$) = "contreinfdelaymin" then
            ContReinfDelayMin := val(Line2$);
            case LCase$(Line1$) = "contreinfto" then
            ContReinfTO := val(Line2$);
            case LCase$(Line1$) = "fadedbinit" then 'these variable names retired due to confusion, retained for compatibility
            FadedBInit := val(Line2$);
            case LCase$(Line1$) = "fadedbinc" then 'these variable names retired due to confusion, retained for compatibility
            FadedBInc := abs(val(Line2$));  'absolute value prevents negative increments/decrements throughout
            case LCase$(Line1$) = "fadedbdec" then 'these variable names retired due to confusion, retained for compatibility
            FadedBDec := abs(val(Line2$));    
            case LCase$(Line1$) = "fadedbmax" then 'these variable names retired due to confusion, retained for compatibility
            FadedBMax := val(Line2$); 
            case LCase$(Line1$) = "fadedbmin" then 'these variable names retired due to confusion, retained for compatibility
            FadedBMin := val(Line2$);   
            case LCase$(Line1$) = "fadeinitatten" then 'new variable name, not confusing
            FadedBInit := val(Line2$);
            case LCase$(Line1$) = "fadecorrect" then 'new variable name, not confusing
            FadedBInc := abs(val(Line2$));  'absolute value prevents negative increments/decrements throughout
            case LCase$(Line1$) = "fadewrong" then 'new variable name, not confusing
            FadedBDec := abs(val(Line2$));    
            case LCase$(Line1$) = "fademaxatten" then 'new variable name, not confusing
            FadedBMax := val(Line2$);
            case LCase$(Line1$) = "fademinatten" then 'new variable name, not confusing
            FadedBMin := val(Line2$);        
            case LCase$(Line1$) = "errorless" then
            Errorless% := val(Line2$);
            case LCase$(Line1$) = "repeatonerror" then
            RepeatOnError% := val(Line2$);
            case LCase$(Line1$) = "interleaved" and ParamsLoadedOnce% = 0 then
            Interleaved% := val(Line2$);
            case LCase$(Line1$) = "passiveandactive" and ParamsLoadedOnce% = 0 then
            PassiveAndActive% := val(Line2$);
            case LCase$(Line1$) = "interleaved" and ParamsLoadedOnce% = 1 then
            if val(Line2$) <> Interleaved% then
                message("Note! The Interleaved value was "+Str$(Interleaved%)+" and cannot change to "+Line2$+"!! Press to continue!");
            endif;
            case LCase$(Line1$) = "passiveandactive" and ParamsLoadedOnce% = 1 then
            if val(Line2$) <> PassiveAndActive% then
                message("Note! The PassiveAndActive value was "+Str$(PassiveAndActive%)+" and cannot change to "+Line2$+"!! Press to continue!");
            endif;
            case LCase$(Line1$) = "expectnewstim" then
            ExpectNewStim% := val(Line2$);
            case LCase$(Line1$) = "issearchbmf" then
            IsSearchBMF% := val(Line2$);
            case LCase$(Line1$) = "additiactive" then
            AddITIactive := val(Line2$);
            case LCase$(Line1$) = "additipassive" then
            AddITIpassive := val(Line2$);
            case LCase$(Line1$) = "taperreward" then
            TaperRew% := val(Line2$);
            case LCase$(Line1$) = "taprewfac" then
            TapRewFac := val(Line2$);
            case LCase$(Line1$) = "taprewsec" then
            TapRewSec% := val(Line2$);
            case LCase$(Line1$) = "paypassprob" then
            PayPassProb := val(Line2$);
            case LCase$(Line1$) = "paypassvalue" then
            PayPassVal := val(Line2$);
            case LCase$(Line1$) = "collecteeg" then
            CollectEEG% := val(Line2$);
            case LCase$(Line1$) = "minresptime" then
            MinRespTime := val(Line2$);
            case LCase$(Line1$) = "fastswitch" then
            FastSwitch% := val(Line2$);
            case LCase$(Line1$) = "fadedbiv" then  'obsolete as of v1.1.8
            StairTargAcc := val(Line2$);
            case LCase$(Line1$) = "stairtargacc" then
            StairTargAcc := val(Line2$);    
            case LCase$(Line1$) = "persevn" then
            PersevN := val(Line2$);
            case LCase$(Line1$) = "persevpct" then
            PersevPct := val(Line2$);
            case LCase$(Line1$) = "brkpersevn" then
            BrkPersevN := val(Line2$);
            case LCase$(Line1$) = "brkpersevpct" then
            BrkPersevPct := val(Line2$);
            case LCase$(Line1$) = "contreinfinit" then
            ContReinfInit$ := LCase$(Line2$);
            case LCase$(Line1$) = "contreinfend" then
            ContReinfEnd$ := LCase$(Line2$);   
            case LCase$(Line1$) = "feedbackoff" then
            FeedbackOff% := val(Line2$);
            case LCase$(Line1$) = "numhitscr" then
            NumHitsCR% := val(Line2$);
            case LCase$(Line1$) = "motion" then
            Motion% := val(Line2$);    
            case LCase$(Line1$) = "trialwrap" then
            TrialWrap% := val(Line2$);  
            case LCase$(Line1$) = "oneaxis" then
            OneAxis% := val(Line2$); 
            case LCase$(Line1$) = "fixation" then
            DoFixation% := val(Line2$);
            case LCase$(Line1$) = "calibration" then
            CalibrationMode := val(Line2$); 
            'CalibrationMode settings
            'If in Calibration Mode, set several variables to standard calibration-worthy values
            'Do this in the Docase statement so that later parameter file variables can modify these
            'values - for example, if you want to calibrate in stereo...
            RespDevice% := 0;  'Response device is lever (if there is a response device)
            NSpeakers% := 1;  'Speaker is mono
            IntPenalty := 0;  'No interrupt penalty
            FAPenalty := 0;  'No FA penalty
            MPenalty := 0;  'No Miss penalty
            ReleaseTO := 200;  'Release timeout is 200 seconds...but no penalty
            ReleaseTOPenalty := 0;  'No Release penalty
            FeedbackOff% := 1;  'Do not give feedback
            UsedNTrodes% := 1;  'assert that we have used the NTrodes (i.e. newer) syntax
            if CalibrationMode = 1 then  'and some specific settings depending on whether it is ballistic or not
            Passive% := 0;  'Response mode is active
            NTrodes% := 0;  'Don't record
            MinITI := 0.5;  'Leave half a second between stimuli
            TrialOnsetDelay := 0.2;  'Start trial 200 ms after button press
            else
                if CalibrationMode < 0 then
                    Passive% := 1;  'Response mode is passive
                    NTrodes% := 1;  'Record the sound being played in ballistic calibrations
                    MinITI := -CalibrationMode;  'use value in CalibrationMode to set delay between stimuli
                    TrialOnsetDelay := 0;  'don't use a trial onset delay
                    AddITIpassive := 0;  'change default passive ITI random to 0
                endif
            endif            
            case LCase$(Line1$) = "cuelight" then
            CueLightEachTrial% := val(Line2$);
            case LCase$(Line1$) = "cuelightoverride" then
            CueLightOverride$ := Line2$;
            case LCase$(Line1$) = "cuelightfrudup" then
            CueLightFRUDUp$ := Line2$;
            case LCase$(Line1$) = "cuelightfruddown" then
            CueLightFRUDDown$ := Line2$;
            case LCase$(Line1$) = "ignorejoythreshcap" then
            IgnoreJoyThreshCap% := val(Line2$);
            case LCase$(Line1$) = "checkjoytime" then
            CheckJoyTime := val(Line2$);
            case LCase$(Line1$) = "doresponsebias" then
            DoResponseBias% := val(Line2$);
            case LCase$(Line1$) = "biastapertrials" then
            BiasTaper% := val(Line2$);   
            case LCase$(Line1$) = "biaswindow" then
            BiasWindow% := val(Line2$); 
            case LCase$(Line1$) = "biasmax" then
            BiasMax := val(Line2$);   
            case LCase$(Line1$) = "ledtoflash" then
            FlashLEDOnError$ := Left$(Line2$,1);
            case LCase$(Line1$) = "flashoncuechange" then
            FlashLEDOnCueChange% := val(Line2$);
            case LCase$(Line1$) = "flashonmiss" then
            FlashLEDOnMiss% := val(Line2$);
            case LCase$(Line1$) = "flashonfa" then
            FlashLEDOnFA% := val(Line2$);
            case LCase$(Line1$) = "flashfreq" then
            FlashLEDFrequency := val(Line2$);
            case LCase$(Line1$) = "flashccdur" then
            FlashLEDCCDur := val(Line2$);
            case LCase$(Line1$) = "flasherrordur" then
            FlashLEDErrorDur := val(Line2$);
            case LCase$(Line1$) = "ntrialsfiles" then
            NTrialsFiles% := val(Line2$);
            case LCase$(Line1$) = "switchwindow" then
            SwitchWindow% := val(Line2$);
            case LCase$(Line1$) = "switchharder" then
            SwitchHarder := val(Line2$);
            case LCase$(Line1$) = "switcheasier" then
            SwitchEasier := val(Line2$);
            case LCase$(Line1$) = "switchstartfile" then
            SwitchCurrFile% := val(Line2$);
            case LCase$(Line1$) = "criteriaindprime" then
            CriteriaIndPrime% := val(Line2$);
            case LCase$(Line1$) = "deltaiti" then
            DeltaITI := val(Line2$);
            case LCase$(Line1$) = "maxdeltaiti" then
            MaxDeltaITI := val(Line2$);
            case LCase$(Line1$) = "continuousrove" then
            ContinuousRove := val(Line2$);
            case LCase$(Line1$) = "targetmotionwindow" then
            TargetMotionWindow% := val(Line2$);
            case LCase$(Line1$) = "targetmotiondprimecrit" then
            TargetMotiondPrimeCrit := val(Line2$);
            case LCase$(Line1$) = "pa5absent" then
            PA5Absent% := val(Line2$);
        else
            message("The parameter file variable "+Line1$+" is not recognized!");
            printlog("The parameter file variable "+Line1$+" is not recognized!\n");
            view(HiddenLogHandle%).print("The parameter file variable "+Line1$+" is not recognized!\r");
            return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        endcase;
    wend;
    
    
    'And now...the dummy-proofing!
    
    
	'check that the six -- five -- variables that don't have default values are filled
    docase
        case not asc(StimPath$[0]) then  'Only checking for the first entry in StimPath, any other error not caught
		message("The variable 'stimpath' must be filled!");
        printlog("The variable 'stimpath' must be filled!\n");
        view(HiddenLogHandle%).print("The variable 'stimpath' must be filled!\r");
		return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        case Passive%<0 then
		message("The variable 'respmode' must be filled!");
        printlog("The variable 'respmode' must be filled!\n");
        view(HiddenLogHandle%).print("The variable 'respmode' must be filled!\r");
		return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        'case Behavioral%<0 then
		'message("The variable 'datamode' must be filled!");
        'printlog("The variable 'datamode' must be filled!\n");
        'view(HiddenLogHandle%).print("The variable 'datamode' must be filled!\r");
		'return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        case RespDevice% = -100 then
		message("The variable 'respdevice' must be filled!");
        printlog("The variable 'respdevice' must be filled!\n");
        view(HiddenLogHandle%).print("The variable 'respdevice' must be filled!\r");
		return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        case NSpeakers% < 1 then
		message("The variable 'speaker' must be filled!");
        printlog("The variable 'speaker' must be filled!\n");
        view(HiddenLogHandle%).print("The variable 'speaker' must be filled!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endcase;
    
    'independent check for Datamode/NTrodes as of 1.4.19 when NTrodes was introduced
    docase
    case UsedDataMode% = 0 and UsedNTrodes% = 0 then  'neither specified, this is an error
        message("Either NTrodes% or Datamode must be specified!");
        printlog("Either NTrodes% or Datamode must be specified!\n");
        view(HiddenLogHandle%).print("Either NTrodes% or Datamode must be specified!\r");
		return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    case UsedDataMode% = 1 and UsedNTrodes% = 0 then  'Only Datamode specified, this is legacy for backwards compatibility
        if Behavioral% = 0 then
            NTrodes% := 1;  'If we are recording without 'trode spec, use one 'trode on non-Thomas
        else
            NTrodes% := 0;  'If not, zero 'trodes, of course
        endif;
    case UsedDataMode% = 0 and UsedNTrodes% = 1 then  'Only NTrodes% specified, this is new version, set Behavioral properly (eventually excise Behavioral!)
        if NTrodes% = 0 then
            Behavioral% := 1;
        else
            Behavioral% := 0;
        endif;
    case UsedDataMode% = 1 and UsedNTrodes% = 1 then  'both specified, this is only an error if they are incompatible
        if(NTrodes% = 0 and Behavioral% = 1) or (NTrodes% > 0 and Behavioral% = 0) then 'this is OK
            message("You have specified both NTrodes% and Datamode!  Values are legal but update parameter file to remove Datamode!");
            printlog("You have specified both NTrodes% and Datamode!  Values are legal but update parameter file to remove Datamode!\n");
            view(HiddenLogHandle%).print("You have specified both NTrodes% and Datamode!  Values are legal but update parameter file to remove Datamode!\r");
        else  'Not OK, NTrodes% and Behavioral are in conflict
            message("You have specified both NTrodes% and Datamode!  Values are in conflict!  Quitting!");
            printlog("You have specified both NTrodes% and Datamode!  Values are in conflict!  Quitting!\n");
            view(HiddenLogHandle%).print("You have specified both NTrodes% and Datamode!  Values are in conflict!  Quitting!\r");
            return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        endif;
    endcase;
    
    if NTrodes% > 3 then
        message("The maximum number of electrodes is 3!  Quitting!");
        printlog("The maximum number of electrodes is 3!  Quitting!\n");
        view(HiddenLogHandle%).print("The maximum number of electrodes is 3!  Quitting!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    
    ' ' ' ' ' ' Default setting and dummy-checking for days! ' ' ' ' ' ' 
    
        
    
    
    'Set PayCR variables to hit values if not specified; do not leave as default
    if PayCRValSet% = 0 then
        PayCRVal := PayHVal;
    endif;
    if PayCRProbSet% = 0 then
        PayCRProb := PayHProb;
    endif;
    
    
    'make sure lever, godbutton, motion are not set simultaneously, because they use the same input port
    docase
    case RespDevice% = 0 and GodButtonExists% = 1 then
        printlog("Parameter File Error!  Lever and God Button use same input port and cannot be used together!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Lever and God Button use same input port and cannot be used together!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    case RespDevice% = 0 and Motion% = 1 then
        printlog("Parameter File Error!  Lever and motion detector use same input port and cannot be used together!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Lever and motion detector use same input port and cannot be used together!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    case Motion% = 1 and GodButtonExists% = 1 then
        printlog("Parameter File Error!  Motion detector and God Button use same input port and cannot be used together!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Motion detector and God Button use same input port and cannot be used together!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endcase
    
    
    'Set a default value for Grow% based on joystick variables used, unless one has been specifically set
    if GrowSet% = 0 then
        if FourJoy% = 1 then  'if the joystick is a four-threshold rather than eight-threshold
            Grow% := 0;  'by default use shifting increments for four-threshold
        else
            Grow% := 1;  'by default use grow/shrink increments for eight-threshold
        endif;
    endif;
    
    'Make sure that a Target Motion is set for MonoJoystickFRUD
    if RespDevice% = -4 and TargetMotion% = 2 then
        printlog("Parameter File Error!  TargetMotion must be set if response device is MonoJoystickFRUD!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  TargetMotion must be set if response device is MonoJoystickFRUD!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    'And not set otherwise
    if RespDevice% <> -4 and TargetMotion% <> 2 then 'don't allow definition of target motion except for MonoJoystickFRUD
        message("TargetMotion cannot be set using this response device!  Unsetting!");
        TargetMotion% := 2;
    endif;
    
    
    
    'Put a cap on UpThreshInnerMax, etc. based on allowable travel in position on the chairs
    if IgnoreJoyThreshCap% = 0 then
        if LeftThreshInnerMax > 25 then
            LeftThreshInnerMax := 25;
            message("LeftThreshInnerMax has been automatically reduced to 25!")  'temporary change, permanent solution?
        endif;
        if LeftThreshOuterMax > 25 then
            LeftThreshOuterMax := 25;
            message("LeftThreshOuterMax has been automatically reduced to 25!")  'temporary change, permanent solution?
        endif;
        if RightThreshInnerMax > 18 then
            RightThreshInnerMax := 18;
            message("RightThreshInnerMax has been automatically reduced to 18!")
        endif;
        if RightThreshOuterMax > 18 then
            RightThreshOuterMax := 18;
            message("RightThreshOuterMax has been automatically reduced to 18!")
        endif;
        if UpThreshInnerMax > 18 then
            UpThreshInnerMax := 18;
            message("UpThreshInnerMax has been automatically reduced to 18!")
        endif;
        if UpThreshOuterMax > 18 then
            UpThreshOuterMax := 18;
            message("UpThreshOuterMax has been automatically reduced to 18!")
        endif;
        if DownThreshInnerMax > 18 then
            DownThreshInnerMax := 18;
            message("DownThreshInnerMax has been automatically reduced to 18!")
        endif;
        if DownThreshOuterMax > 18 then
            DownThreshOuterMax := 18;
            message("DownThreshOuterMax has been automatically reduced to 18!")
        endif;
    endif; 
    
    'Make sure that inner thresholds are not greater than outer thresholds
    if UpThreshInner > UpThreshOuter then
        printlog("Parameter File Error!  The Inner Up Threshold cannot be greater than the Outer Up Threshold!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  The Inner Up Threshold cannot be greater than the Outer Up Threshold!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if DownThreshInner > DownThreshOuter then
        printlog("Parameter File Error!  The Inner Down Threshold cannot be greater than the Outer Down Threshold!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  The Inner Down Threshold cannot be greater than the Outer Down Threshold!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if LeftThreshInner > LeftThreshOuter then
        printlog("Parameter File Error!  The Inner Left Threshold cannot be greater than the Outer Left Threshold!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  The Inner Left Threshold cannot be greater than the Outer Left Threshold!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if RightThreshInner > RightThreshOuter then
        printlog("Parameter File Error!  The Inner Right Threshold cannot be greater than the Outer Right Threshold!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  The Inner Right Threshold cannot be greater than the Outer Right Threshold!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    'Make sure that inner/outer min/max values are also logical
    if UpThreshOuterMax < UpThreshOuterMin then
        printlog("Parameter File Error!  Up Outer Threshold Max cannot be less than Up Outer Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Up Outer Threshold Max cannot be less than Up Outer Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if DownThreshOuterMax < DownThreshOuterMin then
        printlog("Parameter File Error!  Down Outer Threshold Max cannot be less than Down Outer Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Down Outer Threshold Max cannot be less than Down Outer Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if LeftThreshOuterMax < LeftThreshOuterMin then
        printlog("Parameter File Error!  Left Outer Threshold Max cannot be less than Left Outer Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Left Outer Threshold Max cannot be less than Left Outer Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if RightThreshOuterMax < RightThreshOuterMin then
        printlog("Parameter File Error!  Right Outer Threshold Max cannot be less than Right Outer Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Right Outer Threshold Max cannot be less than Right Outer Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if UpThreshInnerMax < UpThreshInnerMin then
        printlog("Parameter File Error!  Up Inner Threshold Max cannot be less than Up Inner Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Up Inner Threshold Max cannot be less than Up Inner Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if DownThreshInnerMax < DownThreshInnerMin then
        printlog("Parameter File Error!  Down Inner Threshold Max cannot be less than Down Inner Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Down Inner Threshold Max cannot be less than Down Inner Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if LeftThreshInnerMax < LeftThreshInnerMin then
        printlog("Parameter File Error!  Left Inner Threshold Max cannot be less than Left Inner Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Left Inner Threshold Max cannot be less than Left Inner Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if RightThreshInnerMax < RightThreshInnerMin then
        printlog("Parameter File Error!  Right Inner Threshold Max cannot be less than Right Inner Threshold Min!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Right Inner Threshold Max cannot be less than Right Inner Threshold Min!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    'More threshold checks
    'The below error is the only fatal one.  If some of the other thresholds are whacked, they just won't get there.
    if UpThreshInnerMin > UpThreshOuterMax then
        printlog("Parameter File Error!  Up Inner Threshold Min cannot be greater than Up Threshold Outer Max!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Up Inner Threshold Min cannot be greater than Up Threshold Outer Max!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if DownThreshInnerMin > DownThreshOuterMax then
        printlog("Parameter File Error!  Down Inner Threshold Min cannot be greater than Down Threshold Outer Max!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Down Inner Threshold Min cannot be greater than Down Threshold Outer Max!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if LeftThreshInnerMin > LeftThreshOuterMax then
        printlog("Parameter File Error!  Left Inner Threshold Min cannot be greater than Left Threshold Outer Max!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Left Inner Threshold Min cannot be greater than Left Threshold Outer Max!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if RightThreshInnerMin > RightThreshOuterMax then
        printlog("Parameter File Error!  Right Inner Threshold Min cannot be greater than Right Threshold Outer Max!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Right Inner Threshold Min cannot be greater than Right Threshold Outer Max!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    'ALSO - we must make sure that the initial thresholds start at a legal value!
    if UpThreshInner > UpThreshInnerMax or UpThreshInner < UpThreshInnerMin then
        printlog("Parameter File Error!  Initial Up Inner Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Up Inner Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if DownThreshInner > DownThreshInnerMax or DownThreshInner < DownThreshInnerMin then
        printlog("Parameter File Error!  Initial Down Inner Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Down Inner Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if LeftThreshInner > LeftThreshInnerMax or LeftThreshInner < LeftThreshInnerMin then
        printlog("Parameter File Error!  Initial Left Inner Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Left Inner Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if RightThreshInner > RightThreshInnerMax or RightThreshInner < RightThreshInnerMin then
        printlog("Parameter File Error!  Initial Right Inner Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Right Inner Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if UpThreshOuter > UpThreshOuterMax or UpThreshOuter < UpThreshOuterMin then
        printlog("Parameter File Error!  Initial Up Outer Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Up Outer Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if DownThreshOuter > DownThreshOuterMax or DownThreshOuter < DownThreshOuterMin then
        printlog("Parameter File Error!  Initial Down Outer Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Down Outer Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if LeftThreshOuter > LeftThreshOuterMax or LeftThreshOuter < LeftThreshOuterMin then
        printlog("Parameter File Error!  Initial Left Outer Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Left Outer Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if RightThreshOuter > RightThreshOuterMax or RightThreshOuter < RightThreshOuterMin then
        printlog("Parameter File Error!  Initial Right Outer Threshold is not within defined Min/Max limits!\n");
        view(HiddenLogHandle%).print("Parameter File Error!  Initial Right Outer Threshold is not within defined Min/Max limits!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    
	'Check variables which take negative values to mean "get value from another variable"
    if ContReinfDelayMin < 0 then
        ContReinfDelayMin := ContReinfDelay;
    endif;
    if RespWindowMax < 0 then
        RespWindowMax := ResponseWindow;
    endif;
    if FadedBDec < 0 then  'this will NOT be defeated by the ABS() added above
        FadedBDec := FadedBInc;
    endif;
    
    
    'Check we didn't screw up the FadedBMin/FadedBMax, because min corresponds to minimum attenuation
    if FadedBMin > FadedBMax then 
        TempFdB := FadedBMin;
        FadedBMin := FadedBMax;
        FadedBMax := TempFdB;
    endif;
    'Make sure FadedBMin is not negative, that would error the PA5
    if FadedBMin < 0 then
        FadedBMin := 0;
        message("FadedBMin was negative, has been automatically increased to 0!")
    endif;
    'Make sure FadedBMax is not 0 or negative, that is wrong, and would error the PA5 if negative
    if FadedBMax <= 0 then
        FadedBMax := 100;
        message("FadedBMax was 0 or negative, has been automatically increased to 100!")
    endif;
    
    
    
    
	'Check Pay Values - since we'd like to be consistent, Pay Values should probably be specified in
	'seconds rather than milliseconds, but ms are needed later (and are also in all legacy parameter
	'files.
    if PayPassVal < 2 then
        PayPassVal := PayPassVal*1000;  'convert to milliseconds if less than 2
        '2 is a good cutoff because the minimum legal
        'duration is 2 ms and the maximum legal duration
        'is 1999 ms.
    endif;
    if PayHVal < 2 then
        PayHVal := PayHVal*1000;  
    endif;
    if PayHUVal < 2 then
        PayHUVal := PayHUVal*1000;  
    endif;
    if PayHDVal < 2 then
        PayHDVal := PayHDVal*1000;  
    endif;
    if PayHRVal < 2 then
        PayHRVal := PayHRVal*1000;  
    endif;
    if PayHLVal < 2 then
        PayHLVal := PayHLVal*1000;  
    endif;
    if PayCRVal < 2 then
        PayCRVal := PayCRVal*1000;  
    endif;
    if PayMVal < 2 then
        PayMVal := PayMVal*1000;  
    endif;
    if PayMUVal < 2 then
        PayMUVal := PayMUVal*1000;  
    endif;
    if PayMDVal < 2 then
        PayMDVal := PayMDVal*1000; 
    endif;    
    if PayMLVal < 2 then
        PayMLVal := PayMLVal*1000;  
    endif;
    if PayMRVal < 2 then
        PayMRVal := PayMRVal*1000; 
    endif;
    if PayFAVal < 2 then
        PayFAVal := PayFAVal*1000;  
    endif;
    if PayPTVal < 2 then
        PayPTVal := PayPTVal*1000;  
    endif;
    if PayPNTVal < 2 then
        PayPNTVal := PayPNTVal*1000;  
    endif;
    if PayNRVal < 2 then
        PayNRVal := PayNRVal*1000;  
    endif;	
    if PayCatchVal < 2 then
        PayCatchVal := PayCatchVal*1000;  
    endif;
    
    
    
	'Make sure RepeatOnError% is either 0 or 1
    if RepeatOnError% <> 0 and RepeatOnError% <> 1 then
        RepeatOnError% := 0;
        printlog("RepeatOnError% was set to a non-zero, non-one value and has been set to zero!\n");
        view(HiddenLogHandle%).print("RepeatOnError% was set to a non-zero, non-one value and has been set to zero!\r");
    endif;
    
    'RepeatOnError% is used later in the code as a subtrahend and PersevN is used to see if we even go into
    'ROE mode.  But if PersevN was set in the parameter file, and RepeatOnError% was set to 0, it did NOT turn
    'off the ROE function until this line was inserted in 1.3.22.  It's bad coding to use a variable as a "switch"
    'at the beginning of the code and then as a subtrahend later, but I did it.  Oh well.  It's all good now.
    if RepeatOnError% = 0 then
        PersevN := 0;
    endif;
    
	'Set FadedBLast
    FadedBLast := FadedBInit;
    
    
	'Just force Passive% to 0 if it's Interleaved, because we need to open an active config file
    if Interleaved% = 1 then
        Passive% := 0;
    else  'fill ActivePassive% with ones if it's Passive (it's already filled with zeros if active, and will be filled at the trials file if interleaved
        if Passive% = 1 then
            arrconst(ActivePassive%[],1);
        endif;
    endif;
    
	'Do not allow a scenario to be both interleaved and continuous reinforcement/errorless
	'Technically, we could try work out interleaved errorless active with passive, but for now, no.
    if Interleaved% = 1 and (ContReinfDelay >= 0 or Errorless% > 0) then
        message("Interleaved scenarios are not compatible with doing continuous reinforcement or errorless trials!");
        printlog("Interleaved scenarios are not compatible with doing continuous reinforcement or errorless trials!\n");
        view(HiddenLogHandle%).print("Interleaved scenarios are not compatible with doing continuous reinforcement or errorless trials!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
	'If re-loading parameters, make sure Behavioral% is the same
    if OrigNTrodes% >= 0 and not (OrigNTrodes% = NTrodes%) then
        message("You tried to change the number of electrodes!  It will stay the same!");
        NTrodes% := OrigNTrodes%;
    endif;
    
    
	'Check that continuous reinforcement scenarios are active, behavioral, and use the joystick
    if ContReinfDelay >= 0 and Passive% = 1 then
        message("Continuous Reinforcement scenarios must be active!");
        printlog("Continuous Reinforcement scenarios must be active!\n");
        view(HiddenLogHandle%).print("Continuous Reinforcement scenarios must be active!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if ContReinfDelay >= 0 and RespDevice% < 1 then
        message("Continuous Reinforcement scenarios must use the joystick!");
        printlog("Continuous Reinforcement scenarios must use the joystick!\n");
        view(HiddenLogHandle%).print("Continuous Reinforcement scenarios must use the joystick!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if ContReinfDelay >= 0 and Behavioral% = 0 then
        message("Continuous Reinforcement scenarios must be behavioral!");
        printlog("Continuous Reinforcement scenarios must be behavioral!\n");
        view(HiddenLogHandle%).print("Continuous Reinforcement scenarios must be behavioral!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    'Check that continuous reinforcement directions do not conflict
    if ContReinfInit$ = "x" and (ContReinfEnd$ = "left" or ContReinfEnd$ = "right") then
        message("Continuous Reinforcement - X initiation direction is incompatible with left/right end positions!  Use 'same' instead!\n");
        printlog("Continuous Reinforcement - X initiation direction is incompatible with left/right end positions!  Use 'same' instead!\n");
        view(HiddenLogHandle%).print("Continuous Reinforcement - X initiation direction is incompatible with left/right end positions!  Use 'same' instead!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if ContReinfInit$ = "y" and (ContReinfEnd$ = "up" or ContReinfEnd$ = "down") then
        message("Continuous Reinforcement - Y initiation direction is incompatible with up/down end positions!  Use 'same' instead!\n");
        printlog("Continuous Reinforcement - Y initiation direction is incompatible with up/down end positions!  Use 'same' instead!\n");
        view(HiddenLogHandle%).print("Continuous Reinforcement - Y initiation direction is incompatible with up/down end positions!  Use 'same' instead!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if ContReinfInit$ = "up" and ContReinfEnd$ = "same" then  'adjust same to "up" because we know the exact position
        ContReinfEnd$ := "up";
    endif;
    if ContReinfInit$ = "down" and ContReinfEnd$ = "same" then  'etc.
        ContReinfEnd$ := "down";
    endif;
    if ContReinfInit$ = "left" and ContReinfEnd$ = "same" then  'etc.
        ContReinfEnd$ := "left";
    endif;
    if ContReinfInit$ = "right" and ContReinfEnd$ = "same" then  'etc.
        ContReinfEnd$ := "right";
    endif;
    
    
    'assign CRaxis%, if appropriate
    if ContReinfInit$ = "x" or ContReinfInit$ = "left" or ContReinfInit$ = "right" then
        CRaxis$ := "x";
    endif;
    if ContReinfInit$ = "y" or ContReinfInit$ = "up" or ContReinfInit$ = "down" then
        CRaxis$ := "y";
    endif;
    
    
    'Check that stairstep scenarios are not errorless
    if StairTargAcc > 0 and Errorless% > 0 then
        message("Stairstep scenarios cannot be errorless!");
        printlog("Stairstep scenarios cannot be errorless!\n");
        view(HiddenLogHandle%).print("Stairstep scenarios cannot be errorless!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    
	'Check that errorless scenarios are active, behavioral and use the joystick (OK, Josh wants behavioral Errorless)
    if Errorless% > 0 and Passive% = 1 then
        message("Errorless scenarios must be active!");
        printlog("Errorless scenarios must be active!\n");
        view(HiddenLogHandle%).print("Errorless scenarios must be active!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if Errorless% > 0 and (RespDevice% <> 1 and RespDevice% <> -4) then
        message("Errorless scenarios must use the joystick or monojoystickfrud (forced choice scenario)!");
        printlog("Errorless scenarios must use the joystick or monojoystickfrud (forced choice scenario)!\n");
        view(HiddenLogHandle%).print("Errorless scenarios must use the joystick or monojoystickfrud (forced choice scenario)!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    'if Errorless% > 0 and Behavioral% = 0 then
    '    message("Errorless scenarios must be behavioral!");
    '    printlog("Errorless scenarios must be behavioral!\n");
    '    view(HiddenLogHandle%).print("Errorless scenarios must be behavioral!\r");
    '    return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    'endif;
    if Errorless% > 0 and RepeatOnError% > 0 then
        message("Errorless scenarios cannot repeat on error!");
        printlog("Errorless scenarios cannot repeat on error!\n");
        view(HiddenLogHandle%).print("Errorless scenarios cannot repeat on error!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if Errorless% > 0 then
        'Make sure errorless values are commensurate with the response device
        'It doesn't make sense to force the user to remember this stuff when making a parameter file
        if RespDevice% = -4 then
            Errorless% := 2;
        endif;
        if RespDevice% = 1 then
            Errorless% := 1;
        endif;
    endif;
    
    
    
    'Make sure that BrkPersevN has a value if PersevN has a value
    if PersevN > 0 and BrkPersevN = 0 then
        printlog("BrkPersevN was assigned no value but PersevN is non-zero!  BrkPersevN must have a value, assigning 20!\n");
        view(HiddenLogHandle%).print("BrkPersevN was assigned no value but PersevN is non-zero!  BrkPersevN must have a value, assigning 20!\r");
        BrkPersevN := 20;
    endif;
    
    'Make sure that PersevN and BrkPersevN are not 1 - error will result
    if PersevN = 1 then
        message("PersevN cannot be 1!");
        printlog("PersevN cannot be 1!\n");
        view(HiddenLogHandle%).print("PersevN cannot be 1!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    if BrkPersevN = 1 then
        message("BrkPersevN cannot be 1!");
        printlog("BrkPersevN cannot be 1!\n");
        view(HiddenLogHandle%).print("BrkPersevN cannot be 1!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    'Do not allow CheckPerseverance and UpdateTargetMotion together - just WAY too much of a pain to even try to keep track of accuracy
    if PersevN > 0 and TargetMotionWindow% > 0 then
        message("Check Perseverance and Update Target Motion cannot be used together!");
        printlog("Check Perseverance and Update Target Motion cannot be used together!\n");
        view(HiddenLogHandle%).print("Check Perseverance and Update Target Motion cannot be used together!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    
    'Dummyproof DeltaITI and MaxDeltaITI to have same sign
    if DeltaITI*MaxDeltaITI < 0 then
        message("DeltaITI and MaxDeltaITI must have the same sign!");
        printlog("DeltaITI and MaxDeltaITI must have the same sign!\n");
        view(HiddenLogHandle%).print("DeltaITI and MaxDeltaITI must have the same sign!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    if abs(DeltaITI) > abs(MaxDeltaITI) then
        message("DeltaITI cannot be larger than MaxDeltaITI!");
        printlog("DeltaITI cannot be larger than MaxDeltaITI!\n");
        view(HiddenLogHandle%).print("DeltaITI cannot be larger than MaxDeltaITI!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    
    'calculate ITI floor and ceiling values
    if DeltaITI >= 0 then
        MinITIFloor := MinITI;
        MinITICeil := MinITI + maxDeltaITI;
    else
        MinITIFloor := MinITI + maxDeltaITI;  'yes, maxDeltaITI will be negative
        MinITICeil := MinITI;
    endif;
    
    
    
    
	'convert UpThresh, etc. from degree measurements (as specified in the parameter file, or default) to
    'voltage values so we don't have to deal with it later
    vdcon := 0.09;  'this value is appropriate for the 4.5 volt power adapters
    UpThreshInner := UpThreshInner*vdcon;
    UpThreshOuter := UpThreshOuter*vdcon;
    DownThreshInner := DownThreshInner*vdcon;
    DownThreshOuter := DownThreshOuter*vdcon;
    LeftThreshInner := LeftThreshInner*vdcon;
    LeftThreshOuter := LeftThreshOuter*vdcon;
    RightThreshInner := RightThreshInner*vdcon;
    RightThreshOuter := RightThreshOuter*vdcon;
    UpThreshInnerInc := UpThreshInnerInc*vdcon;
    UpThreshOuterInc := UpThreshOuterInc*vdcon;
    DownThreshInnerInc := DownThreshInnerInc*vdcon;
    DownThreshOuterInc := DownThreshOuterInc*vdcon;
    LeftThreshInnerInc := LeftThreshInnerInc*vdcon;
    LeftThreshOuterInc := LeftThreshOuterInc*vdcon;
    RightThreshInnerInc := RightThreshInnerInc*vdcon;
    RightThreshOuterInc := RightThreshOuterInc*vdcon;
    UpThreshInnerMax := UpThreshInnerMax*vdcon;
    UpThreshOuterMax := UpThreshOuterMax*vdcon;
    DownThreshInnerMax := DownThreshInnerMax*vdcon;
    DownThreshOuterMax := DownThreshOuterMax*vdcon;
    LeftThreshInnerMax := LeftThreshInnerMax*vdcon;
    LeftThreshOuterMax := LeftThreshOuterMax*vdcon;
    RightThreshInnerMax := RightThreshInnerMax*vdcon;
    RightThreshOuterMax := RightThreshOuterMax*vdcon;
    UpThreshInnerDec := UpThreshInnerDec*vdcon;
    UpThreshOuterDec := UpThreshOuterDec*vdcon;
    DownThreshInnerDec := DownThreshInnerDec*vdcon;
    DownThreshOuterDec := DownThreshOuterDec*vdcon;
    LeftThreshInnerDec := LeftThreshInnerDec*vdcon;
    LeftThreshOuterDec := LeftThreshOuterDec*vdcon;
    RightThreshInnerDec := RightThreshInnerDec*vdcon;
    RightThreshOuterDec := RightThreshOuterDec*vdcon;
    UpThreshInnerMin := UpThreshInnerMin*vdcon;
    UpThreshOuterMin := UpThreshOuterMin*vdcon;
    DownThreshInnerMin := DownThreshInnerMin*vdcon;
    DownThreshOuterMin := DownThreshOuterMin*vdcon;
    LeftThreshInnerMin := LeftThreshInnerMin*vdcon;
    LeftThreshOuterMin := LeftThreshOuterMin*vdcon;
    RightThreshInnerMin := RightThreshInnerMin*vdcon;
    RightThreshOuterMin := RightThreshOuterMin*vdcon;
    
    
    'make sure TrialOnsetDelay does not exceed TrialOnsetMax/Min
    if TrialOnsetDelay > TrialOnsetMax then
        TrialOnsetDelay := TrialOnsetMax;
    endif;
    if TrialOnsetDelay < TrialOnsetMin then
        TrialOnsetDelay := TrialOnsetMin;
    endif;
    
    
    'prelims for continuous rove
    if ContinuousRove <> 0 then
        RovedB := abs(ContinuousRove);  'negative/positive values will be the same
        RovedB := round(RovedB*10)/10;  'round to nearest 0.1 because PA5 is in tenths.
    else
        RovedB := 0;
    endif;
    
    
    'make sure that nobody tries to use the motion detector in a lever scenario (they use the same channel)
    if Motion% = 1 and RespDevice% = 0 then
        Motion% := 0;
        message("Motion detector cannot be used in a LEVER scenario!");
        printlog("Motion detector cannot be used in a LEVER scenario!\n");
        view(HiddenLogHandle%).print("Motion detector cannot be used in a LEVER scenario!\r");
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endif;
    
    
    'Calculate flashing LED duration
    docase
        case LCase$(FlashLEDOnError$) = "n" then
        FlashDur := 0;
        case LCase$(FlashLEDOnError$) = "r" or LCase$(FlashLEDOnError$) = "g" or LCase$(FlashLEDOnError$) = "y" then 'specific light request
        FlashDur := FlashLEDErrorDur;
        case LCase$(FlashLEDOnError$) = "c" or LCase$(FlashLEDOnError$) = "h" or LCase$(FlashLEDOnError$) = "i" then 'current or (house/incandescent) request, same but long line split
        FlashDur := FlashLEDErrorDur;
    else
        message("FlashLEDOnError$ was given unknown value '" + LCase$(FlashLEDOnError$) + "', quitting!");
        printlog("FlashLEDOnError$ was given unknown value '%s'!\n",LCase$(FlashLEDOnError$));
        view(HiddenLogHandle%).print("FlashLEDOnError$ was given unknown value '%s'!\r",LCase$(FlashLEDOnError$));
        return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
    endcase
    
    'Make sure we don't have too many trials files, set SwitchCurrFile% if not set already
    docase
    case NTrialsFiles% > MaxTrialsFiles% then
        message("Too many trials files!  Quitting!");
        printlog("Too many trials files!  Quitting!\n");
        view(HiddenLogHandle%).print("Too many trials files!  Quitting!\r");
        return ConditionalQuit%();
    case NTrialsFiles% = 1 then  'Doesn't matter what it was, ignore any entry (including the default 0) and set to 1
        SwitchCurrFile% := 1;  
    case SwitchCurrFile% > NTrialsFiles% then  'If SwitchStartFile is too big, set it to the max
        SwitchCurrFile% := NTrialsFiles%;
        Message("SwitchCurrFile (" + Str$(SwitchCurrFile%) + ") was > NTrialsFiles% (" + Str$(NTrialsFiles%) + "), set to " + Str$(NTrialsFiles%));
    case SwitchCurrFile% < 1 and SwitchEasier >= 0 then  'If this is adaptive, start with middle-ish trial file by default
        SwitchCurrFile% := NTrialsFiles%/2;  'Because this is an integer type, the floor operation is implicit
    case SwitchCurrFile% < 1 and SwitchEasier < 0 then
        SwitchCurrFile% := 1;  'If SwitchEasier is -1, all files are expected to be the same difficulty, just start with file 1 by default
    endcase
    
    'Set float version of SwitchWindow
    SwitchWindow := SwitchWindow%;  'I figure just doing it will cost no more time than checking to see if we are file-switching
    
    'Lots of things are incompatible with multiple trials files:
    if NTrialsFiles% > 1 then
        docase
        'Passive
        case Passive% = 1 then
            message("Passive scenarios are incompatible with adaptive switching between trials files!  Quitting!");
            printlog("Passive scenarios are incompatible with adaptive switching between trials files!  Quitting!\n");
            view(HiddenLogHandle%).print("Passive scenarios are incompatible with adaptive switching between trials files!  Quitting!\r");
            return ConditionalQuit%();
        'Continuous Reinforcement
        case ContReinfDelay > -1 then
            message("Continuous Reinforcement is incompatible with adaptive switching between trials files!  Quitting!");
            printlog("Continuous Reinforcement is incompatible with adaptive switching between trials files!  Quitting!\n");
            view(HiddenLogHandle%).print("Continuous Reinforcement is incompatible with adaptive switching between trials files!  Quitting!\r");
            return ConditionalQuit%();
        'Errorless
        case Errorless% = 1 then
            message("Errorless scenarios are incompatible with adaptive switching between trials files!  Quitting!");
            printlog("Errorless scenarios are incompatible with adaptive switching between trials files!  Quitting!\n");
            view(HiddenLogHandle%).print("Errorless scenarios are incompatible with adaptive switching between trials files!  Quitting!\r");
            return ConditionalQuit%();    
        'Interleaved
        case Interleaved% = 1 then
            message("Interleaved scenarios are incompatible with adaptive switching between trials files!  Quitting!");
            printlog("Interleaved scenarios are incompatible with adaptive switching between trials files!  Quitting!\n");
            view(HiddenLogHandle%).print("Interleaved scenarios are incompatible with adaptive switching between trials files!  Quitting!\r");
            return ConditionalQuit%();
        'Passive And Active
        case PassiveAndActive% = 1 then
            message("PassiveAndActive scenarios are incompatible with adaptive switching between trials files!  Quitting!");
            printlog("PassiveAndActive scenarios are incompatible with adaptive switching between trials files!  Quitting!\n");
            view(HiddenLogHandle%).print("PassiveAndActive scenarios are incompatible with adaptive switching between trials files!  Quitting!\r");
            return ConditionalQuit%();
        'Passive
        case PersevN > 0 then
            message("Control of perseverance is incompatible with adaptive switching between trials files!  Quitting!");
            printlog("Control of perseverance is incompatible with adaptive switching between trials files!  Quitting!\n");
            view(HiddenLogHandle%).print("Control of perseverance is incompatible with adaptive switching between trials files!  Quitting!\r");
            return ConditionalQuit%();
        'FastSwitch
        case FastSwitch% = 1 then
            message("FastSwitch is incompatible with adaptive switching between trials files!  Quitting!");
            printlog("FastSwitch is incompatible with adaptive switching between trials files!  Quitting!\n");
            view(HiddenLogHandle%).print("FastSwitch is incompatible with adaptive switching between trials files!  Quitting!\r");
            return ConditionalQuit%();
        endcase
        
    endif;
    
    
    '''lots of work has to be done to make sure cue lighting isn't messed up
    'chop cue light override to first character if it isn't one character already
    if CueLightOverride$ <> "" then
        CueLightOverride$ := LCase$(Left$(CueLightOverride$,1));
    endif;
    
    'make sure the CueLightOverride$ value isn't unknown
    if CueLightOverride$ <> "r" and CueLightOverride$ <> "g" and CueLightOverride$ <> "y" and CueLightOverride$ <> "" then
        message("CueLightOverride value of '" + CueLightOverride$ + "' is unknown!  Quitting!");
        printlog("CueLightOverride value of '" + CueLightOverride$ + "' is unknown!  Quitting!\n");
        view(HiddenLogHandle%).print("CueLightOverride value of '" + CueLightOverride$ + "' is unknown!  Quitting!\r");
        return ConditionalQuit%();
    endif;    
    
    'make sure CueLightEachTrial% is not set to correspond to target motion if scenario is passive
    if CueLightEachTrial% = 2 and Passive% = 1 then
        message("CueLightEachTrial% cannot be 2 (corrsponding to target motion) in a Passive scenario!  Quitting!");
        printlog("CueLightEachTrial% cannot be 2 (corrsponding to target motion) in a Passive scenario!  Quitting!\n");
        view(HiddenLogHandle%).print("CueLightEachTrial% cannot be 2 (corrsponding to target motion) in a Passive scenario!  Quitting!\r");
        return ConditionalQuit%();
    endif;
    
    'and make sure the two incompatible arguments aren't both selected
    if CueLightEachTrial% > 0 and CueLightOverride$ <> "" then
        CueLightEachTrial% := 0;
        message("Both CueLight and CueLightOverride are specified in parameters file!  Overriding CueLight!");
        printlog("Both CueLight and CueLightOverride are specified in parameters file!  Overriding CueLight!\n");
        view(HiddenLogHandle%).print("Both CueLight and CueLightOverride are specified in parameters file!  Overriding CueLight!\r");
        'but don't quit because there is a default definition to "override" so it's probably intended
        'the user just ought to remove the incompatible definition from the parameter file.
    endif;
    
    'chop CueLightFRUDUp$/Down$ to first character if it isn't one character already
    if CueLightFRUDUp$  <> "" then
        CueLightFRUDUp$  := LCase$(Left$(CueLightFRUDUp$ ,1));
    endif;
    if CueLightFRUDDown$  <> "" then
        CueLightFRUDDown$  := LCase$(Left$(CueLightFRUDDown$ ,1));
    endif;
    
    'make sure that CueLightEachTrial is on for a monojoystickFRUD scenario
    if CueLightEachTrial% = 0 and RespDevice% = -4 then
        message("This is a MonoJoystickFRUD scenario, so CueLightEachTrial ('cuelight' in param file) must be set to 1 or 2!!!");
        printlog("This is a MonoJoystickFRUD scenario, so CueLightEachTrial ('cuelight' in param file) must be set to 1 or 2!!!\n");
        view(HiddenLogHandle%).print("This is a MonoJoystickFRUD scenario, so CueLightEachTrial ('cuelight' in param file) must be set to 1 or 2!!!\r");
        return ConditionalQuit%();
    endif;
    
    'make sure we don't try to use the wrong respdevice with CueLightEachTrial = 2
    if CueLightEachTrial% = 2 and RespDevice% <> -4 then
        message("If CueLightEachTrial is set to Targetmotion,this must be a MonoJoystickFRUD scenario!!!");
        printlog("If CueLightEachTrial is set to Targetmotion,this must be a MonoJoystickFRUD scenario!!!\n");
        view(HiddenLogHandle%).print("If CueLightEachTrial is set to Targetmotion,this must be a MonoJoystickFRUD scenario!!!\r");
        return ConditionalQuit%();
    endif;
    
    
    
    'make sure that if the response device is monoJoystickFRUD that CueLightFRUDUp$ is specified as "r" or "g"
    if CueLightFRUDUp$ <> "r" and CueLightFRUDUp$ <> "g" and CueLightEachTrial% = 2 then
        message("Cue Light is being taken from TargetMotion, so CueLightFRUDUp must be either 'g' or 'r'!!!");
        printlog("Cue Light is being taken from TargetMotion, so CueLightFRUDUp must be either 'g' or 'r'!!!\n");
        view(HiddenLogHandle%).print("Cue Light is being taken from TargetMotion, so CueLightFRUDUp must be either 'g' or 'r'!!!\r");
        return ConditionalQuit%();
    endif;
    
    'then default the down cue light to the opposite color if not specified, no dummy check 'cause I don't know what it should be
    if CueLightFRUDDown$ = "" then
        if CueLightFRUDUp$ = "r" then  'note that ONLY 'r' and 'g' are legal from the code directly above for UP, DOWN could be 'y'
            CueLightFRUDDown$ := "g";
        else
            CueLightFRUDDown$ := "r";
        endif;
    endif;
    
    'if we are doing fixation, make sure to read in the parameters
    if DoFixation% > 0 then
        GetFixationParameters();
    endif;
    
    
    
    'Reading Parameter File for stimuli, checking for length as we go
    Finished% := 0;  'just reuse Finished
    i% := 0;
    while Finished% = 0 do
        NumRead% := Read(StimInfo$[i%],StimLet$[i%],StimName$[i%],TempStimpath%[i%],ISI[i%],SampP[i%],NormAtten[i%]);  'read lines one at a time
        'StimLet$: stimulus letter code, StimName$: name on disk, ISI: InterStimulus Interval
        'SampP: sample period (uS), NormAtten: Attenuation value to normalize stimulus
        
        'Keep a concatenated record of StimLet$s and their lengths, the "A" keeps everything unique (because no code is allowed to have multiple letters)
        StimLetConcat$ := StimLetConcat$ + "A" + StimLet$[i%];  'add an A to the front, concatenate current StimLet$
        StimLetLen%[i%] := len(StimLet$[i%])+1;  'how long is it ("A" + x)
        
        i% := i% + 1;  'increment i%
        if NumRead% < 1 then
            Finished% := 1;
        else
            if NumRead% < 7 then
                printlog("On line %d of the stimulus section of the parameter file, read %d columns, expected 7!\n",stimN%+1,NumRead%);
                view(HiddenLogHandle%).print("Read %d columns from stimulus section of parameter file, expected 7!\r",NumRead%);
                return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
            endif;
            stimN% := stimN% + 1;  'increment stimN% each time we read a stimulus
        endif;
        if stimN% > len(ISI) then  'if there are too many stimuli for size of declared variables, alert the user.
            printlog("\nError - there are at least %d stimuli in the parameter file but the\n",i%);
            printlog("Pres_Engine stimulus variables are only %d elements long!\n",len(ISI));
            printlog("Please increase the declared length of all appropriate parameter file variables\n");
            printlog("and also StimLength under 'plotting variables'.  Quitting!  \n");
            view(HiddenLogHandle%).print("\rError - there are at least %d stimuli in the parameter file but the\r",i%);
            view(HiddenLogHandle%).print("Pres_Engine stimulus variables are only %d elements long!\r",len(ISI));
            view(HiddenLogHandle%).print("Please increase the declared length of all appropriate parameter file variables\r");
            view(HiddenLogHandle%).print("and also StimLength under 'plotting variables'.  Quitting!  \r");
            return ConditionalQuit%();  'Quits if params haven't been loaded, returns otherwise
        endif;
    wend;
    
    
	'Finished reading Parameter File
    fileclose();  'close parameter file fh0%
    
    
    'Only fill WhichStimPath%[] if multiple stimpaths are specified and 
    'there aren't any invalid indices in TempStimPath 
    if HighStimPath% > 1  then 'there are multiple stimpaths specified
        if TempStimPath%[max(TempStimPath%)] < HighStimPath%+1 and TempStimPath%[min(TempStimPath%)] = 1 then
            ArrConst(WhichStimPath%[],TempStimPath%[]);  'copy TempStimPath%[] over, everything is OK
        else
            printlog("\nError - an invalidly numbered stimulus path has been specified in the parameter file.\n");
            printlog("The column to specify which stimpath to use cannot exceed the size of the stimpath variable!\n");
            view(HiddenLogHandle%).print("\rError - an invalidly numbered stimulus path has been specified in the parameter file.\r");
            view(HiddenLogHandle%).print("The column to specify which stimpath to use cannot exceed the size of the stimpath variable!\r");
            'please note that this will not catch stupid errors, such as specifying stimpath as 20 without defining
            'stimpath20 in the variables section.
        endif;
    endif;
end;



'================================ Read Trials File ==================================
'Will read any type of trials file (mono/stereo) (atten included/not included)
func ReadTrialFile%(block%)
    
    var TrialText$;   'to read trial sequence
    var TrialText2$;  'for stereo
    var ActivePassive$;  'for interleaved trials
    var TextLen%;  'length of TrialText$
    var eof := 1;  'check for end of file
    var found%;  'have we found the letter?
    var SearchCount%;  'how many have we checked?
    var TargVar$;
    var TempAtten;   'Temporary hardware attenuation value, for read from Trials file 
    var TempAtten2;  'for stereo
    var TrialTextPH%;  'placeholder variable for TrialText$
    var LastCharPH%;  'placeholder variable for most recent "character"
    var ThisCharLen%; 'holds length of currently-considered "character"
    var Ascii%;       'holds ASCII value of current character
    var TempString$;  'holds a temporary string
    var StimSymbol$;  'holds the full (symbol+)letter specifier for a stimulus
    var EndOfChar%;   'is one if we have reached the end of a "character"
    var ii%;  	'looping variable
    var foundCount%;
    var CheckIsTrial% := 1;  'do we check to make sure the specified file is a trials file?
    var IsTrial%;  'is the specified file a trials file?
    var q%; 
    var min1;
    var min2;
    var StartInd%;
    
    StartInd% := MaxTFLen%*(block%-1);  'this is the index of the minimum trial for this block
    
	'Set TotalTrialsSutter% to 0
    TotalTrialsSutter%[block%-1] := 0;
    
	'Open Trials file, TrialFile$ will be empty except under "fast-switch"
    if VerboseStimLoad% = 1 then
        view(HiddenLogHandle%).print("Looking for trial file %s\r",TrialFile$);
    endif;
    
    'Only try to open Trials file if one is specified - this will only happen under "fast-switch"
    if TrialFile$ = "" then
        fh0% := -1000;  'specific "failure value" allows different dialog text for user open
        printlog("Asking user to select trials file\n");
        view(HiddenLogHandle%).print("Asking user to select trials file\r");
    else  'go ahead and try to open it if a trials file is specified
        fh0%:=FileOpen(TrialFile$,8,0);  
    endif;
    
	'If Trials file not found/specified, bring up dialog box so that user can browse to select one
    docase
    case fh0% = -1000 and NTrialsFiles% = 1 then  'no file specified, only one trials file
        fh0%:=FileOpen(ParamDir$+"*.txt",8,0,"Please select a Trials file.");
    case fh0% = -1000 and NTrialsFiles% > 1 then  'no file specified, multiple trials files
        fh0%:=FileOpen(ParamDir$+"*.txt",8,0,"Please select Trials file #" + Str$(block%) + " where #1 is easiest and #" + Str$(NTrialsFiles%) + " is hardest.");
    case fh0% < 0 then 'specified trials file not found
        fh0%:=FileOpen(ParamDir$+"*.txt",8,0,"Could not find the specified Trials file. Please select a Trials file.");
    endcase;
    
    'we now have an open file which is expected to be a trials file
    TrialFile$ := filename$();  'get name of open file
    TrialFileShort$ := filename$(3) + filename$(4);  'get the short name (file name only, for registry, be sure to get trailing numbers)
    fileclose();  'close file fh0%
    'check to make sure the specified file is actually a trials file
    while CheckIsTrial% = 1 do
        IsTrial% := TestParamTrialFile%(TrialFile$);
        if IsTrial% <> 3 then  'it's not a trials file!
            q% := query("USER ERROR! The specified file IS NOT a trials file!","Try Again","Quit");
            if q% = 0 then
                printlog("Quitting because the user pressed the 'Quit' button after opening something that wasn't a trials file!\n");  
                view(HiddenLogHandle%).print("Quitting because the user pressed the 'Quit' button after opening something that wasn't a trials file!\r");  
                quit%();
            else
                fh0%:=FileOpen(ParamDir$+"*.txt",8,0,"Please select a Trials file");
                TrialFile$ := filename$();  'get file name of opened file
                FileClose();  'and close fh0%
            endif;
        else
            CheckIsTrial% := 0;  'we have found a valid trials file            
        endif;        
    wend 
    
    TrialFileList$[block%-1] := TrialFile$;  'keep the name to write in the IDX
    TrialFileListShort$[block%-1] := TrialFileShort$;  'keep the name to write in the registry
    
    fh0% := FileOpen(TrialFile$,8,0);  're-open valid trials file because TestParamTrialFile does not leave file ID at beginning
    
    printlog("\n\n\nCurrent trials file is %s\n",TrialFile$);
    view(HiddenLogHandle%).print("\r\r\rCurrent trials file is %s\r",TrialFile$);
    
	'Set up read parameters for Trials file	
    readsetup(",","	 ","","","	");  'new version, as explained in ReadParamFile%()
    
	'Read Trials file
    while eof > 0 do
		'Here we will read an attenuation value into TempAtten if present, otherwise TempAtten will be 0
		'Attenuation value should be separated from stimulus sequence in Trials file by a tab.
        if NSpeakers% = 1 then  
            if Interleaved% = 0 then  'read the original mono version
                eof := read(TrialText$,TempAtten);  'TrialText$ will hold the contents of the line, eof will be negative error code if we try to read beyond the end of the file
            else  'read interleaved mono version
                eof := read(ActivePassive$,TrialText$,TempAtten);
            endif;
        else  'two speakers
            if Interleaved% = 0 then  'read original stereo version
                eof := read(TrialText$,TrialText2$,TempAtten,TempAtten2);
            else  'read interleaved stereo version
                eof := read(ActivePassive$,TrialText$,TrialText2$,TempAtten,TempAtten2);
            endif;
        endif;
        if eof > 0 then                     'Begin looping through if we have a new stimulus
            Atten[TotalTrialsSutter%[block%-1]+StartInd%] := TempAtten;         'Put attenuation value in Atten[]
            Atten2[TotalTrialsSutter%[block%-1]+StartInd%] := TempAtten2;       'Put attenuation value in Atten2[]
            if Interleaved% = 1 then
                if LCase$(ActivePassive$) = "a" then
                    ActivePassive%[TotalTrialsSutter%[block%-1]+StartInd%] := 0;  'will eventually set Passive% to 0, active
                else 'any user-created file errors automatically become passive trials
                    ActivePassive%[TotalTrialsSutter%[block%-1]+StartInd%] := 1;
                endif;
            endif;
            TextLen% := len(TrialText$);        'Get length of the text section, in characters
            if VerboseStimLoad% = 1 then
                view(HiddenLogHandle%).print("\rThe Stim Sequence for the first speaker is read as %s\r",TrialText$);
                view(HiddenLogHandle%).print("The Attenuation for the first speaker is read as %f\r",Atten[TotalTrialsSutter%[block%-1]+StartInd%]);
            endif;
            'check for "common" error of not assigning trial target status
            TempString$ := right$(TrialText$,1);  'Gets rightmost character
            Ascii% := asc(TempString$);  'convert to ASCII
            if Ascii% < 48 or Ascii% > 57 then 'it's not a number!
                q% := query("Trials File Read Error|An error was found in the trials file, see details in the Log window.","Quit","Try Again");
                printlog("An error has been found while reading the trials file!\n");            
                printlog("It appears that no target status is specified on trial %d - '%s'!\n",TotalTrialsSutter%[block%-1]+1,TrialText$);
                printlog("If the trial listed above is Trial 1, most likely the trial file format is incorrect\n");
                printlog("with respect to INTERLEAVED or STEREO settings in the parameter file.\n"); 
                view(HiddenLogHandle%).print("An error has been found while reading the trials file!\r"); 
                view(HiddenLogHandle%).print("It appears that no target status is specified on trial %d - '%s'!\r",TotalTrialsSutter%[block%-1]+1,TrialText$);
                view(HiddenLogHandle%).print("If the trial listed above is Trial 1, most likely the trial file format is incorrect\r");
                view(HiddenLogHandle%).print("with respect to INTERLEAVED or STEREO settings in the parameter file.\r");
                if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                    return ConditionalQuit%();
                else
                    return 0;
                endif;
            endif;        
            ConcatStim%[TotalTrialsSutter%[block%-1]+StartInd%] := 0;  'how many stimuli are concatenated in this trial, will increment as go along
            TrialTextPH% := 0;  'placeholder variable for TrialText$
            LastCharPH% := 0;  'placeholder variable for most recent "character"
            ThisCharLen% := 1;  'length of the current "character"
            foundCount% := 0;   'Number of stimuli found
            while TrialTextPH% <= TextLen%-2 do  'will loop through all but final character, which is test/standard indicator
                EndOfChar% := 0;  'Are we at the end of a "virtual" character?
                while EndOfChar% = 0 do  'while we haven't found the end of a character	
                    TempString$ := mid$(TrialText$,TrialTextPH%+1,1);  'Get current character, first index is ONE
                    Ascii% := asc(TempString$);  'Get ASCII version of current character
                    docase  'this docase determines if we have reached the end of the "character"
                        case Ascii% >= 48 and Ascii% <= 57 then 'it's a number, which we don't expect
                        q% := query("A number has been unexpectedly found within the stimulus definition!","Quit","Try Again");
                        printlog("A number has been unexpectedly found within the stimulus definition %d - '%s'!\n",TotalTrialsSutter%[block%-1]+1,TrialText$);
                        view(HiddenLogHandle%).print("A number has been unexpectedly found within the stimulus definition %d - '%s'!\r",TotalTrialsSutter%[block%-1]+1,TrialText$);
                        if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                            return ConditionalQuit%();
                        else
                            return 0;
                        endif;
                        case Ascii% >= 65 and Ascii% <= 90 then 'it's an upper-case letter, end of "character"
						EndOfChar% := 1;
                        case Ascii% >= 97 and Ascii% <= 122 then 'it's a lower-case letter, end of "character"
						EndOfChar% := 1;
                        case Ascii% <= 32 or Ascii% >= 127 then 'it's an unexpected character
                        q% := query("An unexpected character has been found within the stimulus definition!","Quit","Try Again");
                        printlog("An unexpected character has been found within the stimulus definition %d - '%s'!\n",TotalTrialsSutter%[block%-1]+1,TrialText$);
                        view(HiddenLogHandle%).print("An unexpected character has been found within the stimulus definition %d - '%s'!\r",TotalTrialsSutter%[block%-1]+1,TrialText$);
                        if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                            return ConditionalQuit%();
                        else
                            return 0;
                        endif;
					else 'it's a non-letter/numeral character, used to extend the number of possible stimuli
						EndOfChar% := 0;  
						ThisCharLen% := ThisCharLen% + 1;
                    endcase;
                    if EndOfChar% = 1 then  'if we have gotten the end of a character
                        foundCount% := foundCount% + 1;  'Increment foundCount%, number of stimuli found
                        if VerboseStimLoad% = 1 then
                            view(HiddenLogHandle%).print("Total metachars found is %d\r",foundCount%);
                        endif;
                        ConcatStim%[TotalTrialsSutter%[block%-1]+StartInd%] := foundCount%;  'Increment number of stimuli, just use foundCount%
                        StimSymbol$ := mid$(TrialText$,LastCharPH%+1,ThisCharLen%);  'Get "character" in full
                        if VerboseStimLoad% = 1 then
                            view(HiddenLogHandle%).print("Current metachar in full is %s\r",StimSymbol$);
                        endif;
                        LastCharPH% := LastCharPH% + ThisCharLen%;  'Update LastCharPH%
                        ThisCharLen% := 1;  'Reset ThisCharLen%
                        StimOrder$[TotalTrialsSutter%[block%-1]+StartInd%][foundCount%-1] := StimSymbol$; 'put "character" in StimOrder
                        found% := 0;
                        SearchCount% := 0;
                        'change the letters to numbers for easier use down the road
                        while found% = 0 do
                            if StimSymbol$ = StimLet$[SearchCount%] then 'on a match
                                StimOrder%[TotalTrialsSutter%[block%-1]+StartInd%][foundCount%-1] := SearchCount%;
                                TrialPoints%[TotalTrialsSutter%[block%-1]+StartInd%] := TrialPoints%[TotalTrialsSutter%[block%-1]+StartInd%] + StimPoints%[SearchCount%];
                                found% := 1;  'to break while
                            else
                                if SearchCount% = len(StimLet$)-1 then 'all the way through, no match
                                    q% := query("Error!  The current letter   " + StimSymbol$ + "   was not found in the stimulus set!","Quit","Try Again");
                                    printlog("Error!  The current letter,   %s   , was not found in the stimulus set!\n",StimSymbol$);
                                    view(HiddenLogHandle%).print("Error!  The current letter,   %s   , was not found in the stimulus set!\r",StimSymbol$);
                                    if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                                        return ConditionalQuit%();
                                    else
                                        return 0;
                                    endif;
                                endif;
                            endif;
                            SearchCount% := SearchCount% + 1;
                        wend
                        'Note the final stimulus on each trial
                        if TrialTextPH% = TextLen%-2 then 'it has to be the final stimulus
                            TestStim%[TotalTrialsSutter%[block%-1]+StartInd%] := SearchCount% -1; 'minus one because it is incremented on the final while round
                            if VerboseStimLoad% = 1 then
                                view(HiddenLogHandle%).print("The test stimulus is number %d\r",SearchCount%-1);
                            endif;
                        endif;
                    endif;
                    TrialTextPH% := TrialTextPH% + 1;  'Increment TrialTextPH%
                wend;
            wend;
            
            TargVar$ := mid$(TrialText$,TextLen%,1); 'get last character, which is a number, usually 0=standard, 1=target, 9=probe
            'NEW!  0=standard, 1-7=target, defines # of solenoid hits, 8,9=probe
            TargVar%[TotalTrialsSutter%[block%-1]+StartInd%] := val(TargVar$);  'convert from string
            if VerboseStimLoad% = 1 then
                view(HiddenLogHandle%).print("Target value is %s\r",TargVar$);
            endif;
            
            
            'Do it all over again for second stimulus, won't enter while loop if TrialText2$ isn't filled (mono trial)
            
            TextLen% := len(TrialText2$);        'Get length of the text section, in characters
            if TextLen% > 0 then
                if VerboseStimLoad% = 1 then
                    view(HiddenLogHandle%).print("\rThe Stim Sequence for the second speaker is read as %s\r",TrialText2$);
                    view(HiddenLogHandle%).print("The Attenuation for the second speaker is read as %f\r",Atten2[TotalTrialsSutter%[block%-1]+StartInd%]);
                endif;
                'check for "common" error of not assigning trial target status
                TempString$ := right$(TrialText2$,1);  'Gets rightmost character
                Ascii% := asc(TempString$);  'convert to ASCII
                if Ascii% < 48 or Ascii% > 57 then 'it's not a number!
                    q% := query("Trials File Read Error|An error was found in the trials file, see details in the Log window.","Quit","Try Again");
                    printlog("An error has been found while reading the trials file!\n");            
                    printlog("It appears that no target status is specified on trial %d - '%s'!\n",TotalTrialsSutter%[block%-1]+1,TrialText2$);
                    printlog("If the trial listed above is Trial 1, most likely the trial file format is incorrect\n");
                    printlog("with respect to INTERLEAVED or STEREO settings in the parameter file.\n");
                    view(HiddenLogHandle%).print("An error has been found while reading the trials file!\r");
                    view(HiddenLogHandle%).print("It appears that no target status is specified on trial %d - '%s'!\r",TotalTrialsSutter%[block%-1]+1,TrialText2$);
                    view(HiddenLogHandle%).print("If the trial listed above is Trial 1, most likely the trial file format is incorrect\r");
                    view(HiddenLogHandle%).print("with respect to INTERLEAVED or STEREO settings in the parameter file.\r");
                    if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                        return ConditionalQuit%();
                    else
                        return 0;
                    endif;
                endif;
                ConcatStim2%[TotalTrialsSutter%[block%-1]+StartInd%] := 0;  'how many stimuli are concatenated in this trial, will increment as go along
                TrialTextPH% := 0;  'placeholder variable for TrialText$
                LastCharPH% := 0;  'placeholder variable for most recent "character"
                ThisCharLen% := 1;  'length of the current "character"
                foundCount% := 0;   'Number of stimuli found
            endif;
            while TrialTextPH% <= TextLen%-2 do  'will loop through all but final character, which is test/standard indicator
                EndOfChar% := 0;  'Are we at the end of a "virtual" character?
                while EndOfChar% = 0 do  'while we haven't found the end of a character	
                    TempString$ := mid$(TrialText2$,TrialTextPH%+1,1);  'Get current character, first index is ONE
                    Ascii% := asc(TempString$);  'Get ASCII version of current character
                    docase  'this docase determines if we have reached the end of the "character"
                        case Ascii% >= 48 and Ascii% <= 57 then 'it's a number, which we don't expect
                        q% := query("A number has been unexpectedly found within the stimulus definition!","Quit","Try Again");
                        printlog("A number has been unexpectedly found within the stimulus definition %d - '%s'!\n",TotalTrialsSutter%[block%-1]+1,TrialText2$);
                        view(HiddenLogHandle%).print("A number has been unexpectedly found within the stimulus definition %d - '%s'!\r",TotalTrialsSutter%[block%-1]+1,TrialText2$);
                        if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                            return ConditionalQuit%();
                        else
                            return 0;
                        endif;
                        case Ascii% >= 65 and Ascii% <= 90 then 'it's an upper-case letter, end of "character"
						EndOfChar% := 1;
                        case Ascii% >= 97 and Ascii% <= 122 then 'it's a lower-case letter, end of "character"
						EndOfChar% := 1;
                        case Ascii% <= 32 or Ascii% >= 127 then 'it's an unexpected character
                        q% := query("An unexpected character has been found within the stimulus definition!","Quit","Try Again");
                        printlog("An unexpected character has been found within the stimulus definition %d - '%s'!\n",TotalTrialsSutter%[block%-1]+1,TrialText2$);
                        view(HiddenLogHandle%).print("An unexpected character has been found within the stimulus definition %d - '%s'!\r",TotalTrialsSutter%[block%-1]+1,TrialText2$);
                        if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                            return ConditionalQuit%();
                        else
                            return 0;
                        endif;
					else 'it's a non-letter/numeral character, used to extend the number of possible stimuli
						EndOfChar% := 0;  
						ThisCharLen% := ThisCharLen% + 1;
                    endcase;
                    if EndOfChar% = 1 then  'if we have gotten the end of a character
                        foundCount% := foundCount% + 1;  'Increment foundCount%, number of stimuli found
                        if VerboseStimLoad% = 1 then
                            view(HiddenLogHandle%).print("Total metachars found is %d\r",foundCount%);
                        endif;
                        ConcatStim2%[TotalTrialsSutter%[block%-1]+StartInd%] := foundCount%;  'Increment number of stimuli, just use foundCount%
                        StimSymbol$ := mid$(TrialText2$,LastCharPH%+1,ThisCharLen%);  'Get "character" in full
                        if VerboseStimLoad% = 1 then
                            view(HiddenLogHandle%).print("Current metachar in full is %s\r",StimSymbol$);
                        endif;
                        LastCharPH% := LastCharPH% + ThisCharLen%;  'Update LastCharPH%
                        ThisCharLen% := 1;  'Reset ThisCharLen%
                        StimOrder2$[TotalTrialsSutter%[block%-1]+StartInd%][foundCount%-1] := StimSymbol$; 'put "character" in StimOrder
                        found% := 0;
                        SearchCount% := 0;
                        'change the letters to numbers for easier use down the road
                        while found% = 0 do
                            if StimSymbol$ = StimLet$[SearchCount%] then 'on a match
                                StimOrder2%[TotalTrialsSutter%[block%-1]+StartInd%][foundCount%-1] := SearchCount%;
                                TrialPoints2%[TotalTrialsSutter%[block%-1]+StartInd%] := TrialPoints2%[TotalTrialsSutter%[block%-1]+StartInd%] + StimPoints%[SearchCount%];
                                found% := 1;  'to break while
                            else
                                if SearchCount% = len(StimLet$)-1 then 'all the way through, no match
                                    q% := query("Error!  The current letter   " + StimSymbol$ + "   was not found in the stimulus set!","Quit","Try Again");
                                    printlog("Error!  The current letter,   %s   , was not found in the stimulus set\n",StimSymbol$);
                                    view(HiddenLogHandle%).print("Error!  The current letter,   %s   , was not found in the stimulus set\r",StimSymbol$);
                                    if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                                        return ConditionalQuit%();
                                    else
                                        return 0;
                                    endif;
                                endif;
                            endif;
                            SearchCount% := SearchCount% + 1;
                        wend
                        'Note the final stimulus on each trial
                        if TrialTextPH% = TextLen%-2 then 'it has to be the final stimulus
                            TestStim2%[TotalTrialsSutter%[block%-1]+StartInd%] := SearchCount% -1; 'minus one because it is incremented on the final while round
                            if VerboseStimLoad% = 1 then
                                view(HiddenLogHandle%).print("The test stimulus is number %d\n",SearchCount%-1);
                            endif;
                        endif;
                    endif;
                    TrialTextPH% := TrialTextPH% + 1;  'Increment TrialTextPH%
                wend;
            wend;
            
            if TextLen% > 1 then  'we have to check this time, essentially will fill if NSpeakers% is 2
                TargVar$ := mid$(TrialText2$,TextLen%,1); 'get last character, which is a number, usually 0=standard, 1=target, 2=probe
                TargVar2%[TotalTrialsSutter%[block%-1]+StartInd%] := val(TargVar$);  'convert from string
                if VerboseStimLoad% = 1 then
                    view(HiddenLogHandle%).print("Target value is %s\r",TargVar$);
                endif;
            endif;
            
            
            TotalTrialsSutter%[block%-1] := TotalTrialsSutter%[block%-1] + 1;  'Holds actual number of trials
        endif;
    wend;
    
    'if we are doing errorless=1,we must have exactly one trial designated a "1-8" target (probes count as targets)
    'note that for errorless=2 there is no good way to change the reward size 
    if Errorless% = 1 then
        for ii% := StartInd% to TotalTrialsSutter%[block%-1]-1+StartInd% do  'TotalTrialsSutter%[block%-1] has already been incremented
            if (TargVar%[ii%] < 1 and TargVar2%[ii%] < 1) or (TargVar%[ii%] >= 1 and TargVar2%[ii%] >= 1) then
                q% := query("On 'errorless' presentation, exactly one stimulus must be a target/probe!","Quit","Try Again");
                printlog("On 'errorless' presentation, exactly one stimulus must be a target/probe!\n");
                view(HiddenLogHandle%).print("On 'errorless' presentation, exactly one stimulus must be a target/probe!\r");
                if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                    return ConditionalQuit%();
                else
                    return 0;
                endif;
            endif;
        next;
    endif;
    
	'now that MaxPoint% is being manually assigned, check that no trials are too long
	'note we can only do this here on secondary runs - on the first run we haven't assigned MaxPoint% yet 
    if ParamsLoadedOnce% = 1 then
        for ii% := StartInd% to TotalTrialsSutter%[block%-1]-1+StartInd% do 'TotalTrialsSutter%[block%-1] has already been incremented
            if TrialPoints%[ii%] > MaxPoint% then
                q% := query("Error! There is a trial which is longer than MaxPoint%!","Quit","Try Again");
                printlog("Error! There is a trial which is longer than MaxPoint%!\n");
                view(HiddenLogHandle%).print("Error! There is a trial which is longer than MaxPoint%!\r");
                if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                    return ConditionalQuit%();
                else
                    return 0;
                endif;
            endif;
            if nSpeakers% = 2 then
                if TrialPoints2%[ii%] > MaxPoint% then
                    q% := query("Error! There is a trial which is longer than MaxPoint%!","Quit","Try Again");
                    printlog("Error! There is a trial which is longer than MaxPoint%!\n");
                    view(HiddenLogHandle%).print("Error! There is a trial which is longer than MaxPoint%!\r");
                    if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
                        return ConditionalQuit%();
                    else
                        return 0;
                    endif;
                endif;
            endif;
        next;
    endif;
    
    'Check to make sure that if there are negative attenuations, they are no greater than the minimum attenuation
    'so that we don't try to "amplify" (either software or via PA5!)
    min1 := Atten[min(Atten[])];  'get minimum trial-based attenuation on first speaker
    min2 := Atten2[min(Atten2[])];  'get minimum trial-based attenuation on second speaker, will be 0 if not used
    if min2 < min1 then  'set MIN1 to be the lowest trial-based attenuation, robust to 0
        min1 := min2;
    endif;
    if NormAtten[min(NormAtten[])] + min1 < 0 then
        q% := query("Error! There is a trial which has negative attenuation that would require amplification!","Quit","Try Again");
        printlog("Error! There is a trial which has negative attenuation that would require amplification!\n");
        view(HiddenLogHandle%).print("Error! There is a trial which has negative attenuation that would require amplification!\r");
        if q% = 1 then  'try to quit if user elects to quit, retry opening trials file otherwise
            return ConditionalQuit%();
        else
            return 0;
        endif;
    endif;
    
    
	'Done with Trials file
    fileclose();  'close fh0%

    TrialFile$ := "";

    return 1;
    
end;



'============================ Reset Trials File Variables ===========================
'Resets variables made when reading trials file, used when new stimuli are loaded or trials file load is in error
func ResetTrialFileVars%(block%)
    var ii%;
    var jj%;
    var thismin%;
    
    thismin% := MaxTFLen%*(block%-1);  'this is the index of the minimum trial for this block
    
    for ii% := thismin% to thismin%+MaxTFLen%-1 do
        for jj% := 0 to 9 do
            StimOrder$[ii%][jj%] := "";
            StimOrder2$[ii%][jj%] := "";
		next;
	next;
    arrconst(Atten[thismin%:MaxTFLen%],0);  'thismin% is the start index, MaxTFLen% is the length
    arrconst(Atten2[thismin%:MaxTFLen%],0);
    arrconst(ActivePassive%[thismin%:MaxTFLen%],0);
    arrconst(TargVar%[thismin%:MaxTFLen%],0);
    arrconst(TargVar2%[thismin%:MaxTFLen%],0);
    arrconst(TestStim%[thismin%:MaxTFLen%],0);
    arrconst(TestStim2%[thismin%:MaxTFLen%],0);
    arrconst(TrialPoints%[thismin%:MaxTFLen%],0);
    arrconst(TrialPoints2%[thismin%:MaxTFLen%],0);
    arrconst(StimOrder%[thismin%:MaxTFLen%][0:10],0);
    arrconst(StimOrder2%[thismin%:MaxTFLen%][0:10],0);
    arrconst(ConcatStim%[thismin%:MaxTFLen%],0);
    arrconst(ConcatStim2%[thismin%:MaxTFLen%],0);
    
end;

'============================= Load Stimuli Into Buffers =============================
func LoadStim%(WhichTrial%)   'LoadStim%() finds the appropriate files to open, accesses the disk and opens them,
    'then puts them into a play buffer
    
    var fh%;                   'File handle
    var n%;                    'Number of samples in the loaded stimulus
    var ii%;                   'Looping variable       
    var Wav%[maxpoint%];       'Variable in which to create entire trial
    var Wav2%[maxpoint%][2];   'Variable in which to hold stereo stimulus
    var WavTemp%[maxpoint%];   'Variable to hold each stimulus as it is loaded 
    var WavTempScaled%[maxpoint%];  'A scaled version of WavTemp%[]
    var ThisIsi;               'Current ISI
    var ThisStim%;             'Identity of this stimulus
    var LastStim% := -100;     'Identity of previous stimulus, we won't access the disk if the same one is in RAM
    var start%;                'Current position in playback buffer
    var temp%;                 'Holds length of stimulus on first speaker (stereo) to aid in stimulus length determination
    var StimPathHolder$;			'Holds current StimPath$ now that we have two possible StimPath$s, just cuts a few lines out
    var TempScale;             'Holds the actual scale factor.  Common attenuation is now done with PA5, software scaling
    'is only for the difference and within-stimulus changes
    var FadeIndB;              'number of dB to drop down any fade-in standards
    var TempRovedB;
    
    'Tricky bug here found only when instituting TrialWrap - normally the stimulus is set to load while the previous
    'stimulus is playing, but the wrap of CurrTrialIndex% does not occur until after the reward is given.  Since the
    'trial variables are all "oversized" (NMaxTrials% in length) and padded with zeros the load portions of this function
    'do not execute ("for i%:=1 to 0" does nothing) and vectors of zeros are transferred into the play buffers once
    'the trials list is over.  Since the next trial does not execute, this is transparent until TrialWrap.
    'Changing this to take WhichTrial% as an argument instead of using CurrTrialIndex% as a global - seems easiest.
    
	'Bring Current View to front
    view(ctview%);
    
	'Set Wav%[] to zeros
    arrconst(Wav%[],0);   
    
    'Set RoveValue$ to empty
    RoveValue$ := "";
    
	'Build the entire trial out of component stimuli - speaker 1 (or mono)
    for ii%:=1 to ConcatStim%[WhichTrial%] do
        ThisStim% := StimOrder%[WhichTrial%][ii%-1];
        'for the first stimulus (only for mono/speaker 1) check the StimInfo$ if CueLightEachTrial% is set
        'and get the stim lights for the next trial
        if ii% = 1 and CueLightEachTrial% = 1 then
            NextCueLights$ := StimInfo$[ThisStim%];
        endif;
		'If this stim is not the same as the last one, load this stim
        if ThisStim% <> LastStim% then 			
            arrconst(WavTemp%[],0);  'Set WavTemp%[] to zeros
            
            'ThisStim% is the right index here!
            StimPathHolder$ := StimPath$[WhichStimPath%[ThisStim%]-1];
            
            'open current stimulus
            fh%:=fileopen(StimPathHolder$+StimName$[ThisStim%]+".wfm",9,0);
            if fh%<0 then
                message("Warning Message | failed to load the stimulus waveform!");
                printlog("Quitting because the Stim waveform %s failed to load!\n",StimPathHolder$+StimName$[ThisStim%]+".wfm");
                view(HiddenLogHandle%).print("Quitting because the Stim waveform %s failed to load!\r",StimPathHolder$+StimName$[ThisStim%]+".wfm");
                quit%();
                return 0;
            endif;
            'reads fh% two bytes at a time, puts in WavTemp%[]
            n%:=breadsize(2,WavTemp%[]); 
            
            'close current stimulus
            fileclose();  'close fh%
            
        endif;  'Otherwise we'll just keep the previous stimulus
        
        'Software scale current stimulus
        if ii% < ConcatStim%[WhichTrial%] and NSpeakers% = 1 then
            FadeIndB := FadedBInit;  'FadedBInit covers either sequence fade-in (one speaker, via software) or speaker fade-in (two speakers, via PA5)
        else
            FadeIndB := 0;  'If two speakers, the fade-in is done by IF#3 in the main loop, do not fade here
        endif;
        'Calculate rove, if any
        if RovedB > 0 then
            'Bear with this.  We need a random value uniformly distributed in 0.1 increments between -RovedB and RovedB.
            'RovedB is already rounded to the nearest tenth.  We are working in 10x so we can round to the nearest 1
            'and then divide by 10 to get into 0.1 increments.  This is identical to working in 1x and rounding to
            'the nearest 0.1.  So thinking in 1x, the floor of our distribution is -(RovedB+0.05) and the ceiling is
            'RovedB+0.05.  So every value, including the extremes, has 0.05 on either side, meaning equal probability.
            'Note that there is a finite chance of Rand returning 0, and thus a finite chance of -(RovedB+0.1), but...
            TempRovedB := round(rand((RovedB*20)+1,(RovedB*-10)-0.5))/10;
            if ii% = 1 then
                RoveValue$ := RoveValue$ + "Rove1";
            endif;
            RoveValue$ := RoveValue$ + "," + Str$(TempRovedB,0,-1);
        endif;        
        TempScale := ScaleFactor[ThisStim%]+FadeIndB+TempRovedB;
        if PA5Absent% = 1 then
            TempScale := TempScale+Atten[WhichTrial%];
        endif;
        TempScale := pow(10,(-TempScale/20));  'solving "dB = 20 * log10(A1/A2)" for (A1/A2) gives multiplicative scale factor
        ArrConst(WavTempScaled%[],WavTemp%[]);  'move WavTemp%[] into WavTempScaled%[]
        ArrMul(WavTempScaled%[],TempScale);
        
		'This holds the time in seconds at which we are inserting the final stimulus.  Assuming
 	    'the final stimulus is the only potential non-Standard stimulus, at the end of the loop
		'this will hold the time at which the standards stop and the test stimulus begins.
		'This is recalculated each time through the loop but updates before Start% updates
		'so on the last time through it holds the end of the next-to-last stimulus.  (Or, technically
		'the start of the final stimulus.)
        EndOfStandards := start%/SampleRate;
        EndOfStandards2 := EndOfStandards;  'Assign these to be the same, if there's a stereo stim EndOfStandards2 will be changed
        
		'Put stimulus into Wav%[]
        arrconst(Wav%[start%:n%],WavTempScaled%[0:n%]);   'Remember that the format is [start:length] NOT [start:end]!!!
        
		'Update start position
        start% := start% + n%; 
        
		'Get ISI for this stimulus
        ThisIsi := ISI[ThisStim%];
        
		'If there is an ISI delay, insert it by updating start position, intervening points in
		'Wav%[] are already zero; ISI is in milliseconds, don't insert after final stimulus
        if ThisIsi > 0 and ii% < ConcatStim%[WhichTrial%] then 
			'Update start position
            start% := start% + (ThisIsi*SamplesPerMS%); 'update start position
        endif;
        
		'Note most recent stimulus
        LastStim% := ThisStim%; 
        
    next;  'Trial is now built in Wav%[]
    
	'Put Wav%[] trial into rotating buffer and change BufferToPlay%
	'BufferToPlay currently holds the most recently played buffer.
	'Only do this if we have just one speaker
    if NSpeakers% = 1 then
        if BufferToPlay%=2 then
            ok%:=PlayWaveCopy("S",Wav%[]);
            BufferToPlay%:=1;
        else
            ok%:=PlayWaveCopy("T",Wav%[]);
            BufferToPlay%:=2;
        endif;
    else 'put Wav% into Wav2, first column, just do the whole damn thing
        arrconst(Wav2%[0:maxpoint%][0],Wav%[0:maxpoint%]);  'Remember that the format is [start:length] NOT [start:end]!!!
    endif;
    
	'Hold the updated start position, necessary for stereo stimuli
    temp% := start%;
    
	'Build the entire trial out of component stimuli - speaker 2, stereo only
    if NSpeakers% = 2 then
        
        start% := 0;  'reset start%
        arrconst(Wav%[],0); 'reset Wav%
        
        for ii%:=1 to ConcatStim2%[WhichTrial%] do
            ThisStim% := StimOrder2%[WhichTrial%][ii%-1];
			'If this stim is not the same as the last one, load this stim
            if ThisStim% <> LastStim% then 				
                arrconst(WavTemp%[],0);  'Set WavTemp%[] to zeros
                
                'ThisStim% is the right index here!
                StimPathHolder$ := StimPath$[WhichStimPath%[ThisStim%]-1];
                
				'open current stimulus
                fh%:=fileopen(StimPathHolder$+StimName$[ThisStim%]+".wfm",9,0);
                if fh%<0 then
                    message("Warning Message | failed to load the stimulus waveform!");
                    printlog("Quitting because Stim waveform %s failed to load!\n",StimPathHolder$+StimName$[ThisStim%]+".wfm");
                    view(HiddenLogHandle%).print("Quitting because Stim waveform %s failed to load!\r",StimPathHolder$+StimName$[ThisStim%]+".wfm");
                    quit%();
                    return 0;
                endif;
				'reads fh% two bytes at a time, puts in WavTemp%[]
                n%:=breadsize(2,WavTemp%[]); 
                
				'close current stimulus
                fileclose();   'close fh%
                
            endif;
            
            'scale current stimulus
            'Calculate rove, if any
            if RovedB > 0 then
                'Bear with this.  We need a random value uniformly distributed in 0.1 increments between -RovedB and RovedB.
                'RovedB is already rounded to the nearest tenth.  We are working in 10x so we can round to the nearest 1
                'and then divide by 10 to get into 0.1 increments.  This is identical to working in 1x and rounding to
                'the nearest 0.1.  So thinking in 1x, the floor of our distribution is -(RovedB+0.05) and the ceiling is
                'RovedB+0.05.  So every value, including the extremes, has 0.05 on either side, meaning equal probability.
                'Note that there is a finite chance of Rand returning 0, and thus a finite chance of -(RovedB+0.1), but...
                TempRovedB := round(rand((RovedB*20)+1,(RovedB*-10)-0.5))/10;
                if ii% = 1 then
                RoveValue$ := RoveValue$ + " Rove2";
            endif;
            RoveValue$ := RoveValue$ + "," + Str$(TempRovedB,0,-1);
            endif;
            TempScale := ScaleFactor[ThisStim%]+RovedB;  'Currently, do not allow for fade in of standard sequence on two-speaker paradigm
            if PA5Absent% = 1 then
                TempScale := TempScale+Atten2[WhichTrial%];
            endif;
            TempScale := pow(10,(-TempScale/20));  'solving "dB = 20 * log10(A1/A2)" for (A1/A2) gives multiplicative scale factor
            ArrConst(WavTempScaled%[],WavTemp%[]);  'move WavTemp%[] into WavTempScaled%[]
            ArrMul(WavTempScaled%[],TempScale);
            
			'Put stimulus into Wav%[]
            arrconst(Wav%[start%:n%],WavTempScaled%[0:n%]);   'Remember that the format is [start:length] NOT [start:end]!!!
            
			'(long note redacted, see above loop)
            EndOfStandards2 := start%/SampleRate;
            
			'Update start position
            start% := start% + n%; 
            
			'Get ISI for this stimulus
            ThisIsi := ISI[ThisStim%];
            
			'If there is an ISI delay, insert it by updating start position, intervening points in
			'Wav%[] are already zero; ISI is in milliseconds, don't insert after final stimulus
            if ThisIsi > 0 and ii% < ConcatStim2%[WhichTrial%] then 
				'Update start position
                start% := start% + (ThisIsi*SamplesPerMS%); 'update start position
            endif;
            
			'Note most recent stimulus
            LastStim% := ThisStim%; 
            
        next;  'Trial is now built in Wav%[]
        
		'Put Wav%[] into Wav2%[][], then into rotating buffers as above
        arrconst(Wav2%[0:maxpoint%][1],Wav%[0:maxpoint%]);  'Remember that the format is [start:length] NOT [start:end]!!!
        if BufferToPlay%=2 then
            ok%:=PlayWaveCopy("S",Wav2%[][]);
            BufferToPlay% := 1;
        else
            ok%:=PlayWaveCopy("T",Wav2%[][]);
            BufferToPlay% := 2;
        endif;
        
    endif;
    
    
	'Determine the duration of the stimulus (or the longer of the two, if stereo)
    if NSpeakers% = 1 then
		'stim duration in seconds, start% is the index of the first open slot in the
		'Wav%[] variable, which is also the number of elements.
        NextStimDur:=(start%)/SampleRate;   
        if VerboseStimLoad% = 1 then
            view(HiddenLogHandle%).print("The next stimulus should be %f samples and %f seconds long\r",start%,start%/SampleRate);
        endif;
    else
        if temp% >= start% then  'temp% is just start% copied over from the first loop (speaker 1)
            NextStimDur:=(temp%)/SampleRate;
            if VerboseStimLoad% = 1 then
                view(HiddenLogHandle%).print("The next stimulus should be %f samples and %f seconds long\r",temp%,temp%/SampleRate);
            endif;
        else
            NextStimDur:=(start%)/SampleRate;
            if VerboseStimLoad% = 1 then
                view(HiddenLogHandle%).print("The next stimulus should be %f samples and %f seconds long\r",start%,start%/SampleRate);
            endif;
        endif;
    endif;
	
    
    return 1;
end;





'========================= Set Trial Result, Go/No-Go Trials =========================
'Checks actual response against expected response and determines result of trial, Go/No-Go
proc TrialResultGoNoGo()
    
    MPenaltyTemp := MPenalty;  'By default, this is what MPenaltyTemp should be

    docase
        'note that RewardCodes%[0] can be set in each case if you want to indicate different
        'values of rewards
    case TargetResponse% = 1 and TargVar%[CurrTrialIndex%] > 0 and TargVar%[CurrTrialIndex%] < 8 then 'HIT
        RandReward(PayHProb,TargVar%[CurrTrialIndex%]);  'will calculate reward status, number of rewards
        'SolenoidOpenDur% := CalcPayVal%(PayHVal,1);  'Reward value, bias term is positive for "go"
        SolenoidOpenDur% := JuiceRewardMS%;
        if RepeatOnError% = 1 then
            HitsR := UpdateBehavVal(HitsR);  'allows us to deal with increment AND StimIsRepeating%
            UpdateBehavVal2(NonRepeatedTrialCount%,HitsNR%[]);
            TrialResult$ := "Hr";
            printlog("Hit\n");
            view(HiddenLogHandle%).print("Hit\r");
        else
            Hits := Hits + 1;
            Hits%[TrialCount%-1] := 1;
            TrialResult$ := "H";
            HitRTTotal := HitRTTotal + ResponseTime2 - StimOn - StimDur;
            printlog("Hit, RT this trial = %.1f, RT Overall on hits = %.1f\n",(ResponseTime2-StimOn-StimDur)*1000,HitRTTotal*1000/Hits);
            view(HiddenLogHandle%).print("Hit, RT this trial = %.1f, RT Overall on hits = %.1f\r",(ResponseTime2-StimOn-StimDur)*1000,HitRTTotal*1000/Hits);
        endif;
        if DoResponseBias% > 0 then
            printlog("The reward size is %d ms\n",SolenoidOpenDur%);  'And report solenoid open duration if changing
            view(HiddenLogHandle%).print("The reward size is %d ms\r",SolenoidOpenDur%);
        endif; 
        UpdateResponseWindow("dec");  'Shorten response window on hits ONLY
        LastResult% := 1;
        UpdateITI();
        
    case TargetResponse% = 1 and TargVar%[CurrTrialIndex%] = 0 then 'FALSE ALARM
        RandReward(PayFAProb,1);  'if rewarding on FA, only reward once
        'SolenoidOpenDur% := PayFAVal;  'Reward value
        SolenoidOpenDur% := 0;
        FalseAlarm% := 1;  'Note that it was a false alarm
        if RepeatOnError% = 1 then
            FAsR := UpdateBehavVal(FAsR);  'allows us to deal with increment AND StimIsRepeating%
            UpdateBehavVal2(NonRepeatedTrialCount%,FAsNR%[]);
            TrialResult$ := "FAr";
        else
            FAs := FAs + 1;
            FAs%[TrialCount%-1] := 1;
            TrialResult$ := "FA";
        endif;
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        printlog("False Alarm\n");
        view(HiddenLogHandle%).print("False Alarm\r");
        LastResult% := -1;
        UpdateITI();
        
    case TargetResponse% = 0 and TargVar%[CurrTrialIndex%] = 0 then 'CORRECT REJECTION
        RandReward(PayCRProb,NumHitsCR%);  'Calculate reward, give number based on CR value
        'SolenoidOpenDur% := CalcPayVal%(PayCRVal,-1);  'Reward value, bias term is negative for "no-go"
        SolenoidOpenDur% := JuiceRewardMS%;
        if RepeatOnError% = 1 then
            CRsR := UpdateBehavVal(CRsR);  'allows us to deal with increment AND StimIsRepeating%
            UpdateBehavVal2(NonRepeatedTrialCount%,CRsNR%[]);
            TrialResult$ := "CRr";
        else
            CRs := CRs + 1;
            CRs%[TrialCount%-1] := 1;
            TrialResult$ := "CR";
        endif;
        printlog("Correct Rejection\n");
        view(HiddenLogHandle%).print("Correct Rejection\r");
        if DoResponseBias% > 0 then
            printlog("The reward size is %d ms\n",SolenoidOpenDur%);  'And report solenoid open duration if changing
            view(HiddenLogHandle%).print("The reward size is %d ms\r",SolenoidOpenDur%);
        endif; 
        LastResult% := 1;
        UpdateITI();
        
    case TargetResponse% = 0 and TargVar%[CurrTrialIndex%] > 0 and TargVar%[CurrTrialIndex%] < 8 then 'MISS
        RandReward(PayMProb,1); 'If paying on miss, only give one reward
        'SolenoidOpenDur% := PayMVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Note that it was a Miss
        if RepeatOnError% = 1 then
            MissesR := UpdateBehavVal(MissesR);  'allows us to deal with increment AND StimIsRepeating%
            UpdateBehavVal2(NonRepeatedTrialCount%,MissesNR%[]);
            TrialResult$ := "Mr";
        else
            Misses := Misses + 1;
            Misses%[TrialCount%-1] := 1;
            TrialResult$ := "M";
        endif;
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        UpdateResponseWindow("inc");  'Extend response window on misses ONLY
        printlog("Miss\n");
        view(HiddenLogHandle%).print("Miss\r");
        LastResult% := -1;
        UpdateITI();
        
    case TargetResponse% = 1 and TargVar%[CurrTrialIndex%] = 8 then 'PROBE 1 TARGET RESPONSE
        RandReward(PayPTProb,1);  'if paying on probe, only give one reward
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        if RepeatOnError% = 1 then
            PoTsR := UpdateBehavVal(PoTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1Tr";
        else
            PoTs := PoTs + 1;
            TrialResult$ := "P1T";
        endif;
        printlog("Probe 1, Target Response\n");
        view(HiddenLogHandle%).print("Probe 1, Target Response\r");
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 0 and TargVar%[CurrTrialIndex%] = 8 then 'PROBE 1 NONTARGET RESPONSE
        RandReward(PayPNTProb,1); 'if paying on probe, only give one reward
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        if RepeatOnError% = 1 then
            PoNTsR := UpdateBehavVal(PoNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1NTr";
        else
            PoNTs := PoNTs + 1;
            TrialResult$ := "P1NT";
        endif;
        printlog("Probe 1, Nontarget Response\n");
        view(HiddenLogHandle%).print("Probe 1, Nontarget Response\r");
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and TargVar%[CurrTrialIndex%] = 9 then 'PROBE 2 TARGET RESPONSE
        RandReward(PayPTProb,1);  'if paying on probe, only give one reward
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        if RepeatOnError% = 1 then
            PtTsR := UpdateBehavVal(PtTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2Tr";
        else
            PtTs := PtTs + 1;
            TrialResult$ := "P2T";
        endif;
        printlog("Probe 2, Target Response\n");
        view(HiddenLogHandle%).print("Probe 2, Target Response\r");
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 0 and TargVar%[CurrTrialIndex%] = 9 then 'PROBE 2 NONTARGET RESPONSE
        RandReward(PayPNTProb,1); 'if paying on probe, only give one reward
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        if RepeatOnError% = 1 then
            PtNTsR := UpdateBehavVal(PtNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2NTr";
        else
            PtNTs := PtNTs + 1;
            TrialResult$ := "P2NT";
        endif;
        printlog("Probe 2, Nontarget Response\n");
        view(HiddenLogHandle%).print("Probe 2, Nontarget Response\r");
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 100 and TargVar%[CurrTrialIndex%] > 0 and TargVar%[CurrTrialIndex%] < 8 then 'NO RESPONSE IN MONOJOYSTICKFRUD, TARGET
        if RepeatOnError% = 1 then
            'note that the UpNR etc. values are never used, so I'm not going to make new variables for this.  Just let it slide
            'until (if) we actually want to report this junk
            TrialResult$ := "NRTr";
        else
            TrialResult$ := "NRT";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for no response
        UpdateResponseWindow("inc");  'Lengthen response window on no-response
        printlog("NoResponse(Target)\n");
        view(HiddenLogHandle%).print("NoResponse(Target)\r");
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        LastResult% := -1;
        
    case TargetResponse% = 100 and TargVar%[CurrTrialIndex%] = 0 then 'NO RESPONSE IN MONOJOYSTICKFRUD, NONTARGET
        if RepeatOnError% = 1 then
            TrialResult$ := "NRNTr";
        else
            TrialResult$ := "NRNT";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for no response
        UpdateResponseWindow("inc");  'Lengthen response window on no-response
        printlog("NoResponse(NonTarget)\n");
        view(HiddenLogHandle%).print("NoResponse(NonTarget)\r");
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        LastResult% := -1;   
        
    else  'does not fit, should not ever enter here, but just in case
        printlog("The combination of Target Repsonse %d and Nontarget/Target/Probe type %d is not recognized!!\n",TargetResponse%,TargVar%[CurrTrialIndex%]);
        view(HiddenLogHandle%).print("The combination of Target Repsonse %d and Nontarget/Target/Probe type %d is not recognized!!\r",TargetResponse%,TargVar%[CurrTrialIndex%]);
        RewardCount% := 1;  'Do not allow penalty
        SolenoidOpenDur% := 2;  'Allow minimal reward to avoid potential crash
        LastResult% := 0;
    endcase;
    
    
    
end
'========================= Set Trial Result, Up/Down Forced Choice Trials =========================
'Checks actual response against expected response and determines result of trial, forced choice up/down
func TrialResultForcedChoiceUD(NRew%,NRew2%)
    
    MPenaltyTemp := MPenalty;  'By default, this is what MPenaltyTemp should be
    
    docase
    case TargetResponse% = 1 and ExpectedResponse% = 1 then 'Hit (up)
        if RepeatOnError% = 1 then
            UpHitsR := UpdateBehavVal(UpHitsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "HUr";
        else
            UpHits := UpHits + 1;
            UpHits%[TrialCount%-1] := 1;
            TrialResult$ := "HU";
        endif;
        RandReward(PayHUProb,NRew%);  'will calculate reward status, number of rewards
        'SolenoidOpenDur% := CalcPayVal%(PayHUVal,1);  'Reward value, bias term is positive for "up"
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("Hit(Up)\n");
        view(HiddenLogHandle%).print("Hit(Up)\r");
        if DoResponseBias% > 0 then
            printlog("The reward size is %d ms\n",SolenoidOpenDur%);  'And report solenoid open duration if changing
            view(HiddenLogHandle%).print("The reward size is %d ms\r",SolenoidOpenDur%);
        endif; 
        ChangeThresh(1,0,1,1);  'Increase Up thresh on a hit, increase X threshold on any completed trial
        UpdateResponseWindow("dec");  'Shorten response window on hits ONLY
        LastResult% := 1;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 2 then 'Miss (joystick up)
        if RepeatOnError% = 1 then
            UpMissesR := UpdateBehavVal(UpMissesR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "MUr";
        else
            UpMisses := UpMisses + 1;
            UpMisses%[TrialCount%-1] := 1;
            TrialResult$ := "MU";
        endif;
        RandReward(PayMUProb,1);  'will calculate reward status, only one reward on miss
        'SolenoidOpenDur% := PayMUVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1; 
        MPenaltyTemp := MPenaltyTDown;  'change MPenaltyTemp to the correct penalty for down target
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        printlog("Miss(JoystickUp)\n");
        view(HiddenLogHandle%).print("Miss(JoystickUp)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := -1;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 18 then 'Probe 1 (joystick to probe)
        if RepeatOnError% = 1 then
            PoTsR := UpdateBehavVal(PoTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1PUr";
        else
            PoTs := PoTs + 1;
            TrialResult$ := "P1PU";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("ToProbe1(Up)\n");
        view(HiddenLogHandle%).print("ToProbe1(Up)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 28 then 'Probe 1 (joystick to nontarget)
        if RepeatOnError% = 1 then
            PoNTsR := UpdateBehavVal(PoNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1NPUr";
        else
            PoNTs := PoNTs + 1;
            TrialResult$ := "P1NPU";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only on reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe1(JoystickUp)\n");
        view(HiddenLogHandle%).print("AwayFromProbe1(JoystickUp)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 19 then 'Probe 2 (joystick to probe)
        if RepeatOnError% = 1 then
            PtTsR := UpdateBehavVal(PtTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2PUr";
        else
            PtTs := PtTs + 1;
            TrialResult$ := "P2PU";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("ToProbe2(Up)\n");
        view(HiddenLogHandle%).print("ToProbe2(Up)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 29 then 'Probe 2 (joystick to nontarget)
        if RepeatOnError% = 1 then
            PtNTsR := UpdateBehavVal(PtNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2NPUr";
        else
            PtNTs := PtNTs + 1;
            TrialResult$ := "P2NPU";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only on reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe2(JoystickUp)\n");
        view(HiddenLogHandle%).print("AwayFromProbe2(JoystickUp)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 0 then 'Catch trial (up)
        if RepeatOnError% = 1 then
            CatchUpR := UpdateBehavVal(CatchUpR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "CUr";
        else
            CatchUp := CatchUp + 1;
            TrialResult$ := "CU";
        endif;
        RandReward(PayMUProb,1);  'will calculate reward status, only one reward on response to catch
        'SolenoidOpenDur% := PayMUVal;  'Reward value
        SolenoidOpenDur% := 0;
        printlog("Catch(JoystickUp)\n");
        view(HiddenLogHandle%).print("Catch(JoystickUp)\r");
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := CatchPenalty;  'change MPenaltyTemp to the correct penalty for catch trial
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 2 then 'Hit (down)
        if RepeatOnError% = 1 then
            DownHitsR := UpdateBehavVal(DownHitsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "HDr";
        else
            DownHits := DownHits + 1;
            DownHits%[TrialCount%-1] := 1;
            TrialResult$ := "HD";
        endif;
        RandReward(PayHDProb,NRew2%);  'will calculate reward status, number of reward hits
        'SolenoidOpenDur% := CalcPayVal%(PayHDVal,-1);  'Reward value, bias term is negative for "down"
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("Hit(Down)\n");
        view(HiddenLogHandle%).print("Hit(Down)\r");
        if DoResponseBias% > 0 then
            printlog("The reward size is %d ms\n",SolenoidOpenDur%);  'And report solenoid open duration if changing
            view(HiddenLogHandle%).print("The reward size is %d ms\r",SolenoidOpenDur%);
        endif; 
        ChangeThresh(0,1,1,1);  'Increase Down thresh on a hit, increase X threshold on any completed trial
        UpdateResponseWindow("dec");  'Shorten response window on hits ONLY
        LastResult% := 1;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 1 then 'Miss (joystick down)
        if RepeatOnError% = 1 then
            DownMissesR := UpdateBehavVal(DownMissesR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "MDr";
        else
            DownMisses := DownMisses + 1;
            DownMisses%[TrialCount%-1] := 1;
            TrialResult$ := "MD";
        endif;
        RandReward(PayMDProb,1);  'will calculate reward status, only one reward on miss
        'SolenoidOpenDur% := PayMDVal;  'Reward value
        SolenoidOpenDur% := 0;
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        Miss% := 1; 
        MPenaltyTemp := MPenaltyTUp;  'change MPenaltyTemp to the correct penalty for up target
        printlog("Miss(JoystickDown)\n");
        view(HiddenLogHandle%).print("Miss(JoystickDown)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := -1;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 18 then 'Probe 1 (to nontarget)
        if RepeatOnError% = 1 then
            PoNTsR := UpdateBehavVal(PoNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1NPDr";
        else
            PoNTs := PoNTs + 1;
            TrialResult$ := "P1NPD";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe1(JoystickDown)\n");
        view(HiddenLogHandle%).print("AwayFromProbe1(JoystickDown)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 28 then 'Probe 1 (to probe)
        if RepeatOnError% = 1 then
            PoTsR := UpdateBehavVal(PoTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1PDr";
        else
            PoTs := PoTs + 1;
            TrialResult$ := "P1PD";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("ToProbe1(Down)\n");
        view(HiddenLogHandle%).print("ToProbe1(Down)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 19 then 'Probe 2 (to nontarget)
        if RepeatOnError% = 1 then
            PtNTsR := UpdateBehavVal(PtNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2NPDr";
        else
            PtNTs := PtNTs + 1;
            TrialResult$ := "P2NPD";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe2(JoystickDown)\n");
        view(HiddenLogHandle%).print("AwayFromProbe2(JoystickDown)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 29 then 'Probe 2 (to probe)
        if RepeatOnError% = 1 then
            PtTsR := UpdateBehavVal(PtTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2PDr";
        else
            PtTs := PtTs + 1;
            TrialResult$ := "P2PD";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("ToProbe2(Down)\n");
        view(HiddenLogHandle%).print("ToProbe2(Down)\r");
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 0 then 'Catch trial (down)
        if RepeatOnError% = 1 then
            CatchDownR := UpdateBehavVal(CatchDownR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "CDr";
        else
            CatchDown := CatchDown + 1;
            TrialResult$ := "CD";
        endif;
        RandReward(PayMDProb,1);  'will calculate reward status, only one reward on response to catch
        'SolenoidOpenDur% := PayMDVal;  'Reward value
        SolenoidOpenDur% := 0;
        printlog("Catch(JoystickDown)\n");
        view(HiddenLogHandle%).print("Catch(JoystickDown)\r");
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := CatchPenalty;  'change MPenaltyTemp to the correct penalty for catch trial
        ChangeThresh(0,0,1,1);  'Increase X threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 0 and ExpectedResponse% = 1 then 'No Response (up)
        if RepeatOnError% = 1 then
            UpNRR := UpdateBehavVal(UpNRR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRUr";
        else
            UPNR := UpNR + 1;
            TrialResult$ := "NRU";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for no response
        UpdateResponseWindow("inc");  'Lengthen response window on no-response
        printlog("NoResponse(TargetUp)\n");
        view(HiddenLogHandle%).print("NoResponse(TargetUp)\r");
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        LastResult% := -1;
        
    case TargetResponse% = 0 and ExpectedResponse% = 2 then 'No Response (down)
        if RepeatOnError% = 1 then
            DownNRR := UpdateBehavVal(DownNRR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRDr";
        else
            DownNR := DownNR + 1;
            TrialResult$ := "NRD";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for no response
        UpdateResponseWindow("inc");  'Lengthen response window on no-response
        printlog("NoResponse(TargetDown)\n");
        view(HiddenLogHandle%).print("NoResponse(TargetDown)\r");
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        LastResult% := -1;
        
    case TargetResponse% = 0 and ExpectedResponse% = 8 then 'No Response (probe 2)
        if RepeatOnError% = 1 then
            PoNRsR := UpdateBehavVal(PoNRsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRP1r";
        else
            PoNRs := PoNRs + 1;
            TrialResult$ := "NRP1";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for no response
        printlog("NoResponse(Probe1)\n");
        view(HiddenLogHandle%).print("NoResponse(Probe1)\r");
        LastResult% := 0;
        
    case TargetResponse% = 0 and ExpectedResponse% = 9 then 'No Response (probe 2)
        if RepeatOnError% = 1 then
            PtNRsR := UpdateBehavVal(PtNRsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRP2r";
        else
            PtNRs := PtNRs + 1;
            TrialResult$ := "NRP2";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for no response
        printlog("NoResponse(Probe2)\n");
        view(HiddenLogHandle%).print("NoResponse(Probe2)\r");
        LastResult% := 0;
        
    case TargetResponse% = 0 and ExpectedResponse% = 0 then 'No Response (Catch)
        if RepeatOnError% = 1 then
            CatchNRR := UpdateBehavVal(CatchNRR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRCr";
        else
            CatchNR := CatchNR + 1;
            TrialResult$ := "NRC";
        endif;
        RandReward(PayCatchProb,NumHitsCR%);  'will calculate reward status, give same number of hits as CR
        'SolenoidOpenDur% := PayCatchVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("NoResponse(Catch)\n");
        view(HiddenLogHandle%).print("NoResponse(Catch)\r");
        LastResult% := 0;
        
    else  'does not fit, should not ever enter here, but just in case
        printlog("The combination of Target Repsonse %d and Nontarget/Target/Probe type %d is not recognized!!\n",TargetResponse%,TargVar%[CurrTrialIndex%]);
        view(HiddenLogHandle%).print("The combination of Target Repsonse %d and Nontarget/Target/Probe type %d is not recognized!!\r",TargetResponse%,TargVar%[CurrTrialIndex%]);
        RewardCount% := 1;  'Do not allow penalty
        SolenoidOpenDur% := 2;  'Allow minimal reward to avoid potential crash
        LastResult% := 0;
    endcase;
    
end

'========================= Set Trial Result, Left/Right Forced Choice Trials =========================
'Checks actual response against expected response and determines result of trial, forced choice left/right
func TrialResultForcedChoiceLR(NRew%,Nrew2%)
    
    MPenaltyTemp := MPenalty;  'By default, this is what MPenaltyTemp should be
    
    'Note that target response is the X position - which is LR flipped for Human and Monkey joysticks!
    if JoystickType% = 1 then  'denotes HUMAN joystick
        docase
        case TargetResponse% = 1 then
            TargetResponse% := 2;
        case TargetResponse% = 2 then
            TargetResponse% := 1;
        endcase
    endif;
    
    
    docase
    case TargetResponse% = 1 and ExpectedResponse% = 1 then 'Hit (right)
        if RepeatOnError% = 1 then
            RightHitsR := UpdateBehavVal(RightHitsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "HRr";
        else
            RightHits := RightHits + 1;
            RightHits%[TrialCount%-1] := 1;
            TrialResult$ := "HR";
        endif;
        RandReward(PayHRProb,NRew%);  'will calculate reward status, number of reward hits
        'SolenoidOpenDur% := CalcPayVal%(PayHRVal,1);  'Reward value, bias term is positive for "right"
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("Hit(Right)\n");
        view(HiddenLogHandle%).print("Hit(Right)\r");
        if DoResponseBias% > 0 then
            printlog("The reward size is %d ms\n",SolenoidOpenDur%);  'And report solenoid open duration if changing
            view(HiddenLogHandle%).print("The reward size is %d ms\r",SolenoidOpenDur%);
        endif; 
        ChangeThresh(1,1,0,1);  'Increase Right thresh on a hit, increase Y threshold on any completed trial
        UpdateResponseWindow("dec");  'Shorten response window on hits ONLY
        LastResult% := 1;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 2 then 'Miss (joystick right)
        if RepeatOnError% = 1 then
            RightMissesR := UpdateBehavVal(RightMissesR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "MRr";
        else
            RightMisses := RightMisses + 1;
            RightMisses%[TrialCount%-1] := 1;
            TrialResult$ := "MR";
        endif;
        RandReward(PayMRProb,1);  'will calculate reward status, only one reward on miss
        'SolenoidOpenDur% := PayMRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Note that it was a miss
        MPenaltyTemp := MPenaltyTDown;  'change MPenaltyTemp to the correct penalty for DOWN target, will add LEFT variable if necessary
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        printlog("Miss(JoystickRight)\n");
        view(HiddenLogHandle%).print("Miss(JoystickRight)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := -1;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 18 then 'Probe (to probe 1)
        if RepeatOnError% = 1 then
            PoTsR := UpdateBehavVal(PoTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1PRr";
        else
            PoTs := PoTs + 1;
            TrialResult$ := "P1PR";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("ToProbe1(Right)\n");
        view(HiddenLogHandle%).print("ToProbe1(Right)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 19 then 'Probe (to probe 2)
        if RepeatOnError% = 1 then
            PtTsR := UpdateBehavVal(PtTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2PRr";
        else
            PtTs := PtTs + 1;
            TrialResult$ := "P2PR";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("ToProbe2(Right)\n");
        view(HiddenLogHandle%).print("ToProbe2(Right)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 28 then 'Probe 1(to nontarget)
        if RepeatOnError% = 1 then
            PoNTsR := UpdateBehavVal(PoNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1NPRr";
        else
            PoNTs := PoNTs + 1;
            TrialResult$ := "P1NPR";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe1(JoystickRight)\n");
        view(HiddenLogHandle%).print("AwayFromProbe1(JoystickRight)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 29 then 'Probe 2(to nontarget)
        if RepeatOnError% = 1 then
            PtNTsR := UpdateBehavVal(PtNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2NPRr";
        else
            PtNTs := PtNTs + 1;
            TrialResult$ := "P2NPR";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe2(JoystickRight)\n");
        view(HiddenLogHandle%).print("AwayFromProbe2(JoystickRight)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 1 and ExpectedResponse% = 0 then 'Catch trial (right)
        if RepeatOnError% = 1 then
            CatchRightR := UpdateBehavVal(CatchRightR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "CRr";
        else
            CatchRight := CatchRight + 1;
            TrialResult$ := "CR";
        endif;
        RandReward(PayMRProb,1);  'will calculate reward status, only one reward on response to catch trial
        'SolenoidOpenDur% := PayMRVal;  'Reward value
        SolenoidOpenDur% := 0;
        printlog("Catch(JoystickRight)\n");
        view(HiddenLogHandle%).print("Catch(JoystickRight)\r");
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := CatchPenalty;  'change MPenaltyTemp to the correct penalty for catch trial
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 2 then 'Hit (Left)
        if RepeatOnError% = 1 then
            LeftHitsR := UpdateBehavVal(LeftHitsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "HLr";
        else
            LeftHits := LeftHits + 1;
            LeftHits%[TrialCount%-1] := 1;
            TrialResult$ := "HL";
        endif;
        RandReward(PayHLProb,NRew2%);  'will calculate reward status, number of reward hits
        'SolenoidOpenDur% := CalcPayVal%(PayHLVal,-1);  'Reward value, bias term is negative for "left"
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("Hit(Left)\n");
        view(HiddenLogHandle%).print("Hit(Left)\r");
        if DoResponseBias% > 0 then
            printlog("The reward size is %d ms\n",SolenoidOpenDur%);  'And report solenoid open duration if changing
            view(HiddenLogHandle%).print("The reward size is %d ms\r",SolenoidOpenDur%);
        endif; 
        ChangeThresh(1,1,1,0);  'Increase Left thresh on a hit, increase Y threshold on any completed trial
        UpdateResponseWindow("dec");  'Shorten response window on hits ONLY
        LastResult% := 1;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 1 then 'Miss (joystick left)
        if RepeatOnError% = 1 then
            LeftMissesR := UpdateBehavVal(LeftMissesR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "MLr";
        else
            LeftMisses := LeftMisses + 1;
            LeftMisses%[TrialCount%-1] := 1;
            TrialResult$ := "ML";
        endif;
        RandReward(PayMLProb,1);  'will calculate reward status, only one reward on miss
        'SolenoidOpenDur% := PayMLVal;  'Reward value
        SolenoidOpenDur% := 0;
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        Miss% := 1;  'Note that it was a miss
        MPenaltyTemp := MPenaltyTUp;  'change MPenaltyTemp to the correct penalty for UP target, will add RIGHT variable if necessary
        printlog("Miss(JoystickLeft)\n");
        view(HiddenLogHandle%).print("Miss(JoystickLeft)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := -1;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 18 then 'Probe 1(to nontarget)
        if RepeatOnError% = 1 then
            PoNTsR := UpdateBehavVal(PoNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1NPLr";
        else
            PoNTs := PoNTs + 1;
            TrialResult$ := "P1NPL";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe1(JoystickLeft)\n");
        view(HiddenLogHandle%).print("AwayFromProbe1(JoystickLeft)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 19 then 'Probe 2(to nontarget)
        if RepeatOnError% = 1 then
            PtNTsR := UpdateBehavVal(PtNTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2NPLr";
        else
            PtNTs := PtNTs + 1;
            TrialResult$ := "P2NPL";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("AwayFromProbe2(JoystickLeft)\n");
        view(HiddenLogHandle%).print("AwayFromProbe2(JoystickLeft)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 28 then 'Probe 1(to probe)
        if RepeatOnError% = 1 then
            PoTsR := UpdateBehavVal(PoTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P1PLr";
        else
            PoTs := PoTs + 1;
            TrialResult$ := "P1PL";
        endif;
        RandReward(PayPTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPTVal;  'Reward value
        SolenoidOpenDur% := 0;
        printlog("ToProbe1(Left)\n");
        view(HiddenLogHandle%).print("ToProbe1(Left)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 29 then 'Probe 2(to probe)
        if RepeatOnError% = 1 then
            PtTsR := UpdateBehavVal(PtTsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "P2PLr";
        else
            PtTs := PtTs + 1;
            TrialResult$ := "P2PL";
        endif;
        RandReward(PayPNTProb,1);  'will calculate reward status, only one reward on probe
        'SolenoidOpenDur% := PayPNTVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("ToProbe2(Left)\n");
        view(HiddenLogHandle%).print("ToProbe2(Left)\r");
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 2 and ExpectedResponse% = 0 then 'Catch trial (left)
        if RepeatOnError% = 1 then
            CatchLeftR := UpdateBehavVal(CatchLeftR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "CLr";
        else
            CatchLeft := CatchLeft + 1;
            TrialResult$ := "CL";
        endif;
        RandReward(PayMLProb,1);  'will calculate reward status, only one reward on response to catch
        'SolenoidOpenDur% := PayMLVal;  'Reward value
        SolenoidOpenDur% := 0;
        printlog("Catch(JoystickLeft)\n");
        view(HiddenLogHandle%).print("Catch(JoystickLeft)\r");
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := CatchPenalty;  'change MPenaltyTemp to the correct penalty for catch trial
        ChangeThresh(1,1,0,0);  'Increase Y threshold on any completed trial
        LastResult% := 0;
        UpdateITI();
        
    case TargetResponse% = 0 and ExpectedResponse% = 1 then 'No Response (right)
        if RepeatOnError% = 1 then
            RightNRR := UpdateBehavVal(RightNRR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRRr";
        else
            RightNR := RightNR + 1;
            TrialResult$ := "NRR";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for non-response
        UpdateResponseWindow("inc");  'Lengthen response window on no-response
        printlog("NoResponse(TargetRight)\n");
        view(HiddenLogHandle%).print("NoResponse(TargetRight)\r");
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        LastResult% := -1;
        
    case TargetResponse% = 0 and ExpectedResponse% = 2 then 'No Response (left)
        if RepeatOnError% = 1 then
            LeftNRR := UpdateBehavVal(LeftNRR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRLr";
        else
            LeftNR := LeftNR + 1;
            TrialResult$ := "NRL";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for non-response
        UpdateResponseWindow("inc");  'Lengthen response window on no-response
        printlog("NoResponse(TargetLeft)\n");
        view(HiddenLogHandle%).print("NoResponse(TargetLeft)\r");
        if RepeatOnError% = 1 then
            FutureTrialIndex% := CurrTrialIndex%;  '"decrement" current trial to present this stimulus again
            FutureTrialIndexList%[SwitchCurrFile%-1] := CurrTrialIndexList%[SwitchCurrFile%-1];  'decrement list as well
        endif;
        LastResult% := -1;
        
    case TargetResponse% = 0 and ExpectedResponse% = 8 then 'No Response (probe 1)
        if RepeatOnError% = 1 then
            PoNRsR := UpdateBehavVal(PoNRsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRP1r";
        else
            PoNRs := PoNRs + 1;
            TrialResult$ := "NRP1";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for non-response
        printlog("NoResponse(Probe1)\n");
        view(HiddenLogHandle%).print("NoResponse(Probe1)\r");
        LastResult% := 0;
        
    case TargetResponse% = 0 and ExpectedResponse% = 9 then 'No Response (probe 2)
        if RepeatOnError% = 1 then
            PtNRsR := UpdateBehavVal(PtNRsR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRP2r";
        else
            PtNRs := PtNRs + 1;
            TrialResult$ := "NRP2";
        endif;
        RandReward(PayNRProb,1);  'will calculate reward status, only one reward on no-response
        'SolenoidOpenDur% := PayNRVal;  'Reward value
        SolenoidOpenDur% := 0;
        Miss% := 1;  'Consider it a miss
        MPenaltyTemp := NRPenalty;  'change MPenaltyTemp to the correct penalty for non-response
        printlog("NoResponse(Probe2)\n");
        view(HiddenLogHandle%).print("NoResponse(Probe2)\r");
        LastResult% := 0;
        
    case TargetResponse% = 0 and ExpectedResponse% = 0 then 'No Response (Catch)
        if RepeatOnError% = 1 then
            CatchNRR := UpdateBehavVal(CatchNRR);  'allows us to deal with increment AND StimIsRepeating%
            TrialResult$ := "NRCr";
        else
            CatchNR := CatchNR + 1;
            TrialResult$ := "NRC";
        endif;
        RandReward(PayCatchProb,NumHitsCR%);  'will calculate reward status, give same number of rewards as for CR
        'SolenoidOpenDur% := PayCatchVal;  'Reward value
        SolenoidOpenDur% := JuiceRewardMS%;
        printlog("NoResponse(Catch)\n");
        view(HiddenLogHandle%).print("NoResponse(Catch)\r");
        LastResult% := 0;
        
    else  'does not fit, should not ever enter here, but just in case
        printlog("The combination of Target Repsonse %d and Nontarget/Target/Probe type %d is not recognized!!\n",TargetResponse%,TargVar%[CurrTrialIndex%]);
        view(HiddenLogHandle%).print("The combination of Target Repsonse %d and Nontarget/Target/Probe type %d is not recognized!!\r",TargetResponse%,TargVar%[CurrTrialIndex%]);
        RewardCount% := 1;  'Do not allow penalty
        SolenoidOpenDur% := 2;  'Allow minimal reward to avoid potential crash
        LastResult% := 0;
    endcase;
    
end


'============================== Set Attenuation Level ================================
func SetPA5(Attenuation,Attenuation2)
    
    
    var PA5Handle%;
    var SetPA5Killed%;   'have we killed the SetPA5 program?
    'var TimeCount%;      'How long has SetPa5 been running?
    var QueryResult%;
    var StartTime;  'when did we first send the command to the PA5?
    var NowTime;    'makes accurate printlogs easier
    var numTries% := 0;  
    var maxTries% := 5;  'let's try setting the PA5 5 times before giving up
    
    
    'Put ceiling on PA5 setting - anytime atten is set to 120 dB or more (calibration dB + trial-based dB)
    'because this is the limit of the PA5.  Requests to set PA5 to higher values will result in NO VALUE
    'BEING SET
    if Attenuation > 120 then
        Attenuation := 120;
    endif;
    if Attenuation2 > 120 then
        Attenuation2 := 120;
    endif;
    
    while numTries% < maxTries% do  'automatic re-try 5 times, don't know if this might possibly help at all
        SetPA5Killed% := 0;  'reset
        'Run program to set attenuation at the PA5
        if NSpeakers% = 1 then
            PA5Handle%:=ProgRun(SetPA5Loc$+" "+str$(Attenuation));  'now using SetPA5Loc
        else
            PA5Handle%:=ProgRun(SetPA5sLoc$+" "+str$(Attenuation)+" "+str$(Attenuation2));  'format for SetPA5s
        endif;
    
        if VerbosePA5% = 1 then
            printlog("Setting PA5, attempt #%d, handle = %d\n",PA5Handle%,numTries%+1);
            view(HiddenLogHandle%).print("Setting PA5, attempt #%d, handle = %d\r",PA5Handle%,numTries%+1);
        endif;
    
        StartTime := view(ctview%).maxtime();  'it's OK to look at maxtime() because SetPA5 is only called while sampling
        'Wait for program changing the PA5 level to finish. This takes about .15 seconds.
        while ProgStatus(PA5Handle%) > 0 and SetPA5Killed% = 0 do 
            NowTime := view(ctview%).maxtime();
            if (NowTime - StartTime) > 1 then 'if it has been more than one second, kill the PA5
                ProgKill(PA5Handle%);   'kill SetPA5
                SetPA5Killed% := 1;  'break out of while loop if it takes over a second
                numTries% += 1;  'Increment number of tries
                if VerbosePA5% = 1 then 
                    printlog("Setting PA5 failed, status = %d\n",ProgStatus(PA5Handle%));
                    view(HiddenLogHandle%).print("Setting PA5 failed, status = %d\r",ProgStatus(PA5Handle%));
                endif
            endif;
        wend;
        if SetPA5Killed% = 0 then  'break the while loop on success
            numTries% := maxTries%+1; 
            if VerbosePA5% = 1 then 
                printlog("Success setting PA5, required time = %f\n",NowTime-StartTime);
                view(HiddenLogHandle%).print("Success setting PA5 required time = %f\r",NowTime-StartTime);
            endif
        endif;
    wend;
    
    
    if SetPA5Killed% = 1 then
        QueryResult% := query("The PA5 appears to be down.  Please cycle the PA5 and click OK, or press END to quit.","OK","END");
        if QueryResult% = 1 then
            SetPA5(Attenuation,Attenuation2);  'try again
        else
            printlog("Quitting because the user chose to quit rather than cycle the PA5\n");
            view(HiddenLogHandle%).print("Quitting because the user chose to quit rather than cycle the PA5\r");
            quit%();
        endif;
    else
        if VerbosePA5% = 1 or TrialCount% = 0 then 
            printlog("Success in setting PA5!\n");
            view(HiddenLogHandle%).print("Success in setting PA5!\r");
        endif;
    endif;
    
    return 1;
end;


'========================= Turn On/Off Required Cue Lights ===========================
'New function as of 1.3.2 which replaces the prior SafeSampleKeySutter%() cue/house light calls and allows for more flexible
'cue light action (but don't think you can get too fancy)
proc CueLights(HouseOnOffSame$,Cues$,OnOffSame$);  
    
    var loopy%;   'A looping variable
    var tempstr$; 'A temporary string variable
    var NoLight%; 'Keeps track of whether any cue light at all has been changed, to detect param file errors
    
    'Note that the param file should have the info strings y, r, g, rg, ry, gy, gry, etc. to indicate which of the three
    '(y)ellow (r)ed and (g)reen lights should be used.  The info string "red" is incorrect syntax.  However, it might
    'happen, and will be transparent, because this function simply scans through each letter and lights the corresponding
    'light, if applicable, and doesn't throw an error for an unexpected character. "yellow" is similarly not a problem.
    'But "green" would light both green and red lights, so despite the fact that it is incorrect syntax I'm putting in a
    'dummy check for it anyway.  Thus case-insensitive "green" will short-circuit the normal check, and light only the 
    'green light.  I can't expect to deal with all possible syntax errors ("green+yellow" for example) but I'm trying to
    'at least make the most obvious one not fail.
    '
    'Further note that if the info field does not have an "r", a "g", OR a "y", the function will by default assume a
    'yellow cue light rather than no light at all.  If for some bizarre reason no light is required, just put another
    'short-circuit check in...
    
    'First, change the House light if requested
    docase  'Any command NOT "on" or "off" will result in no change of House light
        case LCase$(HouseOnOffSame$) = "on" then
        'SafeSampleKeySutter%("I");  'Turn on House light
        case LCase$(HouseOnOffSame$) = "off" then
        'SafeSampleKeySutter%("J");  'Turn off House light
        case LCase$(HouseOnOffSame$) = "same" then
        'do nothing
    else
        printlog("CueLights was called with invalid house light on/off/same argument %s!\n",HouseOnOffSame$);
        view(HiddenLogHandle%).print("CueLights was called with invalid house light on/off/same argument %s!\r",HouseOnOffSame$);
    endcase;
    
    'Next, change the cue lights
    docase  'Any command NOT "on" or "off" will result in no change of Cue lights
        case LCase$(OnOffSame$) = "on" then  'turn on all appropriate cue lights
        if LCase$(Cues$) = "green" then
            'SafeSampleKeySutter%("G");  'turn on green LED if (incorrect) "green" command is given ("(g)(r)een" results in (g)reen+(r)ed)
        else
            NoLight% := 1;  'indicate that no light has been selected yet
            for loopy% := 1 to len(Cues$) do
                tempstr$ := Left$(Cues$,1);
                Cues$ := DelStr$(Cues$,1,1);
                docase
                    case LCase$(tempstr$) = "r" then
                    'SafeSampleKeySutter%("V");  'turn on red LED
                    NoLight% := 0;  'At least one light was indicated
                    case LCase$(tempstr$) = "g" then
                    'SafeSampleKeySutter%("G");  'turn on green LED
                    NoLight% := 0;  'At least one light was indicated
                    case LCase$(tempstr$) = "y" then
                    'SafeSampleKeySutter%("L");  'turn on yellow LED
                    NoLight% := 0;  'At least one light was indicated
                endcase;
            next;
        endif;
        if NoLight% = 1 then
            'SafeSampleKeySutter%("L"); 'turn on yellow LED if there is no light indicated in the trials file
        endif;
        case LCase$(OnOffSame$) = "off" then  'turn off all appropriate cue lights
        if LCase$(Cues$) = "green" then
            SafeSampleKeySutter%("H");  'turn off green LED if (incorrect) "green" command is given ("(g)(r)een" results in (g)reen+(r)ed)
        else
            NoLight% := 1;
            for loopy% := 1 to len(Cues$) do
                tempstr$ := Left$(Cues$,1);
                Cues$ := DelStr$(Cues$,1,1);
                docase
                    case LCase$(tempstr$) = "r" then
                    'SafeSampleKeySutter%("W");  'turn off red LED
                    NoLight% := 0;  'At least one light was indicated
                    case LCase$(tempstr$) = "g" then
                    'SafeSampleKeySutter%("H");  'turn off green LED
                    NoLight% := 0;  'At least one light was indicated
                    case LCase$(tempstr$) = "y" then
                    'SafeSampleKeySutter%("M");  'turn off yellow LED
                    NoLight% := 0;  'At least one light was indicated
                endcase;
            next;
        endif;
        if NoLight% = 1 then
            'SafeSampleKeySutter%("M"); 'turn off yellow LED if there is no light indicated in the trials file
        endif;
        case LCase$(OnOffSame$) = "same" then  
        'do nothing
    else
        printlog("CueLights was called with invalid cue light on/off/same argument %s!\n",OnOffSame$);
        view(HiddenLogHandle%).print("CueLights was called with invalid cue light on/off/same argument %s!\r",OnOffSame$);
    endcase;
    
    
end;
'========================= Turn On Cue Light Flashing ===========================
'New function as of 1.3.27 which allows onset of cue light flashing.  Flash will continue
'until FlashDurationMS% has elapsed or FlashOff is called, whichever comes first.
'FlashPeriodMS% is the duration of one half-cycle (i.e. one full period = 2*FlashPeriodMS%)
'Currently lights CANNOT be flashed with a duty cycle other than 50% (i.e. on period == off period)
'Also, only ONE light can be flashed, all others will be turned off
'For now, the flash is NOT light-logged.
proc FlashOn(Cue$,FlashDurationMS%,FlashPeriodMS%); 
    
    var ClockSteps%;  '# of clock steps in flash half-period, truncate to integer 
    var FlashRepeats%;  '#of repeats, on+off = 1 repeat
    var tempFlashDur;   'to deal with int/float conversion
    
    'SafeSampleKeySutter%("O");  'Turn off all lights before flashing
    
    Cue$ := Left$(Cue$,1);  'Get first letter - can only flash one LED
    
    docase
        case LCase$(Cue$) = "r" then
        sampleseqvar(4,3);  'Flash red LED
        case LCase$(Cue$) = "g" then
        sampleseqvar(4,2);  'Flash green LED
        case LCase$(Cue$) = "y" then
        sampleseqvar(4,1);  'Flash yellow LED
        case LCase$(Cue$) = "h" or LCase$(Cue$) = "i" then
        sampleseqvar(4,4);  'Flash house light
    else
        sampleseqvar(4,0);  'No flash, will call sequencer with SafeSampleKeySutter%("F") but will simply exit
        printlog("FlashOn was called with invalid cue light argument %s!\n",Cue$);
        view(HiddenLogHandle%).print("FlashOn was called with invalid cue light argument %s!\r",Cue$);
    endcase;    
    
    'Create a copy of flash duration for lightlogging
    tempFlashDur := FlashDurationMS%;  'copy int over to float
    FlashDurationS := tempFlashDur/1000;  'then divide to get float output
    
    ClockSteps% := FlashPeriodMS%/SequencerPeriodMS;  'Calculate number of clock steps in one flash
    sampleseqvar(6,ClockSteps%);  'Set sequencer variable 6 to number of clock steps per period
    
    FlashRepeats% := FlashDurationMS%/(FlashPeriodMS%*2);
    if FlashRepeats% = 0  then
        FlashRepeats% := 1;
        printlog("FlashRepeats was 0, changed to 1!\n");
        view(HiddenLogHandle%).print("FlashRepeats was 0, changed to 1!\r");
    endif;
    sampleseqvar(5,FlashRepeats%);  'Set sequencer variable 5 to number of flashes
    
    sampleseqvar(8,1);  'Set Flash-Allow variable to 1, this allows flashing    
    
    'SafeSampleKeySutter%("F");  'Start the flash
    
end;
'========================= Turn Off Cue Light Flashing ===========================
'New function as of 1.3.27 which immediately turns off cue light flashing
'regardless of number of flashes 
proc FlashOff(); 
    
    sampleseqvar(8,0);  'stop flashing at next flash offset by setting Flash-Allow variable to 0 
    
    docase
        case sampleseqvar(4) = 1 then
        YellowOffTimes[YellowOffIndex%-1] := maxtime();  'set YellowOffTimes[] to actual off time, note index has already incremented
        case sampleseqvar(4) = 2 then
        GreenOffTimes[GreenOffIndex%-1] := maxtime();  'set GreenOffTimes[] to actual off time, note index has already incremented
        case sampleseqvar(4) = 3 then
        RedOffTimes[RedOffIndex%-1] := maxtime();  'set RedOffTimes[] to actual off time, note index has already incremented
        case sampleseqvar(4) = 4 then
        IncOffTimes[IncOffIndex%-1] := maxtime();  'set IncOffTimes[] to actual off time, note index has already incremented
    endcase
    
end;

'============================== Calculate Random Reward ==============================
'if Prob is 1 or 0, will set RewardCount% accordingly.  Otherwise, will set RewardCount%
'to 1 with probability Prob.
func RandReward(Prob,Num%)
    
    docase
        case Prob >= 1 then
		RewardCount% := Num%;
        case Prob <= 0 then
		RewardCount% := 0;
	else
		if rand(0.0) < Prob then  '0.0 seeds with system time
			RewardCount% := Num%;
		else
			RewardCount% := 0;
		endif;
    endcase;
    
end;




'============================ Update Behavioral Value ==============================
'Just a small function to make it easier to update behavioral variables without having 
'to repeat the same code over and over.  If the stimulus is not repeating, the behavioral
'data will be updated, otherwise not.
func UpdateBehavVal(InVal)
    
    if StimIsRepeating% = 1 then
        return InVal;
    else
        InVal := InVal + 1;
        return InVal;
    endif;   
    
end;

'============================ Update Behavioral Value2 ==============================
'Just a small function to make it easier to update behavioral variables without having 
'to repeat the same code over and over.  If the stimulus is not repeating, the behavioral
'data will be updated, otherwise not.  First argument is a count variable, second argument
'is an array holding 1/0 for behavioral history
func UpdateBehavVal2(&InCount%,&InArray%[])
    
    if StimIsRepeating% = 0 then
        InCount% += 1;
        InArray%[InCount%-1] := 1;
    endif;   
    
end;


'=========================== Update Response Window =================================
'Another small function to increment or decrement the response window when appropriate
proc UpdateResponseWindow(IncOrDec$)
    
    if IncOrDec$ = "dec" then
        ResponseWindow := ResponseWindow - RespWindowDec; 
        if ResponseWindow < RespWindowMin then
            ResponseWindow := RespWindowMin;
        endif;
        if VerboseIncrements% = 1 and RespWindowDec > 0 then
            printlog("Response Window is now %f\n",ResponseWindow);
            view(HiddenLogHandle%).print("Response Window is now %f\r",ResponseWindow);
        endif;
    endif;
    
    if IncOrDec$ = "inc" then
        ResponseWindow := ResponseWindow + RespWindowInc; 
        if ResponseWindow > RespWindowMax then
            ResponseWindow := RespWindowMax;
        endif;
        if VerboseIncrements% = 1 and RespWindowInc > 0 then
            printlog("Response Window is now %f\n",ResponseWindow);
            view(HiddenLogHandle%).print("Response Window is now %f\r",ResponseWindow);
        endif;
    endif;
    
    
end;


'============================= Update Trial Onset Delay ================================
'Another small function to increase the trial onset delay when appropriate
proc UpdateTrialOnset(IncOrDec$)
    
    if IncOrDec$ = "inc" then
        TrialOnsetDelay := TrialOnsetDelay + TrialOnsetInc;
        if TrialOnsetDelay > TrialOnsetMax then
            TrialOnsetDelay := TrialOnsetMax;
        endif;
        if VerboseIncrements% = 1 and TrialOnsetInc > 0 then
            printlog("Trial Onset Delay is now %f\n",TrialOnsetDelay);
            view(HiddenLogHandle%).print("Trial Onset Delay is now %f\r",TrialOnsetDelay);
        endif;
    endif;
    
    if IncOrDec$ = "dec" then
        TrialOnsetDelay := TrialOnsetDelay - TrialOnsetDec;
        if TrialOnsetDelay < TrialOnsetMin then
            TrialOnsetDelay := TrialOnsetMin;
        endif;
        if VerboseIncrements% = 1 and TrialOnsetDec > 0 then
            printlog("Trial Onset Delay is now %f\n",TrialOnsetDelay);
            view(HiddenLogHandle%).print("Trial Onset Delay is now %f\r",TrialOnsetDelay);
        endif;
    endif;
    
end;


'============================= Update Target Motion ===============================
'Another small function to change TargetMotion direction if response exceeds criterion
proc UpdateTargetMotion()
    

    var H;  'holds windowed hits
    var F;  'windowed FAs
    var dP;
    var windw;  'a non-integer to hold window for division. "window" is reserved
    var TC%;  'trial count, may be standard or non-repeated
    
    ' if device is MonoJoystickFRUD AND window is set AND criterion is set AND the window is "full" since the last change, then start looking at criterion
    docase
    case RespDevice% = -4 and TargetMotionWindow% > 0 and TargetMotiondPrimeCrit > 0 and RepeatOnError% = 0 and TrialCount%-TargetMotionChangeAt% >= TargetMotionWindow% then
        H := arrsum(Hits%[TrialCount%-TargetMotionWindow%:TargetMotionWindow%]);  'Get number of hits
        F := arrsum(FAs%[TrialCount%-TargetMotionWindow%:TargetMotionWindow%]);   'Get number of FAs   
        TC% := TrialCount%;
        windw := TargetMotionWindow%;  'put value in non-integer variable
        dP := dPrime(H/windw,F/windw);  'get dPrime
        if dP >= TargetMotiondPrimeCrit then  'if dPrime exceeds criterion
            printlog("After %d trials, dPrime is %f, greater than criterion of %f!\n",TC%-TargetMotionChangeAt%,dP,TargetMotiondPrimeCrit);
            printlog("Changing TargetMotion to %d and swapping cue light!\n",TargetMotion%);
            TargetMotionChangeAt% := TC%;  'note the trial # when the change occurs
            TargetMotion% := 1-TargetMotion%;  'and swap TargetMotion, cue light change will occur at if #6A
        else
            printlog("After %d trials, dPrime is %f, less than criterion of %f\n",TC%-TargetMotionChangeAt%,dP,TargetMotiondPrimeCrit);
        endif;
    case RespDevice% = -4 and TargetMotionWindow% > 0 and TargetMotiondPrimeCrit > 0 and RepeatOnError% = 1 and NonRepeatedTrialCount%-TargetMotionChangeAt% >= TargetMotionWindow% then
        H := arrsum(HitsNR%[NonRepeatedTrialCount%-TargetMotionWindow%:TargetMotionWindow%]);  'Get number of hits
        F := arrsum(FAsNR%[NonRepeatedTrialCount%-TargetMotionWindow%:TargetMotionWindow%]);   'Get number of FAs
        TC% := NonRepeatedTrialCount%;
        windw := TargetMotionWindow%;  'put value in non-integer variable
        dP := dPrime(H/windw,F/windw);  'get dPrime
        if dP >= TargetMotiondPrimeCrit then  'if dPrime exceeds criterion
            printlog("After %d trials, dPrime is %f, greater than criterion of %f!\n",TC%-TargetMotionChangeAt%,dP,TargetMotiondPrimeCrit);
            printlog("Changing TargetMotion to %d and swapping cue light!\n",TargetMotion%);
            TargetMotionChangeAt% := TC%;  'note the trial # when the change occurs
            TargetMotion% := 1-TargetMotion%;  'and swap TargetMotion, cue light change will occur at if #6A
        else
            printlog("After %d trials, dPrime is %f, less than criterion of %f\n",TC%-TargetMotionChangeAt%,dP,TargetMotiondPrimeCrit);
        endif;
    endcase;
    
end;


'============================= Print Behavioral Stats ===============================
'Prints behavioral stats to the log file.  Removes these lines from the main loop and allows
'us to seamlessly print for either "Regular" or "RepeatOnError" conditions while keeping the 
'stats for the two conditions separate in the new vector-form variables
proc PrintBehavStats()
    
    var Hits2;
    var CRs2;
    var Misses2;
    var FAs2;
    var UpHits2;
    var DownHits2;
    var UpMisses2;
    var DownMisses2;
    var RightHits2;
    var LeftHits2;
    var RightMisses2;
    var LeftMisses2;
    var PoTs2;  'shared by both go/no-go and forced response conditions
    var PoNTs2; 'shared by both go/no-go and forced response conditions
    var PtTs2;  'shared by both go/no-go and forced response conditions
    var PtNTs2; 'shared by both go/no-go and forced response conditions
    var UpNR2;
    var DownNR2;
    var RightNR2;
    var LeftNR2;
    var PoNRs2;
    var PtNRs2;
    var CatchUp2;
    var CatchDown2;
    var CatchLeft2;
    var CatchRight2;
    var CatchNR2;
    var OverallTotal;
    var H%;  'holds windowed hits
    var M%;  'windowed misses
    var C%;  'windowed CRs
    var F%;  'windowed FAs
    var BiasWindow2%;  'prevents index errors at beginning of experiment
    
    if RepeatOnError% = 0 then 'if not repeating, use regular stats
        Hits2 := Hits;
        CRs2 := CRs;
        Misses2 := Misses;
        FAs2 := FAs;
        UpHits2 := UpHits;
        DownHits2 := DownHits;
        UpMisses2 := UpMisses;
        DownMisses2 := DownMisses;
        LeftHits2 := LeftHits;
        RightHits2 := RightHits;
        LeftMisses2 := LeftMisses;
        RightMisses2 := RightMisses;
        PoTs2 := PoTs;
        PoNTs2 := PoNTs;
        PtTs2 := PtTs;
        PtNTs2 := PtNTs;
        UpNR2 := UpNR;
        DownNR2 := DownNR;
        RightNR2 := RightNR;
        LeftNR2 := LeftNR;
        PoNRs2 := PoNRs;
        PtNRs2 := PtNRs;
        CatchUp2 := CatchUp;
        CatchDown2 := CatchDown;
        CatchRight2 := CatchRight;
        CatchLeft2 := CatchLeft;
        CatchNR2 := CatchNR;
    else  'if repeating, use alternate stats
        Hits2 := HitsR;
        CRs2 := CRsR;
        Misses2 := MissesR;
        FAs2 := FAsR;
        UpHits2 := UpHitsR;
        DownHits2 := DownHitsR;
        UpMisses2 := UpMissesR;
        DownMisses2 := DownMissesR;
        LeftHits2 := LeftHitsR;
        RightHits2 := RightHitsR;
        LeftMisses2 := LeftMissesR;
        RightMisses2 := RightMissesR;
        PoTs2 := PoTsR;
        PoNTs2 := PoNTsR;
        PtTs2 := PtTsR;
        PtNTs2 := PtNTsR;
        UpNR2 := UpNRR;
        DownNR2 := DownNRR;
        RightNR2 := RightNRR;
        LeftNR2 := LeftNRR;
        PoNRs2 := PoNRsR;
        PtNRs2 := PtNRsR;
        CatchUp2 := CatchUpR;
        CatchDown2 := CatchDownR;
        CatchRight2 := CatchRightR;
        CatchLeft2 := CatchLeftR;
        CatchNR2 := CatchNRR;
    endif;
    
    BiasWindow2% := min(BiasWindow%,TrialCount%);  'Don't use full BiasWindow if there aren't that many trials yet.
    
    if RespDevice% < 1 then  'for go/no-go trials, use these lines
        OverallTotal := TrialCount%;
        if OverallTotal > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Trial Number %d:%d (%d overall) has been completed.  Response Window is %f.",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal,ResponseWindow);
                printlog("  Total accuracy is %f.  Number of interrupts is %d.\n",(Hits2+CRs2)/max(Hits2+CRs2+FAs2+Misses2,1),NumInterrupt%);
                printlog("  dPrime is %f\n",dPrime(Hits2/max(Hits2+Misses2,1),FAs2/max(FAs2+CRs2,1)));
                view(HiddenLogHandle%).print("Trial Number %d:%d (%d overall) has been completed.  Response Window is %f.",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal,ResponseWindow);
                view(HiddenLogHandle%).print("  Total accuracy is %f.  Number of interrupts is %d.\r",(Hits2+CRs2)/max(Hits2+CRs2+FAs2+Misses2,1),NumInterrupt%);
                view(HiddenLogHandle%).print("  dPrime is %f\r",dPrime(Hits2/max(Hits2+Misses2,1),FAs2/max(FAs2+CRs2,1)));
            else
                printlog("Trial Number %d:%d (%d overall) has been completed.  Total accuracy is %f.\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal,(Hits2+CRs2)/max(Hits2+CRs2+FAs2+Misses2,1));
                printlog("  dPrime is %f\n",dPrime(Hits2/max(Hits2+Misses2,1),FAs2/max(FAs2+CRs2,1)));
                view(HiddenLogHandle%).print("Trial Number %d:%d (%d overall) has been completed.  Response Window is %f.",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal,ResponseWindow);
                view(HiddenLogHandle%).print("  Total accuracy is %f.  Number of interrupts is %d.\r",(Hits2+CRs2)/max(Hits2+CRs2+FAs2+Misses2,1),NumInterrupt%);
                view(HiddenLogHandle%).print("  dPrime is %f\r",dPrime(Hits2/max(Hits2+Misses2,1),FAs2/max(FAs2+CRs2,1)));
            endif;
            'positive response bias means biased towards "go"
            H% := arrsum(Hits%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            M% := arrsum(Misses%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            F% := arrsum(FAs%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            C% := arrsum(CRs%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            if VerboseAccuracy% = 1 then
                printlog("Hit history is %d\n",Hits%[TrialCount%-BiasWindow2%:BiasWindow2%]);
                printlog("Miss history is %d\n",Misses%[TrialCount%-BiasWindow2%:BiasWindow2%]);
                printlog("FA history is %d\n",FAs%[TrialCount%-BiasWindow2%:BiasWindow2%]);
                printlog("CR history is %d\n",CRs%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            endif;
            GetResponseBias(H%/max(H%+M%,1),F%/max(F%+C%,1),H%+M%,F%+C%);  'get response bias if there is at least one stim
        endif;
        'the following lines use IFs instead of max(...,1) to ensure no divide by zero - could compact the code, but this
        'way the stats don't print if no stimuli of that category have come up yet.
        if Hits2 + Misses2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Target Stims = %d\tHits = %d\t\tMisses = %d\t\tTarget Accuracy = %f\n",Hits2+Misses2,Hits2,Misses2,Hits2/(Hits2+Misses2));
                view(HiddenLogHandle%).print("Target Stims = %d\tHits = %d\t\tMisses = %d\t\tTarget Accuracy = %f\r",Hits2+Misses2,Hits2,Misses2,Hits2/(Hits2+Misses2));
            else
                printlog("Target Stims = %d\tTarget Accuracy = %f\n",Hits2+Misses2,Hits2/(Hits2+Misses2));
                view(HiddenLogHandle%).print("Target Stims = %d\tHits = %d\t\tMisses = %d\t\tTarget Accuracy = %f\r",Hits2+Misses2,Hits2,Misses2,Hits2/(Hits2+Misses2));
            endif;
        endif;
        if CRs2 + FAs2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Nontarget Stims = %d\tCorrect Rejections = %d\tFalse Alarms = %d\tNontarget Accuracy = %f\n",CRs2+FAs2,CRs2,FAs2,CRs2/(CRs2+FAs2));
                view(HiddenLogHandle%).print("Nontarget Stims = %d\tCorrect Rejections = %d\tFalse Alarms = %d\tNontarget Accuracy = %f\r",CRs2+FAs2,CRs2,FAs2,CRs2/(CRs2+FAs2));
            else
                printlog("Nontarget Stims = %d\tNontarget Accuracy = %f\n",CRs2+FAs2,CRs2/(CRs2+FAs2));
                view(HiddenLogHandle%).print("Nontarget Stims = %d\tCorrect Rejections = %d\tFalse Alarms = %d\tNontarget Accuracy = %f\r",CRs2+FAs2,CRs2,FAs2,CRs2/(CRs2+FAs2));
            endif;
        endif;
        if PoTs2 + PoNTs2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Probe 1 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tPercent Target Response = %f\n",PoTs2+PoNTs2,PoTs2,PoNTs2,PoTs2/(PoTs2+PoNTs2));
                view(HiddenLogHandle%).print("Probe 1 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tPercent Target Response = %f\r",PoTs2+PoNTs2,PoTs2,PoNTs2,PoTs2/(PoTs2+PoNTs2));
            else
                printlog("Probe 1 Stims = %d\tPercent Target Response = %f\n",PoTs2+PoNTs2,PoTs2/(PoTs2+PoNTs2));
                view(HiddenLogHandle%).print("Probe 1 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tPercent Target Response = %f\r",PoTs2+PoNTs2,PoTs2,PoNTs2,PoTs2/(PoTs2+PoNTs2));
            endif;
        endif;
        if PtTs2 + PtNTs2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Probe 2 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tPercent Target Response = %f\n",PtTs2+PtNTs2,PtTs2,PtNTs2,PtTs2/(PtTs2+PtNTs2));
                view(HiddenLogHandle%).print("Probe 2 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tPercent Target Response = %f\r",PtTs2+PtNTs2,PtTs2,PtNTs2,PtTs2/(PtTs2+PtNTs2));
            else
                printlog("Probe 2 Stims = %d\tPercent Target Response = %f\n",PtTs2+PtNTs2,PtTs2/(PtTs2+PtNTs2));
                view(HiddenLogHandle%).print("Probe 2 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tPercent Target Response = %f\r",PtTs2+PtNTs2,PtTs2,PtNTs2,PtTs2/(PtTs2+PtNTs2));
            endif;
        endif;
        if DoResponseBias% <> 0 then
            printlog("Response Bias = %f, positive indicates biased towards 'go', negative indicates biased towards 'no-go'\n",ResponseBias);
            view(HiddenLogHandle%).print("Response Bias = %f, positive indicates biased towards 'go', negative indicates biased towards 'no-go'\r",ResponseBias);
        endif;
        if DeltaITI <> 0 then
            printlog("Current ITI = %f\n",MinITI);
            view(HiddenLogHandle%).print("Current ITI = %f\r",MinITI);
        endif;
        printlog("\n");  'put in a spacing line  
        view(HiddenLogHandle%).print ("\r");   
    else
        OverallTotal := TrialCount%;
        if OverallTotal > 0 and RespDevice% = 1 then 'initial stats for RespDevice = 1, Up-down joystick
            if VerboseAccuracy% = 1 then
                printlog("Trial Number %d:%d (%d overall) has been completed.  ",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal);
                printlog("Response Window is %f. Total accuracy is %f.  ",ResponseWindow,(UpHits2+DownHits2)/max(UpHits2+DownHits2+UpMisses2+DownMisses2,1));
                printlog("Number of Interrupts is %d.\n",NumInterrupt%);  'Split because line was over 255 characters
                printlog("  dPrime is %f\n",dPrime(UpHits2/max(UpHits2+UpMisses2,1),DownMisses2/max(DownMisses2+DownHits2,1)));
                view(HiddenLogHandle%).print("Trial Number %d:%d (%d overall) has been completed.  ",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal);
                view(HiddenLogHandle%).print("Response Window is %f. Total accuracy is %f.  ",ResponseWindow,(UpHits2+DownHits2)/max(UpHits2+DownHits2+UpMisses2+DownMisses2,1));
                view(HiddenLogHandle%).print("Number of Interrupts is %d.\r",NumInterrupt%);
                view(HiddenLogHandle%).print("  dPrime is %f\r",dPrime(UpHits2/max(UpHits2+UpMisses2,1),DownMisses2/max(DownMisses2+DownHits2,1)));
            else
                printlog("Trial Number %d:%d (%d overall) has been completed. Total accuracy is %f.\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal,(UpHits2+DownHits2)/max(UpHits2+DownHits2+UpMisses2+DownMisses2,1));
                printlog("  dPrime is %f\n",dPrime(UpHits2/max(UpHits2+UpMisses2,1),DownMisses2/max(DownMisses2+DownHits2,1)));
                view(HiddenLogHandle%).print("Trial Number %d:%d (%d overall) has been completed.  ",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,OverallTotal);
                view(HiddenLogHandle%).print("Response Window is %f. Total accuracy is %f.  ",ResponseWindow,(UpHits2+DownHits2)/max(UpHits2+DownHits2+UpMisses2+DownMisses2,1));
                view(HiddenLogHandle%).print("Number of Interrupts is %d.\r",NumInterrupt%);
                view(HiddenLogHandle%).print("  dPrime is %f\r",dPrime(UpHits2/max(UpHits2+UpMisses2,1),DownMisses2/max(DownMisses2+DownHits2,1)));
            endif;
            'Positive response bias means bias towards Up response
            H% := arrsum(UpHits%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            M% := arrsum(DownMisses%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            F% := arrsum(UpMisses%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            C% := arrsum(DownHits%[TrialCount%-BiasWindow2%:BiasWindow2%]);            
            GetResponseBias(H%/max(H%+M%,1),F%/max(F%+C%,1),H%+M%,F%+C%);  'get response bias if there is at least one stim
        endif;
        if OverallTotal > 0 and RespDevice% = 2 then 'initial stats for RespDevice = 2, Left-right joystick
            if VerboseAccuracy% = 1 then
                printlog("Trial Number %d:%d has been completed.  ",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                printlog("Response Window is %f. Total accuracy is %f.  ",ResponseWindow,(RightHits2+LeftHits2)/max(RightHits2+LeftHits2+RightMisses2+LeftMisses2,1));
                printlog("Number of Interrupts is %d.\n",NumInterrupt%);  'Split because line was over 255 characters
                printlog("  dPrime is %f\n",dPrime(RightHits2/max(RightHits2+RightMisses2,1),LeftMisses2/max(LeftMisses2+LeftHits2,1)));
                view(HiddenLogHandle%).print("Trial Number %d:%d has been completed.  ",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                view(HiddenLogHandle%).print("Response Window is %f. Total accuracy is %f.  ",ResponseWindow,(RightHits2+LeftHits2)/max(RightHits2+LeftHits2+RightMisses2+LeftMisses2,1));
                view(HiddenLogHandle%).print("Number of Interrupts is %d.\r",NumInterrupt%);
                view(HiddenLogHandle%).print("  dPrime is %f\r",dPrime(RightHits2/max(RightHits2+RightMisses2,1),LeftMisses2/max(LeftMisses2+LeftHits2,1)));
            else
                printlog("Trial Number %d:%d has been completed.  Total accuracy is %f.\n",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1,(RightHits2+LeftHits2)/max(RightHits2+LeftHits2+RightMisses2+LeftMisses2,1));
                printlog("  dPrime is %f\n",dPrime(RightHits2/max(RightHits2+RightMisses2,1),LeftMisses2/max(LeftMisses2+LeftHits2,1)));
                view(HiddenLogHandle%).print("Trial Number %d:%d has been completed.  ",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);
                view(HiddenLogHandle%).print("Response Window is %f. Total accuracy is %f.  ",ResponseWindow,(RightHits2+LeftHits2)/max(RightHits2+LeftHits2+RightMisses2+LeftMisses2,1));
                view(HiddenLogHandle%).print("Number of Interrupts is %d.\r",NumInterrupt%);
                view(HiddenLogHandle%).print("  dPrime is %f\r",dPrime(RightHits2/max(RightHits2+RightMisses2,1),LeftMisses2/max(LeftMisses2+LeftHits2,1)));
            endif;
            'Positive response bias means bias towards Right response
            H% := arrsum(RightHits%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            M% := arrsum(LeftMisses%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            F% := arrsum(RightMisses%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            C% := arrsum(LeftHits%[TrialCount%-BiasWindow2%:BiasWindow2%]);
            GetResponseBias(H%/max(H%+M%,1),F%/max(F%+C%,1),H%+M%,F%+C%);  'get response bias if there is at least one stim
        endif;
        'the following lines use IFs instead of max(...,1) to ensure no divide by zero - could compact the code, but this
        'way the stats don't print if no stimuli of that category have come up yet.
        if UpHits2 + DownMisses2 + UpNR2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Up Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tUp Accuracy = %f\n",UpHits2+DownMisses2+UpNR2,UpHits2,DownMisses2,UpNR2,UpHits2/(UpHits2+DownMisses2+UpNR2));
                view(HiddenLogHandle%).print("Up Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tUp Accuracy = %f\r",UpHits2+DownMisses2+UpNR2,UpHits2,DownMisses2,UpNR2,UpHits2/(UpHits2+DownMisses2+UpNR2));
            else
                printlog("Up Targets = %d\tUp Accuracy = %f\n",UpHits2+DownMisses2+UpNR2,UpHits2/(UpHits2+DownMisses2+UpNR2));
                view(HiddenLogHandle%).print("Up Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tUp Accuracy = %f\r",UpHits2+DownMisses2+UpNR2,UpHits2,DownMisses2,UpNR2,UpHits2/(UpHits2+DownMisses2+UpNR2));
            endif;
        endif;
        if DownHits2 + UpMisses2 + DownNR2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Down Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tDown Accuracy = %f\n",DownHits2+UpMisses2+DownNR2,DownHits2,UpMisses2,DownNR2,DownHits2/(DownHits2+UpMisses2+DownNR2));
                view(HiddenLogHandle%).print("Down Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tDown Accuracy = %f\r",DownHits2+UpMisses2+DownNR2,DownHits2,UpMisses2,DownNR2,DownHits2/(DownHits2+UpMisses2+DownNR2));
            else
                printlog("Down Targets = %d\tDown Accuracy = %f\n",DownHits2+UpMisses2+DownNR2,DownHits2/(DownHits2+UpMisses2+DownNR2));
                view(HiddenLogHandle%).print("Down Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tDown Accuracy = %f\r",DownHits2+UpMisses2+DownNR2,DownHits2,UpMisses2,DownNR2,DownHits2/(DownHits2+UpMisses2+DownNR2));
            endif;
        endif;
        if RightHits2 + LeftMisses2 + RightNR2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Right Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tUp Accuracy = %f\n",RightHits2+LeftMisses2+RightNR2,RightHits2,LeftMisses2,RightNR2,RightHits2/(RightHits2+LeftMisses2+RightNR2));
                view(HiddenLogHandle%).print("Right Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tUp Accuracy = %f\r",RightHits2+LeftMisses2+RightNR2,RightHits2,LeftMisses2,RightNR2,RightHits2/(RightHits2+LeftMisses2+RightNR2));
            else
                printlog("Right Targets = %d\tRight Accuracy = %f\n",RightHits2+LeftMisses2+RightNR2,RightHits2/(RightHits2+LeftMisses2+RightNR2));
                view(HiddenLogHandle%).print("Right Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tUp Accuracy = %f\r",RightHits2+LeftMisses2+RightNR2,RightHits2,LeftMisses2,RightNR2,RightHits2/(RightHits2+LeftMisses2+RightNR2));
            endif;
        endif;
        if LeftHits2 + RightMisses2 + LeftNR2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Left Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tLeft Accuracy = %f\n",LeftHits2+RightMisses2+LeftNR2,LeftHits2,RightMisses2,LeftNR2,LeftHits2/(LeftHits2+RightMisses2+LeftNR2));
                view(HiddenLogHandle%).print("Left Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tLeft Accuracy = %f\r",LeftHits2+RightMisses2+LeftNR2,LeftHits2,RightMisses2,LeftNR2,LeftHits2/(LeftHits2+RightMisses2+LeftNR2));
            else
                printlog("Left Targets = %d\tLeft Accuracy = %f\n",LeftHits2+RightMisses2+LeftNR2,LeftHits2/(LeftHits2+RightMisses2+LeftNR2));
                view(HiddenLogHandle%).print("Left Targets = %d\tHits = %d\t\tMisses = %d\t\tNo Response = %d\t\tLeft Accuracy = %f\r",LeftHits2+RightMisses2+LeftNR2,LeftHits2,RightMisses2,LeftNR2,LeftHits2/(LeftHits2+RightMisses2+LeftNR2));
            endif;
        endif;
        if PoTs2 + PoNTs2 + PoNRs2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Probe 1 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tNo Response = %d\tPercent Target Response = %f\n",PoTs2+PoNTs2+PoNRs2,PoTs2,PoNTs2,PoNRs2,PoTs2/(PoTs2+PoNTs2+PoNRs2));
                view(HiddenLogHandle%).print("Probe 1 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tNo Response = %d\tPercent Target Response = %f\r",PoTs2+PoNTs2+PoNRs2,PoTs2,PoNTs2,PoNRs2,PoTs2/(PoTs2+PoNTs2+PoNRs2));
            else
                printlog("Probe 1 Stims = %d\tPercent Target Response = %f\n",PoTs2+PoNTs2+PoNRs2,PoTs2/(PoTs2+PoNTs2+PoNRs2));
                view(HiddenLogHandle%).print("Probe 1 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tNo Response = %d\tPercent Target Response = %f\r",PoTs2+PoNTs2+PoNRs2,PoTs2,PoNTs2,PoNRs2,PoTs2/(PoTs2+PoNTs2+PoNRs2));
            endif;
        endif;
        if PtTs2 + PtNTs2 + PtNRs2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Probe 2 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tNo Response = %d\tPercent Target Response = %f\n",PtTs2+PtNTs2+PtNRs2,PtTs2,PtNTs2,PtNRs2,PtTs2/(PtTs2+PtNTs2+PtNRs2));
                view(HiddenLogHandle%).print("Probe 2 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tNo Response = %d\tPercent Target Response = %f\r",PtTs2+PtNTs2+PtNRs2,PtTs2,PtNTs2,PtNRs2,PtTs2/(PtTs2+PtNTs2+PtNRs2));
            else
                printlog("Probe 2 Stims = %d\tPercent Target Response = %f\n",PtTs2+PtNTs2+PtNRs2,PtTs2/(PtTs2+PtNTs2+PtNRs2));
                view(HiddenLogHandle%).print("Probe 2 Stims = %d\tProbe Response = %d\tNontarget Response = %d\tNo Response = %d\tPercent Target Response = %f\r",PtTs2+PtNTs2+PtNRs2,PtTs2,PtNTs2,PtNRs2,PtTs2/(PtTs2+PtNTs2+PtNRs2));
            endif;
        endif;
        if CatchUp2 + CatchDown2 + CatchNR2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Catch Stims = %d\tUp Response = %d\tDown Response = %d\tNo Response = %d\tPercent No Response = %f\n",CatchUp2+CatchDown2+CatchNR2,CatchUp2,CatchDown2,CatchNR2,CatchNR2/(CatchUp2+CatchDown2+CatchNR2));
                view(HiddenLogHandle%).print("Catch Stims = %d\tUp Response = %d\tDown Response = %d\tNo Response = %d\tPercent No Response = %f\r",CatchUp2+CatchDown2+CatchNR2,CatchUp2,CatchDown2,CatchNR2,CatchNR2/(CatchUp2+CatchDown2+CatchNR2));
            else 'do same for now because it's not clear what we would want
                printlog("Catch Stims = %d\tUp Response = %d\tDown Response = %d\tNo Response = %d\tPercent No Response = %f\n",CatchUp2+CatchDown2+CatchNR2,CatchUp2,CatchDown2,CatchNR2,CatchNR2/(CatchUp2+CatchDown2+CatchNR2));
                view(HiddenLogHandle%).print("Catch Stims = %d\tUp Response = %d\tDown Response = %d\tNo Response = %d\tPercent No Response = %f\r",CatchUp2+CatchDown2+CatchNR2,CatchUp2,CatchDown2,CatchNR2,CatchNR2/(CatchUp2+CatchDown2+CatchNR2));
            endif;
        endif;
        if CatchRight2 + CatchLeft2 + CatchNR2 > 0 then
            if VerboseAccuracy% = 1 then
                printlog("Catch Stims = %d\tRight Response = %d\t",CatchRight2+CatchLeft2+CatchNR2,CatchRight2);
                printlog("Left Response = %d\tNo Response = %d\tPercent No Response = %f\n",CatchLeft2,CatchNR2,CatchNR2/(CatchRight2+CatchLeft2+CatchNR2));
                view(HiddenLogHandle%).print("Catch Stims = %d\tRight Response = %d\t",CatchRight2+CatchLeft2+CatchNR2,CatchRight2);
                view(HiddenLogHandle%).print("Left Response = %d\tNo Response = %d\tPercent No Response = %f\r",CatchLeft2,CatchNR2,CatchNR2/(CatchRight2+CatchLeft2+CatchNR2));
            else 'do same for now because it's not clear what we would want
                printlog("Catch Stims = %d\tRight Response = %d\t",CatchRight2+CatchLeft2+CatchNR2,CatchRight2);
                printlog("Left Response = %d\tNo Response = %d\tPercent No Response = %f\n",CatchLeft2,CatchNR2,CatchNR2/(CatchRight2+CatchLeft2+CatchNR2));
                view(HiddenLogHandle%).print("Catch Stims = %d\tRight Response = %d\t",CatchRight2+CatchLeft2+CatchNR2,CatchRight2);
                view(HiddenLogHandle%).print("Left Response = %d\tNo Response = %d\tPercent No Response = %f\r",CatchLeft2,CatchNR2,CatchNR2/(CatchRight2+CatchLeft2+CatchNR2));
            endif;
        endif;
        if DoResponseBias% <> 0 then
            if RespDevice% = 1 then
                printlog("Response Bias = %f, positive indicates biased towards 'up', negative indicates biased towards 'down'\n",ResponseBias);
                view(HiddenLogHandle%).print("Response Bias = %f, positive indicates biased towards 'up', negative indicates biased towards 'down'\r",ResponseBias);
            endif;
            if RespDevice% = 2 then
                printlog("Response Bias = %f, positive indicates biased towards 'right', negative indicates biased towards 'left'\n",ResponseBias);
                view(HiddenLogHandle%).print("Response Bias = %f, positive indicates biased towards 'right', negative indicates biased towards 'left'\r",ResponseBias);
            endif;
        endif;
        if DeltaITI <> 0 then
            printlog("Current ITI = %f\n",MinITI);
            view(HiddenLogHandle%).print("Current ITI = %f\r",MinITI);
        endif;
        printlog("\n");  'put in a spacing line 
        view(HiddenLogHandle%).print("\r");
    endif;    
    
end;
'================================= Use Sample Key Safely ============================
'This function replaces SampleKey() to guarantee there will be no interruption of any
'sequencer command while it is executing.  The sequencer .pls file must use variable V2
'to hold whether the sequencer is currently executing or not - set V2 to 1 to disallow
'access as the first step and set V2 to 0 to reallow access as the last step.  This design
'delays execution of any output by 1 step (usually 1 ms) at the sequencer level, AND by one
'step worth of time at the script level, so the actual time of onset will be about 2 steps
'later than requested.  
'SafeSampleKeySutter% now also keeps track of LED and incandescent state for logging
func SafeSampleKeySutter%(Key$)
    
    var try:=1;
    var nowtime;  'will hold the time of the LED/Incandescent change
    var FlashLight%;
    
    yield(.001);  'It takes the sequencer up to a full step to change the value of variable V2
    'Step is here assumed to be 1 ms, could possibly be read from sequencer?
    
    while try do
        if sampleseqvar(2) = 0 then
            SampleKey(Key$);
            nowtime := maxtime();  'get the time of the instruction, this is not precise
            'but it's not so crucial to get as the time of the sound
            'This is all for light logging
            if Key$ = "B" or Key$ = "L" then 'yellow LED On
                if YellowOn% = 0 then  'if we changed the state of the yellow LED
                    YellowOn% := 1;  'note yellow LED is now on
                    YellowOnTimes[YellowOnIndex%] := nowtime;  'set YellowOnTimes[]
                    YellowOnIndex% := YellowOnIndex% + 1;  'increment YellowOnIndex%
                    if YellowOnIndex% = 50 then  'don't let it crash by exceeding variable size
                        YellowOnIndex% := 49;
                    endif;
                endif;            
            endif;
            if Key$ = "C" or Key$ = "M" or Key$ = "O" then 'yellow LED Off
                if YellowOn% = 1 then  'if we changed the state of the yellow LED
                    YellowOn% := 0;  'note yellow LED is now off
                    YellowOffTimes[YellowOffIndex%] := nowtime;  'set YellowOffTimes[]
                    YellowOffIndex% := YellowOffIndex% + 1;  'increment YellowOffIndex%
                endif;   
                if YellowOffIndex% = 50 then  'don't let it crash by exceeding variable size
                    YellowOffIndex% := 49;
                endif;            
            endif;
            if Key$ = "V" then 'Red LED On
                if RedOn% = 0 then  'if we changed the state of the red LED
                    RedOn% := 1;  'note red LED is now on
                    RedOnTimes[RedOnIndex%] := nowtime;  'set RedOnTimes[]
                    RedOnIndex% := RedOnIndex% + 1;  'increment RedOnIndex%
                    if RedOnIndex% = 50 then  'don't let it crash by exceeding variable size
                        RedOnIndex% := 49;
                    endif;
                endif;            
            endif;
            if Key$ = "W" or Key$ = "O" then 'Red LED Off
                if RedOn% = 1 then  'if we changed the state of the red LED
                    RedOn% := 0;  'note red LED is now off
                    RedOffTimes[RedOffIndex%] := nowtime;  'set RedOffTimes[]
                    RedOffIndex% := RedOffIndex% + 1;  'increment RedOffIndex%
                endif;   
                if RedOffIndex% = 50 then  'don't let it crash by exceeding variable size
                    RedOffIndex% := 49;
                endif;            
            endif;
            if Key$ = "G" then 'Green LED On
                if GreenOn% = 0 then  'if we changed the state of the green LED
                    GreenOn% := 1;  'note green LED is now on
                    GreenOnTimes[GreenOnIndex%] := nowtime;  'set GreenOnTimes[]
                    GreenOnIndex% := GreenOnIndex% + 1;  'increment GreenOnIndex%
                    if GreenOnIndex% = 50 then  'don't let it crash by exceeding variable size
                        GreenOnIndex% := 49;
                    endif;
                endif;            
            endif;
            if Key$ = "H" or Key$ = "O" then 'Green LED Off
                if GreenOn% = 1 then  'if we changed the state of the green LED
                    GreenOn% := 0;  'note green LED is now off
                    GreenOffTimes[GreenOffIndex%] := nowtime;  'set GreenOffTimes[]
                    GreenOffIndex% := GreenOffIndex% + 1;  'increment GreenOffIndex%
                endif;   
                if GreenOffIndex% = 50 then  'don't let it crash by exceeding variable size
                    GreenOffIndex% := 49;
                endif;            
            endif;
            if Key$ = "B" or Key$ = "I" then 'Incandescent On
                if IncOn% = 0 then  'if we changed the state of the Incandescent
                    IncOn% := 1;  'note Incandescent is now on
                    IncOnTimes[IncOnIndex%] := nowtime;  'set IncOnTimes[]
                    IncOnIndex% := IncOnIndex% + 1;  'increment IncOnIndex%
                endif;    
                if IncOnIndex% = 50 then  'don't let it crash by exceeding variable size
                    IncOnIndex% := 49;
                endif;            
            endif;
            if Key$ = "C" or Key$ = "J" or Key$ = "O" then 'Incandescent Off
                if IncOn% = 1 then  'if we changed the state of the Incandescent
                    IncOn% := 0;  'note Incandescent is now off
                    IncOffTimes[IncOffIndex%] := nowtime;  'set IncOffTimes[]
                    IncOffIndex% := IncOffIndex% + 1;  'increment IncOffIndex%
                endif;  
                if IncOffIndex% = 50 then  'don't let it crash by exceeding variable size
                    IncOffIndex% := 49;
                endif;            
            endif;     
            if Key$ = "F" then 'Flashing light start
                FlashLight% := sampleseqvar(4);
                docase
                    case FlashLight% = 1 then
                    YellowOnFlash[YellowOnFIndex%] := nowtime;  'set YellowOnFlash[]
                    YellowOnFIndex% := YellowOnFIndex% + 1;  'increment YellowOnFIndex%
                    YellowOffFlash[YellowOffFIndex%] := nowtime + FlashDurationS;  'set YellowOffFlash[], assume full duration
                    YellowOffFIndex% := YellowOffFIndex% + 1;  'increment YellowOffFIndex%
                    case FlashLight% = 2 then
                    GreenOnFlash[GreenOnFIndex%] := nowtime;  'set GreenOnFlash[]
                    GreenOnFIndex% := GreenOnFIndex% + 1;  'increment GreenOnFIndex%
                    GreenOffFlash[GreenOffFIndex%] := nowtime + FlashDurationS;  'set GreenOffFlash[], assume full duration
                    GreenOffFIndex% := GreenOffFIndex% + 1;  'increment GreenOffFIndex%
                    case FlashLight% = 3 then
                    RedOnFlash[RedOnFIndex%] := nowtime;  'set RedOnFlash[]
                    RedOnFIndex% := RedOnFIndex% + 1;  'increment RedOnFIndex%
                    RedOffFlash[RedOffFIndex%] := nowtime + FlashDurationS;  'set RedOffFlash[], assume full duration
                    RedOffFIndex% := RedOffFIndex% + 1;  'increment RedOffFIndex%
                    case FlashLight% = 4 then
                    IncOnFlash[IncOnFIndex%] := nowtime;  'set IncOnFlash[]
                    IncOnFIndex% := IncOnFIndex% + 1;  'increment IncOnFIndex%
                    IncOffFlash[IncOffFIndex%] := nowtime + FlashDurationS;  'set IncOffFlash[], assume full duration
                    IncOffFIndex% := IncOffFIndex% + 1;  'increment IncOffFIndex%
                endcase
            endif;
            
            try := 0;  'break out of the while loop
        endif;
    wend;
    
end;




'============================ Change Joystick Thresholds ===========================
'This function allows the increment or decrement of the Up, Down, Left and Right thresholds simultaneously,
'making it possible to do in one line of code in the main loop what took 8 lines before.
'The first input is the Up change, the second input is the Down change, the third is the Left, the fourth the Right.  
'Enter 0 for no change, -1 to decrement and 1 to increment.  That easy.
func ChangeThresh(ddUp,dDown,dLeft,dRight)  '"dup" is reserved
    
    var overshoot;
    
    if Grow% = 0 then  'shifting the thresholds
        
        if ddUp > 0 then 'increment Up
            'shift both together
            UpThreshOuter := UpThreshOuter + UpThreshOuterInc;  'Increment Up threshold, Outer
            UpThreshInner := UpThreshInner + UpThreshInnerInc;  'Increment Up threshold, Inner
            'check for overshoot
            if UpThreshOuter > UpThreshOuterMax then
                overshoot := UpThreshOuter - UpThreshOuterMax;
                UpThreshOuter := UpThreshOuterMax;  '= UpThreshOuter - overshoot;
                UpThreshInner := UpThreshInner - overshoot;  'Decrement UpThreshInner by the same amount
            endif;
            if UpThreshInner > UpThreshInnerMax then
                overshoot := UpThreshInner - UpThreshInnerMax;
                UpThreshInner := UpThreshInnerMax;  '= UpThreshInner - overshoot;
                UpThreshOuter := UpThreshOuter - overshoot;  'Decrement UpThreshOuter by the same amount
            endif;
        endif;
        
        if ddUp < 0 then 'decrement Up
            'shift both together
            UpThreshOuter := UpThreshOuter - UpThreshOuterDec;  'Decrement Up threshold, Outer
            UpThreshInner := UpThreshInner - UpThreshInnerDec;  'Decrement Up threshold, Inner
            'check for overshoot
            if UpThreshOuter < UpThreshOuterMin then
                overshoot := UpThreshOuterMin - UpThreshOuter;
                UpThreshOuter := UpThreshOuterMin;  '= UpThreshOuter + overshoot;
                UpThreshInner := UpThreshInner + overshoot;  'Increment UpThreshInner by the same amount
            endif;
            if UpThreshInner < UpThreshInnerMin then
                overshoot := UpThreshInnerMin - UpThreshInner;
                UpThreshInner := UpThreshInnerMin;  '= UpThreshInner + overshoot;
                UpThreshOuter := UpThreshOuter + overshoot;  'Increment UpThreshOuter by the same amount
            endif;
        endif;
        
        if dDown > 0 then 'increment Down
            'shift both together
            DownThreshOuter := DownThreshOuter + DownThreshOuterInc;  'Increment Down threshold, Outer
            DownThreshInner := DownThreshInner + DownThreshInnerInc;  'Increment Down threshold, Inner
            'check for overshoot
            if DownThreshOuter > DownThreshOuterMax then
                overshoot := DownThreshOuter - DownThreshOuterMax;
                DownThreshOuter := DownThreshOuterMax;  '= DownThreshOuter - overshoot;
                DownThreshInner := DownThreshInner - overshoot;  'Decrement DownThreshInner by the same amount
            endif;
            if DownThreshInner > DownThreshInnerMax then
                overshoot := DownThreshInner - DownThreshInnerMax;
                DownThreshInner := DownThreshInnerMax;  '= DownThreshInner - overshoot;
                DownThreshOuter := DownThreshOuter - overshoot;  'Decrement DownThreshOuter by the same amount
            endif;
        endif;
        
        if dDown < 0 then 'decrement Down
            'shift both together
            DownThreshOuter := DownThreshOuter - DownThreshOuterDec;  'Decrement Down threshold, Outer
            DownThreshInner := DownThreshInner - DownThreshInnerDec;  'Decrement Down threshold, Inner
            'check for overshoot
            if DownThreshOuter < DownThreshOuterMin then
                overshoot := DownThreshOuterMin - DownThreshOuter;
                DownThreshOuter := DownThreshOuterMin;  '= DownThreshOuter + overshoot;
                DownThreshInner := DownThreshInner + overshoot;  'Increment DownThreshInner by the same amount
            endif;
            if DownThreshInner < DownThreshInnerMin then
                overshoot := DownThreshInnerMin - DownThreshInner;
                DownThreshInner := DownThreshInnerMin;  '= DownThreshInner + overshoot;
                DownThreshOuter := DownThreshOuter + overshoot;  'Increment DownThreshOuter by the same amount
            endif;
        endif;
        
        if dLeft > 0 then 'increment Left
            'shift both together
            LeftThreshOuter := LeftThreshOuter + LeftThreshOuterInc;  'Increment Left threshold, Outer
            LeftThreshInner := LeftThreshInner + LeftThreshInnerInc;  'Increment Left threshold, Inner
            'check for overshoot
            if LeftThreshOuter > LeftThreshOuterMax then
                overshoot := LeftThreshOuter - LeftThreshOuterMax;
                LeftThreshOuter := LeftThreshOuterMax;  '= LeftThreshOuter - overshoot;
                LeftThreshInner := LeftThreshInner - overshoot;  'Decrement LeftThreshInner by the same amount
            endif;
            if LeftThreshInner > LeftThreshInnerMax then
                overshoot := LeftThreshInner - LeftThreshInnerMax;
                LeftThreshInner := LeftThreshInnerMax;  '= LeftThreshInner - overshoot;
                LeftThreshOuter := LeftThreshOuter - overshoot;  'Decrement LeftThreshOuter by the same amount
            endif;
        endif;
        
        if dLeft < 0 then 'decrement Left
            'shift both together
            LeftThreshOuter := LeftThreshOuter - LeftThreshOuterDec;  'Decrement Left threshold, Outer
            LeftThreshInner := LeftThreshInner - LeftThreshInnerDec;  'Decrement Left threshold, Inner
            'check for overshoot
            if LeftThreshOuter < LeftThreshOuterMin then
                overshoot := LeftThreshOuterMin - LeftThreshOuter;
                LeftThreshOuter := LeftThreshOuterMin;  '= LeftThreshOuter + overshoot;
                LeftThreshInner := LeftThreshInner + overshoot;  'Increment LeftThreshInner by the same amount
            endif;
            if LeftThreshInner < LeftThreshInnerMin then
                overshoot := LeftThreshInnerMin - LeftThreshInner;
                LeftThreshInner := LeftThreshInnerMin;  '= LeftThreshInner + overshoot;
                LeftThreshOuter := LeftThreshOuter + overshoot;  'Increment LeftThreshOuter by the same amount
            endif;
        endif;
        
        if dRight > 0 then 'increment Right
            'shift both together
            RightThreshOuter := RightThreshOuter + RightThreshOuterInc;  'Increment Right threshold, Outer
            RightThreshInner := RightThreshInner + RightThreshInnerInc;  'Increment Right threshold, Inner
            'check for overshoot
            if RightThreshOuter > RightThreshOuterMax then
                overshoot := RightThreshOuter - RightThreshOuterMax;
                RightThreshOuter := RightThreshOuterMax;  '= RightThreshOuter - overshoot;
                RightThreshInner := RightThreshInner - overshoot;  'Decrement RightThreshInner by the same amount
            endif;
            if RightThreshInner > RightThreshInnerMax then
                overshoot := RightThreshInner - RightThreshInnerMax;
                RightThreshInner := RightThreshInnerMax;  '= RightThreshInner - overshoot;
                RightThreshOuter := RightThreshOuter - overshoot;  'Decrement RightThreshOuter by the same amount
            endif;
        endif;
        
        if dRight < 0 then 'decrement Right
            'shift both together
            RightThreshOuter := RightThreshOuter - RightThreshOuterDec;  'Decrement Right threshold, Outer
            RightThreshInner := RightThreshInner - RightThreshInnerDec;  'Decrement Right threshold, Inner
            'check for overshoot
            if RightThreshOuter < RightThreshOuterMin then
                overshoot := RightThreshOuterMin - RightThreshOuter;
                RightThreshOuter := RightThreshOuterMin;  '= RightThreshOuter + overshoot;
                RightThreshInner := RightThreshInner + overshoot;  'Increment RightThreshInner by the same amount
            endif;
            if RightThreshInner < RightThreshInnerMin then
                overshoot := RightThreshInnerMin - RightThreshInner;
                RightThreshInner := RightThreshInnerMin;  '= RightThreshInner + overshoot;
                RightThreshOuter := RightThreshOuter + overshoot;  'Increment RightThreshOuter by the same amount
            endif;
        endif;
        
    else 'if Grow% = 1, we grow/shrink the gap between thresholds 
        
        if ddUp > 0 then 'grow the gap
            UpThreshOuter := UpThreshOuter + UpThreshOuterInc;  'Increment Up threshold, Outer
            UpThreshInner := UpThreshInner - UpThreshInnerDec;  'Decrement Up threshold, Inner
            'check for overshoot
            if UpThreshOuter > UpThreshOuterMax then
                UpThreshOuter := UpThreshOuterMax;  'Do not allow to go beyond the Max
            endif;
            if UpThreshInner < UpThreshInnerMin then
                UpThreshInner := UpThreshInnerMin;  'Do not allow to go beyond the Min
            endif;
        endif;
        
        if ddUp < 0 then 'shrink the gap
            UpThreshOuter := UpThreshOuter - UpThreshOuterDec;  'Decrement Up threshold, Outer
            UpThreshInner := UpThreshInner + UpThreshInnerInc;  'Increment Up threshold, Inner
            if UpThreshOuter < UpThreshOuterMin then
                UpThreshOuter := UpThreshOuterMin;  'Do not allow to go beyond the Min
            endif;
            if UpThreshInner > UpThreshInnerMax then
                UpThreshInner := UpThreshInnerMax;  'Do not allow to go beyond the Max
            endif;
        endif;
        
        if dDown > 0 then 'grow the gap
            DownThreshOuter := DownThreshOuter + DownThreshOuterInc;  'Increment Down threshold, Outer
            DownThreshInner := DownThreshInner - DownThreshInnerDec;  'Decrement Down threshold, Inner
            'check for overshoot
            if DownThreshOuter > DownThreshOuterMax then
                DownThreshOuter := DownThreshOuterMax;  'Do not allow to go beyond the Max
            endif;
            if DownThreshInner < DownThreshInnerMin then
                DownThreshInner := DownThreshInnerMin;  'Do not allow to go beyond the Min
            endif;
        endif;
        
        if dDown < 0 then 'shrink the gap
            DownThreshOuter := DownThreshOuter - DownThreshOuterDec;  'Decrement Down threshold, Outer
            DownThreshInner := DownThreshInner + DownThreshInnerInc;  'Increment Down threshold, Inner
            if DownThreshOuter < DownThreshOuterMin then
                DownThreshOuter := DownThreshOuterMin;  'Do not allow to go beyond the Min
            endif;
            if DownThreshInner > DownThreshInnerMax then
                DownThreshInner := DownThreshInnerMax;  'Do not allow to go beyond the Max
            endif;
        endif;
        
        if dLeft > 0 then 'grow the gap
            LeftThreshOuter := LeftThreshOuter + LeftThreshOuterInc;  'Increment Left threshold, Outer
            LeftThreshInner := LeftThreshInner - LeftThreshInnerDec;  'Decrement Left threshold, Inner
            'check for overshoot
            if LeftThreshOuter > LeftThreshOuterMax then
                LeftThreshOuter := LeftThreshOuterMax;  'Do not allow to go beyond the Max
            endif;
            if LeftThreshInner < LeftThreshInnerMin then
                LeftThreshInner := LeftThreshInnerMin;  'Do not allow to go beyond the Min
            endif;
        endif;
        
        if dLeft < 0 then 'shrink the gap
            LeftThreshOuter := LeftThreshOuter - LeftThreshOuterDec;  'Decrement Left threshold, Outer
            LeftThreshInner := LeftThreshInner + LeftThreshInnerInc;  'Increment Left threshold, Inner
            if LeftThreshOuter < LeftThreshOuterMin then
                LeftThreshOuter := LeftThreshOuterMin;  'Do not allow to go beyond the Min
            endif;
            if LeftThreshInner > LeftThreshInnerMax then
                LeftThreshInner := LeftThreshInnerMax;  'Do not allow to go beyond the Max
            endif;
        endif;
        
        if dRight > 0 then 'grow the gap
            RightThreshOuter := RightThreshOuter + RightThreshOuterInc;  'Increment Right threshold, Outer
            RightThreshInner := RightThreshInner - RightThreshInnerDec;  'Decrement Right threshold, Inner
            'check for overshoot
            if RightThreshOuter > RightThreshOuterMax then
                RightThreshOuter := RightThreshOuterMax;  'Do not allow to go beyond the Max
            endif;
            if RightThreshInner < RightThreshInnerMin then
                RightThreshInner := RightThreshInnerMin;  'Do not allow to go beyond the Min
            endif;
        endif;
        
        if dRight < 0 then 'shrink the gap
            RightThreshOuter := RightThreshOuter - RightThreshOuterDec;  'Decrement Right threshold, Outer
            RightThreshInner := RightThreshInner + RightThreshInnerInc;  'Increment Right threshold, Inner
            if RightThreshOuter < RightThreshOuterMin then
                RightThreshOuter := RightThreshOuterMin;  'Do not allow to go beyond the Min
            endif;
            if RightThreshInner > RightThreshInnerMax then
                RightThreshInner := RightThreshInnerMax;  'Do not allow to go beyond the Max
            endif;
        endif;
        
    endif;    
    
    if VerboseIncrements% = 1 then
        printlog("New UpThreshOuter = %f degrees, New UpThreshInner = %f degrees\n",UpThreshOuter/.09,UpThreshInner/.09);
        printlog("New DownThreshOuter = %f degrees, New DownThreshInner = %f degrees\n",DownThreshOuter/.09,DownThreshInner/.09);
        printlog("New LeftThreshOuter = %f degrees, New LeftThreshInner = %f degrees\n",LeftThreshOuter/.09,LeftThreshInner/.09);
        printlog("New RightThreshOuter = %f degrees, New RightThreshInner = %f degrees\n",RightThreshOuter/.09,RightThreshInner/.09);
        view(HiddenLogHandle%).print("New UpThreshOuter = %f degrees, New UpThreshInner = %f degrees\r",UpThreshOuter/.09,UpThreshInner/.09);
        view(HiddenLogHandle%).print("New DownThreshOuter = %f degrees, New DownThreshInner = %f degrees\r",DownThreshOuter/.09,DownThreshInner/.09);
        view(HiddenLogHandle%).print("New LeftThreshOuter = %f degrees, New LeftThreshInner = %f degrees\r",LeftThreshOuter/.09,LeftThreshInner/.09);
        view(HiddenLogHandle%).print("New RightThreshOuter = %f degrees, New RightThreshInner = %f degrees\r",RightThreshOuter/.09,RightThreshInner/.09);
    endif;
    
end;



'============================ Update ITIs ===========================
'This function updates the ITI
proc UpdateITI()
    MinITI += DeltaITI;  'DeltaITI may be negative, that's OK
    if MinITI > MinITICeil then
        MinITI := MinITICeil;
    endif;
    if MinITI < MinITIFloor then
        MinITI := MinITIFloor;
    endif;
end
'=========================== Change Fade-In Attenuation Level, Staircase ===========================
'Changes fade-in attenuation level using a staircase method
func StaircasedB()
    
    var Action%;
    
    'Wrap the whole thing with an if, just short out if we're not actually changing dB
    'Also make conditional on StimIsRepeating% - if the monkey already missed it once, and
    'is perseverating, don't keep moving the staircase
    'Also do not insert "zero" results (from probe/catch trials) into ResponseHistory%, which can cause crashes
    if StairTargAcc > 0 and StimIsRepeating% = 0  and LastResult% <> 0 then
        
        ResponseHistory%[ResponseIndex%] := LastResult%;  'Put most recent result into ResponseHistory%
        ResponseIndex% := ResponseIndex% + 1;  'Increment ResponseIndex%
        
        Action% := TransStair%(ResponseHistory%[],StairTargAcc);  'Action% will be 0 (do nothing), -1 (make easier) or 1 (make harder)
        
        docase
            case Action% = 1 then
            FadedBLast := FadedBInit;  'Hold value of most recent FadedB
            FadedBInit := FadedBInit - FadedBInc;  'Update value in FadedB
            if FadedBInit < FadedBMin then 'make sure we don't drop below 0
                FadedBInit := FadedBMin;
            endif;
            'Give report on change
            if VerboseIncrements% = 1 then
                printlog("Decreasing attenuation of noise stimulus after response pattern %d to %f dB\n",ResponseHistory%[],FadedBInit);
                view(HiddenLogHandle%).print("Decreasing attenuation of noise stimulus after response pattern %d to %f dB\r",ResponseHistory%[],FadedBInit);
            endif;
            'reset response history
            ResponseIndex% := 0;
            ArrConst(ResponseHistory%[],0);
            case Action% = -1 then
            FadedBLast := FadedBInit;  'Hold value of most recent FadedB
            FadedBInit := FadedBInit + FadedBInc;  'Update value in FadedB
            if FadedBInit > FadedBMax then 'make sure we don't exceed 100
                FadedBInit := FadedBMax;
            endif;
            'Give report on change
            if VerboseIncrements% = 1 then
                printlog("Increasing attenuation of noise stimulus after response pattern %d to %f dB\n",ResponseHistory%[],FadedBInit);
                view(HiddenLogHandle%).print("Increasing attenuation of noise stimulus after response pattern %d to %f dB\r",ResponseHistory%[],FadedBInit);
            endif;
            'reset response history
            ResponseIndex% := 0;
            ArrConst(ResponseHistory%[],0);
        else
            'Report no change
            FadedBLast := FadedBInit;  'Get current value of FadedB
            if VerboseIncrements% = 1 then
                printlog("No attenuation change after response pattern %d\n",ResponseHistory%[]);
                view(HiddenLogHandle%).print("No attenuation change after response pattern %d\r",ResponseHistory%[]);
            endif;
        endcase;
        
        
    endif;
    
end;

'=========================== Change Fade-In Attenuation Level, Simple ==============================
proc SimpleStepdB(Last%)
    
    if Last% = -1  then 'a miss
        FadedBLast := FadedBInit;  'Hold value of most recent FadedB
        FadedBInit := FadedBInit + FadedBDec;  'more attenuation
        if FadedBInit > FadedBMax then
            FadedBInit := FadedBMax;
        endif;
        if VerboseIncrements% = 1 then
            printlog("After miss, new attenuation will be %f\n",FadedBInit);
            view(HiddenLogHandle%).print("After miss, new attenuation will be %f\r",FadedBInit);
        endif;
    endif;
    
    if Last% = -2  then 'an interrupt
        FadedBLast := FadedBInit;  'Hold value of most recent FadedB
        FadedBInit := FadedBInit + FadedBDec;  'more attenuation
        if FadedBInit > FadedBMax then
            FadedBInit := FadedBMax;
        endif;
        if VerboseIncrements% = 1 then
            printlog("After interrupt, new attenuation will be %f\n",FadedBInit);
            view(HiddenLogHandle%).print("After interrupt, new attenuation will be %f\r",FadedBInit);
        endif;
    endif;
    
    if Last% = 1  then 'a hit
        FadedBLast := FadedBInit;  'Hold value of most recent FadedB
        FadedBInit := FadedBInit - FadedBInc;  'less attenuation
        if FadedBInit < FadedBMin then
            FadedBInit := FadedBMin;
        endif;
        if VerboseIncrements% = 1 then
            printlog("After hit, new attenuation will be %f\n",FadedBInit);
            view(HiddenLogHandle%).print("After hit, new attenuation will be %f\r",FadedBInit);
        endif;
    endif;
    
end;


'================================= Check for Perseverance =====================================
'This function looks at the previous PersevN trials to determine if the monkey is perseverating
'and switches to "RepeatOnError", or if it's in "RepeatOnError" state, checks for accuracy over
'BrkPersevN trials and switches to regular mode
func CheckPerseverance()
    
    var TempHistory%[40];
    var PctCorrect;
    var TotCorrect%;
    var UpRight;  'Count of correct up responses, etc.  CANNOT BE AN INTEGER I HATE YOU SPIKE2
    var UpWrong;
    var DownRight;
    var DownWrong;
    var NRRight;
    var NRWrong;
    var tempcount;
    var loopy%;   'loop variable
    var pct := .4;  'Percentage of PersevN; this many mistakes required to trigger perseverance
    
    if PersevN > 0 and LastResult% <> 0 then  'Don't check for perseverance if PersevN is zero or if last trial was a probe/catch
        
        if RepeatOnError% = 0 then
            'first, load up history
            if PersevIndex%+1 <= PersevN then  'Index starts at 0, so we have to add one
                PersevHistory%[PersevIndex%] := LastResult%; 'put result in PersevHistory%
                RespPersevHistory%[PersevIndex%] := TargetResponse%;  'put most recent response 
                PersevIndex% := PersevIndex% + 1;  'increment index, holds total number of elements once inc'ed
            else 'if index is already "full"
                ArrConst(TempHistory%[0:PersevIndex%-1],PersevHistory%[1:PersevIndex%-1]);  'copy latest elements to temp array
                ArrConst(PersevHistory%[0:PersevIndex%-1],TempHistory%[0:PersevIndex%-1]);  'Recopy back
                PersevHistory%[PersevIndex%-1] := LastResult%; 'put most recent value in PersevHistory%
                ArrConst(TempHistory%[0:PersevIndex%-1],RespPersevHistory%[1:PersevIndex%-1]);  'Repeat for RespPersevHistory%
                ArrConst(RespPersevHistory%[0:PersevIndex%-1],TempHistory%[0:PersevIndex%-1]);  
                RespPersevHistory%[PersevIndex%-1] := TargetResponse%; 
            endif;
            
            'check to see if monkey is perseverating, only check if we might have reached criterion # of events
            'first, get positions (in RespPersevHistory%[]) of up, down, and no responses (for joystick, will be "up" and "no resp" only)
            if PersevIndex% >= PersevN*pct then 'PersevIndex has already incremented
                for loopy% := 0 to PersevIndex%-1 do
                    if RespPersevHistory%[loopy%] = 1 and PersevHistory%[loopy%] = 1 then
                        UpRight := UpRight + 1;
                    endif;
                    if RespPersevHistory%[loopy%] = 2 and PersevHistory%[loopy%] = 1 then
                        DownRight := DownRight + 1;
                    endif;
                    if RespPersevHistory%[loopy%] = 0 and PersevHistory%[loopy%] = 1 then
                        NRRight := NRRight + 1;
                    endif;
                    if RespPersevHistory%[loopy%] = 1 and PersevHistory%[loopy%] = -1 then
                        UpWrong := UpWrong + 1;
                    endif;
                    if RespPersevHistory%[loopy%] = 2 and PersevHistory%[loopy%] = -1 then
                        DownWrong := DownWrong + 1;
                    endif;
                    if RespPersevHistory%[loopy%] = 0 and PersevHistory%[loopy%] = -1 then
                        NRWrong := NRWrong + 1;
                    endif;
                next;
                docase
                    case RespDevice% < 1 then 'We're not using the joystick
                    
                    tempcount := UpWrong + NRRight;  'total "hold" responses expected
                    if tempcount > 0 then  'kill divide by zero error
                        if tempcount >= PersevN*pct and UpWrong/tempcount >= PersevPct then
                            RepeatOnError% := 1;  'Turn on Repeating
                            PersevIndex% := 0;  'Reset index
                            ArrConst(PersevHistory%[],0);  'Clear history
                            ArrConst(RespPersevHistory%[],0);  'Clear history
                            Printlog("\n*\n*\n*\n Accuracy on standard trials is too low.  Perseveration suspected.  We are now repeating on error!!!\n\n");
                            view(HiddenLogHandle%).print("\r*\r*\r*\r Accuracy on standard trials is too low.  Perseveration suspected.  We are now repeating on error!!!\r\r");
                            return 1
                        endif;
                    endif;
                    tempcount := NRWrong + UpRight;  'total "release" responses expected
                    if tempcount > 0 then  'kill divide by zero error
                        if tempcount >= PersevN*pct and NRWrong/tempcount >= PersevPct then
                            RepeatOnError% := 1;  'Turn on Repeating
                            PersevIndex% := 0;  'Reset index
                            ArrConst(PersevHistory%[],0);  'Clear history
                            ArrConst(RespPersevHistory%[],0);  'Clear history
                            Printlog("\n*\n*\n*\n Accuracy on target trials is too low.  Perseveration suspected.  We are now repeating on error!!!\n\n");
                            view(HiddenLogHandle%).print("\r*\r*\r*\r Accuracy on target trials is too low.  Perseveration suspected.  We are now repeating on error!!!\r\r");
                            return 1;
                        endif;
                    endif;
                    
                    case RespDevice% = 1 then 'We are using the joystick(up/down response)
                    tempcount := PersevIndex%;  'total trials
                    if tempcount > 0 then  'kill divide by zero error
                        if tempcount >= PersevN*pct and NRWrong/tempcount >= PersevPct then
                            RepeatOnError% := 1;  'Turn on Repeating
                            PersevIndex% := 0;  'Reset index
                            ArrConst(PersevHistory%[],0);  'Clear history
                            ArrConst(RespPersevHistory%[],0);  'Clear history
                            Printlog("\n*\n*\n*\n Too many no-responses detected.  Perseveration suspected.  We are now repeating on error!!!\n\n");
                            view(HiddenLogHandle%).print("\r*\r*\r*\r Too many no-responses detected.  Perseveration suspected.  We are now repeating on error!!!\r\r");
                            return 1;
                        endif;
                    endif;
                    tempcount := UpWrong + DownRight;  'total "down" responses expected
                    if tempcount > 0 then  'kill divide by zero error
                        if tempcount >= PersevN*pct and UpWrong/tempcount >= PersevPct then
                            RepeatOnError% := 1;  'Turn on Repeating
                            PersevIndex% := 0;  'Reset index
                            ArrConst(PersevHistory%[],0);  'Clear history
                            ArrConst(RespPersevHistory%[],0);  'Clear history
                            Printlog("\n*\n*\n*\n Accuracy on down trials is too low.  Perseveration suspected.  We are now repeating on error!!!\n\n");
                            view(HiddenLogHandle%).print("\r*\r*\r*\r Accuracy on down trials is too low.  Perseveration suspected.  We are now repeating on error!!!\r\r");
                            return 1;
                        endif;
                    endif;
                    tempcount := DownWrong + UpRight;  'total "release" responses expected
                    if tempcount > 0 then  'kill divide by zero error
                        if tempcount >= PersevN*pct and DownWrong/tempcount >= PersevPct then
                            RepeatOnError% := 1;  'Turn on Repeating
                            PersevIndex% := 0;  'Reset index
                            ArrConst(PersevHistory%[],0);  'Clear history
                            ArrConst(RespPersevHistory%[],0);  'Clear history
                            Printlog("\n*\n*\n*\n Accuracy on up trials is too low.  Perseveration suspected.  We are now repeating on error!!!\n\n");
                            view(HiddenLogHandle%).print("\r*\r*\r*\r Accuracy on up trials is too low.  Perseveration suspected.  We are now repeating on error!!!\r\r");
                            return 1;
                        endif;
                    endif
                    case RespDevice% = 2 then
                    message("Currently the code for perseverance for JoystickLR is not implemented!\n");
                    printlog("Currently the code for perseverance for JoystickLR is not implemented!\n");
                    view(HiddenLogHandle%).print("Currently the code for perseverance for JoystickLR is not implemented!\r");
                endcase;          
                
            endif;     
            
        else 'if we're repeating on error already
            'first, load up history
            if PersevIndex%+1 <= BrkPersevN then  'Index starts at 0, so we have to add one
                if LastResult% = 1 then
                    PersevHistory%[PersevIndex%] := 1; 'put 1 in PersevHistory% if correct
                else
                    PersevHistory%[PersevIndex%] := 0; 'put 0 in if wrong
                endif;
                PersevIndex% := PersevIndex% + 1;  'increment index, holds total number of elements once inc'ed
            else 'if index is already "full"
                ArrConst(TempHistory%[0:PersevIndex%-1],PersevHistory%[1:PersevIndex%-1]);  'copy latest elements to temp array
                ArrConst(PersevHistory%[0:PersevIndex%-1],TempHistory%[0:PersevIndex%-1]);  'Recopy back
                PersevHistory%[PersevIndex%-1] := LastResult%; 'put most recent value in PersevHistory%
            endif;
            
            'check to see if we've beaten the BrkPersevPct, make sure we've got enough trials
            TotCorrect% := ArrSum(PersevHistory%[0:PersevIndex%],PctCorrect); 'get PctCorrect and TotCorrect
            if TotCorrect% >= BrkPersevPct*BrkPersevN and PctCorrect >= BrkPersevPct then
                RepeatOnError% := 0;  'Turn off Repeating
                PersevIndex% := 0;  'Reset index
                ArrConst(PersevHistory%[],0);  'Clear history
                Printlog("\n*\n*\n*\n Accuracy has reached criterion.  We are no longer repeating on error!!!\n\n");
                view(HiddenLogHandle%).print("\r*\r*\r*\r Accuracy has reached criterion.  We are no longer repeating on error!!!\r\r");
                ReleaseFromPersevTrial% := TrialCount%-1;
                return 1;
            endif;   
        endif;
        
    endif;
    return 0;
end;


'================================= Debounce the Lever Channel =================================
'This function serves as a software debounce for incoming TTL pulses.  It can only parse 1000
'events at one time, but is called every time main%() is called (if we are sampling) and at 
'various points in main%() as well, so the 1000 event limit should not really be in danger.
'If there are > 1000 events, I BELIEVE it will simply parse the first 1000, allowing it to 
'continue parsing 1000 events each time it is called until it is caught up.  ...that hasn't been tested.
func DebounceLever%()
    
    var TimesArray[1000];            'array of times of most recent events
    var TimesArrayTemp[999];         'array of times used only the first time through
    var LeverStatusAfter[1000];      'array of lever statuses corresponding to TimesArray[]
    var TimeToPrev[1000];            'array of differences between times in TimesArray[] and previous event
    var TimeToNext[1000];            'array of differences between times in TimesArray[] and next event
    var temp1[999];
    var temp2;
    var RealEventTime[1000];         'Holds times of real (not bouncing) events 
    var RealEventValue[1000];        'Holds lever values resulting from real events
    var EventCount%;                 'Counter for real events
    var ValueCount%;                 'Counter for real lever values
    var DebounceTime := .040;        'Debounce over 40 ms, can be changed manually
    var Now;                         'Grabs current time at beginning of execution this subfunction
    var NumEvents%;                  'Number of potential lever events in the current execution
    var LeverString$;						'A string which details the lever event (for textmark channel)
    var ii%, jj%, BreakVar;
    
	'Figure out what time it is now
    Now := maxtime();
    
    view(ctview%);
    
    if LeverTime = 0 then 'if it's the first pass or there have not been any events (LeverInitTime and LeverResponseTime are identical for lever scenarios)
        NumEvents% := chandata(configLeverChannel%,TimesArrayTemp[],0,Now);  'put recent times of lever presses in a temporary array
        arrconst(TimesArray[1:999],TimesArrayTemp[]);  'move temporary numbers to regular array, leaving first time blank (indicates "known" event at time = 0)
        NumEvents% := NumEvents% + 1;  'Increment NumEvents% by one to account for asserted event at time = 0
    else
        NumEvents% := chandata(configLeverChannel%,TimesArray[],LeverTime,Now);  'put times of recent lever presses in regular array, starting with most recent known event
    endif;
    
    
	'There should always be a "first event" at LeverInitTime.  If there are no more, we haven't actually
	'had anything happen, so don't do anything
    if NumEvents% > 1 then
		'Calculate time to previous, next events
        
		'Fill temp1 with a shifted version of TimesArray, shifted one to the left
		'Note that the fill for a single element must be done differently
        if NumEvents% = 2 then
            temp1[0] := TimesArray[1];
        else
            arrconst(temp1[0:NumEvents%-1],TimesArray[1:NumEvents%-1]);
        endif;
        
		'Subtract, so temp1[x] holds the time difference between TimesArray[x] and TimesArray[x+1]
        arrsub(temp1,TimesArray[]);
        
		'Fill TimeToNext and TimeToPrev, note that temp1[NumEvents%-1] will be negative, and is useless
        if NumEvents% = 2 then
            TimeToPrev[1] := temp1[0];
            TimeToNext[0] := temp1[0];
        else
            arrconst(TimeToPrev[1:NumEvents%-1],temp1[0:NumEvents%-1]);
            arrconst(TimeToNext[0:NumEvents%-1],temp1[0:NumEvents%-1]);
        endif;
        
		'Fill final spot in TimeToNext with time to Now.
        TimeToNext[NumEvents%-1] := Now - TimesArray[NumEvents%-1];
        
		'Get lever status resulting from each lever event
        for ii% := 1 to NumEvents%-1 do 'only consider events starting at second position in array
            nexttime(configLeverChannel%,TimesArray[ii%],temp2);  'temp2 will be 0 if low-to-high and 1 if high-to-low
            LeverStatusAfter[ii%] := 1 - temp2; 'LeverStatusAfter will be 1 if low-to-high and 0 if high-to-low
        next;
        
        
		'Check each event in TimesArray (except [0])
        for ii% := 1 to NumEvents%-1 do 
			'If there was more than DebounceTime between the previous event and this one, the
			'previous state was stable, this should be considered a real event
            if TimeToPrev[ii%] > DebounceTime then
                RealEventTime[EventCount%] := TimesArray[ii%];
                EventCount% := EventCount% + 1;
				'Get the lever status for this event by looking for next stable period
                BreakVar := 0;
                jj% := ii%;
                while jj% <= NumEvents%-1 and BreakVar = 0 do
                    if TimeToNext[jj%] > DebounceTime then 'it has been stable long enough
                        RealEventValue[ValueCount%] := LeverStatusAfter[jj%];
                        ValueCount% := ValueCount% + 1;
                        BreakVar := 1;
                    else
                        jj% := jj% + 1;
                    endif;
                wend;
            endif;
        next;
        
		'Check to see that the number of lever presses and events correspond appropriately
        if ValueCount% <> EventCount% then
            if ValueCount% > EventCount% then
                printlog("Quitting because we have found more real lever presses than real events.  This is a serious bug!\n");
                view(HiddenLogHandle%).print("Quitting because we have found more real lever presses than real events.  This is a serious bug!\r");
                quit%();
            endif;
            if ValueCount% < EventCount%-1 then
                printlog("Quitting because we have found more than one event which does not correspond to a stable lever press!\n");
                view(HiddenLogHandle%).print("Quitting because we have found more than one event which does not correspond to a stable lever press!\r");
                quit%();
            else
                EventCount% := EventCount%-1;  'decrement, do not consider last event real as we do not have a
                'corresponding lever press
            endif;
        endif;
        
        'Put events in memory channel if they exist and change LeverInitTime/LeverResponseTime/LeverInit%/LeverResponse%
        if EventCount% > 0 then	
            if VerboseJoyLev% = 1 then
                view(HiddenLogHandle%).print("Debounce: The lever events we considered to be real occurred at times: %f\r",RealEventTime[0:EventCount%]);
            endif;
            for ii% := 0 to EventCount%-1 do
                LeverCodes%[0] := RealEventValue[ii%];
                if RealEventValue[ii%] = 0 then
                    LeverString$ := "Lever Pressed";
                else
                    LeverString$ := "Lever Released";
                endif;
                view(ctview%).MemSetItem(MemChanLeverDebounce%,0,RealEventTime[ii%],LeverCodes%[],LeverString$);
            next;
            'return most recent event and value
            LeverTime := RealEventTime[ii%-1]; 'subtract one because ii% is incremented a final time by the for loop
            LeverPos% := RealEventValue[ii%-1]; 'ditto
            
			'indicate whether lever is in the origin (meaning not pressed), only if we are responding w/ lever
			'also indicate if lever is in trial initiation position
			'also indicate if lever is in trial response position
            if RespDevice% = 0 then
                InOrigin% := 1 - LeverPos%;
                TrialInit% := LeverPos%;
                TrialResponse% := InOrigin%;  'for lever, trial response position is same as origin
                if TrialResponse% = 1 then
                    ResponseTime := LeverTime;
                endif;
            endif;
            
        endif;  'end "if there were any events"
        
    endif;  
    
    return 1;
    
end;





'============================== Calibrate Joystick =========================
'This function will automatically calibrate the joystick.  Woot.
func CalibrateJoystick%()
    var currentX;
    var currentY;
    var ii%;
    var jview%;
    
    'need a dialog to determine whether joystick is human or monkey so we can keep both
    var jt%;  'joystick type
    var mystr$[2];
    mystr$[0] := "monkey";
    mystr$[1] := "human";
    
    DlgCreate("Select Joystick Type");
    DlgList(1,"Type of Joystick",mystr$);
    ii% := DlgShow(jt%);
    
    if ii% = 1 then
        'get the current offsets, joystickXOffset and joystickYOffset
        GetJoystickOffsets(jt%);  
        
        'here we need code to start sampling with two joystick channels and get the values of the current
        'position, which won't be exactly 0 in either the X or Y direction into currentX, currentY
        'create joystick channels
        'X
        SampleWaveform(configJoyXChannel%,configJoyXPort%,5000); 
        SampleComment$(configJoyXChannel%,"JoystikX");
        SampleTitle$(configJoyXChannel%,"JoystikX");
        'Y
        SampleWaveform(configJoyYChannel%,configJoyYPort%,5000); 
        SampleComment$(configJoyYChannel%,"JoystikY");
        SampleTitle$(configJoyYChannel%,"JoystikY");

        'Set additional info for joystick channels, notably current offset
        SampleCalibrate(configJoyXChannel%,"volt",1,joystickXOffset);
        SampleCalibrate(configJoyYChannel%,"volt",1,joystickYOffset);
        
        'Start sampling, sample for about 5 seconds,
        samplemode(1);   'sets continuous recording
        jview% := FileNew(0,1+2+4);
        SampleStart();   'start sampling
        while view(jview%).maxtime() < 5 do
            yield(1);
        wend;
        
        'Get mean X and Y value in currentX, currentY
        currentX := ChanMeasure(configJoyXChannel%,2,0,5);
        currentY := ChanMeasure(configJoyYChannel%,2,0,5);
        
        'Stop sampling
        SampleStop();
        
        'Adjust the offsets
        joystickXOffset := joystickXOffset - currentX;  'Not sure of sign because not sure of "offset" logic.  Test.
        joystickYOffset := joystickYOffset - currentY;
    
        'Save the new offset values
        SaveJoystickOffsets(jt%);
        
        view(jview%);  'bring data window to front to close it
        FileClose(0,-1);  'Close data window without saving
        
    endif;
    
    
    return 1;  'return to toolbar
end;


'================================= Read the Joystick Channel =================================
'this function will read the joystick channel.  Data from the two joystick channels will be moved
'to four level channels in memory, two per axis.  If both levels for an axis read 0, the joystick
'is centered on that axis.  If either reads 1, the joystick is in that position.  If both read 1, 
'this is an error.
func ReadJoystick%()
    
    var Now;								'Gets current time at begining of function execution
    const TALen% := 1000;
    var TimesArrayTemp[TALen%];   'getting rid of "asserted" events
    var TimesArrayRO[TALen%];		'Arrays of event times for each of the eight memory channels
    var TimesArrayLO[TALen%];
    var TimesArrayUO[TALen%];
    var TimesArrayDO[TALen%];
    var TimesArrayRI[TALen%];	
    var TimesArrayLI[TALen%];
    var TimesArrayUI[TALen%];
    var TimesArrayDI[TALen%];
    var TimesArrayAll[8000];
    var NumEventsRO%;		   'How many events were found for the rightward movement channel
    var NumEventsLO%;
    var NumEventsUO%;
    var NumEventsDO%;
    var NumEventsRI%;		   'How many events were found for the centerward (from right) movement channel
    var NumEventsLI%;
    var NumEventsUI%;
    var NumEventsDI%;
    var DebounceTime := 0;     'Debounce over 40 ms, don't know if MemImport expects seconds yet
    'Oh, no, no!  Do not use debounce!  Set to 0!
    var LastEventTime;		   'LastEventTime will correspond to the most recent event, whether it was the X- or Y-axis on the joystick 
    var LastRunTime;           'An attempt to separate the last time it was run from the last time anything real happened
    var temp;
    var temp2;
    var JoystickAfter%[8000];
    var LeverString$;
    var rio%;								'right index, outward
    var lio%;								'left index, outward
    var uio%;								'up index, outward
    var dio%;								'down index, outward
    var rii%;                                'right index, inward
    var lii%;                                'etc.
    var uii%;
    var dii%;
    var ai%;                      'all index, for TimesArrayAll[]
    var ii%;
    var EventCount%;						'total number of events
    var RealEventCount%;                    'total number of events, does not include non-state-changing axis crossings (inner/outer threshold "recrossings" do not change state)
    var IsRealEvent%;                       'If 1, this event is counted in RealEventCount%
    var move%;
    var xmove%;
    var ymove%;
    var xind%:=1;							'"index" into TimesArrayAll for xmoves
    var yind%:=1;							'"index" into TimesArrayAll for ymoves
    var tic;								'A tiny clock increment, kind of a fudge, see note to 1.0.4/1.0.5
    var tic2;
    var tempx;
    var tempy;
    var trash%[4];
    var tempEventTime;
    
    
    
    view(ctview%);
    
    'Set tic value
    tic := SecPerSample;  'This tic prevents us from reading the same event twice
    tic2 := 0.005;  'This tic allows us to grab 5 ms of redundant time - that corresponds to 25 samples of
    'the joystick channels - because threshold crossings were being missed on occasion
    
    'find out what time it is now
    Now := maxtime();
    
    'find most recent time ReadJoystick% was run and most recent event time
    LastRunTime := HoldLastCheckTime;  'LastRunTime updates every call the ReadJoystick, regardless of whether there was a joystick event or not
    LastEventTime := HoldLastEventTime;  
    HoldLastCheckTime := Now;  'Set HoldLastCheckTime for NEXT run of ReadJoystick
    
    if VerboseJoyLev% = 1 then
        view(HiddenLogHandle%).print("LastRunTime is %f and Now is %f\r",LastRunTime,Now);
    endif;
    
    'If we are switching from passive to active mode, there may be too many (over 1000) joystick events.
    'In order to avoid overflowing JoystickAfter%[], just ignore joystick events during passive
    if PassiveToActive% = 1 then  'If we are changing from Passive to Active
        LastEventTime := Now;  'Override HoldLastCheckTime, change to Now, events during Passive will be ignored
        PassiveToActive% := 0;  'reset PassiveToActive%
    endif;
    
    
    'Define events by threshold crossings; Put event times into the eight channels
    MemImport(MemChanJoystickRO%,10,LastRunTime-tic2,Now,3,DebounceTime,-RightThreshOuter);  'Crossing RO thresh going outward
    MemImport(MemChanJoystickLO%,10,LastRunTime-tic2,Now,2,DebounceTime,LeftThreshOuter);    'Crossing LO thresh going outward
    MemImport(MemChanJoystickUO%,11,LastRunTime-tic2,Now,3,DebounceTime,-UpThreshOuter);     'Crossing UO thresh going outward
    MemImport(MemChanJoystickDO%,11,LastRunTime-tic2,Now,2,DebounceTime,DownThreshOuter);    'Crossing DO thresh going outward
    MemImport(MemChanJoystickRI%,10,LastRunTime-tic2,Now,2,DebounceTime,-RightThreshInner);  'Crossing RI thresh going inward
    MemImport(MemChanJoystickLI%,10,LastRunTime-tic2,Now,3,DebounceTime,LeftThreshInner);    'Crossing LI thresh going inward
    MemImport(MemChanJoystickUI%,11,LastRunTime-tic2,Now,2,DebounceTime,-UpThreshInner);     'Crossing UI thresh going inward
    MemImport(MemChanJoystickDI%,11,LastRunTime-tic2,Now,3,DebounceTime,DownThreshInner);    'Crossing DI thresh going inward
    
    'Determine initial joystick location the very first time ReadJoystick is run, per experiment
    if JoystickReadOnce% = 0 then
        JoystickReadOnce% := 1;  'only do this the very first time the joystick is read
        tempx := ChanValue(10,0);  'Put the very first X axis value into tempx
        tempy := ChanValue(11,0);  'Same for Y, tempy
        LastPos% := 0;
        xstat% := 0;
        ystat% := 0;
        if tempx < -RightThreshOuter then
            LastPos% := LastPos% + 2;
            xstat% := 2;
        else
            if tempx < LeftThreshOuter then
                LastPos% := LastPos% + 1;
                xstat% := 1;
            endif;
        endif;
        if tempy < -UpThreshOuter then
            LastPos% := LastPos% + 20;
            ystat% := 20;
        else
            if tempy < DownThreshOuter then
                LastPos% := LastPos% + 10;
                ystat% := 10;
            endif;
        endif;
        printlog("Initial values: x = %f, y = %f, upthreshinner = %f, downthreshinner = %f, leftthreshinner = %f, rightthreshinner = %f\n",tempx,tempy,UpThreshInner,DownThreshInner,LeftThreshInner,RightThreshInner);
        printlog("    upthreshouter = %f, downthreshouter = %f, leftthreshouter = %f, rightthreshouter = %f\n",UpThreshOuter,DownThreshOuter,LeftThreshOuter,RightThreshOuter);
        printlog("Initial joystick position was %d where 20-10-0 is up-center-down and 2-1-0 is right-center-left\n",LastPos%);
        view(HiddenLogHandle%).print("Initial values: x = %f, y = %f, upthreshinner = %f, downthreshinner = %f, leftthreshinner = %f, rightthreshinner = %f\r",tempx,tempy,UpThreshInner,DownThreshInner,LeftThreshInner,RightThreshInner);
        view(HiddenLogHandle%).print("    upthreshouter = %f, downthreshouter = %f, leftthreshouter = %f, rightthreshouter = %f\r",UpThreshOuter,DownThreshOuter,LeftThreshOuter,RightThreshOuter);
        view(HiddenLogHandle%).print("Initial joystick position was %d where 20-10-0 is up-center-down and 2-1-0 is right-center-left\r",LastPos%);
    endif;
    
    'Put recent events into time arrays
    NumEventsRO% := chandata(MemChanJoystickRO%,TimesArrayTemp[],LastEventTime+tic,Now);  'Put recent event times in a temporary array
    arrconst(TimesArrayRO[],TimesArrayTemp[]);  'Move temporary numbers to real array, "asserted" events removed
    NumEventsLO% := chandata(MemChanJoystickLO%,TimesArrayTemp[],LastEventTime+tic,Now);  
    arrconst(TimesArrayLO[],TimesArrayTemp[]);
    NumEventsUO% := chandata(MemChanJoystickUO%,TimesArrayTemp[],LastEventTime+tic,Now);  
    arrconst(TimesArrayUO[],TimesArrayTemp[]);
    NumEventsDO% := chandata(MemChanJoystickDO%,TimesArrayTemp[],LastEventTime+tic,Now);  
    arrconst(TimesArrayDO[],TimesArrayTemp[]);
    NumEventsRI% := chandata(MemChanJoystickRI%,TimesArrayTemp[],LastEventTime+tic,Now);
    arrconst(TimesArrayRI[],TimesArrayTemp[]);
    NumEventsLI% := chandata(MemChanJoystickLI%,TimesArrayTemp[],LastEventTime+tic,Now);  
    arrconst(TimesArrayLI[],TimesArrayTemp[]);
    NumEventsUI% := chandata(MemChanJoystickUI%,TimesArrayTemp[],LastEventTime+tic,Now);  
    arrconst(TimesArrayUI[],TimesArrayTemp[]);
    NumEventsDI% := chandata(MemChanJoystickDI%,TimesArrayTemp[],LastEventTime+tic,Now);  
    arrconst(TimesArrayDI[],TimesArrayTemp[]);
    
    
    'We are getting some frustrating crashes here, and I can't figure out why there should be a problem so I am going to 
    'hit the thing with a big fat hammer and see if I can make it stop.  This is monstruous but I don't have much choice.
    
    'In case the logic isn't clear, here we are asserting a time of 99999999 for the (nonexistent) threshold crossing
    'AFTER the final real crossing we have in the memory channel.  If we did not do this, the value would be zero.  However,
    'then the subsequent line that finds the earliest unprocessed threshold crossing would break once we had exhausted the
    'events in any given channel, because the MIN function would find the min to be 0.  99999999 is safely larger than any
    'possible event time (by a lot) and keeps the MIN function working as expected.
    'Note that if there are too many (over-999) events on a channel we have to decrease the event count or we will
    'loop too long below, and grab a 99999999 - which kills the joystick.
    if NumEventsRO% < 0 then
        TimesArrayRO[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsRO% > TALen%-1 then
            TimesArrayRO[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsRO%;
            NumEventsRO% := TALen%-1;
        else
            TimesArrayRO[NumEventsRO%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    if NumEventsLO% < 0 then
        TimesArrayLO[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsLO% > TALen%-1 then
            TimesArrayLO[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsLO%;
            NumEventsLO% := TALen%-1;
        else
            TimesArrayLO[NumEventsLO%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    if NumEventsUO% < 0 then
        TimesArrayUO[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsUO% > TALen%-1 then
            TimesArrayUO[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsUO%;
            NumEventsUO% := TALen%-1;
        else
            TimesArrayUO[NumEventsUO%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    if NumEventsDO% < 0 then
        TimesArrayDO[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsDO% > TALen%-1 then
            TimesArrayDO[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsDO%;
            NumEventsDO% := TALen%-1;
        else
            TimesArrayDO[NumEventsDO%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    if NumEventsRI% < 0 then
        TimesArrayRI[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsRI% > TALen%-1 then
            TimesArrayRI[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsRI%;
            NumEventsRI% := TALen%-1;
        else
            TimesArrayRI[NumEventsRI%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    if NumEventsLI% < 0 then
        TimesArrayLI[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsLI% > TALen%-1 then
            TimesArrayLI[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsLI%;
            NumEventsLI% := TALen%-1;
        else
            TimesArrayLI[NumEventsLI%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    if NumEventsUI% < 0 then
        TimesArrayUI[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsUI% > TALen%-1 then
            TimesArrayUI[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsUI%;
            NumEventsUI% := TALen%-1;
        else
            TimesArrayUI[NumEventsUI%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    if NumEventsDI% < 0 then
        TimesArrayDI[0] := 99999999;  'If negative value in index would cause crash, just change first value
        NumFoundNegativeIndex% += 1;  'and remember this, report it at the end.
    else
        if NumEventsDI% > TALen%-1 then
            TimesArrayDI[TALen%-1] := 99999999;  'If the value is too large, just change the last value
            NumFoundTooBigIndex% += 1;  'and remember this, report it at the end.
            TooBigIndexValue% := NumEventsDI%;
            NumEventsDI% := TALen%-1;
        else
            TimesArrayDI[NumEventsDI%] := 99999999;  'The index value is OK, do what we expect
        endif;
    endif;
    
    
    'Restore this code if we ever figure out the problem above
    ''put dummy numbers into the first "empty" slot in TimesArrays, necessary for next FOR loop, empty slot can't be 0
    'TimesArrayRO[NumEventsRO%] := 99999999;  'should be sufficiently large to never be the minimum number
    'TimesArrayLO[NumEventsLO%] := 99999999;  
    'TimesArrayUO[NumEventsUO%] := 99999999;
    'TimesArrayDO[NumEventsDO%] := 99999999;
    'TimesArrayRI[NumEventsRI%] := 99999999;
    'TimesArrayLI[NumEventsLI%] := 99999999;
    'TimesArrayUI[NumEventsUI%] := 99999999;
    'TimesArrayDI[NumEventsDI%] := 99999999;
    
    'Get joystick status resulting from each event
    'Go through each event in order that it occurred
    EventCount% := NumEventsRO%+NumEventsLO%+NumEventsUO%+NumEventsDO%+NumEventsRI%+NumEventsLI%+NumEventsUI%+NumEventsDI%;  'removing "asserted" events
    
    for ii% := 1 to EventCount% do  'if EventCount% is 0, loop does not execute, which is perfect
        temp := min(TimesArrayRO[rio%],TimesArrayLO[lio%],TimesArrayUO[uio%],TimesArrayDO[dio%],TimesArrayRI[rii%],TimesArrayLI[lii%],TimesArrayUI[uii%],TimesArrayDI[dii%]);      
        
        IsRealEvent% := 1;  'Assume for now the event is real    
        
        docase
            case temp = TimesArrayRO[rio%] then	  'Crossing RO thresh going outward
            docase
                case xstat% = 0 then  'unexpected - the joystick went from left to right without registering in the center
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Error - x position change (l->r) did not go through center, setting state anyway!\r")
                endif;
                xstat% := 2;  'but set the x state to 2 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayRO[rio%];  'fill TimesArrayAll because it's a real event
                rio% := rio%+1;  'and update both indices
                ai% := ai%+1;  
                case xstat% = 1 then  'center to right movement
                xstat% := 2;
                TimesArrayAll[ai%] := TimesArrayRO[rio%];  'fill TimesArrayAll because it's a real event
                rio% := rio%+1;  'and update both indices
                ai% := ai%+1;
                case xstat% = 2 then  're-crossed threshold without going to center - just ignore 
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick exceeded outer right threshold without going to center!\r")
                endif;
                rio% := rio%+1;  'and update rio% index, or we get stuck here - do not update ai% index
            endcase;
            case temp = TimesArrayLO[lio%] then   'Crossing LO thresh going outward
            docase
                case xstat% = 2 then  'unexpected - the joystick went from right to left without registering in the center
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Error - x position change (r->l) did not go through center, setting state anyway!\r")
                endif;
                xstat% := 0;  'but set the x state to 2 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayLO[lio%];  'fill TimesArrayAll because it's a real event
                lio% := lio%+1;  'and update both indices
                ai% := ai%+1;
                case xstat% = 1 then  'center to leftt movement
                xstat% := 0;
                TimesArrayAll[ai%] := TimesArrayLO[lio%];  'fill TimesArrayAll because it's a real event
                lio% := lio%+1;  'and update both indices
                ai% := ai%+1;
                case xstat% = 0 then  're-crossed threshold without going to center - just ignore
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick exceeded outer left threshold without going to center!\r")
                endif;
                lio% := lio%+1;  'and update lio% index, or we get stuck here - do not update ai% index
            endcase;
            case temp = TimesArrayUO[uio%] then	  'Crossing UO thresh going outward		
            docase
                case ystat% = 0 then  'unexpected - the joystick went from down to up without registering in the center
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Error - y position change (d->u) did not go through center, setting state anyway!\r")
                endif;
                ystat% := 20;  'but set the y state to 2 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayUO[uio%];  'fill TimesArrayAll because it's a real event
                uio% := uio%+1;  'and update both indices
                ai% := ai%+1;
                case ystat% = 10 then  'center to up movement
                ystat% := 20;
                TimesArrayAll[ai%] := TimesArrayUO[uio%];  'fill TimesArrayAll because it's a real event
                uio% := uio%+1;  'and update both indices
                ai% := ai%+1;
                case ystat% = 20 then  're-crossed threshold without going to center - just ignore
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick exceeded outer up threshold without going to center!\r")
                endif;
                uio% := uio%+1;  'and update uio% index, or we get stuck here - do not update ai% index
            endcase;
            case temp = TimesArrayDO[dio%] then   'Crossing DO thresh going outward
            docase
                case ystat% = 20 then  'unexpected - the joystick went from up to down without registering in the center
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Error - y position change (u->d) did not go through center, setting state anyway!\r")
                endif;
                ystat% := 0;  'but set the y state to 2 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayDO[dio%];  'fill TimesArrayAll because it's a real event
                dio% := dio%+1;  'and update both indices
                ai% := ai%+1;
                case ystat% = 10 then  'center to down movement
                ystat% := 0;
                TimesArrayAll[ai%] := TimesArrayDO[dio%];  'fill TimesArrayAll because it's a real event
                dio% := dio%+1;  'and update both indices
                ai% := ai%+1;
                case ystat% = 0 then  're-crossed threshold without going to center - just ignore
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick exceeded outer down threshold without going to center!\r")
                endif;
                dio% := dio%+1;  'and update dio% index, or we get stuck here - do not update ai% index
            endcase;
            case temp = TimesArrayRI[rii%] then   'Crossing RI thresh going inward
            docase
                case xstat% = 0 then  'highly unexpected - the joystick went from left to crossing a right threshold towards the left
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("VERY MAJOR Error - x position change (r->c) started from left, setting state anyway!\r")
                endif;
                xstat% := 1;  'but set the x state to 1 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayRI[rii%];  'fill TimesArrayAll because it's a real event
                rii% := rii%+1;  'and update both indices
                ai% := ai%+1;
                case xstat% = 1 then  're-crossed threshold without leaving center - just ignore
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick recrossed inner right threshold without going fully right!\r")
                endif;
                rii% := rii%+1;  'and update rii% index, or we get stuck here - do not update ai% index
                case xstat% = 2 then  'right to center movement 
                xstat% := 1;
                TimesArrayAll[ai%] := TimesArrayRI[rii%];  'fill TimesArrayAll because it's a real event
                rii% := rii%+1;  'and update both indices
                ai% := ai%+1;
            endcase;
            case temp = TimesArrayLI[lii%] then   'Crossing LI thresh going inward
            docase
                case xstat% = 2 then  'highly unexpected - the joystick went from right to crossing a left threshold towards the right
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("VERY MAJOR Error - x position change (l->c) started from right, setting state anyway!\r")
                endif;
                xstat% := 1;  'but set the x state to 1 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayLI[lii%];  'fill TimesArrayAll because it's a real event
                lii% := lii%+1;  'and update both indices
                ai% := ai%+1;
                case xstat% = 1 then  're-crossed threshold without leaving center - just ignore
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick recrossed inner left threshold without going fully left!\r")
                endif;
                lii% := lii%+1;  'and update lii% index, or we get stuck here - do not update ai% index
                case xstat% = 0 then  'left to center movement 
                xstat% := 1;
                TimesArrayAll[ai%] := TimesArrayLI[lii%];  'fill TimesArrayAll because it's a real event
                lii% := lii%+1;  'and update both indices
                ai% := ai%+1;
            endcase;
            case temp = TimesArrayUI[uii%] then   'Crossing UI thresh going inward
            docase
                case ystat% = 0 then  'highly unexpected - the joystick went from down to crossing an up threshold downwards
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("VERY MAJOR Error - y position change (u->c) started from down, setting state anyway!\r")
                endif;
                ystat% := 10;  'but set the y state to 1 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayUI[uii%];  'fill TimesArrayAll because it's a real event
                uii% := uii%+1;  'and update both indices
                ai% := ai%+1;
                case ystat% = 10 then  're-crossed threshold without leaving center - just ignore
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick recrossed inner up threshold without going fully up!\r")
                endif;
                uii% := uii%+1;  'and update uii% index, or we get stuck here - do not update ai% index
                case ystat% = 20 then  'up to center movement 
                ystat% := 10;
                TimesArrayAll[ai%] := TimesArrayUI[uii%];  'fill TimesArrayAll because it's a real event
                uii% := uii%+1;  'and update both indices
                ai% := ai%+1;
            endcase;
            case temp = TimesArrayDI[dii%] then  'Crossing DI thresh going inward
            docase
                case ystat% = 20 then  'highly unexpected - the joystick went from up to crossing a down threshold upwards
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("VERY MAJOR Error - y position change (d->c) started from up, setting state anyway!\r")
                endif;
                ystat% := 10;  'but set the y state to 1 anyway, because that's where it is
                TimesArrayAll[ai%] := TimesArrayDI[dii%];  'fill TimesArrayAll because it's a real event
                dii% := dii%+1;  'and update both indices
                ai% := ai%+1;
                case ystat% = 10 then  're-crossed threshold without leaving center - just ignore
                IsRealEvent% := 0;  'This is not a real event after all, correct for earlier assertion
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Joystick recrossed inner down threshold without going fully down!\r")
                endif;
                dii% := dii%+1;  'and update dii% index, or we get stuck here - do not update ai% index
                case ystat% = 0 then  'down to center movement 
                ystat% := 10;
                TimesArrayAll[ai%] := TimesArrayDI[dii%];  'fill TimesArrayAll because it's a real event
                dii% := dii%+1;  'and update both indices
                ai% := ai%+1;
            endcase;
        else
            if VerboseJoyLev% = 1 then
                view(HiddenLogHandle%).print("Error in ReadJoystick% - event time does not correspond to known event!\r");
            endif;
        endcase;
        if IsRealEvent% = 1 then  'we are definitely getting excessive counts of IsRealEvent when doing a passive/active
            'switch when Udon has the joystick...is it checking joystick position during passive?
            RealEventCount% := RealEventCount% + 1;  'increment count of real events
            if RealEventCount% > 8000 then
                view(HiddenLogHandle%).print("RealEventCount has reached %d, crash imminent!\r",RealEventCount%);
            endif
            JoystickAfter%[RealEventCount%-1] := xstat% + ystat%;  'holds a code indicating joystick position:
            '0 = down/left;  1 = down/middle;  2 = down/right
            '10 = middle/left;  11 = middle/middle;  12 = middle/right
            '20 = up/left;  21 = up/middle;  22 = up/right
            if VerboseJoyLev% = 1 then
                view(HiddenLogHandle%).print("JoystickAfter set to %d\r",JoystickAfter%[RealEventCount%-1]);
            endif;
        endif;
    next;
    
    'Attempt to fix over-999 error (one of several) - allow last event time to include "not real events"
    'It would appear that we may be duplicating not-real events, which contributes to the problem
    if EventCount% > 0 then
        HoldLastEventTime := temp;  'if the above FOR ran, temp will hold the last event, real or not.   
    endif;
    
    'Put events in memory channel if they exist and change LeverInitTime/LeverResponseTime/LeverInit%/LeverResponse%	
    if RealEventCount% > 0 then	
        
        if VerboseJoyLev% = 1 then
            for ii% := 0 to 4 do  'this lists first five entries from TimesArrayAll for reference, regardless of how many there are
                view(HiddenLogHandle%).print("Entry %d in TimesArrayAll is %f\r",ii%,TimesArrayAll[ii%]);
            next;
        endif;
        for ii% := 0 to RealEventCount%-1 do
            LeverCodes%[0] := LastPos%;
            LeverCodes%[1] := JoystickAfter%[ii%];
            docase
                case JoystickAfter%[ii%] = 22 and LastPos% = 21 then
                LeverString$ := "X Center to Right (Y Up)";
                move% := 1;
                case JoystickAfter%[ii%] = 21 and LastPos% = 22 then
                LeverString$ := "X Right to Center (Y Up)";
                move% := -1;
                case JoystickAfter%[ii%] = 12 and LastPos% = 11 then
                LeverString$ := "X Center to Right (Y Middle)";
                move% := 1;
                case JoystickAfter%[ii%] = 11 and LastPos% = 12 then
                LeverString$ := "X Right to Center (Y Middle)";
                move% := -1;
                case JoystickAfter%[ii%] = 2 and LastPos% = 1 then
                LeverString$ := "X Center to Right (Y Down)";
                move% := 1;
                case JoystickAfter%[ii%] = 1 and LastPos% = 2 then
                LeverString$ := "X Right to Center (Y Down)";
                move% := -1;
                case JoystickAfter%[ii%] = 20 and LastPos% = 21 then
                LeverString$ := "X Center to Left (Y Up)";
                move% := 2;
                case JoystickAfter%[ii%] = 21 and LastPos% = 20 then
                LeverString$ := "X Left to Center (Y Up)";
                move% := -2;
                case JoystickAfter%[ii%] = 10 and LastPos% = 11 then
                LeverString$ := "X Center to Left (Y Middle)";
                move% := 2;
                case JoystickAfter%[ii%] = 11 and LastPos% = 10 then
                LeverString$ := "X Left to Center (Y Middle)";
                move% := -2;
                case JoystickAfter%[ii%] = 0 and LastPos% = 1 then
                LeverString$ := "X Center to Left (Y Down)";
                move% := 2;
                case JoystickAfter%[ii%] = 1 and LastPos% = 0 then
                LeverString$ := "X Left to Center (Y Down)";
                move% := -2;
                case JoystickAfter%[ii%] = 22 and LastPos% = 12 then
                LeverString$ := "Y Middle to Up (X Right)";
                move% := 3;
                case JoystickAfter%[ii%] = 12 and LastPos% = 22 then
                LeverString$ := "Y Up to Middle (X Right)";
                move% := -3;
                case JoystickAfter%[ii%] = 21 and LastPos% = 11 then
                LeverString$ := "Y Middle to Up (X Center)";
                move% := 3;
                case JoystickAfter%[ii%] = 11 and LastPos% = 21 then
                LeverString$ := "Y Up to Middle (X Center)";
                move% := -3;
                case JoystickAfter%[ii%] = 20 and LastPos% = 10 then
                LeverString$ := "Y Middle to Up (X Left)";
                move% := 3;
                case JoystickAfter%[ii%] = 10 and LastPos% = 20 then
                LeverString$ := "Y Up to Middle (X Left)";
                move% := -3;
                case JoystickAfter%[ii%] = 2 and LastPos% = 12 then
                LeverString$ := "Y Middle to Down (X Right)";
                move% := 4;
                case JoystickAfter%[ii%] = 12 and LastPos% = 2 then
                LeverString$ := "Y Down to Middle (X Right)";
                move% := -4;
                case JoystickAfter%[ii%] = 1 and LastPos% = 11 then
                LeverString$ := "Y Middle to Down (X Center)";
                move% := 4;
                case JoystickAfter%[ii%] = 11 and LastPos% = 1 then
                LeverString$ := "Y Down to Middle (X Center)";
                move% := -4;
                case JoystickAfter%[ii%] = 0 and LastPos% = 10 then
                LeverString$ := "Y Middle to Down (X Left)";
                move% := 4;
                case JoystickAfter%[ii%] = 10 and LastPos% = 0 then
                LeverString$ := "Y Down to Middle (X Left)";
                move% := -4;
            else
                if VerboseJoyLev% = 1 then
                    view(HiddenLogHandle%).print("Error! JoystickAfter (%d) and LastPos (%d) do not correspond to any known combo!\r",JoystickAfter%[ii%],LastPos%);
                endif;
            endcase;
            if move% > 2 or move% < -2 then  'if it was a move in the Y direction
                ymove% := move%;  'set ymove% to most recent move in Y direction
                yind% := 1;  'set yind% to 1 because y was the last direction moved
                xind% := xind% + 1;  'Increment xind% by 1 - will hold the number of ymoves since the last xmove, plus 1
            else
                if move% < 3 and move% > -3 then  'do opposite
                    xmove% := move%;
                    xind% := 1;
                    yind% := yind% + 1;
                else
                    xind% := xind% + 1;  'increment both if the move was "unexplained"
                    yind% := yind% + 1;
                endif;
            endif;
            LastPos% := JoystickAfter%[ii%];  'Update LastPos%
            if TimesArrayAll[ii%] > Now then 'This is a hack to try to prevent the script from putting in a memory item at a too-large time
                tempEventTime := TimesArrayAll[ii%-1]+tic;  'don't know what to use, this should in principle keep it at about the right time
            else
                tempEventTime := TimesArrayAll[ii%];
            endif;
            view(ctview%).MemSetItem(MemChanJoystick%,0,tempEventTime,LeverCodes%[],LeverString$);
            'view(ctview%).MemSetItem(MemChanJoystick%,0,TimesArrayAll[ii%],LeverCodes%[],LeverString$);
        next;
        
        'return most recent event and value
        docase
            case xmove% = 1 then						
            XPos% := 1;  '1 for right joystick
            XTime := TimesArrayAll[ii%-xind%];  'ii% is incremented by the for loop as loop exits
            case xmove% = 2 then
            XPos% := 2;  '2 for left joystick
            XTime := TimesArrayAll[ii%-xind%];
            case xmove% = -1 or xmove% = -2 then
            XPos% := 0;  '0 for centering joystick
            XTime := TimesArrayAll[ii%-xind%];
        endcase;
        docase
            case ymove% = 3 then
            YPos% := 1;  '1 for up joystick
            YTime := TimesArrayAll[ii%-yind%];
            case ymove% = 4 then
            YPos% := 2;  '2 for down joystick
            YTime := TimesArrayAll[ii%-yind%];
            case ymove% = -3 or ymove% = -4 then
            YPos% := 0;  '0 for centering joystick
            YTime := TimesArrayAll[ii%-yind%];
        endcase;
        
        'update LastEventTime to that of the last real event
        'In an attempt to fix the over-999 error, HoldLastEventTime now gets the time of the last event, real or not
'        if XTime > YTime then
'            HoldLastEventTime := XTime;
'        else
'            HoldLastEventTime := YTime;
'        endif;
        
    else  'if there are no real events
        if Now - HoldLastEventTime > 10 then 'if there have been no "real" events in the last 10 seconds
            HoldLastEventTime := Now - 10;  'Update HoldLastEventTime so that we only check for events within
            'the last 10 seconds on the next go-around.  This should hopefully
            'solve the buffer overflow problems we are having.
        endif;
        
        
    endif;	'end "if there is a joystick event"	
    
    'Finish up
    AssignJoystickVariables();
    
    if VerboseJoyLev% = 1 then
        view(HiddenLogHandle%).print("TrialInit% is %d, XPos% is %d, YPos% is %d\r",TrialInit%,XPos%,YPos%);
    endif;
    
    return 1;
end;





'========================= Given Joystick Position, Determine IN_ORIGIN, etc. ======================
'Once XPos% and YPos% are known, we need to decide whether the joystick is in the origin, in a response
'position, etc.  This depends on which "joystick device" is being used.
'This code is now farmed out to a subfunction because it has to be done twice.
proc AssignJoystickVariables()
    
    'Indicate whether joystick is in the origin
    if XPos% + YPos% = 0 then
        InOrigin% := 1;
    else
        InOrigin% := 0;
    endif;
    
    'Get TrialInit, TrialResponse, OffAxis, ResponseTime for all cases
    docase
        case RespDevice% = 1 then  '"Joystick"(l/r init, up/down response)
        'Indicate whether joystick is in trial initiation position
        if XPos% > 0 then
            TrialInit% := 1;
        else
            TrialInit% := 0;
        endif;
        
        'Indicate whether joystick is in trial response position
        if YPos% > 0 then
            TrialResponse% := 1;
            ResponseTime := YTime;
        else
            TrialResponse% := 0;
        endif;
        
        'Indicate whether joystick has moved in "off" (non-trial-init) axis
        if YPos% > 0 then
            OffAxis% := 1;
        else
            OffAxis% := 0;
        endif;
        
        case RespDevice% = 2 then  '"JoystickLR"(u/d init, left/right response)
        'Indicate whether joystick is in trial initiation position
        if YPos% > 0 then
            TrialInit% := 1;
        else
            TrialInit% := 0;
        endif;
        
        'Indicate whether joystick is in trial response position
        if XPos% > 0 then
            TrialResponse% := 1;
            ResponseTime := XTime;
        else
            TrialResponse% := 0;
        endif;
        
        'Indicate whether joystick has moved in "off" (non-trial-init) axis
        if XPos% > 0 then
            OffAxis% := 1;
        else
            OffAxis% := 0;
        endif;
        ''''''    implement in the future, if necessary
        '    case RespDevice% = 3 then '"JoystickUDC" (new device, l/r init, up/down/center response
        '        'Indicate whether joystick is in trial initiation position
        '        if XPos% > 0 then
        '            TrialInit% := 1;
        '        else
        '            TrialInit% := 0;
        '        endif;
        '        
        '        'Indicate whether joystick is in trial response position
        '        if YPos% > 0 then  'either move on the y-axis is a response
        '            TrialResponse% := 1;
        '            ResponseTime := YTime;
        '        else
        '            if XPos% = 0 then  'centering on the x-axis is also a response
        '                TrialResponse% := 1;
        '                ResponseTime := XTime;
        '            else
        '                TrialResponse% := 0;
        '            endif;
        '        endif;
        '        
        '        'Indicate whether joystick has moved in "off" (non-trial-init) axis
        '        if YPos% > 0 then
        '            OffAxis% := 1;
        '        else
        '            OffAxis% := 0;
        '        endif;
        
        case RespDevice% = -1 then  '"JoystickAsLever"
        'Indicate whether joystick is in trial initiation position
        if Ypos% = 2 then
            TrialInit% := 1;
        else
            TrialInit% := 0;
        endif;
        
        'Indicate whether joystick is in trial response position
        if YPos% = 0 then  
            TrialResponse% := 1;
            ResponseTime := YTime;
        else
            TrialResponse% := 0;
        endif;
        
        'Indicate whether joystick has moved in "off" (non-trial-init) axis
        if XPos% > 0 and OneAxis% = 0 then  'if OneAxis% is 1, do not interrupt for off-axis
            OffAxis% := 1;
        else
            OffAxis% := 0;
        endif;
        
        case RespDevice% = -2 then  '"DownUpJoystick"
        'Indicate whether joystick is in trial initiation position
        if Ypos% = 2 then
            TrialInit% := 1;
        else
            TrialInit% := 0;
        endif;
        
        'Indicate whether joystick is in trial response position
        if YPos% = 1 then  
            TrialResponse% := 1;
            ResponseTime := YTime;
        else
            TrialResponse% := 0;
        endif;
        
        'Indicate whether joystick has moved in "off" (non-trial-init) axis
        if XPos% > 0 and OneAxis% = 0 then  'if OneAxis% is 1, do not interrupt for off-axis
            OffAxis% := 1;
        else
            OffAxis% := 0;
        endif;
        
        case RespDevice% = -3 then  '"JoystickAsLeverLR" - moving lever L/R inititates trial, response is to center
        'Indicate whether joystick is in trial initiation position
        if Xpos% > 0 then
            TrialInit% := 1;
        else
            TrialInit% := 0;
        endif;
        
        'Indicate whether joystick is in trial response position
        if XPos% = 0 then  
            TrialResponse% := 1;
            ResponseTime := XTime;
        else
            TrialResponse% := 0;
        endif;
        
        'Indicate whether joystick has moved in "off" (non-trial-init) axis
        if YPos% > 0 and OneAxis% = 0 then  'if OneAxis% is 1, do not interrupt for off-axis
            OffAxis% := 1;
        else
            OffAxis% := 0;
        endif;
        
        case RespDevice% = -4 then  '"MonoJoystickFRUD" - moving lever L/R inititates trial, response is up or down
        'Indicate whether joystick is in trial initiation position
        if Xpos% > 0 then
            TrialInit% := 1;
        else
            TrialInit% := 0;
        endif;
        
        'Indicate whether joystick is in trial response position
        if YPos% > 0 then  
            TrialResponse% := 1;
            ResponseTime := YTime;
        else
            TrialResponse% := 0;
        endif;
        
        'Indicate whether joystick has moved in "off" (non-trial-init) axis
        if YPos% > 0 and OneAxis% = 0 then  'if OneAxis% is 1, do not interrupt for off-axis
            OffAxis% := 1;
        else
            OffAxis% := 0;
        endif;        
        
    endcase;
    
end;
'========================= Calculate Current Response Bias ===========================
'This function will calculate the current experiment-wide bias rate based on the given hit and false alarm
'rates.  For a go/no-go experiment, positive values will indicate bias for "go" response and negative values
'will indicate bias fo "no-go" response.  For a forced-choice experiment, the false alarm rate is equivalent
'to the miss rate in the opposite stimulus condition (e.g. hit stimulus up, miss stimulus down), a positive
'value indicates bias towards the "hit" (e.g. "up") stimulus and a negative value indicates a bias toward the
'"miss" (e.g. "down") stimulus.  N is the number of trials over which the HitRate and FARate are calculated
proc GetResponseBias(HitRate,FARate,nHit,nFA)
    
    'var ZScoreCumSum2[699];  'Create these three variables so that we don't manipulate the ones we loaded at
    'var ZScoreCumSum3[699];  'the beginning of the program
    'var ZScoreXax2[699];
    var HitZ;                'To hold the hit rate
    var FAZ;                 'To hold the FA rate
    
    'Adjust hit rate/FA rate for number of trials
    'This is being done because of a window size/ceiling problem.  For small windows, the probability of a 100%
    'hit rate (or FA rate) is not terribly bad.  This, however, gets into the extremes of the ZScore distribution
    'and can cause very large bias corrections.  Furthermore, the difference between a hit rate of 7/8 and a hit
    'rate of 8/8 is very large in terms of ZScore result.  Thus, for a 15-trial window (admittedly small), a bias
    'term which seems reasonable when the hit rate is 7/8 can become extreme when that one miss drops off and the
    'hit rate becomes 8/8, leading to instant and wacky changes in bias and reward size.  This was previously fixed
    'via a taper window, but this still implicitly relied on the fact that all trials on that day were being used 
    '(rather than a smaller window of data).  Once windows got smaller (which is actually a good thing to do as
    'the response history ought to have a limited "memory") some ugliness was allowed to appear.  This code fixes 
    'that ugliness, by clamping the HitRate and FARate based on the number of trials that are being used to calculate
    'them.  In essence, it forces Hit and FA rates to be the less extreme of 1) the actual value, and 2) either
    'n/(n+1) at the high end or 1/(n+1) on the low end.  Metaphorically, this means the "last miss" can never drop
    'off of the history.
    HitRate := min(nHit/(nHit+1),HitRate);
    HitRate := max(1/(nHit+1),HitRate);
    FARate := min(nFA/(nFA+1),FARate);
    FARate := max(1/(nFA+1),FARate);
        
    HitZ := zScore(HitRate);
    FAZ := zScore(FARate);
    
    ResponseBias := (HitZ+FAZ)/2;
    
    
end;
'========================= Calculate the Correct Pay Value =============================
'With the addition of the response bias measure, it is possible to manipulate the pay value according to the
'response bias, with the intent of "rewarding" the direction which has been biased against.  For all pay values
'which are to be modified by bias, this function will return the correct value.  Note that if DoResponseBias is
'not set to 1, SolenoidOpenDur% will be set to PayIn.  
func CalcPayVal%(PayIn,BiasDir)
    
    'Currently, I am only using this method for Hit values, because we are not really giving rewards 
    'on Misses (though that ability is present).  The logic might need to be different on Misses, but
    'I'm not even bothering to think about that right now.
    
    'The basic idea here is to cap the change of the pay value between 1/4 and 7/4 of the original value
    'We will want to use an exponential curve instead of a linear one, because we don't want to make big
    'changes if there isn't much bias, and we will also taper the pay value changes in - we don't want big
    'changes in the pay value as a result of early-session, low-n bias values.  Accordingly, the exponential
    'curve is tapered by a linear ramp of (currently) 100 trials.
    'BiasDir is positive if the value being changed is in the "positive" bias direction ("go", "up", "right")
    
    
    var BiasTemp;
    var DeltaTemp;
    var TrialCount;   'local float version
    var BiasTaper;       'local float version
    var SolenoidOpenDur; 'local float version
    
    
    if DoResponseBias% < 1 or ResponseBias = 0 then  'if we're not doing response bias, or the bias is exactly zero
        return PayIn;  'just return the input value
    else
        BiasTemp := ResponseBias;      'copy ResponseBias to Bias Temp
        'BiasTemp := BiasTemp/BiasMax;  'Get ratio of bias to maximum bias
        'BiasTemp := Abs(BiasTemp);     'Take absolute value, we will check sign of ResponseBias when needed
        'BiasTemp := min(BiasTemp,1);   'This will cap bias at BiasMax, BiasTemp ranges between 0-1
        'I don't follow that above stuff
        BiasTemp := Abs(BiasTemp);
        BiasTemp := min(BiasTemp,BiasMax);  'How about that.  That works.
        'BiasTemp := BiasTemp*BiasTemp; 'Square BiasTemp to steepen the exponential curve, for now, let's NOT do this.
        BiasTemp := Pow(4,BiasTemp);   'Raise 4 to the BiasTemp power, value is between 1-4
        BiasTemp := BiasTemp - 1;      'Now, value is between 0-3
        if TrialCount% < BiasTaper% then
            TrialCount := TrialCount%;  'Fill local float variables for math
            BiasTaper := BiasTaper%;
            BiasTemp := BiasTemp*TrialCount;  'Multiply the 0-3 bias term by total # of stimuli
            BiasTemp := BiasTemp/BiasTaper;      'And divide by the number of stimuli to taper over, giving linear reduction in BiasTemp 
        endif;
        SolenoidOpenDur := PayIn;  'Fill local float
        DeltaTemp := PayIn;        'And again
        DeltaTemp := DeltaTemp*BiasTemp;  'Multiply by the taper value (0-3)
        DeltaTemp := DeltaTemp/4;   'and divide by 4 - this value is now a max of 3/4 of PayIn% and the value to be added/subtracted 
        if ResponseBias > 0 then  'if bias is in "go", "up", "right" direction
            if BiasDir > 0 then   
                SolenoidOpenDur := SolenoidOpenDur - DeltaTemp;  'Decrease reward if response is in direction of bias 
            else
                SolenoidOpenDur := SolenoidOpenDur + DeltaTemp;  'Increase reward if response is in opposite direction 
            endif;
        else  'if bias is in "no-go", "down", "left" direction
            if BiasDir < 0 then
                SolenoidOpenDur := SolenoidOpenDur - DeltaTemp;  'Decrease reward if response is in direction of bias 
            else
                SolenoidOpenDur := SolenoidOpenDur + DeltaTemp;  'Increase reward if response is in opposite direction 
            endif;
        endif;
        return SolenoidOpenDur;  'Return the recalculated value
        if VerboseAccuracy% = 1 then
            printlog("Original pay value is %f and bias-adjusted pay value is %f\n",PayIn,SolenoidOpenDur);
        endif;
    endif;
    
end;


'========================= Check Initial Values for Continuous Reinforcment ======================
'This function compares the x/y positions of the joystick to the required conditions for initiation
'and returns 1 if the CR trial is initiated, 0 if nothing, and -1 if interrupt (any "non-initating" move)
func CRinit%(init$)
    
    docase
        case init$ = "x" then
        if YPos% > 0 then
            return -1;  'interrupt
        endif;
        if XPos% > 0 then
            CRInitPos% := XPos%;  'keep track of which direction was the initiation direction for generic x
            return 1; 'initiated
        else
            return 0; 'no movement yet
        endif;
        case init$ = "y" then
        if XPos% > 0 then
            return -1;  'interrupt
        endif;
        if YPos% > 0 then
            CRInitPos% := YPos%;  'keep track of which direction was the initiation direction for generic y
            return 1; 'initiated
        else
            return 0; 'no movement yet
        endif;
        case init$ = "left" then
        if XPos% = 2 then
            return 1; 'initiated
        endif;
        if XPos% = 0 and YPos% = 0 then
            return 0; 'no movement yet
        else
            return -1; 'interrupt
        endif;
        case init$ = "right" then
        if XPos% = 1 then
            return 1; 'initiated
        endif;
        if XPos% = 0 and YPos% = 0 then
            return 0; 'no movement yet
        else
            return -1; 'interrupt
        endif;
        case init$ = "down" then
        if YPos% = 2 then
            return 1; 'initiated
        endif;
        if XPos% = 0 and YPos% = 0 then
            return 0; 'no movement yet
        else
            return -1; 'interrupt
        endif;
        case init$ = "up" then
        if YPos% = 1 then
            return 1; 'initiated
        endif;
        if XPos% = 0 and YPos% = 0 then
            return 0; 'no movement yet
        else
            return -1; 'interrupt
        endif;
    endcase;
    
end



'======================= Check On-axis Interrupt for Continuous Reinforcement ==================
'This function is used once the CR trial has begun, and checks if the joystick leaves the init 
'position on-axis earlier than allowed.  If so, returns 1 for interrupt, otherwise returns 0
func CRintonaxis%(init$)
    
    docase
        case init$ = "x" then
        if XPos% <> CRInitPos% then
            return 1; 'interrupt
        else
            return 0; 'still in init position
        endif;        
        case init$ = "y" then
        if YPos% <> CRInitPos% then
            return 1; 'interrupt
        else
            return 0; 'still in init position
        endif;           
        case init$ = "left" then
        if XPos% <> 2 then
            return 1; 'interrupt
        else
            return 0; 'still in init position
        endif;
        case init$ = "right" then
        if XPos% <> 1 then
            return 1; 'interrupt
        else
            return 0; 'still in init position
        endif;   
        case init$ = "down" then
        if YPos% <> 2 then
            return 1; 'interrupt
        else
            return 0; 'still in init position
        endif;
        case init$ = "up" then
        if YPos% <> 1 then
            return 1; 'interrupt
        else
            return 0; 'still in init position
        endif;
    endcase;
    
end


'======================= Check Off-axis Interrupt for Continuous Reinforcement ==================
'This function is used once the CR trial has begun, and checks if the joystick leaves the center 
'position off-axis earlier than allowed.  If so, returns 1 for interrupt, otherwise returns 0
func CRintoffaxis%(init$)
    
    if init$ = "x" or init$ = "left" or init$ = "right" then  'anything x axis
        if YPos% > 0 then
            return 1;  'interrupt
        else
            return 0;  'still in center off-axis
        endif;
    else  'anything y axis
        if XPos% > 0 then
            return 1;  'interrupt
        else
            return 0;  'still in center off axis
        endif;
    endif;
    
    
end



'======================== Check for end of Continuous Reinforcement Trial ========================
'This function is used to look for the end conditions of a continuous reinforcement trial.  If the joystick
'is in the end position, returns 1; if the joystick is moved on the incorrect axis, returns -1 for interrupt;
'if the joystick hasn't moved, or hasn't moved far enough, returns 0
func CRend%(init$,endpos$,StillWaiting%)
    
    'the StillWaiting% variable is required for the addition of the "same" end position.  Set to 1 only while 
    'waiting for the end of the delay period and checking for interrupt.  If the joystick is in the correct position
    'but not enough time has elapsed, CRend% will return 0 (no action) instead of 1 (in end position) because
    'the latter is interpreted as an interrupt.
    
    docase
        case init$ = "x" then
        docase 
            case endpos$ = "return" then
            if YPos% > 0 then
                return -1;  'interrupt
            endif;
            if XPos% = 0 then
                return 1;  'joystick in end position
            endif
            if XPos% <> CRInitPos% then
                return -1;  'joystick has crossed center to other side
            else
                return 0;  'nothing happened yet
            endif;
            case endpos$ = "up" then
            if XPos% <> CRInitPos% or YPos% = 2 then
                return -1;  'interrupt
            endif;
            if YPos% = 1 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet
            endif;
            case endpos$ = "down" then
            if XPos% <> CRInitPos% or YPos% = 1 then
                return -1;  'interrupt
            endif;
            if YPos% = 2 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet
            endif;
            case endpos$ = "same" then
            if XPos% <> CRInitPos% or YPos% > 0 then
                return -1;   'interrupt
            endif;
            if XPos% = CRInitPos% then
                if StillWaiting% = 0 then
                    return 1;  'joystick in end position, CR is done
                else
                    return 0;  'Still waiting for delay to elapse, do not consider joystick in end position
                endif;
            endif;
        endcase;    
        case init$ = "y" then
        docase 
            case endpos$ = "return" then
            if XPos% > 0 then
                return -1;  'interrupt
            endif;
            if YPos% = 0 then
                return 1;  'joystick in end position
            endif
            if YPos% <> CRInitPos% then
                return -1;  'joystick has crossed center to other side
            else
                return 0;  'nothing happened yet
            endif;
            case endpos$ = "right" then
            if YPos% <> CRInitPos% or XPos% = 2 then
                return -1;  'interrupt
            endif;
            if XPos% = 1 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet, assumes no center crossing in 8-40 ms
            endif;
            case endpos$ = "left" then
            if YPos% <> CRInitPos% or XPos% = 1 then
                return -1;  'interrupt
            endif;
            if XPos% = 2 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet, assumes no center crossing in 8-40 ms
            endif;
            case endpos$ = "same" then
            if YPos% <> CRInitPos% or XPos% = 1 then
                return -1;   'interrupt
            endif;
            if YPos% = CRInitPos% then
                if StillWaiting% = 0 then
                    return 1;  'joystick remains in end position
                else
                    return 0;  'Still waiting for delay to elapse, do not consider joystick in end position
                endif;
            endif;
        endcase;
        case init$ = "up" or init$ = "down" then
        docase
            case endpos$ = "return" then
            if XPos% > 0 then
                return -1;  'interrupt
            endif;
            if YPos% = 0 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet, assumes no center crossing
            endif;
            case endpos$ = "left" then
            if YPos% = 0 or XPos% = 1 then
                return -1;  'interrupt
            endif;
            if XPos% = 2 then
                return 1;  'joystick in end position
            else
                return 0;  'Nothing happened yet
            endif;
            case endpos$ = "right" then
            if YPos% = 0 or XPos% = 2 then
                return -1;  'interrupt
            endif;
            if XPos% = 1 then
                return 1;  'joystick in end position
            else
                return 0;  'Nothing happened yet
            endif; 
            case init$ = "up" and endpos$ = "down" then
            if XPos% > 0 then
                return -1;  'interrupt
            endif;
            if YPos% = 2 then
                return 1;  'joystick in end position
            else
                return 0;  'Nothing happened yet
            endif;
            case init$ = "down" and endpos$ = "up" then
            if XPos% > 0 then
                return -1;  'interrupt
            endif;
            if YPos% = 1 then
                return 1;  'joystick in end position
            else
                return 0;  'Nothing happened yet
            endif;
            case init$ = "up" and endpos$ = "up" then
            if XPos% > 0  or YPos% <> 1 then
                return -1;  'interrupt
            endif;
            if YPos% = 1 then
                if StillWaiting% = 0 then
                    return 1;  'joystick remains in end position
                else
                    return 0;  'Still waiting for delay to elapse, do not consider joystick in end position
                endif;
            endif;
            case init$ = "down" and endpos$ = "down" then
            if XPos% > 0  or YPos% <> 2 then
                return -1;  'interrupt
            endif;
            if YPos% = 2 then
                if StillWaiting% = 0 then
                    return 1;  'joystick remains in end position
                else
                    return 0;  'Still waiting for delay to elapse, do not consider joystick in end position
                endif;
            endif;
        endcase;
        case init$ = "left" or init$ = "right" then
        docase
            case endpos$ = "return" then
            if YPos% > 0 then
                return -1;  'interrupt
            endif;
            if XPos% = 0 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet, assumes no cetner crossing
            endif;
            case endpos$ = "up" then
            if XPos% = 0 or YPos% = 2 then
                return -1;  'interrupt
            endif;
            if YPos% = 1 then
                return 1;  'joystick in end position
            else
                return 0;  'Nothing happened yet
            endif;
            case endpos$ = "down" then
            if XPos% = 0 or YPos% = 1 then
                return -1;  'interrupt
            endif;
            if YPos% = 2 then
                return 1;  'joystick in end position
            else
                return 0;  'Nothing happened yet
            endif; 
            case init$ = "left" and endpos$ = "right" then
            if YPos% > 0 then
                return -1;  'interrupt
            endif;
            if XPos% = 1 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet, assumes no cetner crossing
            endif;
            case init$ = "right" and endpos$ = "left" then
            if YPos% > 0 then
                return -1;  'interrupt
            endif;
            if XPos% = 2 then
                return 1;  'joystick in end position
            else
                return 0;  'nothing happened yet, assumes no cetner crossing
            endif;
            case init$ = "right" and endpos$ = "right" then
            if YPos% > 0  or XPos% <> 1 then
                return -1;  'interrupt
            endif;
            if XPos% = 1 then
                if StillWaiting% = 0 then
                    return 1;  'joystick remains in end position
                else
                    return 0;  'Still waiting for delay to elapse, do not consider joystick in end position
                endif;
            endif;
            case init$ = "left" and endpos$ = "left" then
            if YPos% > 0  or XPos% <> 2 then
                return -1;  'interrupt
            endif;
            if XPos% = 2 then
                if StillWaiting% = 0 then
                    return 1;  'joystick remains in end position
                else
                    return 0;  'Still waiting for delay to elapse, do not consider joystick in end position
                endif;
            endif;
        endcase; 
    endcase;
    
end

'=========================== Update Online Files Safely ==============================
'This function is designed to allow both Spike2 and an external program (typically Matlab)
'to both be able to access, read (and write to) the same files without causing any access
'violations, etc.  The Matlab access script must also include a mirror of SafeUpdate().
'Here we check for the existence of the file "matlab_done.txt" by attempting to delete it.  
'If the file was present, Matlab is not accessing the IDX and SPK files, so we can update 
'them.  When we are finished, we recreate spike2_done.txt (by copying another text file
'in its place) to signal to Matlab that we are done accessing the IDX and SPK files.
'If the file is not present, assume Matlab is accessing the files and return failure.
'Matlab will check for the existence of spike2_done, delete it, access the files, close
'them, then create matlab_done.  Since file copying is somewhat slow on Matlab (300-600 ms)
'for some reason, the routine has been written so that the time-intensive Matlab call does
'not interfere with the execution of Spike2.  Basically, we don't want to wait for Matlab
'to finish reading, etc., so that we can write the "true" IDX and SPK files.  So instead
'we write the true files each time, and update the secondary files after each Matlab read,
'letting Matlab take its time.  When there are no stimuli left, we should take the time to
'update one last time.  SafeUpdate generally takes 10ms or less to execute in testing.
func SafeUpdate(Success%[])
    
    ok% := filedelete(OnlineDir$+"matlab_done.txt");
    
    if ok% > 0 then 'if the file is successfully deleted, run the online updater
	 	'these IFs are not mutually exclusive
        if Success%[0] = 0 then
            ok% := filecopy(OnlineDir$+MyAutoName$+"a.idx",OnlineDir$+MyAutoName$+"a_ma.idx",1);
        endif;
        if Success%[1] = 0 then
            ok% := filecopy(OnlineDir$+MyAutoName$+"p.idx",OnlineDir$+MyAutoName$+"p_ma.idx",1);
        endif;
        if Success%[2] = 0 then
            ok% := filecopy(OnlineDir$+MyAutoName$+"m.idx",OnlineDir$+MyAutoName$+"m_ma.idx",1);
        endif;
        if Success%[3] = 0 then
            ok% := filecopy(OnlineDir$+MyAutoName$+"w.idx",OnlineDir$+MyAutoName$+"w_ma.idx",1);
        endif;
        ok% := filecopy(OnlineDir$+MyAutoName$+"all.idx",OnlineDir$+MyAutoName$+"all_ma.idx",1);
        ok% := filecopy(OnlineDir$+MyAutoName$+".spk",OnlineDir$+MyAutoName$+"_ma.spk",1);
        ok% := filecopy(OnlineDir$+"empty_file.txt",OnlineDir$+"spike2_done.txt");
        arrconst(UpdateSuccess%[],1);  'Reset success for all (even if not all were updated - none failed)
    endif;
    
    return 1;
end;




'============================= Update Online IDX File ================================
func IDXupdate(Type$)
    
    var fh%;   'file handle for type-specific IDX file
    var fh2%;  'file handle for overall IDX file
    var fhlog%; 'file handle for log file
    var ii%;  'looping
    var a;   'will hold either trial-specific attenuation or fade attenuation as appropriate
    
	'Try opening type-specific file.  File will not exist on first run of each type
    fh%:=fileopen(OnlineDir$+MyAutoName$+Type$+".idx",8,2);  
    
    
	'If the type-specific file does not exist, create it
    if fh%<0 then
        fh%:=fileopen(OnlineDir$+MyAutoName$+Type$+".idx",8,3); 
        if NSpeakers% < 2 then
            view(fh%).print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t","Trial","S-Seq","T-Info","T-Name","Atten","S-Onset","T-Onset","S-Offset","T-Resp"); 'header tag1, split for length and looping
            'print("%s\t%s\t%s\t%s\t%s\n\n","Result",Date$(),"Parameter File: "+ParamFile$,"Trials File: "+TrialFile$,ThisVersion$); 'header tag2, old, pre-looping
            view(fh%).print("%s\t%s\t%s\t","Result",Date$(),"Parameter File: "+ParamFile$); 'header tag 2
            for ii% := 0 to NTrialsFiles%-1 do
                view(fh%).print("%s\t","Trials File " + Str$(ii%+1) + ": " + TrialFileList$[ii%]); 'header tag 3
            next
            view(fh%).print("%s\n\n",ThisVersion$); 'header tag 4
        else
            view(fh%).print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t","Trial","S-Seq","T-Info","T-Name","Atten","S-Seq2","T-Info2","T-Name2","Atten2","S-Onset","T-Onset"); 'header tag1, split for length and looping
            'print("%s\t%s\t%s\t%s\t%s\t%s\t%s\n\n","S-Offset","T-Resp","Result",Date$(),"Parameter File: "+ParamFile$,"Trials File: "+TrialFile$,ThisVersion$); 'header tag2, old, pre-looping
            view(fh%).print("%s\t%s\t%s\t%s\t%s\t","S-Offset","T-Resp","Result",Date$(),"Parameter File: "+ParamFile$); 'header tag 2
            for ii% := 0 to NTrialsFiles%-1 do
                view(fh%).print("%s\t","Trials File " + Str$(ii%+1) + ": " + TrialFileList$[ii%]); 'header tag 3
            next
            view(fh%).print("%s\n\n",ThisVersion$); 'header tag 4
        endif;
    endif;
    
	'Print Data to files, start with trial number
    view(fh%).print("%d:%d\t",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1); 'trial number
	'stimulus sequence, in letters, plus target indicator
    for ii%:=1 to ConcatStim%[CurrTrialIndex%] do
        view(fh%).print("%s",StimOrder$[CurrTrialIndex%][ii%-1]);
    next;
    view(fh%).print("%d\t",TargVar%[CurrTrialIndex%]);
    if CueLightEachTrial% > 0 then  'If we're changing the cue light, record stiminfo indicating which cue light is on as well as stiminfo for last test stimulus
        view(fh%).print("%s--%s\t",StimInfo$[StimOrder%[CurrTrialIndex%][0]],StimInfo$[TestStim%[CurrTrialIndex%]]);
    else  'record stiminfo for test stimulus only
        view(fh%).print("%s\t",StimInfo$[TestStim%[CurrTrialIndex%]]);  'stimulus info for test stimulus that just played
    endif;
    view(fh%).print("%s\t",StimName$[TestStim%[CurrTrialIndex%]]);  'stimulus name of stimulus that just played
    if FadedBInit = 0 then  'assign proper value to attenuation whether specified on the trial or fading in
        a := Atten[CurrTrialIndex%];
    else
        if TargVar2%[CurrTrialIndex%] > 0 and TargVar2%[CurrTrialIndex%] < 9 then 
            a := FadedBLast;  'if it's a non-target (being faded in)
        else
            a := 0;
        endif;
    endif;    
    view(fh%).print("%f\t",a);      'Attenuation of stimulus that just played
    if NSpeakers% > 1 then
        'stimulus sequence, in letters, plus target indicator
        for ii%:=1 to ConcatStim2%[CurrTrialIndex%] do
            view(fh%).print("%s",StimOrder2$[CurrTrialIndex%][ii%-1]);
        next;
        view(fh%).print("%d\t",TargVar2%[CurrTrialIndex%]);
        if CueLightEachTrial% > 0 then  'If we're changing the cue light, record stiminfo indicating which cue light is on as well as stiminfo for last test stimulus
            view(fh%).print("%s--%s\t",StimInfo$[StimOrder2%[CurrTrialIndex%][0]],StimInfo$[TestStim2%[CurrTrialIndex%]]);
        else  'record stiminfo for test stimulus only
            view(fh%).print("%s\t",StimInfo$[TestStim2%[CurrTrialIndex%]]);  'stimulus info for test stimulus that just played
        endif;
        
        view(fh%).print("%s\t",StimName$[TestStim2%[CurrTrialIndex%]]);  'stimulus name of stimulus that just played
        if FadedBInit = 0 then  'assign proper value to attenuation whether specified on the trial or fading in
            a := Atten2[CurrTrialIndex%];
        else
            if TargVar%[CurrTrialIndex%] > 0 and TargVar%[CurrTrialIndex%] < 9 then
                a := FadedBLast;  'if it's a non-target (being faded in)
            else
                a := 0;
            endif;
        endif; 
        view(fh%).print("%f\t",a);      'Attenuation of stimulus that just played
    endif;
    view(fh%).print("%f\t",StimOn);  'stimulus onset time
    view(fh%).print("%f\t",StimOn+min(PrevEOS,PrevEOS2));  'onset time of test portion of stimulus - next has been loaded
    view(fh%).print("%f\t",StimOn+StimDur);  'stimulus offset time, calculated
    view(fh%).print("%f\t",ResponseTime2);    'response time, actual if lever released, calculated (end of response window) if lever held
    view(fh%).print("%s\n",TrialResult$);    'Trial result
    fileclose();  'close fh%
    
    
    
	'Try opening overall file.  File will not exist on first run
    fh2%:=fileopen(OnlineDir$+MyAutoName$+".idx",8,2);
    
	'If the overall file does not exist, create it
    if fh2%<0 then
        fh2%:=fileopen(OnlineDir$+MyAutoName$+".idx",8,3); 
        if NSpeakers% < 2 then
            view(fh2%).print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t","Trial","Type","S-Seq","T-Info","T-Name","Atten","S-Onset","T-Onset","S-Offset","T-Resp"); 'header tag1, split for length and looping
            'print("%s\t%s\t%s\t%s\t%s\n\n","Result",Date$(),"Parameter File: "+ParamFile$,"Trials File: "+TrialFile$,ThisVersion$); 'header tag2, old, pre-looping
            view(fh2%).print("%s\t%s\t%s\t","Result",Date$(),"Parameter File: "+ParamFile$); 'header tag 2
            for ii% := 0 to NTrialsFiles%-1 do
                view(fh2%).print("%s\t","Trials File " + Str$(ii%+1) + ": " + TrialFileList$[ii%]); 'header tag 3
            next
            view(fh2%).print("%s\n\n",ThisVersion$); 'header tag 4
        else
            view(fh2%).print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t","Trial","Type","S-Seq","T-Info","T-Name","Atten","S-Seq2","T-Info2","T-Name2","Atten2","S-Onset","T-Onset"); 'header tag, split in two to be under 256 char
            'print("%s\t%s\t%s\t%s\t%s\t%s\t%s\n\n","S-Offset","T-Resp","Result",Date$(),"Parameter File: "+ParamFile$,"Trials File: "+TrialFile$,ThisVersion$); 'header tag2, old, pre-looping
            view(fh2%).print("%s\t%s\t%s\t%s\t%s\t","S-Offset","T-Resp","Result",Date$(),"Parameter File: "+ParamFile$); 'header tag 2
            for ii% := 0 to NTrialsFiles%-1 do
                view(fh2%).print("%s\t","Trials File " + Str$(ii%+1) + ": " + TrialFileList$[ii%]); 'header tag 3
            next
            view(fh2%).print("%s\n\n",ThisVersion$); 'header tag 4
        endif;
    endif;
    
	'Print Data to files, start with trial number
    view(fh2%).print("%d:%d\t",SwitchCurrFile%,CurrTrialIndexList%[SwitchCurrFile%-1]+1);  'trial number
	'Print type of trial, only for the overall IDX file
    view(fh2%).print("%s\t",Type$);  'Trial type a=active, p=passive, m=bmf search, w=working during bmf search
	'stimulus sequence, in letters, plus target indicator
    for ii%:=1 to ConcatStim%[CurrTrialIndex%] do
        view(fh2%).print("%s",StimOrder$[CurrTrialIndex%][ii%-1]);
    next;
    view(fh2%).print("%d\t",TargVar%[CurrTrialIndex%]);
    if CueLightEachTrial% > 0 then  'If we're changing the cue light, record stiminfo indicating which cue light is on as well as stiminfo for last test stimulus
        view(fh2%).print("%s--%s\t",StimInfo$[StimOrder%[CurrTrialIndex%][0]],StimInfo$[TestStim%[CurrTrialIndex%]]);
    else  'record stiminfo for test stimulus only
        view(fh2%).print("%s\t",StimInfo$[TestStim%[CurrTrialIndex%]]);  'stimulus info for test stimulus that just played
    endif;
    view(fh2%).print("%s\t",StimName$[TestStim%[CurrTrialIndex%]]);  'stimulus name of stimulus that just played
    view(fh2%).print("%f\t",Atten[CurrTrialIndex%]);     'Attenuation of stimulus that just played
    if NSpeakers% > 1 then
        'stimulus sequence, in letters, plus target indicator
        for ii%:=1 to ConcatStim2%[CurrTrialIndex%] do
            view(fh2%).print("%s",StimOrder2$[CurrTrialIndex%][ii%-1]);
        next;
        view(fh2%).print("%d\t",TargVar2%[CurrTrialIndex%]);
        if CueLightEachTrial% > 0 then  'If we're changing the cue light, record stiminfo indicating which cue light is on as well as stiminfo for last test stimulus
            view(fh2%).print("%s--%s\t",StimInfo$[StimOrder2%[CurrTrialIndex%][0]],StimInfo$[TestStim2%[CurrTrialIndex%]]);
        else  'record stiminfo for test stimulus only
            view(fh2%).print("%s\t",StimInfo$[TestStim2%[CurrTrialIndex%]]);  'stimulus info for test stimulus that just played
        endif;
        
        view(fh2%).print("%s\t",StimName$[TestStim2%[CurrTrialIndex%]]);  'stimulus name of stimulus that just played
        view(fh2%).print("%f\t",Atten2[CurrTrialIndex%]);     'Attenuation of stimulus that just played
    endif;
    view(fh2%).print("%f\t",StimOn);  'stimulus onset time
    view(fh2%).print("%f\t",StimOn+min(PrevEOS,PrevEOS2));  'onset time of test portion of stimulus - next has been loaded
    view(fh2%).print("%f\t",StimOn+StimDur);  'stimulus offset time, calculated
    view(fh2%).print("%f\t",ResponseTime2);  'response time, actual if lever released, calculated (end of response window) if lever held, end of stimulus for Passive
    view(fh2%).print("%s\n",TrialResult$);  'Trial result
    fileclose();  'Close fh2%
    
    
    
    
	'Try opening log file.  File will not exist on first run
    fhlog%:=fileopen(LogDir$+MyAutoName$+".log",8,2);
    
	'If the log file does not exist, create it
    if fhlog%<0 then
        fhlog%:=fileopen(LogDir$+MyAutoName$+".log",8,3); 
        view(fhlog%).print("%s\t%s\t",Date$(),"Parameter File: "+ParamFile$); 'header tag 1
        for ii% := 0 to NTrialsFiles%-1 do
            view(fhlog%).print("%s\t","Trials File " + Str$(ii%+1) + ": " + TrialFileList$[ii%]); 'header tag 2
        next
        view(fhlog%).print("%s\n\n",ThisVersion$); 'header tag 3
    endif;
    
    view(HiddenLogHandle%).EditSelectAll();  'select text out of the hidden log window
    view(fhlog%).print("%s\r",view(HiddenLogHandle%).Selection$());  'print selection to the log
    view(HiddenLogHandle%).EditClear();  'clear the current text in the hidden log window
    fileclose();  'Close fhlog%
    
    
    return 1;
end;




'============================= Update Online SPK File (Append) ============================
'This function is designed to append to an SPK file instead of overwrite
func SPKappend();
    
    var fh%; 
    var ii%;  'looping
    var Now;  'what time is it?
    var EventTime;  'Holds the event time from the WaveMark Channel
    var Code%[4];  'To collect the code (spike classification) from the WaveMark Channel, must be an integer array
    var fileSuffix$;
    
    view(ctview%);
    Now := maxtime();
    
    for ii% := 1 to tunNWavemarks% do
        
        'if there is only one electrode, maintain standard .spk file naming scheme
        if tunNWavemarks% = 1 then
            fileSuffix$ := ".spk";
        else 'if there are multiple electrodes, use the standard scheme, but add "_1", "_2", etc. designating the electrode number
            fileSuffix$ := "_" + Str$(ii%) + ".spk";
        endif
        'Note that the above lines are probably the only section of code in the entire pres_engine to 
        'have the flexibility for more than three electrodes. Everything else is individually written
        'for each of the three 'trodes.
        

        'Try opening file.  File will not exist on first run
        fh%:=fileopen(OnlineDir$+MyAutoName$+fileSuffix$,8,2);
        
        'If the file does not exist, create it
        if fh%<0 then
            fh%:=fileopen(OnlineDir$+MyAutoName$+fileSuffix$,8,3); 
            view(fh%).print("Header\t","Info\t","Here\n"); 'header tag
        endif;
        
        'get data since last update
        EventTime := SPKAppendTime;  'EventTime will now be SPKAppendTime from last execution
        
        
        view(ctview%);  'must change to active view after opening fh% to use NextTime()
        
        'Check for first spike, will be -1 if there are no more spikes 
        docase
        case ii% = 1 then
            EventTime := NextTime(WavemarkPorts%[0],EventTime,Code%[]);
        case ii% = 2 then
            EventTime := NextTime(WavemarkPorts%[1],EventTime,Code%[]);    
        case ii% = 3 then
            EventTime := NextTime(WavemarkPorts%[2],EventTime,Code%[]);
        endcase
        
        'Is current spike in a valid range
        while (EventTime <= Now and EventTime > 0) do
            'The last call to NextTime() produced a spike in a a valid range, write that data to file
            view(fh%).print("%f\t",EventTime);  'view is currently ctview%
            view(fh%).print("%d\n",Code%[0]);   'view is currently ctview%
            'Check for next spike
            docase
            case ii% = 1 then
                EventTime := NextTime(WavemarkPorts%[0],EventTime,Code%[]);
            case ii% = 2 then
                EventTime := NextTime(WavemarkPorts%[1],EventTime,Code%[]);    
            case ii% = 3 then
                EventTime := NextTime(WavemarkPorts%[2],EventTime,Code%[]);
            endcase
        wend;
        
        view(fh%);  'must switch view to close fh%, current view is ctview%
        fileclose();  'close fh%
        view(ctview%);  'should go back to data view
        
    next;
    
    SPKAppendTime := Now;  'Set SPKAppendTime once we are done with the loop
        
    return 1;
end;




'========================== Write Light Log ==============================
'Writes LED and incandescent information to the light log file
proc WriteLightLog()
    
    var fh%;   'file handle for type-specific IDX file
    var ii%;  'looping
    
	'Try opening light log file.  File will not exist on first run
    fh%:=fileopen(OnlineDir$+MyAutoName$+"lightlog.idx",8,2);  
    
	'If the light log file does not exist, create it
    if fh%<0 then
        fh%:=fileopen(OnlineDir$+MyAutoName$+"lightlog.idx",8,3); 
        view(fh%).print("Action\t","Time\t",ThisVersion$+"\n"); 'header tag, note version here as well
    endif;
    
    'Print Data vto file with complete disregard for time order
    if YellowOnIndex% > 0 then 'this means there was at least one yellow LED on event
        for ii% := 0 to YellowOnIndex%-1 do
            view(fh%).print("YellowOn\t");
            view(fh%).print("%f\n",YellowOnTimes[ii%]); 
        next;
        YellowOnIndex% := 0; 'reset YellowOnIndex
        arrconst(YellowOnTimes[],0);  'clear YellowOnTimes[]
    endif;
    if YellowOffIndex% > 0 then 'this means there was at least one yellow LED off event
        for ii% := 0 to YellowOffIndex%-1 do
            view(fh%).print("YellowOff\t");
            view(fh%).print("%f\n",YellowOffTimes[ii%]); 
        next;
        YellowOffIndex% := 0; 'reset YellowOffIndex
        arrconst(YellowOffTimes[],0);  'clear YellowOffTimes[]
    endif;
    if RedOnIndex% > 0 then 'this means there was at least one red LED on event
        for ii% := 0 to RedOnIndex%-1 do
            view(fh%).print("RedOn\t");
            view(fh%).print("%f\n",RedOnTimes[ii%]); 
        next;
        RedOnIndex% := 0; 'reset RedOnIndex
        arrconst(RedOnTimes[],0);  'clear RedOnTimes[]
    endif;
    if RedOffIndex% > 0 then 'this means there was at least one red LED off event
        for ii% := 0 to RedOffIndex%-1 do
            view(fh%).print("RedOff\t");
            view(fh%).print("%f\n",RedOffTimes[ii%]); 
        next;
        RedOffIndex% := 0; 'reset RedOffIndex
        arrconst(RedOffTimes[],0);  'clear RedOffTimes[]
    endif;
    if GreenOnIndex% > 0 then 'this means there was at least one green LED on event
        for ii% := 0 to GreenOnIndex%-1 do
            view(fh%).print("GreenOn\t");
            view(fh%).print("%f\n",GreenOnTimes[ii%]); 
        next;
        GreenOnIndex% := 0; 'reset GreenOnIndex
        arrconst(GreenOnTimes[],0);  'clear GreenOnTimes[]
    endif;
    if GreenOffIndex% > 0 then 'this means there was at least one green LED off event
        for ii% := 0 to GreenOffIndex%-1 do
            view(fh%).print("GreenOff\t");
            view(fh%).print("%f\n",GreenOffTimes[ii%]); 
        next;
        GreenOffIndex% := 0; 'reset GreenOffIndex
        arrconst(GreenOffTimes[],0);  'clear GreenOffTimes[]
    endif;
    if IncOnIndex% > 0 then 'this means there was at least one incandescent on event
        for ii% := 0 to IncOnIndex%-1 do
            view(fh%).print("IncOn\t");
            view(fh%).print("%f\n",IncOnTimes[ii%]); 
        next;
        IncOnIndex% := 0; 'reset IncOnIndex
        arrconst(IncOnTimes[],0);  'clear IncOnTimes[]
    endif;
    if IncOffIndex% > 0 then 'this means there was at least one incandescent off event
        for ii% := 0 to IncOffIndex%-1 do
            view(fh%).print("IncOff\t");
            view(fh%).print("%f\n",IncOffTimes[ii%]); 
        next;
        IncOffIndex% := 0; 'reset IncOffIndex
        arrconst(IncOffTimes[],0);  'clear IncOffTimes[]
    endif;
    
    'Now for flashes
    if YellowOnFIndex% > 0 then 'this means there was at least one yellow LED on event
        for ii% := 0 to YellowOnFIndex%-1 do
            view(fh%).print("YellowFlashOn\t");
            view(fh%).print("%f\n",YellowOnFlash[ii%]); 
        next;
        YellowOnFIndex% := 0; 'reset YellowOnFIndex
        arrconst(YellowOnFlash[],0);  'clear YellowOnFlash[]
    endif;
    if YellowOffFIndex% > 0 then 'this means there was at least one yellow LED off event
        for ii% := 0 to YellowOffFIndex%-1 do
            view(fh%).print("YellowFlashOff\t");
            view(fh%).print("%f\n",YellowOffFlash[ii%]); 
        next;
        YellowOffFIndex% := 0; 'reset YellowOffFIndex
        arrconst(YellowOffFlash[],0);  'clear YellowOffFlash[]
    endif;
    if RedOnFIndex% > 0 then 'this means there was at least one red LED on event
        for ii% := 0 to RedOnFIndex%-1 do
            view(fh%).print("RedFlashOn\t");
            view(fh%).print("%f\n",RedOnFlash[ii%]); 
        next;
        RedOnFIndex% := 0; 'reset RedOnFIndex
        arrconst(RedOnFlash[],0);  'clear RedOnFlash[]
    endif;
    if RedOffFIndex% > 0 then 'this means there was at least one red LED off event
        for ii% := 0 to RedOffFIndex%-1 do
            view(fh%).print("RedFlashOff\t");
            view(fh%).print("%f\n",RedOffFlash[ii%]); 
        next;
        RedOffFIndex% := 0; 'reset RedOffFIndex
        arrconst(RedOffFlash[],0);  'clear RedOffFlash[]
    endif;
    if GreenOnFIndex% > 0 then 'this means there was at least one green LED on event
        for ii% := 0 to GreenOnFIndex%-1 do
            view(fh%).print("GreenFlashOn\t");
            view(fh%).print("%f\n",GreenOnFlash[ii%]); 
        next;
        GreenOnFIndex% := 0; 'reset GreenOnFIndex
        arrconst(GreenOnFlash[],0);  'clear GreenOnFlash[]
    endif;
    if GreenOffFIndex% > 0 then 'this means there was at least one green LED off event
        for ii% := 0 to GreenOffFIndex%-1 do
            view(fh%).print("GreenFlashOff\t");
            view(fh%).print("%f\n",GreenOffFlash[ii%]); 
        next;
        GreenOffFIndex% := 0; 'reset GreenOffFIndex
        arrconst(GreenOffFlash[],0);  'clear GreenOffFlash[]
    endif;
    if IncOnFIndex% > 0 then 'this means there was at least one incandescent on event
        for ii% := 0 to IncOnFIndex%-1 do
            view(fh%).print("IncFlashOn\t");
            view(fh%).print("%f\n",IncOnFlash[ii%]); 
        next;
        IncOnFIndex% := 0; 'reset IncOnIFndex
        arrconst(IncOnFlash[],0);  'clear IncOnFlash[]
    endif;
    if IncOffFIndex% > 0 then 'this means there was at least one incandescent off event
        for ii% := 0 to IncOffFIndex%-1 do
            view(fh%).print("IncFlashOff\t");
            view(fh%).print("%f\n",IncOffFlash[ii%]); 
        next;
        IncOffFIndex% := 0; 'reset IncOffFIndex
        arrconst(IncOffFlash[],0);  'clear IncOffFlash[]
    endif;
    
    fileclose();  'Close fh%
    
end;



'========================== Write Timing Log ==============================
'Writes timing information about how long it takes to write log files to a log file.
proc WriteTimingLog(id,wl,sp,sa,no)
    
    var fh%;   'file handle for type-specific IDX file
    var ii%;  'looping
    
	'Try opening light log file.  File will not exist on first run
    fh%:=fileopen(OnlineDir$+MyAutoName$+"timinglog.idx",8,2);  
    
	'If the light log file does not exist, create it
    if fh%<0 then
        fh%:=fileopen(OnlineDir$+MyAutoName$+"timinglog.idx",8,3); 
        view(fh%).print("IDX\t","Lightlog\t","SPK\t","SafeUpdate\t","Total\t",ThisVersion$+"\n"); 'header tag, note version here as well
    endif;
    
    'Print Data to file with complete disregard for time order
    view(fh%).print("%f\t",id); 
    view(fh%).print("%f\t",wl);
    view(fh%).print("%f\t",sp);
    view(fh%).print("%f\t",sa);
    view(fh%).print("%f\n",no);
    
    fileclose();  'Close fh%
    
end;



'============================= Clear Rasters ==================================
func ClearRasters%()
	PSTHBeginTime := view(-1).maxtime();
	return 1;
end;

'========================= GetTrialIndices ===============================
'A function that gets trial Indices from the registry. The input argument is a monkey letter
proc GetTrialIndices(monk$)
	var key$;
    var i%;
    key$:="PresEngine\\Monkey" + monk$ + "\\";
    
    for i% := 1 to MaxTrialsFiles% do
        if TrialFileListShort$[i%-1] <> "" then  'only do registry work for present files
            CurrTrialIndexList%[i%-1] := GetIntRegistryValue%(key$, TrialFileListShort$[i%-1], 0); 'return 0 if registry value does not exist
        endif;
    next;
    
	return;
end

'======================== SaveTrialIndices ===============================
'A function that saves trial indices to the registry.  The input argument is a monkey letter,
proc SaveTrialIndices(monk$)
	var key$;
    var i%;
    key$:="PresEngine\\Monkey" + monk$ + "\\";

    
    for i% := 1 to MaxTrialsFiles% do
        if TrialFileListShort$[i%-1] <> "" then  'only do registry work for present files
            SetIntRegistryValue(key$, TrialFileListShort$[i%-1], CurrTrialIndexList%[i%-1]);
        endif;
    next;
    
	return;
end

'========================= GetJoystickOffsets ===============================
'A function that gets joystick offsets from the registry
proc GetJoystickOffsets(jt%)
	var key$;
    key$:="PresEngine\\General\\";
    
    joystickXOffset := GetFloatRegistryValue(key$, "joystickXOffset"+Str$(jt%), 0); 'return 0 if registry value does not exist
    joystickYOffset := GetFloatRegistryValue(key$, "joystickYOffset"+Str$(jt%), 0); 'return 0 if registry value does not exist
    
	return;
end

'========================= SaveJoystickOffsets ===============================
'A function that saves joystick offsets to the registry
proc SaveJoystickOffsets(jt%)
	var key$;
    key$:="PresEngine\\General\\";
    
    SetFloatRegistryValue(key$, "joystickXOffset"+Str$(jt%), joystickXOffset); 
    SetFloatRegistryValue(key$, "joystickYOffset"+Str$(jt%), joystickYOffset);    
    
	return;
end


'========================= GetFixationParamters ===============================
'A function that gets joystick offsets from the registry
proc GetFixationParameters()
	var key$;
    key$:="PresEngine\\General\\";
    
    FixWindowRadius := GetFloatRegistryValue(key$, "FixWindowRadius", 0); 'return 0 if registry value does not exist
    FixXLoc := GetFloatRegistryValue(key$, "FixXLoc", 0); 'return 0 if registry value does not exist
    FixYLoc := GetFloatRegistryValue(key$, "FixYLoc", 0); 'return 0 if registry value does not exist
    DegreesPerVoltX := GetFloatRegistryValue(key$, "DegreesPerVoltX", 1); 'return 1 if registry value does not exist
    DegreesPerVoltY := GetFloatRegistryValue(key$, "DegreesPerVoltY", 1); 'return 1 if registry value does not exist
    'FixXOffset := GetFloatRegistryValue(key$, "FixXOffset", 0); 'return 0 if registry value does not exist, probably won't use this
    'FixYOffset := GetFloatRegistryValue(key$, "FixYOffset", 0); 'return 0 if registry value does not exist, probably won't use this

	return;
end

'========================= SaveFixationParameters ===============================
'A function that saves joystick offsets to the registry
proc SaveFixationParameters()
	var key$;
    key$:="PresEngine\\General\\";

    SetFloatRegistryValue(key$, "FixWindowRadius", FixWindowRadius);  
    SetFloatRegistryValue(key$, "FixXLoc", FixXLoc); 
    SetFloatRegistryValue(key$, "FixYLoc", FixYLoc); 
    SetFloatRegistryValue(key$, "DegreesPerVoltX", DegreesPerVoltX); 
    SetFloatRegistryValue(key$, "DegreesPerVoltY", DegreesPerVoltY); 
    'SetFloatRegistryValue(key$, "FixXOffset", FixXOffset);  'probably won't use this
    'SetFloatRegistryValue(key$, "FixYOffset", FixYOffset);  'probably won't use this
    
	return;
end


'========================= Fixation Parameters ===============================
'A function that allows the setting of fixation parameters
func FixationParameters%()
    var ok%;
    
    GetFixationParameters();
    
    DlgCreate("Set Fixation Parameters");
    DlgReal(1,"FixPt X Location (deg)",0,15);
    DlgReal(2,"FixPt Y Location (deg)",0,15);
    DlgReal(3,"FixPt Window Radius (deg)",0.01,30);
    DlgReal(4,"FixPt X Scale Factor (deg/V)",-1000,1000);
    DlgReal(5,"FixPt Y Scale Factor (deg/V)",-1000,1000);
    ok% := DlgShow(FixXLoc,FixYLoc,FixWindowRadius,DegreesPerVoltX,DegreesPerVoltY);
    if ok% = 1 then
        SaveFixationParameters();
    endif    
    
	return 1;  'return to toolbar
end


'========================= DrawFix ===============================
' Draws fixpt in xy window (iDraw%==1) or blanks it (0). 
proc DrawFix(iDraw%)

	if iDraw% > 0 then

		' Draw fixation point in xy window
		View(EyeXYWindow%).XYAddData(iFixChannel%, FixationX, FixationY);
	
		' draw fixation window
		ArrConst(windowX[], FixWindowX[]);
		ArrAdd(windowX[], FixationX);
		ArrConst(windowY[], FixWindowY[]);
		ArrAdd(windowY[], FixationY);

		View(EyeXYWindow%).XYAddData(iFixWindowChannel%, windowX[], windowY[]);		
	else 
		' erase the stim and the window from xy view
		View(EyeXYWindow%).XYDelete(iFixChannel%);
		View(EyeXYWindow%).XYDelete(iFixWindowChannel%);
	endif

end;


'========================= Looking ===============================
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixXLoc,2) + Pow(EyePosY-FixYLoc,2)) <= Pow(FixWindowRadius,2) then 
        return 1; 
    else 
        return 0; 
    endif
end;


'======================== CreateStartTrialString ===============================
func CreateStartTrialString$()
    var sts$;
    var ii%;
    
    for ii% := 1 to NTrialsFiles% do
        sts$ := sts$ + str$(CurrTrialIndexList%[ii%-1]+1);  'increment by 1 because the variable holds indices
        if ii% < NTrialsFiles% then
            sts$ := sts$ + ",";
        endif;
    next;    
    
    return sts$;
end


'======================== InterpretStartTrialString ===============================
func InterpretStartTrialString%(sts$)
    var charind%;
    var ii%;
    var temp$;
    
    for ii% := 1 to NTrialsFiles%-1 do
        charind% := InStr(sts$,","); 'get location of comma
        if charind% < 2 then
            return 0;  'return failure if we do not find enough commas (0), or we get a comma in position 1 (1)
        endif;
        temp$ := Left$(sts$,charind%-1);  'get value preceding comma as a string
        CurrTrialIndexList%[ii%-1] := val(temp$)-1;  'convert value to number, subtract 1 becuase it's an index
        sts$ := Right$(sts$,Len(sts$)-charind%);  'get remainder of string after comma
        
        ok% := val(temp$);
        if ok% < 1 then
            return ok%;
        endif;
    next;
    'get final value, subtract 1 becuase it's an index
    CurrTrialIndexList%[NTrialsFiles%-1] := val(sts$)-1;

    'to start, set future trial index list identical to current
    arrconst(FutureTrialIndexList%[],CurrTrialIndexList%[]);

    'get return value
    ok% := val(sts$);    
    return ok%;  'if this is zero, we didn't get a valid number
    
end



'=========================== Set Stim Codes ==============================
'Because Stim Codes can only be a max of 255 in each of the four positions,
'this function will take a stim code that is greater than 255 and parse it
'across the four entries in StimCodes%[], value is returned in StimCodes%[]
'
'To be succinct, here are two examples of inputs and outputs:
'
'value%                                      StimCodes%[]
'257                                         1,1,0,0
'34+(256*7)+(256*256*154)+(256*256*256*76)   34,7,154,76
func SetStimCodes%(&StimCodes%[],value%);
    var i%;
    var rem%;
    
    ArrConst(StimCodes%[],0);  'reset StimCodes%
    
    'Loop through value three times, we are basically doing base-256 math here
    'This is fully tested because integer math scares me.  But it works.
    for i% := 0 to 2 do
        rem% := value%/256;  'This gets the number of 256s in value%
        value% := value% - (rem%*256);  'This gets the remainder of value% when we subtract out the 256s
        StimCodes%[i%] := value%;  'Put the remainder value in the current entry in StimCodes%[]
        value% := rem%;  'Place the number of 256s into value%, loop if appropriate
    next;
    StimCodes%[3] := value%;  'once loops are finished, put final number of "256s" (actually number of 256*256*256s) in final position in StimCodes%[]
    
    return 1;  'not doing any error checking or anything here
end

'=========================== Mark Mask 4 ==============================
'This function sets the marker filter to select for all four values in a set of StimCodes,
'because apparently there's no way to do this with MarkMask without looping
proc MarkMask4(Chan%,StimCodes%[])
    var i%;
    
    MarkMask(Chan%,-1,0,-1);  'Set mask to accept nothing
    
    for i% := 0 to 3 do
        MarkMask(Chan%,i%,1,StimCodes%[i%]);  'Set layer i% of mask to accept value in StimCodes%[i%]
    next
    
end

'=========================== Set Defaults ==============================
func SetDefaults%()
    var ii%;
    
    stimN% := 0;
    arrconst(StimPath$[],"");  'The only array in the parameter file variables!
    Passive% := -1;
    Behavioral% := -1;  'unchanged at 1.4.19, but this value no longer matters
    NTrodes% := 0;
    RespDevice% := -100;
    NSpeakers% := 0;
    MinITI := 1;
    DeltaITI := 0;
    MaxDeltaITI := 0;
    ResponseWindow := 0.8;
    RespWindowDelay := 0;
    RespWindowDec := 0;
    RespWindowInc := 0;
    RespWindowMin := 0.8;
    RespWindowMax := -1;  'will take value of ResponseWindow by default
    IntPenalty := 2;
    FAPenalty := 5;
    MPenalty := 5;
    MPenaltyTUp := 5;
    MPenaltyTDown := 5;
    CatchPenalty := 0;
    NRPenalty := 5;
    LazyTO := 200;
    LazyTOPenalty := 10;
    LazyTOFactor := 1;
    LazyTOMax := 10;
    ReleaseTO := 20;
    ReleaseTOPenalty := 10;
    ReleaseTOFactor := 1;
    ReleaseTOMax := 10;
    RewardDelay := 0.2;
    TrialOnsetDelay := 0.5;
    TrialOnsetInc := 0;
    TrialOnsetMax := 2;
    TrialOnsetDec := 0;
    TrialOnsetMin := 0.1;
    PayPassProb := 0.025;
    PayHProb := 1;
    PayHUProb := 1;
    PayHDProb := 1;
    PayHLProb := 1;
    PayHRProb := 1;
    PayCRProb := 1;
    PayMProb := 0;
    PayMUProb := 0;
    PayMDProb := 0;
    PayMLProb := 0;
    PayMRProb := 0;
    PayFAProb := 0;
    PayPTProb := 0;
    PayPNTProb := 0;
    PayNRProb := 0;
    PayCatchProb := 0;
    PayPassVal := 200;  'Note that the parameter file is read in seconds, but this is OK because it's converted to ms later.
    PayHVal := 200;
    PayHUVal := 200;
    PayHDVal := 200;
    PayHLVal := 200;
    PayHRVal := 200;
    PayCRVal := 200;
    PayMVal := 200;
    PayMUVal := 200;
    PayMDVal := 200;
    PayMRVal := 200;
    PayMLVal := 200;
    PayFAVal := 200;
    PayPTVal := 200;
    PayPNTVal := 200;
    PayNRVal := 200;
    PayCatchVal := 200;
    LeftThreshInner := 7;
    LeftThreshOuter := 15;
    RightThreshInner := 7;
    RightThreshOuter := 15;
    UpThreshInner := 7;
    UpThreshOuter := 15;
    DownThreshInner := 7;
    DownThreshOuter := 15;
    LeftThreshInnerInc := 0;
    LeftThreshOuterInc := 0;
    RightThreshInnerInc := 0;
    RightThreshOuterInc := 0;
    UpThreshInnerInc := 0;
    UpThreshOuterInc := 0;
    DownThreshInnerInc := 0;
    DownThreshOuterInc := 0;
    LeftThreshInnerDec := 0;
    LeftThreshOuterDec := 0;
    RightThreshInnerDec := 0;
    RightThreshOuterDec := 0;
    UpThreshInnerDec := 0;
    UpThreshOuterDec := 0;
    DownThreshInnerDec := 0;
    DownThreshOuterDec := 0;
    LeftThreshInnerMax := 25;  'Not permanent!
    LeftThreshOuterMax := 25;
    RightThreshInnerMax := 18;
    RightThreshOuterMax := 18;
    UpThreshInnerMax := 18;
    UpThreshOuterMax := 18;
    DownThreshInnerMax := 18;
    DownThreshOuterMax := 18;
    LeftThreshInnerMin := 2;
    LeftThreshOuterMin := 2;
    RightThreshInnerMin := 2;
    RightThreshOuterMin := 2;
    UpThreshInnerMin := 2;
    UpThreshOuterMin := 2;
    DownThreshInnerMin := 2;
    DownThreshOuterMin := 2;
    GodButtonExists% := 0;
    ContReinfDelay := -1;
    ContReinfDelayInc := 0;
    ContReinfDelayDec := 0;
    ContReinfDelayMax := 10;
    ContReinfDelayMin := -1;  'will take value of ContReinfDelay if not set
    ContReinfTO := 0.1;
    FadedBInit := 0;
    StairTargAcc := 0;
    FadedBInc := 0;
    FadedBDec := -1;  'will take value of FadedBInc if not set
    FadedBMax := 100;  'Default max of 100 dB attenuation
    FadedBMin := 0;  'Default min of 0 dB attenuation
    Errorless% := 0;
    RepeatOnError% := 0;
    Interleaved% := 0;
    ExpectNewStim% := 0;
    IsSearchBMF% := 0;
    AddITIactive := 0;
    AddITIpassive := 0.2;
    TaperRew% := 0;
    TapRewFac := 2.5;
    TapRewSec% := 600;
    CollectEEG% := 0;
    MinRespTime := 0;
    FastSwitch% := 0;
    PersevN := 0;
    PersevPct := .9;
    BrkPersevN := 0;
    BrkPersevPct := .85;
    ContReinfInit$ := "down";
    ContReinfEnd$ := "return";
    JoystickType% := 0;  'default joystick is monkey joystick
    FeedbackOff% := 0;
    NumHitsCR% := 1;
    Motion% := 0;
    TrialWrap% := 0;
    OneAxis% := 0;
    Grow% := 1;  'default is "grow", but will be actively changed based on inferred 4/8-threshold mode later
    CalibrationMode := 0;
    CueLightEachTrial% := 0;
    CueLightOverride$ := "";
    CueLightFRUDUp$ := "";
    CueLightFRUDDown$ := "";
    IgnoreJoyThreshCap% := 0;
    CheckJoyTime := 2;
    DoResponseBias% := 0;
    BiasTaper% := 100;
    BiasWindow% := 50;
    BiasMax := 1;
    FlashLEDOnError$ := "n";      
    FlashLEDOnCueChange% := 0;
    FlashLEDFrequency := 10;
    FlashLEDCCDur := 5; 
    FlashLEDErrorDur := 3;
    NTrialsFiles% := 1;
    SwitchWindow% := 20;
    SwitchHarder := 0.85;
    SwitchEasier := 0.60;
    SwitchCurrFile% := 0;
    TrialsInSwitchWindow% := 0;
    SwitchToTF% := 0;
    CriteriaIndPrime% := 0;
    ContinuousRove := 0;
    TargetMotion% := 2; '2 is an illegal value
    TargetMotionWindow% := 0;
    TargetMotiondPrimeCrit := 0; 
    TargetMotionChangeAt% := 0;
    OverallPSTHType% := 0;
    PA5Absent% := 0;
    
    'Interleaved%, PassiveAndActive% cannot be changed after first load and therefore cannot (and should not)
    'be set when resetting parameter defaults.
    'Interleaved% := 0;  'Cannot change Interleaved% value now, either
    'PassiveAndActive% := 0;  Changing my mind.  I am NOT setting any default value to PassiveAndActive%.  It will be 0
    'when the variable is initialized, so if it is not set, it will be 0 when sampling starts.  After that it doesn't
    'matter as it only affects two things - the start of sampling and the very end when saving.  Since it needs to be the
    'same at the end to get the save right, don't risk changing it.
    
    'have to loop through for strings
    for ii% := 0 to MaxTrialsFiles%-1 do
        TrialFileList$[ii%] := "";
        TrialFileListShort$[ii%] := "";
    next;
    
    
    'reset behavioral variables as well
    Hits := 0;
    Misses := 0;
    CRs := 0;
    FAs := 0;
    PoTs := 0;
    PoNTs := 0;
    PtTs := 0;
    PtNTs := 0;
    UpHits := 0;
    UpMisses := 0;
    UpNR := 0;
    DownHits := 0;
    DownMisses := 0;
    DownNR := 0;
    PoNRs := 0;
    PtNRs := 0;
    CatchUp := 0;
    CatchDown := 0;
    CatchNR := 0;
    HitsR := 0;
    MissesR := 0;
    CRsR := 0;
    FAsR := 0;
    PoTsR := 0;
    PoNTsR := 0;
    PtTsR := 0;
    PtNTsR := 0;
    UpHitsR := 0;
    UpMissesR := 0;
    UpNRR := 0;
    DownHitsR := 0;
    DownMissesR := 0;
    DownNRR := 0;
    PoNRsR := 0;
    PtNRsR := 0;
    CatchUpR := 0;
    CatchDownR := 0;
    CatchNRR := 0;
    RightHits := 0;
    RightMisses := 0;
    RightNR := 0;
    LeftHits := 0;
    LeftMisses := 0;
    LeftNR := 0;
    CatchRight := 0;
    CatchLeft := 0;
    RightHitsR := 0;
    RightMissesR := 0;
    RightNRR := 0;
    LeftHitsR := 0;
    LeftMissesR := 0;
    LeftNRR := 0;
    CatchRightR := 0;
    CatchLeftR := 0;
    TotalErrorsUp% := 0;
    TotalErrorsDown% := 0;
    TotalCorrectNoErrorsUp% := 0;
    TotalCorrectNoErrorsDown% := 0;
    TempErrors% := 0;    
    arrconst(Hits%[],0);      
    arrconst(Misses%[],0);    
    arrconst(FAs%[],0);    
    arrconst(CRs%[],0);     
    arrconst(UpHits%[],0);     
    arrconst(UpMisses%[],0);    
    arrconst(DownHits%[],0);    
    arrconst(DownMisses%[],0);  
    arrconst(RightHits%[],0);       
    arrconst(RightMisses%[],0);       
    arrconst(LeftHits%[],0);         
    arrconst(LeftMisses%[],0);
    arrconst(TotalTrialsSutter%[],0);
    ReleaseFromPersevTrial% := 0;    
    
    return 1;
    
end;





'=========================== Tokenize ==================================
'This function takes a token string in TOKEN$ and an input string in REMAINDER$,
'it changes remainder to have any portion of the string after the token, FRONT$ 
'to have any portion of the string before the token.  It does not return the token,
'so after return, the string FRONT$+TOKEN$+REMAINDER$ will be equal to the original
'REMAINDER$ string.  If the token is not found, REMAINDER$ will be unchanged,
'FRONT$ will be empty, and OUT% will return 0.  On success OUT% will return 1.
func Tokenize(token$,&remainder$,&front$)

    var out% := 0;
    var ind%;
    ind% := InStr(remainder$,token$);
    if ind% > 0 then
        'Get front
        if ind% = 1 then
            front$ := "";
        else
            front$ := Left$(remainder$,ind%-1);
        endif;
        'Get remainder
        if ind%+len(token$)-1 = len(remainder$) then
            remainder$ := "";
        else
            remainder$ := Right$(remainder$,len(remainder$)-ind%-len(token$)+1);
        endif;
        out% := 1;
    else
        front$ := "";
    endif;
    return out%;
end


'====================== Conditional Quit ========================
'This function is used to test whether we should quit or not on certain errors.
'We may quit if parameters have not yet been loaded, but if they have been, we should 
'return to the main%() loop
func ConditionalQuit%()
    
    if ParamsLoadedOnce% = 0 then
        printlog("Quitting due to above error and the fact that no parameter file has yet been successfully loaded! (Conditional Quit)\n");
        view(HiddenLogHandle%).print("Quitting due to above error and the fact that no parameter file has yet been successfully loaded! (Conditional Quit)\r");
        quit%();
    else
        return 0;  'just return 0, this will keep the main loop from executing
    endif;
    
end;




'======================= Toolbar Quit ====================================
'This function simply records that the Quit button was pressed, then quits.
'This function exists because people were pressing quit and then accusing the
'program of crashing.  This provides logfile evidence that quit was pressed, dammit.
func QuitTB%()
    
    printlog("The Quit button has been pressed on the toolbar!  Quitting!\n");
    view(HiddenLogHandle%).print("The Quit button has been pressed on the toolbar!  Quitting!\r");
    quit%();
    
end;




'======================================= Quit ========================================
func Quit%()
    
    var fh%;  'file handle
var fhlog%;  'file handle for log
var ii%;
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKeySutter%("w");  'Stop recording
        yield(0.1);
        SafeSampleKeySutter%("i");  'Close the file
        SafeSampleKeySutter%("Z");  'zero the DIGLOWs
    endif
    
    if SampleStatus()=2 then
        StopSampling%();  'Turns off LEDs
    endif;
   
    'If we are trial wrapping, save the current trial indices
    if TrialWrap% = 1 then
        SaveTrialIndices(MonkeyLetter$);
    endif;    
    
	'Print final information to LogFile
    printlog("\n*\n*\n*\nThe experiment is complete!\n");
    view(HiddenLogHandle%).print("\r*\r*\r*\rThe experiment is complete!\r");
    if TrialWrap% = 1 then 'if we're wrapping trials, we need a final count
        if NTrialsFiles% = 1 then
            printlog("Begin the next session with trial number %d\n",CurrTrialIndex%+1);
            view(HiddenLogHandle%).print("Begin the next session with trial number %d\r",CurrTrialIndex%+1);
            'create TrialWrap file
            fh%:=fileopen(OnlineDir$+MyAutoName$+"trialwrap.idx",8,3); 
            view(fh%).print(CurrTrialIndex%+1);
            fileclose();   'Close fh%
        else
            printlog("Begin the next session with trial numbers ");
            view(HiddenLogHandle%).print("Begin the next session with trial numbers ");
            'create TrialWrap file
            fh%:=fileopen(OnlineDir$+MyAutoName$+"trialwrap.idx",8,3); 
            for ii% := 0 to NTrialsFiles%-1 do
                printlog("%d ", FutureTrialIndexList%[ii%]+1);
                view(HiddenLogHandle%).print("%d ", FutureTrialIndexList%[ii%]+1);
                view(fh%).print("%d ",FutureTrialIndexList%[ii%]+1);
                'arradd(CurrTrialIndexList%[],1);  'increment - we aren't using it now we've quit anyway
                'printlog("Begin the next session with trial number %d\n",CurrTrialIndexList%[]);
                'view(HiddenLogHandle%).print("Begin the next session with trial number %d\r",CurrTrialIndexList%[]);
                'view(fh%).print("%d",CurrTrialIndexList%[]);
            next;
            printlog("\n");
            view(HiddenLogHandle%).print("\r");
            fileclose();   'Close fh%
        endif;
    endif;
    if ContReinfDelay >= 0 then 'if it's a continuous reinforcement scenario
        printlog("Number of rewards given is %d, number of wrong-axis interrupts is %d, number of delay interrupts is %d\n",NumRewards%,NumCRInterrupt%,NumDelayInterrupt%);
        printlog("Final Up/Down inner threshold is %f/%f degrees, final Left/Right inner threshold is %f/%f degrees\n",UpThreshInner/.09,DownThreshInner/.09,LeftThreshInner/.09,RightThreshInner/.09);
        printlog("Final Up/Down outer threshold is %f/%f degrees, final Left/Right outer threshold is %f/%f degrees\n",UpThreshOuter/.09,DownThreshOuter/.09,LeftThreshOuter/.09,RightThreshOuter/.09);
        printlog("Final required delay is %f seconds\n",ContReinfDelay);
        view(HiddenLogHandle%).print("Number of rewards given is %d, number of wrong-axis interrupts is %d, number of delay interrupts is %d\r",NumRewards%,NumCRInterrupt%,NumDelayInterrupt%);
        view(HiddenLogHandle%).print("Final Up/Down inner threshold is %f/%f degrees, final Left/Right inner threshold is %f/%f degrees\r",UpThreshInner/.09,DownThreshInner/.09,LeftThreshInner/.09,RightThreshInner/.09);
        view(HiddenLogHandle%).print("Final Up/Down outer threshold is %f/%f degrees, final Left/Right outer threshold is %f/%f degrees\r",UpThreshOuter/.09,DownThreshOuter/.09,LeftThreshOuter/.09,RightThreshOuter/.09);
        view(HiddenLogHandle%).print("Final required delay is %f seconds\r",ContReinfDelay);
    endif;
    if GodButtonExists% then 
        printlog("Number of God Button rewards is %d\n",NumGBRewards%);
        view(HiddenLogHandle%).print("Number of God Button rewards is %d\r",NumGBRewards%);
    endif;
    if Passive% = 1 then
        printlog("Number of rewards given is %d\n",NumRewards%);
        view(HiddenLogHandle%).print("Number of rewards given is %d\r",NumRewards%);
    endif;
    if Errorless% = 1 then
        printlog("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
        printlog("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\n",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
        view(HiddenLogHandle%).print("Total errors = %d (up = %d, down = %d), ",TotalErrorsUp%+TotalErrorsDown%,TotalErrorsUp%,TotalErrorsDown%);
        view(HiddenLogHandle%).print("Total Perfect Trials (hit before error = %d (up = %d, down = %d)\r",TotalCorrectNoErrorsUp%+TotalCorrectNoErrorsDown%,TotalCorrectNoErrorsUp%,TotalCorrectNoErrorsDown%);
    endif;
    if FadedBInc > 0 then
        printlog("The final value for fade-in attenuation was %f dB, %f dB done via software and %f dB done via PA5\n",FadedBInit,FadedBInit-CommondB,CommondB);
        view(HiddenLogHandle%).print("The final value for fade-in attenuation was %f dB, %f dB done via software and %f dB done via PA5\r",FadedBInit,FadedBInit-CommondB,CommondB);
    endif;
    if RespWindowInc > 0  or RespWindowDec > 0 then
        printlog("The final response window was %f\n",ResponseWindow);
        view(HiddenLogHandle%).print("The final response window was %f\r",ResponseWindow);
    endif;
    if TrialOnsetInc > 0  or TrialOnsetDec > 0 then
        printlog("The final Trial Onset Delay was %f\n",TrialOnsetDelay);
        view(HiddenLogHandle%).print("The final Trial Onset Delay was %f\r",TrialOnsetDelay);
    endif;
    if Passive% = 0 then
        VerboseAccuracy% := 1;  'force verbose printing of behavioral stats at end
        if PersevN = 0 then  'Just do regular behavioral stats if no Automatic Detection of Perseveration
            PrintBehavStats();
        else
            if RepeatOnError% = 1 then
                printlog("Finished in RepeatOnError state!  Final RepeatOnError stats are:\n");
                view(HiddenLogHandle%).print("Finished in RepeatOnError state!  Final RepeatOnError stats are:\r");
                PrintBehavStats();
                if Hits + Misses + UpHits + DownHits + UpMisses + DownMisses > 0 then 'basically if there was anything
                    RepeatOnError% := 0;  'Set up to print final regular stats
                    printlog("\n\nMost recent Non-RepeatOnError stats are:\n");
                    view(HiddenLogHandle%).print("\r\rMost recent Non-RepeatOnError stats are:\r");
                    PrintBehavStats();
                endif;
            else
                printlog("Finished in Non-RepeatOnError state!  Final Non-RepeatOnError stats are:\n");
                view(HiddenLogHandle%).print("Finished in Non-RepeatOnError state!  Final Non-RepeatOnError stats are:\r");
                PrintBehavStats();
                if HitsR + MissesR + UpHitsR + DownHitsR + UpMissesR + DownMissesR > 0 then 'basically if there was anything
                    RepeatOnError% := 1;  'Set up to print final regular stats
                    printlog("\n\nMost recent RepeatOnError stats are:\n");
                    view(HiddenLogHandle%).print("\r\rMost recent RepeatOnError stats are:\r");
                    PrintBehavStats();
                endif;
            endif;
        endif;
    endif;
    printlog("\n*\n*\n*\n");
    view(HiddenLogHandle%).print("\r*\r*\r*\r");
    



    'Taking all MemSave operations, etc. into view-based calls to hopefully make sure all the saves happen
    if DataCollected% = 1 then
        if RespDevice% = 0 then
            view(ctview%).memsave(MemChanLeverDebounce%,configJoyEventsChannel%,8);  'save as a Textmark channel   
        else
            view(ctview%).memsave(MemChanJoystick%,configJoyEventsChannel%,8);  'save as a Textmark channel
        endif;
        view(ctview%).memsave(MemChanStart%,configTrialStartChannel%,5);
        if behavioral% = 0 then
            if Interleaved% = 1 or Passive% = 0 or PassiveAndActive% = 1 then
                view(ctview%).memsave(MemChanHistTriggerA%,configTestStimStartAChannel%,5);
                if OverallPSTHType% > 0 then
                    view(ctview%).memsave(MemChanHistTriggerAGroup%,configTestStimGroupStartAChannel%,5);
                endif;
            endif;
            if Interleaved% = 1 or Passive% = 1 or PassiveAndActive% = 1 then
                view(ctview%).memsave(MemChanHistTriggerP%,configTestStimStartPChannel%,5);
                if OverallPSTHType% > 0 then
                    view(ctview%).memsave(MemChanHistTriggerAGroup%,configTestStimGroupStartPChannel%,5);
                endif;
            endif;
        endif;
        view(ctview%).memsave(MemChanStim%,configStimulusChannel%,8);
        view(ctview%).memsave(MemChanRw%,configRewardChannel%,5);
        'if RespDevice% <> 0 then
        '    view(ctview%).memsave(configJoyXChannel%,configJoyXChannel%);
        '    view(ctview%).memsave(configJoyYChannel%,configJoyYChannel%);
        'endif;
        if Behavioral% = 1 then
            view(ctview%).ChanShow(configJoyEventsChannel%,configTrialStartChannel%,configTestStimStartChannel%,configStimulusChannel%,configRewardChannel%);
        else
            view(ctview%).ChanShow(configJoyEventsChannel%,configTrialStartChannel%,configTestStimStartChannel%,configStimulusChannel%,configRewardChannel%);  'to get above memory channels to save to .smr file, they must be shown
            view(ctview%).ChanShow(WavemarkPorts%[0]);
            if tunNWavemarks% > 1 then
                view(ctview%).ChanShow(WavemarkPorts%[1]);
            endif
            if tunNWavemarks% > 2 then
                view(ctview%).ChanShow(WavemarkPorts%[2]);
            endif 
        endif;
        'File will now autosave
        'view(ctview%).filesaveas(DataPath$+FilePrefix$+".smr",-1);
    endif;
    
    
    
    'do one last update of the output log file
	'Try opening log file.  File will not exist on first run
    fhlog%:=fileopen(LogDir$+MyAutoName$+".log",8,2);
    
	'If the log file does not exist, create it
    if fhlog%<0 then
        fhlog%:=fileopen(LogDir$+MyAutoName$+".log",8,3); 
        view(fhlog%).print("%s\t%s\t%s\t%s\n\n",Date$(),"Parameter File: "+ParamFile$,"Trials File: "+TrialFile$,ThisVersion$); 'header tag
    endif;
    
    view(HiddenLogHandle%).EditSelectAll();  'select text out of the hidden log window
    view(fhlog%).print("%s\r",view(HiddenLogHandle%).Selection$());  'print selection to the log
    fileclose();  'Close fhlog%
    
    'close the hidden log window
    view(HiddenLogHandle%);
    fileclose(0,-1);  'Close hidden log window, do not ask for save
    
    
    
    'And finally, report errors from joystick checking, if they happen, so we can track this darn thing down
    if NumFoundNegativeIndex% > 0 then
        message("Tell Jeff!!!|During experiment, found a total of " + str$(NumFoundNegativeIndex%) + " negative indices!");
    endif
    if NumFoundTooBigIndex% > 0 then
        message("Tell Jeff!!!|During experiment, found a total of " + str$(NumFoundTooBigIndex%) + " over-999 indices!\nThe last one had a value of " + str$(TooBigIndexValue%));
    endif
    
    
    Halt;
    
    return 0;
    
end;

'=================== PresEngDialogChanged =======================
func PresEngDialogChanged%(item%)
    var status% := 1;
    
    DlgEnable(0,1);  'Disable name, we will use autonaming
    DlgEnable(0,4);  'Disable sampling rate settings
    DlgEnable(0,5);  'Disable sampling rate settings
    DlgEnable(0,6);  'Disable sampling rate settings
    
    return status%;
end