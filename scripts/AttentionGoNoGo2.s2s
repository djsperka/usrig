' $Id$
'
#include "../util/ChannelUtilities.s2s"
#include "../util/UsreyUtil.s2s"
#include "AttentionExtractFunctions.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"
#include "Joystick.s2s"
#include "UsreyGratings.s2s"  'not sure why we didn't just do this from the start...


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' 	Attention script dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'	Vars that control the Attention script 

var attNumberOfSetsOfBlocks%;
var attBlocksPerSet%;
var attTrialsPerBlock%;
var attEasyTrialsPerBlock%;
var attNumMainCues%;
var attNumDistracter1Cues%;
var attNumDistracter2Cues%;
var attNumDistracter3Cues%;
var attNumDistracter4Cues%;
var attNumCueAllCues%;
var attNumRandomNoCACues%;
var attNumRandomWithCACues%;
var cuesToUseNGratings%;  'this is total number of gratings being used - SEEMS redundant with attNumPatches but IS NOT, is actually dialog value which will BECOME attNumPatches, available for use in subdialogs
var distracterOffForEasy%;
var attNumPatches%;  'how many stimulus patches on the screen?
var attGetGPFromMainStim%;  'check box variable, should we get the distractor grating parameters (except for XY position) from the main stimulus?
var attUseCueCircles%;
var attCueCircleExtraRadius;
var attBackgroundColor$;
var attBackgroundRed% := 0;
var attBackgroundGreen% := 0;
var attBackgroundBlue% := 0;
var attBackgroundFromRed% := 0;
var attBackgroundFromGreen% := 0;
var attBackgroundFromBlue% := 0;
var attBackgroundToRed% := 0;
var attBackgroundToGreen% := 0;
var attBackgroundToBlue% := 0;
var attAnswerPointDiameter := 0.05;
var attAnswerPointOffset := 5.0;
var attAnswerPointWindowRadius := 2.5;
var attContrastBase%;
var attMaxContChange;
var attMinContChange;
var attNContLevels%;
var attContrastList[20];        'max of 20 (10 up, 10 down) contrast levels
var attFixationTime;
var attFixationCueMinTime;      
var attFixationCueMaxTime;      
var attCueOnsetTime;
var attCueOffsetTime;
var attStimOnsetTime;
var attHazardMinTime;
var attHazardExpMeanTime;
var attHazardCutoffTime;
var attUseHazardForReward%;
var attHazRewardMin%;
var attHazRewardMax%;
var attAcquisitionTime;
var attInterTrialTime;  'This is the default intertrial time
var attInterTrialTimeThisTrial;  'This is a trial-by-trial intertrial time, miss penalty may be added in
var attTimeTrialEnds;  'filled on a trial-to-trial basis because the value is different for no-change trials
var attContrastChangeDuration;
var attResponseWindow;
var attAbortPenaltyTime;  'These three penalty times are being tied together, at least for now
var attMissPenaltyTime;    'Penalty time tied together
var attFalseAlarmPenaltyTime;  'Penalty time tied together
var attSelectRandomContrastEachTrial%;  'if 1, don't do blocked randomization
var attTrainingContrastCheck%:=0; '**disabled**
var attTrainingContrastPct%:=0; '**disabled**
var attCuedLocationChangePct%;
var attUncuedLocationChangePct%;
var attLockUncuedToCued%;
var attNoCuesMatchFixpt%;

'Variables for colors dialog
var attendRGB%[3];
var ignore1RGB%[3];
var ignore2RGB%[3];
var ignore3RGB%[3];
var ignore4RGB%[3];
var cueallRGB%[3];
var nomatchRGB%[3];  'This was deprecated before it was ever used, but I'm not pulling it out of the dialog box because
                    'A) it will be a pain and B) as soon as I do it will be asked for again.  So it's just sitting
                    'there kind of orphaned.  Won't hurt anything.
var attCueCircleContrastAttend%;
var attCueCirclesMatchCueAllFixpt%;
var attCueCircleContrastIgnore1%;
var attCueCircleContrastIgnore2%;
var attCueCircleContrastIgnore3%;
var attCueCircleContrastIgnore4%;

var attStartBlock%;
'var attNoInfoCondition%;  'not being used, replaced by cue-all, now completely deprecated
var attSwapCueCircle%;
var attCueCircleStrokeWidth%;
var attUseFlashers%;  'flashers are currently disabled, could be enabled later
var attFlasherGratingParams$;
var attFlasherDur; 
var attFlasherTemporalBuffer;
var attFlasherSpatialBuffer;
var attFlasherMaxDist;
var attFlasherHazardValue;
var attFlasherWidth;
var attFlasherHeight;


var attCustomGratingColorCheck%;  'I totally don't think this is being used, but whatever
var attCustomGratingColorStimFrom%[3];
var attCustomGratingColorStimTo%[3];
var attCustomGratingColorDistractorFrom%[3];
var attCustomGratingColorDistractorTo%[3];
var attCustomGratingDialogLabel%[6];  'make a vector, it's easier!

var attPhaseCheck%;
var attPhaseDeg%;
var ContrastFile$ := GetWorkPath$() + "\\ContrastFile.txt";
var Flashers$;

' Counter vars for attention script
var attCountAllTrials% := 0;
var attCountAllTrialsCorrect% := 0;
var attCountAllTrialsAbort% := 0;
var attUseLowReward% := 0;
var attLowReward% := 0;


var lowRewardMS%;
var origRewardMS%;
const screenXmm := 400;
const screenYmm := 300;
var screenXmax;  'these are the borders of the screen in visual degrees
var screenYmax;
var xT;  'target x
var yT;  'target y
var wT;  'target width
var hT;  'target height
var xD1; 'distracter 1, etc.
var yD1;
var wD1;
var hD1;
var xD2;
var yD2;
var wD2;
var hD2;
var xD3;
var yD3;
var wD3;
var hD3;
var xD4;
var yD4;
var wD4;
var hD4;
var xF1; 'flasher 1, the x and y won't really be used but we need them to take dummy values from ParseGratingParametersBrief
var yF1;
var wF1;
var hF1;


' constants for timing dialog (these are being used only inconsistently)
const atttimingdlgAcquisitionTime% := 1;
const atttimingdlgFixationCueMinTime% := 2;
const atttimingdlgFixationCueMaxTime% := 3;
const atttimingdlgCueOnsetTime% := 4;
const atttimingdlgCueOffsetTime% := 5;
const atttimingdlgStimOnsetTime% := 6;
const atttimingdlgHazardMinTime% := 7;
const atttimingdlgHazardExpMeanTime% := 8;
const atttimingdlgHazardCutoffTime% := 9;
const atttimingdlgUseHazardForReward% := 10;
const atttimingdlgHazRewardMin% := 11;
const atttimingdlgHazRewardMax% := 12;
const atttimingdlgContrastChangeDuration% := 13;
const atttimingdlgResponseWindow% := 14;
const atttimingdlgIntertrialTime% := 15;
const atttimingdlgPenaltyTime% := 16;
const atttimingdlgLockUncued% := 17;
const atttimingdlgFixOffAtCC% := 18;

' constants for color dialog
var attdlgColorIndexGray% := 0;
var attdlgColorIndexBlack% := 1;
var attdlgColorIndexWhite% := 2;
var attdlgColorIndexCustom% := 3;
var attcolorsdlgBackgroundColor% := 1;
var attcolorsdlgBackgroundRed% := 2;
var attcolorsdlgBackgroundGreen% := 3;
var attcolorsdlgBackgroundBlue% := 4;
var attcolorsdlgCueContrastAttend% := 5;
var attcolorsdlgCueContrastIgnore1% := 6;
var attcolorsdlgCueContrastIgnore2% := 7;
var attcolorsdlgCueContrastIgnore3% := 8;
var attcolorsdlgCueContrastIgnore4% := 9;
var attcolorsdlgCustomGratingColorCheck% := 10;
var attcolorsdlgCustomGratingColorStimFromRed% := 11;
var attcolorsdlgCustomGratingColorStimFromGreen% := 12;
var attcolorsdlgCustomGratingColorStimFromBlue% := 13;
var attcolorsdlgCustomGratingColorStimToRed% := 14;
var attcolorsdlgCustomGratingColorStimToGreen% := 15;
var attcolorsdlgCustomGratingColorStimToBlue% := 16;
var attcolorsdlgCustomGratingColorDistractorFromRed% := 17;
var attcolorsdlgCustomGratingColorDistractorFromGreen% := 18;
var attcolorsdlgCustomGratingColorDistractorFromBlue% := 19;
var attcolorsdlgCustomGratingColorDistractorToRed% := 20;
var attcolorsdlgCustomGratingColorDistractorToGreen% := 21;
var attcolorsdlgCustomGratingColorDistractorToBlue% := 22;
var attcolorsdlgCueCircleColorAttendR% := 23;
var attcolorsdlgCueCircleColorAttendG% := 24;
var attcolorsdlgCueCircleColorAttendB% := 25;
var attcolorsdlgCueCircleColorIgnore1R% := 26;
var attcolorsdlgCueCircleColorIgnore1G% := 27;
var attcolorsdlgCueCircleColorIgnore1B% := 28;
var attcolorsdlgCueCircleColorIgnore2R% := 29;
var attcolorsdlgCueCircleColorIgnore2G% := 30;
var attcolorsdlgCueCircleColorIgnore2B% := 31;
var attcolorsdlgCueCircleColorIgnore3R% := 32;
var attcolorsdlgCueCircleColorIgnore3G% := 33;
var attcolorsdlgCueCircleColorIgnore3B% := 34;
var attcolorsdlgCueCircleColorIgnore4R% := 35;
var attcolorsdlgCueCircleColorIgnore4G% := 36;
var attcolorsdlgCueCircleColorIgnore4B% := 37;
var attcolorsdlgCueCircleColorCueAllR% := 38;
var attcolorsdlgCueCircleColorCueAllG% := 39;
var attcolorsdlgCueCircleColorCueAllB% := 40;
var attcolorsdlgCueCircleColorNoMatchR% := 41;
var attcolorsdlgCueCircleColorNoMatchG% := 42;
var attcolorsdlgCueCircleColorNoMatchB% := 43;
var attcolorsdlgAllCueCirclesMatchFix% := 44;

'variables for Henry's tuning curve version
const attMaxTrl% := 1000;
var attTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the grating on each trial
var attTrial2Order%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the second grating on each trial
var attTrial[attMaxTrl%];       'this variable is really only here because GetRepeatedParameterProgression wants to fill it; we will ignore it
var attCurrTrialIndex%;         'We'll need to keep track of the current trial index
var attIsCueAll%[attMaxTrl%];  'hold whether or not this is a cue all trial
var attContrastCuedList%[attMaxTrl%];  'A list of which contrast is being used on each trial in cued location, filled by CreateContrastList
var attContrastUncuedList%[attMaxTrl%];  'A list of which contrast is being used on each trial in uncued location, filled by CreateContrastList
var attCuedLocChangesList%[attMaxTrl%];  'An indicator (0/1) of whether the cued location changes
var attUncuedLocChangesList%[attMaxTrl%];  'An indicator (0/1) of whether the cued location changes
var attCuedLocList%[attMaxTrl%];  'A list of which stimulus patch (1 = main, 2 = dist1, 3 = dist2, etc., 6 = CueAll) is being cued
var attUncuedLocList%[attMaxTrl%];  'A list of which unattended stimulus patch (if any) will change
var attCuedLocCCTime[attMaxTrl%];     'holds hazard times, now pre-calculated
var attUncuedLocCCTime[attMaxTrl%];     'holds second hazard times, pre-calculated
var attOffBitsList%[attMaxTrl%];  'A list of which stimulus patches are off for this trial, in a bit sum, 1 = main, 2 = dist1, 4 = dist2, etc.
var attFixColor%[attMaxTrl%];     'A list of which color fixation point (as a number) is being used for this trial
var attCueCircleColor%[5][attMaxTrl%];  '5 possible stimulus locations (main, 4 distractors) per trial
var attBlockList%[attMaxTrl%];    'A list of which block a trial comes in
var attSetList%[attMaxTrl%];    'A list of which set a trial comes in
var attEasyList%[attMaxTrl%];     '1 if the trial is an easy trial, 0 if not - need to keep track of this because there are no flashers on easy trials
var attCuedLocReturnTime[attMaxTrl%];  'The time the cued location returns to baseline contrast
var attUncuedLocReturnTime[attMaxTrl%];  'The time the uncued location returns to baseline contrast
var attTrialEndTime[attMaxTrl%];  'The time the trial ends
var attCueOnsetList[attMaxTrl%];  'A list of the cue onset time for each trial  - note that for now this is not a variable time, but it might be someday
var attCueOffsetList[attMaxTrl%];  'A list of the cue offset time for each trial  - note that for now this is not a variable time, but it might be someday
var attStimOnsetList[attMaxTrl%];  'A list of the stimulus onset time for each trial  - note that for now this is not a variable time, but it might be someday
var thisContrastCued%;                 'for sampletexty stuff
var thisContrastUncued%;
var fixColor$;                  'more sampletexty stuff
var trialIsCueAll%;              'more sampletexty stuff
var FAIsResponse%;              'if 1, use "response abort", otherwise use regular abort
var expectedAnswer%;            'keeps track of expected answer, saves a bunch of redundant code
var expectedAnswerUncued%;      'we need this for cue-all trials
'For fixation/cue colors, use a master list so we don't get a bunch of values redefined, and have to change them all if a change is made
var masterColorList$[7];  'human readable, updated to hold 6 (1 on-RF, 4 distractor, 1 No-change)
var masterColorListVSG$[7];  'VSG readable
const attMaxFlashers% := 30;  'use a maximum of 30 flashers per trial
var flasherTimes[attMaxTrl%][attMaxFlashers%];  'hold flasher times, this is 2-d because we can have multiple per trial
var flasherX[attMaxTrl%][attMaxFlashers%];  'hold flasher x position
var flasherY[attMaxTrl%][attMaxFlashers%];  'hold flasher y position
var flasherCount%[attMaxTrl%];  'hold number of flashers on each trial
var flasherCountThisTrial%;  'keep track of number of flashers played on the current trial
var CCHappened%;  'keep track of what contrast change(s) happen
var answerWindowCuedHighlighted%;
var answerWindowUncuedHighlighted%;
var cuedResponseWindowCloseTime;
var uncuedResponseWindowCloseTime;
var trialIsCRForDelayBasedReward%;  'This variable is needed because delay-based reward is treated differently for CRs
var ActualRewardDuration%;  'we need to keep track of this
var attFixationOffAtCC%;  'do we want to turn the fixation off early, when the contrast change happens?
var attRequireJoystickResponse%;
var attJoyValue;
var attJoyPos%;
var HBCycle% := 1;

'we need to explicitly know the position of the gratings to place the answer windows on the gratings
var mainX;  'the main grating patch is expected to be the one located over the receptive field
var mainY;
var mainW;
var mainH;
var dist1X;  'there are also four possible distracters, these are set in config
var dist1Y;
var dist1W;
var dist1H;
var dist2X; 
var dist2Y;
var dist2W;
var dist2H;
var dist3X; 
var dist3Y;
var dist3W;
var dist3H;
var dist4X; 
var dist4Y;
var dist4W;
var dist4H;


' Optogenetics variables
var attPreStimOptoTime;
var attPostStimOptoTime;
var attOptoVoltageOut;
var attOptoPropOpto;  'proportion (not percentage) of trials on which we do opto, value is 0-1
var attOptoState% := 0;  'current opto state, will toggle (on a per-trial basis), can set here in dialog box
var attOptoStarted% := 0;  'keeps track of whether the opto is currently on
var attOptoNPulses%;
var attPulsedOptoOnset;
var attPulsedOptoWidth;
var attPulsedOptoIPI;
var attPulsedOptoOnsetClockSteps%;
var attPulsedOptoOffsetClockSteps%;
var attPulsedOptoWidthClockSteps%;
var attPulsedOptoIPIClockSteps%;
var attDoOpto%;                     ' New, 1 if doing optogenetics
var attOptoUsePulse% := 0;  'Are we using a "pulsing stimulation"?
var attLaserDiode% := 0;  'Are we recording the output of the laser using a photodiode?  **disabled**
var attInterBlockTime := 0;        ' New, time between blocks, important for opto  **disabled**
var SequencerPeriodMS;
var OptoCopyChannel%;
var PhotodiodeChannel%;
var UtilityChannel%;


' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;
var JoyChannel%;
var TimingChannel%;

var FrameTriggerChannel%;
var SynchChannel%;  '**disabled**
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' XY window stuff
var XYWindow%;			' 
var iFixChannel%;	' channel number for fixation point in xy window
var iFixationWindowChannel%;' channel number for fixation window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iAnswerWindowChannelMain%;  'channel number for main stimulus answer window display in xy window
var iAnswerWindowChannelDist1%;  'channel number for distracter 1 answer window display in XY window
var iAnswerWindowChannelDist2%;  'channel number for distracter 2 answer window display in XY window
var iAnswerWindowChannelDist3%;  'channel number for distracter 3 answer window display in XY window
var iAnswerWindowChannelDist4%;  'channel number for distracter 4 answer window display in XY window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view


' dummy vars
var iScript%;

'Idle function variables
var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure Penalty time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tAnimationOn:=-1;	' time that stim was turned on. Used to measure spike rates 

' Constants for states
const stateStartTrial%:=0;		                        ' Start trial state
const stateWaitForFixPtOn%:=1;		                    ' Waiting for fixation/cue point return trigger (on)
const stateHoldFixationToStimOn%:=2;		            ' Maintaining fixation with cue color point and lollipops up
const stateWaitForAnimationOn%:=3;		                ' Wait for stimulus return trigger (on)
const stateWaitForAcquisition%:=4;	                    ' Waiting for subject to acquire fixation point
const stateCheckForAnswerThroughAnimation%:=5;		    ' Wait through animaiton looking for response
const stateAbort%:=6;			                        ' Failed trial state
const stateAbortPenalty%:=7;	                        ' time out after failed trial
const stateVSGWait%:=8;		                            ' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=9;		                    ' wait for vsg to send ready signal #2
const stateTrialCompleted%:=10;		                    ' trial has been completed successfully	
const stateWaitForBlank%:=11;
const stateBlockCompleted%:=12;
const stateStartBlock%:=13;
const stateTrialCompletedWaitForBlank% := 14;
const stateTrialCompletedPause% := 15;
const stateFalseAlarmPenalty% := 16;
const stateMiss% := 17;
const stateCheckTurnOnOpto% := 18;
const stateRequestStimulus% := 19;
const stateStartOpto% := 20;
const statePulsedOpto% := 21;
const stateWaitOptoPrestim% := 22;
const stateCheckTurnOffOpto% := 23;
const stateTurnOffOpto% := 24;
var iState% := stateVSGWait%;	' present state

'const trialtypeAttendToward% := 100;
'const trialtypeAttendAway% := 101;
'const trialtypeCueAll% := 102;
var trialType%;  'this variable is not doing anything right now...?
var nTrialsCompleted%:=0;
var nTrialsRewarded%:=0;
var nTrialsThisBlock%:=0;
var nTrialsThisBlockCompleted%:=0;
var nBlocksCompleted%:=0;
var iAnswer%;
var trialCatch%;  'need to update the logic for this one
var trialIsTarget%;
var trialAttendLoc%;
var trialHazardFunctionTimeCued;
var trialHazardFunctionTimeUncued;
var tOpt;
var queueReward% := 0;

var attNumWavemarks%;
var attNumContinuous%;
var attWavemarkPorts%[64];
var attContinuousPorts%[64];

UseTwo1401s% := DoWeUseTwo1401s%();
GetPortsAndNumWMsWFs%(attNumWavemarks%,attNumContinuous%,attWavemarkPorts%[],attContinuousPorts%[]);



' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif

'we're going to muck with reward so that Henry can have a "high reward" and a "low reward"
'I hate to do it this way, but I think that the alternative of doing it in the config is even
'worse.  This way, we simply override the config value, but only for the low-reward state. 
'For the high-reward state we still use the config value.  It's not pretty, but it keeps
'everything from cascading into a comedy of errors in other scripts.
'get original reward value from config
origRewardMS% := GetJuiceRewardMS%();

'Joystick channel/port must be set before the main script
JoyChannel% := 35;
InitJoystick2(JoyChannel%,GetJoystickPort%()); 'now calls InitJoystick2 - we must do this BEFORE calling the main dialog
printlog("joystick channel is %d\n",jsChannelNumber%);

' run main script dialog
iScript% := AttentionScriptDialog%();
if iScript% <> 1 then
	PrintLog("User cancel - exit gracefully\n");
	Halt;
endif;



' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 23;
YChannel% := 24;
FrameTriggerChannel% := 25;
FixationPointChannel% := 26;
StimChannel% := 27;
StimChangeChannel% := 28;
ReadyChannel% := 29;
SynchChannel% := 36;
PhotodiodeChannel% := 33;
UtilityChannel% := 34;
TimingChannel% := 35;
OptoCopyChannel% := 49;




ExcludedChans%[0] := 23;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 49;  'OptoCopyChannel is highest non-electrode channel used by this function




'If we are not using the Plexon (and thus linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the Plexon setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401 (the second, non-dominant instance of Spike2) FIRST and on the MICRO 1401 (the first, 
'dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run the VSG program (Fixstim) which gives
'the sampling trigger and sets the experiment in motion.
if UseTwo1401s% = 0 then
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();

    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()
    
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	UpdateToolbarText();
    if UseTwo1401s% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    'placeholder, not using '6' separates Quit from other functions
    'but
    if attRequireJoystickResponse% = 1 then
        ToolbarSet(6,"Adjust Joystick",CallJoystickConfigDialog%);
    endif;
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);
    
end;




proc InitializeWindows()
        
	'Open the data sampling window
	DataWindow% := FileNew(0,4);  'show spike shape setup dialog
    printlog("datawindow is %d\n",dataWindow%);
	Window(0,48,100,95);
	View(DataWindow%).WindowVisible(1);
    
    if UseTwo1401s% = 1 then
        'Get the name of the most recent .s2r resource file, if any
        var key$;
        var fn$;
        key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
        fn$ := GetStringRegistryValue$(key$, "microS2Rfile", "x");
        printlog("S2R file name %s was retrieved from registry\n",fn$);
        
        'Apply the ,s2r resource file to the current data window, which will apply the spike shape templates
        if fn$ <> "x" then  'OK, Henry says no checkbox necessary, just load up every time 
            FileApplyResource(fn$);
            printlog("S2R file name %s was loaded using FileApplyResource\n",fn$);
        endif
    endif;
    

    
	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
    
	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;
    
	'Create a new channel in the XY view to display the fixation window
	iFixationWindowChannel% := XYSetChan(0);
	XYColour(iFixationWindowChannel%,13);
	XYDrawMode(iFixationWindowChannel%,2,1);
	XYJoin(iFixationWindowChannel%,1);
	'Draw the fixation window
	XYAddData(iFixationWindowChannel%, FixWindowX[], FixWindowY[]);
    
    
    'get locations of stimuli so that answer windows overlap them
    ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"),mainX,mainY,mainW,mainH); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"),dist1X,dist1Y,dist1W,dist1H);
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor2"),dist2X,dist2Y,dist2W,dist2H); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor3"),dist3X,dist3Y,dist3W,dist3H); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor4"),dist4X,dist4Y,dist4W,dist4H);     
    
    'Not sure if Henry wants this feature
    'If we are getting our grating parameters from the main stimulus, get ONLY the X and Y position and NOT the width/height, match W/H to main grating
    if attGetGPFromMainStim% = 1 then
        dist1W := mainW;
        dist1H := mainH;
        dist2W := mainW;
        dist2H := mainH;
        dist3W := mainW;
        dist3H := mainH;
        dist4W := mainW;
        dist4H := mainH;
    endif;
    
    'And finally, override answer window size if specified answer window is positive
    'if attAnswerPointWindowRadius > 0 then
    '    mainW := attAnswerPointWindowRadius;
    '    mainH := attAnswerPointWindowRadius;
    '    dist1W := attAnswerPointWindowRadius;
    '    dist1H := attAnswerPointWindowRadius;
    '    dist2W := attAnswerPointWindowRadius;
    '    dist2H := attAnswerPointWindowRadius;
    '    dist3W := attAnswerPointWindowRadius;
    '    dist3H := attAnswerPointWindowRadius;
    '    dist4W := attAnswerPointWindowRadius;
    '    dist4H := attAnswerPointWindowRadius;
    'endif;
    
    
    'Create new channels in the XY view to display the answer windows
    'Main stimulus window
    for index% := 0 to 35 do
        FixWindowX[index%] := mainX + mainW * Cos(index% * twopi/36.0);
		FixWindowY[index%] := mainY + mainH * Sin(index% * twopi/36.0);
	next;
    iAnswerWindowChannelMain% := XYSetChan(0);
    XYColour(iAnswerWindowChannelMain%,13);
	XYDrawMode(iAnswerWindowChannelMain%,2,1);
	XYJoin(iAnswerWindowChannelMain%,1);
	'Draw the answer window
	XYAddData(iAnswerWindowChannelMain%, FixWindowX[], FixWindowY[]);
    

    'Distracter1 window
    if attNumPatches% > 1 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist1X + dist1W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist1Y + dist1H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist1% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist1%,13);
        XYDrawMode(iAnswerWindowChannelDist1%,2,1);
        XYJoin(iAnswerWindowChannelDist1%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist1%, FixWindowX[], FixWindowY[]);
    endif;
       
    'Distracter2 window
    if attNumPatches% > 2 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist2X + dist2W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist2Y + dist2H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist2% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist2%,13);
        XYDrawMode(iAnswerWindowChannelDist2%,2,1);
        XYJoin(iAnswerWindowChannelDist2%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist2%, FixWindowX[], FixWindowY[]);
    endif;    
    
    'Distracter3 window
    if attNumPatches% > 3 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist3X + dist3W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist3Y + dist3H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist3% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist3%,13);
        XYDrawMode(iAnswerWindowChannelDist3%,2,1);
        XYJoin(iAnswerWindowChannelDist3%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist3%, FixWindowX[], FixWindowY[]);
    endif;
    
    'Distracter4 window
    if attNumPatches% > 4 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist4X + dist4W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist4Y + dist4H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist4% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist4%,13);
        XYDrawMode(iAnswerWindowChannelDist4%,2,1);
        XYJoin(iAnswerWindowChannelDist4%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist4%, FixWindowX[], FixWindowY[]);
    endif;    
    
    
    
    
	'Create a new channel in the XY view to display the fixation point
	iFixChannel% := XYSetChan(0);
    
	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
	XYAddData(iMonitorChannel%,-9,-7);
	XYAddData(iMonitorChannel%,9,-7);
	XYAddData(iMonitorChannel%,9,7);
	XYAddData(iMonitorChannel%,-9,7);
    
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
    var key$;
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    var primaryTxt$;
    var secondaryTxt$;
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
    SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!

    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    DoSampleAutoName(key$,"atn","atn",primaryTxt$,secondaryTxt$);
    SampleAutoFile(1);  'Enable automatic file naming
    
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
	'----Event Channel recording definitions----
	SampleEvent(FrameTriggerChannel%,0,2,3600); 'Trigger channel, level
	SampleComment$(FrameTriggerChannel%,"Frame");
	SampleTitle$(FrameTriggerChannel%,"Frame");
    
    ' Synch channel for checking synchronization.  Synch is good down to the microsecond.  Have to change 
' Edit->Edit Preferences->Sampling->Event Ports 0 and 1 on rear digital... to unchecked or it won't work    
'   SampleEvent(SynchChannel%,??,2,3600); 'Synch channel, level
'	SampleComment$(SynchChannel%,"Synch");
    '	SampleTitle$(SynchChannel%,"Synch");
    
    SampleEvent(ReadyChannel%,1,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
 	SampleEvent(FixationPointChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	
    
   
	
    '----Analog, non-spiking electrode recording conditions
    
    'We will record eye position no matter what, GetEyeX(Y)Port% will note if the port is not defined in Config->DAQ
    SampleWaveform(XChannel%,GetEyeXPort%(),1000);
	SampleTitle$(XChannel%,EyeXPortLabel$);
    SampleWaveform(YChannel%,GetEyeYPort%(),1000);
	SampleTitle$(YChannel%,EyeYPortLabel$);
    
    'Add a waveform channel for efference copy, only if defined in Config->DAQ
    if attOptoUsePulse% = 1 and attDoOpto% = 1 and OptoEffCopyPort% > -1 then
        SampleWaveform(OptoCopyChannel%,OptoEffCopyPort%,5000);  'This is 30000 Hz on the acute, but Henry has been using 5000, so...
        SampleTitle$(OptoCopyChannel%,OptoPortLabel$);
    endif;
    
    if PhotodiodePort% > -1 then
        SampleWaveform(PhotodiodeChannel%,PhotodiodePort%,30000);
        SampleTitle$(PhotodiodeChannel%, PhotodiodePortLabel$);
    endif;
    
    if UtilityPort% > -1 then
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);  
        SampleTitle$(UtilityChannel%, UtilityPortLabel$);
    endif;

    'Create joystick channel, but only if the joystick is actually present
    if attRequireJoystickResponse% = 1 then  
        printlog("Joy channel is %d and joystick port is %d\n", JoyChannel%, GetJoystickPort%());
        var ok%;
        ok%:=SampleWaveform(JoyChannel%, GetJoystickPort%(), 1000);
        SampleTitle$(JoyChannel%, JoystickPortLabel$);
    endif;
    if ok% < 0 then
        printlog("Error opening joystick channel: %s\n",Error$(ok%));
    endif;
    
    'Add a digital marker channel for pulsing optogenetics
    'Do it for every opto, easy enough to add this into the wraparound calls in the PLS
    'Will record a '1' for laser on and a '0' for laser off
    'Will record a '101' for eyetracker timing pulses.
    'Note that Opto and eyetracker output are not exclusive.  If both, the channel will be
    'labeled as the laser channel, but both pulses will be present.
    docase
    case attDoOpto% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Laser On");  'Digital marker is by definition channel 32
    case RecordEyeTrackerOutputFile% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"EyeFilePulse");  'Digital marker is by definition channel 32
    case UseTwo1401s% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Timing");  'Digital marker is by definition channel 32    
    endcase
    
    if UseTwo1401s% = 1 then
        SampleEvent(TimingChannel%, 6, 2, 3600); 'Trigger channel, level
        SampleComment$(TimingChannel%,"Handshake");
        SampleTitle$(TimingChannel%,"Hndshk");
    endif;

    
    
    
    '----Set up "spiking" Electrode Channels----
    SetUpElectrodeConfiguration(attNumWavemarks%,ExcludedChans%[]);
    
    
	SampleTextMark(200);  'increase number of allowed characters to 200
    
    if UseTwo1401s% = 0 then
        SampleSequencer(script$ + "Tuning.pls");
    else
        SampleSequencer(script$ + "TuningSendTrigger.pls");
    endif;

    DoSampleOptimise();
	SampleMode(1); 'Continuous sampling
end;





func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    fp$ := SetPathToScriptDirectory$();
    
    'These two functions are not done before initializing the toolbar in dual-1401 mode
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();
    
    StartSecondInstanceOfSpike2();
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var Extras$;
	var Tune$;
	var Stim$:="";
    var ttemp;
    var stimSpec$;
    var dist1Spec$;
    var dist2Spec$;
    var dist3Spec$;
    var dist4Spec$;
    var flasherSpec$;
    var lolSpec$;  'LOLlerskates!  ROFLcopter!
    var x;
    var i%;
    var specFileName$:=GetWorkPath$() + "\\AttentionSpecFile.txt";
    var specHandle%;
    var spec2FileBase$;
    var spec2FileName$;
    var spec2Handle%;
    var contrastHandle%;
    var c$;
    var CueCirc$;  'this begins blank, if we don't use cue circles then it won't get filled
    'var tOff;  'holds the offset time for calculation of flasher times
    'vars for opto setup
    var voltageInteger%;
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;
    var ContrastFileWithFlag$;
    var startSecs := 5;
    var pulseFound%;
    var tRise;
    var tFall;
    
	
    'hard code pReward to 1, per Henry
    pReward := 1;
   
  
    'start sampling
    if UseTwo1401s% = 1 then
        SampleStart(0);  'Set sampling to start immediately
        Yield(0.5);  'Wait half a second
        'Look for handshake, unless disabled
        while pulseFound% < 1 and startSecs > 0 and Dual1401IgnoreHandshake% = 0 do
            pulseFound% := View(DataWindow%).FindPulseUp%(TimingChannel%, 0, tRise, tFall);
            yield(0.1);
            startSecs := startSecs - 0.1;
        wend
        'Send timing pulse
        SafeSampleKey("T");     
    else
    	SampleStart(0); 'Start sampling now
    endif;
    
    if startSecs <= 0 then
        message("Handshake not found in 5 seconds!  Quitting!");
        halt
    endif

    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
    
    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");  'this is DIGOUT
    SafeSampleKey("Z");  'this is DIGLOW
    ttemp := View(DataWindow%).MaxTime();
    Yield();
    tLast := View(DataWindow%).MaxTime();
    PrintLog("ttemp " + str$(ttemp) + " tlast " + str$(tLast) + "\n");
    
    
    if attRequireJoystickResponse% = 1 then
        'Change offset of joystick channel
        View(DataWindow%).ChanOffset(JoyChannel%,joystickOffset);  'use value from registry
        
        'Set value of right/left joystick
        GetJoystickParameters();  'now we run the joystick functions from Sperka, should work smoothly
        DisplayJoystickParameters();
        
        'set YRange for JoyChannel
        View(DataWindow%).YRange(JoyChannel%,0,1);
    endif;
    
    if attDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable. Use vdac32% to get the right value.
        voltageInteger% := vdac32%(attOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
        printlog("Voltage integer is %d\n",voltageInteger%);
        
        'If pulsing, set sample sequencer variables
        if attOptoUsePulse% = 1 then  'yes, this is the same "if" as above, just seems cleaner this way
            'Warn that pulsing opto is untested under the most recent AttenGNG code.
            'Henry's intention is to never use it, but never say never.  This Message() should prevent
            'users from trying it without testing it first.  If testing is successful, then remove message.
            'The basic idea here is that the code which does the calculations of pulses per trial and 
            'remaining time is being done on a trial-by-trial basis (in PrepareTrial) rather than once
            'for the entire experiment.  Before, trials were expected to be *about* the same duration, so
            'we calculated the number of pulses based on the longest trial and enforced that.  Now trial
            'duration may be a bit more variable, so we want to calculate the number of pulses on each trial.
            'This might actually work out of the box, but I wouldn't want to rely on it.
            message("Pulsing Opto has been semi-deprecated!\nNot tested under new AttenGNG scheme!\nShould probably be tested before use!");
            
            'Number of pulses now set on each trial
            'SampleSeqVar(6,attOptoNPulses%);  'set number of pulses
            'printlog("Opto N pulses is %d\n",attOptoNPulses%);
            'For below calculations, the standard numbers we are getting are in seconds, sequencer period is in MS (because that's how it comes)
            
            tempSeqVarValue := attPulsedOptoWidth*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-2;  'now convert to integer, subtract two ticks for sequencer instructions
            SampleSeqVar(7,tempSeqVarValue%);  'set duration of pulse in clock ticks
            printlog("Opto width is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := attPulsedOptoIPI*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
            SampleSeqVar(8,tempSeqVarValue%);  'set interpulse interval in clock ticks
            printlog("Opto IPI width is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := attPulsedOptoOnset*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-1;  'now convert to integer, subtract one tick for sequencer instructions
            SampleSeqVar(9,tempSeqVarValue%);  'set pre-pulse stimulus duration in clock ticks
            printlog("Opto onset is %d\n",tempSeqVarValue%);
            
            'Time remaining now set on each trial
            'tempSeqVarValue := stimTimeRemaining*1000/SequencerPeriodMS;  'do math in float
            'tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
            'SampleSeqVar(10,tempSeqVarValue%);  'set post-pulse stimulus duration in clock ticks
            'printlog("Opto remaining time is %d\n",tempSeqVarValue%);
        endif;
        
    endif;
    
    
    
    
    if attUseCueCircles% > 0 then
        'CueCirc$ := CreateCueCircleColorSets$();
        CueCirc$ := CreateCueCircleColorSetsLite$();  'Lite version only creates one set of cue circles, no rotation
        'printlog("Cue circles list is: %s\n",CueCirc$);
    endif;
    
    'get all these grating parameters
    stimSpec$ := GetGratingParameters$("Stimulus");
    ParseGratingParametersBrief%(stimSpec$, xT, yT, wT, hT);  'we may as well just do this every time - 90+% of the time we will anyway, and why put it in the if statements four times?
    if attNumPatches% > 1 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"), xT, yT, wT, hT);
            dist1Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);  'for helping placement of flashers, etc.
        else
            dist1Spec$ := GetGratingParameters$("Distractor1");
            ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);
        endif;
    endif;
    if attNumPatches% > 2 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor2"), xT, yT, wT, hT);
            dist2Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist2Spec$, xD2, yD2, wD2, hD2);  
        else
            dist2Spec$ := GetGratingParameters$("Distractor2");
            ParseGratingParametersBrief%(dist2Spec$, xD2, yD2, wD2, hD2);
        endif;
    endif;
    if attNumPatches% > 3 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor3"), xT, yT, wT, hT);
            dist3Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist3Spec$, xD3, yD3, wD3, hD3); 
        else
            dist3Spec$ := GetGratingParameters$("Distractor3");
            ParseGratingParametersBrief%(dist3Spec$, xD3, yD3, wD3, hD3);
        endif;
    endif;
    if attNumPatches% > 4 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor4"), xT, yT, wT, hT);
            dist4Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist4Spec$, xD4, yD4, wD4, hD4); 
        else
            dist4Spec$ := GetGratingParameters$("Distractor4");
            ParseGratingParametersBrief%(dist4Spec$, xD4, yD4, wD4, hD4);
        endif;
    endif;

    
    
    if attCustomGratingColorCheck% = 1 then
        var f$, t$;
        f$ := EncodeColor$(attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2]);
        stimSpec$ := ReplaceGratingColorVector$(stimSpec$, f$ + "-" + t$);
        f$ := EncodeColor$(attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
        if attNumPatches% > 1 then
            dist1Spec$ := ReplaceGratingColorVector$(dist1Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 2 then
            dist2Spec$ := ReplaceGratingColorVector$(dist2Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 3 then
            dist3Spec$ := ReplaceGratingColorVector$(dist3Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 4 then
            dist4Spec$ := ReplaceGratingColorVector$(dist4Spec$, f$ + "-" + t$);
        endif;
    endif

    
	Stim$ := " -s " + stimSpec$;  
    if attNumPatches% > 1 then
            Stim$ := Stim$ + " -s " + dist1Spec$;
    endif;
    if attNumPatches% > 2 then
            Stim$ := Stim$ + " -s " + dist2Spec$;
    endif;
    if attNumPatches% > 3 then
            Stim$ := Stim$ + " -s " + dist3Spec$;
    endif;
    if attNumPatches% > 4 then
            Stim$ := Stim$ + " -s " + dist4Spec$;
    endif;
    
    if attUseFlashers% = 1 then
        flasherSpec$ := GetGratingParameters$("Flasher");
        ParseGratingParametersBrief%(flasherSpec$, xF1, yF1, wF1, hF1);
        Stim$ := Stim$ + " -k " + flasherSpec$;  'This specifies flasher #0, the VSG side software allows more flasher gratings to be spec'ed but as of now we will only use one
    endif;
    
    
    'run ScreenBounds to get max size of x/y on screen, to be used to make flashers in random locations
    ScreenBounds(screenXmm,screenYmm,screenXmax,screenYmax);
      

    CreateContrastList(c$,Flashers$,attIsCueAll%[],attCuedLocList%[],attCuedLocChangesList%[],attContrastCuedList%[],attCuedLocCCTime[],
        attCuedLocReturnTime[],attUncuedLocList%[],attUncuedLocChangesList%[],attContrastUncuedList%[],attUncuedLocCCTime[],attUncuedLocReturnTime[],
        attTrialEndTime[],attFixColor%[],attCueCircleColor%[][],attOffBitsList%[],attBlockList%[],attSetList%[],attEasyList%[]);',
        'flasherTimes[][],flasherX[][],flasherY[][],flasherCount%[])  
    
    'Write contrast file, pulling this out of CreateContrastList so we only have to write once
    contrastHandle% := FileOpen(ContrastFile$, 8, 1);
    'print constructed contrast string to file
    Print("%s",c$);
    'close contrast file
	FileClose(0);
    
    ContrastFileWithFlag$ := " -n " + ContrastFile$; 'add flag to string containing loc of ContrastFile
    
    
    'Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$() + " -A " + str$(attAnswerPointOffset) + " -D " + str$(attAnswerPointDiameter) + lolSpec$;  'answer points on
    Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$() + " -p 2 "; '+ " -N ";' + lolSpec$;  'answer points off, lollipop spec off as well
    'if attTrainingContrastCheck% = 1 then
    '    Extras$ := Extras$ + " -T " + str$(attTrainingContrastPct%);
    'endif
    
    'Hardcode the choice points to be red no matter what
    'Turns out that for the attention program the color in the fixation argument sets the color of the choice
    'points but that the actual fixation point is set differently.  FixationArg$ is created at the outset of
    'the script, but here I'm overriding the value to make the choice points always red.
    FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + ",red";    
    
    ' djs Update this to use remote stim when configured
    if GetUseRemoteStimulus%() = 1 then
        CommandLine$ := "cmd /k " + GetBinDir$(1) + "remote.exe " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim -F " + specFileName$;
    else
        CommandLine$ := "cmd /k " + GetBinDir$(1) + "fixstim.exe -F " + specFileName$;
    endif
    
    
    'open a file to write the trial-by-trial specs for the VSG
    specHandle% := FileOpen(specFileName$, 8, 1);
    'print to spec file
    if attUseFlashers% = 1 then
        Print("%s %s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Flashers$,ContrastFileWithFlag$);  'file should be everything starting from FixationArg$ on, use flashers, Flashers$ must come before ContrastFile$!
    else
        Print("%s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,ContrastFileWithFlag$);  'file should be everything starting from FixationArg$ on
    endif;    
    'close spec file
	FileClose(0);
    
    'Print the parameters
    for i% := 1 to Len(CommandLine$) step 100 do
        SampleText(Mid$(CommandLine$, i%, 100));
    next
    
    'Save the spec file/contrast file in a secondary, permanent location
    'added specfile write because this is not retained anywhere, for debug and in case of crash
    ' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	spec2FileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
    spec2FileName$ := spec2FileBase$ + ".spc";
	PrintLog("spec filename is " + specFileName$ + "\n");
	spec2Handle% := FileOpen(spec2FileName$, 8, 1);
    if attUseFlashers% = 1 then
        Print("%s %s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Flashers$,ContrastFileWithFlag$);  'file should be everything starting from FixationArg$ on, use flashers
    else
        Print("%s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,ContrastFileWithFlag$);  'file should be everything starting from FixationArg$ on
    endif; 
    'Close specfile
    FileClose(0);
    'And copy contrast file to new location
    spec2FileName$ := spec2FileBase$ + ".con";
	PrintLog("contrast filename is " + ContrastFile$ + "\n");
    FileCopy(ContrastFile$,spec2FileName$);
    
	
    
	'Begin the stimulus program. 
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then 
        Message("Could not start stimulus."); 
        halt; 
    endif

	
    'If we are asking the eyetracker to record an output file, open the file and start recording
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("I");  'Open the file (this is done by setting a DIGLOW bit), file name will be saved in a sampletext
        yield(0.5);
        SafeSampleKey("W");  'Begin recording the file
        yield(0.5);
    endif
    
    
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);  'Enable stop
	ToolbarEnable(1,0);  'Disable start
	ToolbarEnable(7,0);  'Disable quit
	View(DataWindow%);
	Yield(.1);
    return 1;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
    Pause% :=1;
    ToolbarEnable(4,0);  'Disable Pause
    ToolbarEnable(5,1);  'Enable Resume
    return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
    Pause% :=0;
    ToolbarEnable(4,1);  'Enable Pause
    ToolbarEnable(5,0);  'Disable Resume
    return 1;
end



  
    
' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, mylen%;
    var fn$;
    var chanToExport%[30];  'Henry does not want autoexport to Matlab
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    ' Save the current resource file - might be causing problems
    'FileSaveResource(1);   
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if attDoOpto% = 1 then
        SafeSampleKey("o");
    endif;
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
	' Tell stim app to shut down
	SafeSampleKey("Q");
	Yield(.1);
    
    'Stop sampling
	SampleStop();
    
	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
    
    ' Increment daily totals and save then
	TotalTrials% += nTrialsCompleted%;
	TotalRewards% += nTrialsRewarded%;
	SaveDailyTotals();
    
 
    ' Write parameter file
	WriteParameterFile();
    
    if UseTwo1401s% = 1 then
        ' Save most recent .s2r file name to registry
        fn$ := Left$(fn$,mylen%-4);
        if Right$(fn$,1) = "." then  'if the file is an .smrx, we need to adjust further
            fn$ := Left$(fn$,Len(fn$)-1);
        endif;
        fn$ := fn$ + ".s2r";
        var key$;
        key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
        SetStringRegistryValue(key$, "microS2Rfile", fn$);
        printlog("S2R file name %s was saved to registry\n",fn$);
    endif;
    
    
end;




func IdleProcessing%()
	var iStatus% := 1;	
    var tempanswer%;
    var temptext$;
    
    'The trick here is that sometimes sampling isn't caught up on all channels.  MaxTime() may return a lower
    'value than MaxTime(ChanN%). When we find a trigger and try to place a TextMark, SampleText will do an internal
    'call to MaxTime() - no channel # - to determine whether to place it at the requested time or at MaxTime().
    'In some instances, this has resulted in the TextMark being placed earlier than the event which caused it.
    'We are now explicitly checking for this - if we find it, we have to avoid updating tLast and continue checking
    'in order to not miss the trigger AND to put the TextMark at the right time.
    'Note that we will ONLY do the additional check in instances where a timed TextMark is being placed at the 
    'time of the trigger.
    var updateTLast% := 1;  'due to trigger issues, we may not always update tLast (but we usually will)
    
    
    tNow := View(DataWindow%).MaxTime();
    
    'get eye position, but don't check if tNow is small enough that we would give a negative value to ChanMeasure
    if tNow > .006 then
        xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
        yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
    endif;
        
    ' Don't update display every time....
    if tNow-tLastUpdate > .005 then
        View(XYWindow%).XYAddData(1,xEye,yEye);
        tLastUpdate := tNow;
    endif
    
    
    docase 
    case Pause% = 1 then
        'Pause...just sit here and wait for the enable button to be pressed!
    case iState% = stateVSGWait% then
        
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        tTrigger := View(DataWindow%).NextTime(ReadyChannel%, tLast, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 0 then
            PrintLog("state stateVSGWait: Got leading edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
        endif;
        
    case iState% = stateVSGWaitConfirm% then
        
        ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
        tTrigger := View(DataWindow%).NextTime(ReadyChannel%, tLastTrigger, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 1 then
            PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateStartBlock%, tTrigger);
            if RecordEyeTrackerOutputFile% = 1 then
                'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
                SafeSampleKey("1");
                yield(0.2);
            endif;
        endif;
        
        
    case iState% = stateStartBlock% then
        
        PrepareBlock();  'PrepareBlock() does not do much now, it simply printlogs that a block is starting
        ChangeStateTo(stateStartTrial%, tNow);
        
    case iState% = stateStartTrial% then
        
        ' Start trial. Put up fixation point.
        UpdateToolbarText();
        PrepareTrial();
        attCountAllTrials% += 1;
        
        'put timing marker in both eyetracker file, smr file
        if RecordEyeTrackerOutputFile% = 1 then
            'SafeSampleKey("1");
            docase
            case HBCycle% = 1 then
                SafeSampleKey("1");
            case HBCycle% = 2 then
                SafeSampleKey("2");
            case HBCycle% = 3 then
                SafeSampleKey("3");
            case HBCycle% = 4 then
                SafeSampleKey("4");
            case HBCycle% = 5 then
                SafeSampleKey("5");
            case HBCycle% = 6 then
                SafeSampleKey("6");
            case HBCycle% = 7 then
                SafeSampleKey("7");
            endcase
            HBCycle% += 1;  'increment HBCycle%
            if HBCycle% = 8 then  'and cycle when necessary
                HBCycle% := 1;
            endif
            yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
        endif;
        
        
        PrintLog("Request Fixation Point\n");
        SafeSampleKey("F");
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
        
        
    case iState% = stateWaitForFixPtOn% then
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        docase
        case tTrigger > tLast then 'we have found a trigger
            if tTrigger < tNow then    'View(DataWindow%).MaxTime() then  'try using tNow to avoid rare double-catch
                ' Fixation point is up
                PrintLog("stateWaitForFixPtOn: signal received. " + str$(tTrigger) + "\n");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateWaitForAcquisition%, tTrigger);
                SampleText("Fixation point on",tTrigger);
                DrawFix(1);	' this draws the location of the fixpt.
            else
                updateTLast% := 0;  'waiting for sampling to catch up
            endif;
        case tNow > tLast + 5 then
            PrintLog("Waited 5 seconds for fixation point, trying again!\n");
            SampleText("Waited 5 seconds for fixation point, trying again!",tNow);
            SafeSampleKey("X");
            yield(1.0);
            attCountAllTrials% -= 1;  'we would need to decrement if this happened
            ChangeStateTo(stateStartTrial%, tNow);
        endcase
        updateTLast% := 0;  'don't update tLast, we're waiting for this trigger
        
        
    case iState% = stateWaitForAcquisition% then
        ' Waiting for eye to fall inside of fixation window
        docase
        case Looking%(xEye, yEye) = 1 then
            PrintLog("stateWaitForAcquisition: eye in fixation window.\n");
            SampleText("Fixation Acquired",tNow);
            ChangeStateTo(stateHoldFixationToStimOn%, tNow);
'        case attUseCueCircles% >= 2 and LookingAtCuePoint%(xEye, yEye, 1) <> 0 then  'using a hardcoded radius of 1 degree, only check if we are using cue points
'            'Simple abort on acquisition of cue point instead of fixpt.  Note that IF fixpt window and cue point windows overlap, priority is given to the fixpt window...
'            PrintLog("stateWaitForAcquisition: eye in cue circle window, aborting trial.\n");
'            ChangeStateTo(stateAbort%, tNow);
'            SampleText("Animal Fixated Cue Circle, Trial Aborted",tNow);
        else 
            if tNow - tStateStart > attAcquisitionTime then  'simple abort on failure to acquire
                PrintLog("stateWaitForAcquisition: failed.\n");
                ChangeStateTo(stateAbort%, tNow);
            endif
        endcase
        
        
        
    case iState% = stateHoldFixationToStimOn% then
        
        ' Eye must remain inside of fixation window
        docase
        case Looking%(xEye, yEye) = 1 then
            if tNow - tStateStart > attFixationTime then
                if attRequireJoystickResponse% = 1 then
                    attJoyPos% := GetJoystickPositionUD%(attJoyValue);  'Joy value is filled as secondary output, not used as an input
                    if attJoyPos% = JSDown% then
                        ChangeStateTo(stateCheckTurnOnOpto%, tNow);
                        PrintLog("stateHoldFixationToStimOn: Success with fixation and joystick. Checking to see if we do opto...\n");
                    else
                        'Waiting for joystick down, do not change state
                    endif
                else
                    ChangeStateTo(stateCheckTurnOnOpto%, tNow);
                    PrintLog("stateHoldFixationToStimOn: Success. Checking to see if we do opto...\n");
                endif
            endif
        else 'if fixation fails before stim on, consider this an abort
            PrintLog("stateHoldFixationToStimOn: failed.\n");
            ChangeStateTo(stateAbort%, tNow);
        endcase
        
        
    case iState% = stateCheckTurnOnOpto% then
        docase
        case attdoOpto% = 0 then 'if this is not an opto trial, just start it
            ChangeStateTo(stateRequestStimulus%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",attDoOpto%,attOptoState%,tNow);
        case attOptoUsePulse% = 1 and attOptoState% = 0 then 'if this is a pulsed opto scenario, but not an opto trial, just start it
            'This is the same as the above step, separated to make the logic of the case statement easier
            ChangeStateTo(stateRequestStimulus%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",attDoOpto%,attOptoState%,tNow);
        case attOptoUsePulse% = 1 and attOptoState% = 1 then  'it is a pulsed opto trial, the sequencer will time this
            ChangeStateTo(statePulsedOpto%,tNow);
        else 'otherwise it is a wraparound opto trial and we need to turn opto on
            ChangeStateTo(stateStartOpto%, tNow);
            printlog("Turning Opto On at time = %f\n",tNow);
        endcase   
        
        
    case iState% = stateStartOpto% then
        if attOptoState% = 1 then 'this is an opto-on trial
            SafeSampleKey("O");  'turn on opto
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("OptoOn",tOpt);
            attOptoStarted% := 1;
        else 'this is an opto-off trial
            SafeSampleKey("N");  'don't turn on opto    'this seems pointless - the real thing is we have to wait the same amount of time as for wraparound
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("NoOpto",tOpt);
        endif;
        
        ChangeStateTo(stateWaitOptoPrestim%, tNow);   
        
        
    case iState% = stateWaitOptoPrestim% then
        if tNow > tStateStart + attPreStimOptoTime then
            ChangeStateTo(stateRequestStimulus%, tNow);
        endif;        
        
        
    case iState% = statePulsedOpto% then
        SafeSampleKey("P");  'start pulsed opto, the whole sequence is controlled by the sequencer, this does the "S" implicitly
        tOpt := View(DataWindow%).MaxTime();
        SampleText("Pulsed Opto on",tOpt);
        printlog("Started pulsed opto for trial at %f\n",tOpt);
        attOptoStarted% := 2;  'use a different number to keep track here, if pulsed opto is going, we can't use any SafeSampleKeys until it is stopped
        ChangeStateTo(stateWaitForAnimationOn%, tOpt);
        
        
    case iState% = stateRequestStimulus% then

        ' Start trial. Put up stimulus.
        LogStatus("StartTrial", "Request stimulus");
        SafeSampleKey("S");  'request stimulus  
        ChangeStateTo(stateWaitForAnimationOn%, tNow); 
        
        
    case iState% = stateWaitForAnimationOn% then
        tTrigger := View(DataWindow%).NextTime(StimChannel%, tLast, vTrigger);
        docase
        case tTrigger > tLast and vTrigger = 0 then
            if tTrigger < tNow then         'View(DataWindow%).MaxTime() then   'try using tNow to avoid rare double-catch
                ' gratings et al are up
                PrintLog("stateWaitForAnimationOn: Animation is up.\n");
                tAnimationOn := tTrigger;
                tLastTrigger := tTrigger;
                ChangeStateTo(stateCheckForAnswerThroughAnimation%, tTrigger);
                'In below sampletext, can change hazard time (currently relative to grating onset) to relative to animation onset with simple uncomment in PrepareTrial()
                SampleText("Animation on, Fixation color " + fixColor$ + ", Base contrast " + Str$(attContrastBase%) + ", hazard dur " + Str$(trialHazardFunctionTimeCued) + ", hazard dur2 " + Str$(trialHazardFunctionTimeUncued)
                + ", attend location " + Str$(trialAttendLoc%) + ", change location " + Str$(expectedAnswer%) + ", change contrast " + Str$(thisContrastCued%) + ", is Cue-All trial: " + Str$(trialIsCueAll%),tTrigger);
                
                'If there should be no response, change fixation window now?
                if trialIsTarget% = 0 then
                    view(XYWindow%).XYColour(iFixationWindowChannel%,16);  'Change fixation window to red
                endif;
                'and we need to reset these variables, as they now hold states we need to keep track of over time
                CCHappened% := 0;
                answerWindowCuedHighlighted% := 0;
                answerWindowUncuedHighlighted% := 0;
                
            else
                updateTLast% := 0;  'waiting for sampling to catch up
            endif;
        case tNow > tLast + 5 then
            PrintLog("Waited 5 seconds for animation on, giving up and starting trial over!\n");
            SampleText("Waited 5 seconds for animation on, giving up and starting trial over!",tNow);
            SafeSampleKey("X");
            yield(1.0);
            attCountAllTrials% -= 1;  'we would need to decrement if this happened
            ChangeStateTo(stateStartTrial%, tNow);
        endcase
        updateTLast% := 0;  'waiting for a trigger, don't update tLast
        
        
    case iState% = stateAbort% then
        
        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        PrintLog("stateAbort: send X key.\n");
        docase
        case attOptoStarted% = 2 then  'it is a pulsed opto trial and we have started the opto
            'on a pulsed opto abort, we need to turn off the laser and break out of the opto loop
            SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
            SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
            tOpt := View(DataWindow%).MaxTime();
            SampleText("OptoOff",tOpt);
            SafeSampleKey("X");  'just turn off stimulus, follow up to get fixation channel down
            attOptoStarted% := 0;  'opto is stopped
        case attOptoStarted% = 1 then  'any other non-pulsed opto trial, kill opto on abort if we have started opto
'            if attOptoState% = 1 then
            SafeSampleKey("o");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            SampleText("OptoOff",tOpt);
            attOptoStarted% := 0;  'opto is stopped
            SafeSampleKey("X");  'just turn off stimulus
        else
            SafeSampleKey("X");  'just turn off stimulus
        endcase;
        

        
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Force main stimulus answer window to blue
        if attNumPatches% > 1 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Force distracter1 answer window to blue
        endif;
        if attNumPatches% > 2 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Force distracter2 answer window to blue
        endif;
        if attNumPatches% > 3 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Force distracter3 answer window to blue
        endif;
        if attNumPatches% > 4 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Force distracter4 answer window to blue
        endif;
        
        ' tally up aborted trials, right now not distinguishing between response aborts and regular aborts
        ' but we also have to decrement "all trials" because this messes with the percentages
        attCountAllTrialsAbort% += 1;
        attCountAllTrials% -= 1;

        ' move on
        ChangeStateTo(stateWaitForBlank%, tStateStart);  'don't update time, carry forward
        
    case iState% = stateWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        docase
        case tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            if FAIsResponse% = 1 then
                FAIsResponse% := 0;
                ChangeStateTo(stateFalseAlarmPenalty%, tTrigger);
            else                
                ChangeStateTo(stateAbortPenalty%, tStateStart);  'don't update time, "credits" for time served
            endif;
            DrawFix(0);	' this undraws the location of the fixpt.
        case tNow > tLast + 5 then  'I don't quite know what to do here.  Hopefully this never triggers.  We've definitely sent the 'X', this can't be WORSE than pre-change, where we would just stick here
            PrintLog("Waited 5 seconds for stim off, giving up and starting next trial!\n");
            SampleText("Waited 5 seconds for stim off, giving up and starting next trial!",tNow);
            ChangeStateTo(stateStartTrial%, tNow);
        endcase
        updateTLast% := 0;  'waiting for a trigger, don't update tLast
        
    case iState% = stateAbortPenalty% then
        
        if tNow - tStateStart > attAbortPenaltyTime then
            PrintLog("stateAbortPenalty: time out is done.\n");
            ChangeStateTo(stateStartTrial%, tNow);
        endif
   
         
    case iState% = stateFalseAlarmPenalty% then
        
        if tNow - tStateStart > attFalseAlarmPenaltyTime then
            PrintLog("stateFalseAlarmPenalty: time out is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
        endif        
        
   
    case iState% = stateCheckForAnswerThroughAnimation% then
        
        'Check to see if there was a trigger - here there may be intervening triggers so updating tLast is important
        tTrigger := View(DataWindow%).NextTime(FrameTriggerChannel%, tLast, vTrigger);
        if tTrigger > tLast and vTrigger = 0 then  'only look at rising edge
            if tTrigger < tNow then      'View(DataWindow%).MaxTime() then  'try using tNow to avoid rare double-catch
               tLastTrigger := tTrigger;
                'put in a sample text for Flashers, sample text for CC will be done below
                'right now, flashers are not enabled
                'CCHappened% will now be updated, not overwritten, in order to allow us to keep track of the current state of
                'the target window, and nontarget window if appropriate.  TagTriggerWithSampleText%() will increment CCHappened%
                'by 1 when the target window opens and by 1 when the target window closes, and will increment CCHappened% by 10
                'when the uncued target window opens and by 10 when the uncued target window closes.  Concomitantly, the local
                'code will also do these increments, which allows for us to keep track of when fixation windows have been updated.
                'It's a mess.  But it should work.
                TagTriggerWithSampletext(tLastTrigger,tAnimationOn,attCurrTrialIndex%,flasherCountThisTrial%,CCHappened%,trialIsCueAll%);
            else
                updateTLast% := 0;  'waiting for sampling to catch up
            endif;
        endif;
        
        
        'Check to see if we need to change the colors on the display, cued location
        docase
        case CCHappened% = 1 or CCHappened% = 21 or CCHappened% = 41 then  'This means the cued target window just opened
            'request fixation point off, if requested - Henry reneging before implementation due to inability to change to different contrast fixpt
            'if attFixationOffAtCC% = 1 then
            '    SafeSampleKey("f");
            'endif;
            'change display colors, if cued target window has just opened
            view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Change fixation window to blue
            docase  'expectedAnswer% gives cued location
            case expectedAnswer% = 1 then
                view(XYWindow%).XYColour(iAnswerWindowChannelMain%,16);  'Change main window to red (20 is orange)
            case expectedAnswer% = 2 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,16);  'Change dist1 window to red
            case expectedAnswer% = 3 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,16);  'Change dist2 window to red
            case expectedAnswer% = 4 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,16);  'Change dist3 window to red
            case expectedAnswer% = 5 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,16);  'Change dist4 window to red
            endcase
            CCHappened% := CCHappened% + 1;  'increment CCHappened%, ones column of 2 means cued target window open
        case CCHappened% = 3 or CCHappened% = 23 or CCHappened% = 43 then  'This means the cued target window just closed
            'change display colors, if cued target window has just closed
            docase 'expectedAnswer% gives cued location
            case expectedAnswer% = 1 then
                view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Change main window to blue
            case expectedAnswer% = 2 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Change dist1 window to blue
            case expectedAnswer% = 3 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Change dist2 window to blue
            case expectedAnswer% = 4 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Change dist3 window to blue
            case expectedAnswer% = 5 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Change dist4 window to blue
            endcase
            CCHappened% := CCHappened% + 1;  'increment CCHappened%, ones column of 4 means cued target window closed
        endcase
        
        'Check to see if we need to change the colors on the display, uncued location
        'Actually, because TagTriggerWithSampleText only tags one trigger at a time, we don't need to separate this from the above, but whatever
        docase
        case CCHappened% = 10 or CCHappened% = 12 or CCHappened% = 14 then  'This means the uncued target window just opened
            'change display colors, if uncued target window has just opened
            view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Change fixation window to blue
            docase  'expectedAnswerUncued% gives uncued location
            case expectedAnswerUncued% = 1 then
                view(XYWindow%).XYColour(iAnswerWindowChannelMain%,16);  'Change main window to red
            case expectedAnswerUncued% = 2 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,16);  'Change dist1 window to red
            case expectedAnswerUncued% = 3 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,16);  'Change dist2 window to red
            case expectedAnswerUncued% = 4 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,16);  'Change dist3 window to red
            case expectedAnswerUncued% = 5 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,16);  'Change dist4 window to red
            endcase
            CCHappened% := CCHappened% + 10;  'increment CCHappened%, tens column of 20 means uncued target window open
        case CCHappened% = 30 or CCHappened% = 32 or CCHappened% = 34 then  'This means the uncued target window just closed
            'change display colors, if uncued target window has just closed
            docase 'expectedAnswerUncued% gives uncued location
            case expectedAnswerUncued% = 1 then
                view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Change main window to blue
            case expectedAnswerUncued% = 2 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Change dist1 window to blue
            case expectedAnswerUncued% = 3 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Change dist2 window to blue
            case expectedAnswerUncued% = 4 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Change dist3 window to blue
            case expectedAnswerUncued% = 5 then
                view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Change dist4 window to blue
            endcase
            CCHappened% := CCHappened% + 10;  'increment CCHappened%, tens column of 40 means uncued target window closed
        endcase
        
        'Check to see if the animal has answered, we will use this in below case statement, get both eye and joystick
        iAnswer% := Answer%(xEye, yEye);
        if attRequireJoystickResponse% = 1 then
            attJoyPos% := GetJoystickPositionUD%(attJoyValue);  'Joy value is filled as secondary output, not used as an input
        else
            attJoyPos% := JSDown%;  'If we are not using the joystick, assign "down" (no response)
        endif;
        
        docase  
        'if fixation is broken and no contrast change has happened, begin abort procedure            
        case Looking%(xEye, yEye) = 0 and CCHappened% = 0 then  
            PrintLog("stateCheckForAnswerThroughAnimation: fixation lost before contrast change.\n");
            ChangeStateTo(stateAbort%, tNow);
            
        'if we want a joystick response and fixation is broken, begin abort procedure            
        case Looking%(xEye, yEye) = 0 and attRequireJoystickResponse% = 1 then  
            PrintLog("stateCheckForAnswerThroughAnimation: fixation lost while expecting joystick response.\n");
            ChangeStateTo(stateAbort%, tNow);
            
        'if joystick is up (response) and no contrast change has happened, begin abort procedure    
        case (attJoyPos% = JSCenter% or attJoyPos% = JSUp%) and CCHappened% = 0 then  
            PrintLog("stateCheckForAnswerThroughAnimation: joystick up before contrast change.\n");
            ChangeStateTo(stateAbort%, tNow);
            
        'there is a saccade response, answer is to cued window, and cued window is a legal answer (expected answer is 0 if cued location does not change)    
        case attRequireJoystickResponse% = 0 and iAnswer% > 0 and iAnswer% = expectedAnswer% then 
            docase
            'if cued window has not yet opened, this is a false alarm    
            case CCHappened% = 0 or CCHappened% = 20 or CCHappened% = 40 then  
                queueReward% := -1;                   
                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
                SampleText("Incorrect",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                
            'if cued window has opened and not yet closed, it's a hit, set up reward    
            case tNow <= tStateStart+cuedResponseWindowCloseTime then 
                queueReward% := 1;                   
                attCountAllTrialsCorrect% += 1;
                attInterTrialTimeThisTrial := attInterTrialTime;
                SampleText("Correct",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                
            'cued window has closed, response too late, it's a miss    
            else  
                queueReward% := -1;                    
                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
                SampleText("Incorrect",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);  'we can skip waitForAnswer, response window (i.e. trial) is over
            endcase
            
        'response, there is a saccade response, answer is to uncued window, and uncued window is a legal answer (expectedAnswerUncued% is 0 unless uncued location changes and trial is cue-all)    
        case attRequireJoystickResponse% = 0 and iAnswer% > 0 and iAnswer% = expectedAnswerUncued% then 
            docase
            'if uncued window has not yet opened, this is a false alarm    
            case CCHappened% < 20 then  
                queueReward% := -1;                   
                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
                SampleText("Incorrect",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow); 
                
            'if uncued window has opened and not yet closed, it's a hit, set up reward    
            case tNow <= tStateStart+uncuedResponseWindowCloseTime then 
                queueReward% := 1;                   
                attCountAllTrialsCorrect% += 1;
                attInterTrialTimeThisTrial := attInterTrialTime;
                SampleText("Correct",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                
            'uncued window has closed, response too late, it's a miss    
            else  
                queueReward% := -1;                    
                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
                SampleText("Incorrect",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);  'we can skip waitForAnswer, response window (i.e. trial) is over
            endcase  
            
        'there is a saccade response that does not correspond to any legal location (by process of elimination), false alarm    
        case attRequireJoystickResponse% = 0 and iAnswer% > 0 then 
            queueReward% := -1;                   
            attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
            SampleText("Incorrect",tNow);
            CCHappened% := 0;
            ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            
        'there is a joystick response (joystick is not down), and any legal-to-respond contrast change has happened, hit
        case attRequireJoystickResponse% = 1 and (attJoyPos% = JSCenter% or attJoyPos% = JSUp%) and expectedAnswer%+expectedAnswerUncued% > 0 then
            queueReward% := 1;                   
            attCountAllTrialsCorrect% += 1;
            attInterTrialTimeThisTrial := attInterTrialTime;
            SampleText("Correct",tNow);
            CCHappened% := 0;
            ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            
        'there is a joystick response (joystick is not down), contrast change has happened, but should not be responded to, FA
        case attRequireJoystickResponse% = 1 and (attJoyPos% = JSCenter% or attJoyPos% = JSUp%) and expectedAnswer%+expectedAnswerUncued% = 0 then
            queueReward% := -1;                   
            attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
            SampleText("Incorrect",tNow);
            CCHappened% := 0;
            ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            
        case tNow > tStateStart + attTimeTrialEnds then  'if animation is over and no reponse has occurred
            if trialIsTarget% = 1 then  'this is a miss, we would have caught the answer on the last check if not
                queueReward% := -1;                    
                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
                SampleText("Incorrect",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);  'we can skip waitForAnswer, response window (i.e. trial) is over
            else  'this is a CR, we would have caught fixation break on last check if not
                queueReward% := 1;
                ' Correct rejection   
                trialIsCRForDelayBasedReward% := 1;
                attCountAllTrialsCorrect% += 1;
                attInterTrialTimeThisTrial := attInterTrialTime;
                SampleText("Correct",tNow);
                CCHappened% := 0;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);  'we can skip waitForAnswer, response window (i.e. trial) is over 
            endif;   
            
        'else 'This means the trial is not over, the animal has not aborted, and the animal has not responded.  Keep checking for these events.    
            
            
            'Below commented code was a prior attempt, but it wouldn't work when we extended the response window
            'beyond the duration of the contrast change, above code now seems simpler, should cover all the bases
'        'if the first case does not trigger, either we are still looking, or something has happened, or both    
'        'case CCHappened% = 2 or CCHappened% = 22 or CCHappened% = 42 then  'This means the cued target window is open
'        case tNow <= cuedResponseWindowCloseTime then  'This means the cued target window is open  
'            
'            'Check to see if there is a response - if there is no response, we keep checking
'            docase
'            case iAnswer% = expectedAnswer% then  'A hit!  Set up reward 
'                queueReward% := 1;                   
'                attCountAllTrialsCorrect% += 1;
'                attInterTrialTimeThisTrial := attInterTrialTime;
'                SampleText("Correct",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            case iAnswer% = expectedAnswerUncued% and CCHappened% = 22 then  'A hit on the uncued target while window open!  Set up reward 
'                queueReward% := 1;                   
'                attCountAllTrialsCorrect% += 1;
'                attInterTrialTimeThisTrial := attInterTrialTime;
'                SampleText("Correct",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            case iAnswer% > 0 then  'A saccade to a wrong location (false alarm, I guess)
'                queueReward% := -1;                   
'                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
'                SampleText("Incorrect",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            endcase
'            
'        'case CCHappened% = 4 or CCHappened% = 24 or CCHappened% = 44 then  'This means the cued target window is closed
'        case (CCHappened% = 4 or CCHappened% = 24 or CCHappened% = 44) and tNow > cuedResponseWindowCloseTime and tNow > uncuedResponseWindowCloseTime then
'            
'            'Check for response, if no response, keep checking
'            docase
'            case iAnswer% > 0  and (CCHappened% = 4 or CCHappened% = 44) then  'A saccade to any location if no response window open is a false alarm
'                queueReward% := -1;                   
'                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
'                SampleText("Incorrect",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            case iAnswer% = expectedAnswerUncued% and CCHappened% = 24 then  'This is a saccade to the uncued location while its window is open - a hit!
'                queueReward% := 1;                   
'                attCountAllTrialsCorrect% += 1;
'                attInterTrialTimeThisTrial := attInterTrialTime;
'                SampleText("Correct",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            endcase
'            
'        case CCHappened% = 20 then  'This means the uncued target window is open  'cannot get to CCHappened% = 22 or CCHappened% = 24, those are covered above  
'
'            'Check to see if there is a response - if there is no response, we keep checking
'            docase
'            case iAnswer% = expectedAnswerUncued% then  'A hit!  Set up reward 
'                queueReward% := 1;                   
'                attCountAllTrialsCorrect% += 1;
'                attInterTrialTimeThisTrial := attInterTrialTime;
'                SampleText("Correct",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            case iAnswer% > 0 then  'A saccade to a wrong location (false alarm, I guess)
'                queueReward% := -1;                   
'                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
'                SampleText("Incorrect",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            endcase
'            
'        case CCHappened% = 40 then 'This means the uncued target window is closed  'cannot get to CCHappened% = 42 or CCHappened% = 44, those are covered above  
'  
'            'Check for response, if no response, keep checking
'            if iAnswer% > 0 then  'A saccade to any location if no response window open is a false alarm
'                queueReward% := -1;                   
'                attInterTrialTimeThisTrial := attInterTrialTime + attMissPenaltyTime;
'                SampleText("Incorrect",tNow);
'                CCHappened% := 0;
'                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
'            endif
'            
'            
'        
'            
            
        endcase 

        
        
    case iState% = stateCheckTurnOffOpto% then
        'nTrialsThisBlockCompleted% += 1;  'trial is complete, change of count here makes logic easier 
        'attCurrTrialIndex% += 1;
        docase
        case attDoOpto% = 0 or attOptoStarted% = 0 then 'if this is not an opto trial, trial is complete
            if queueReward% = -1 then 'on a miss, go to miss penalty, otherwise we are done
                ChangeStateTo(stateMiss%, tStateStart);
                queueReward% := 0;  'reset value, will not reward
            else
                ChangeStateTo(stateTrialCompletedWaitForBlank%, tStateStart);
            endif;
            SafeSampleKey("X");  'do this in stateCheckTurnOffOpto
            printlog("Trial complete, Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",attDoOpto%,attOptoState%,tStateStart);
            'give out reward, if necessary, in THIS state if opto is off
            if queueReward% = 1 then
                if attUseHazardForReward% = 1 then 
                    if trialIsCRForDelayBasedReward% = 0 then
                        ActualRewardDuration% := DelayBasedReward%(attHazardMinTime,attHazardCutoffTime,trialHazardFunctionTimeCued);  'this only makes sense for stimulus-change trials
                        SampleText("Delay-based reward, reward duration is " + Str$(ActualRewardDuration%) + " ms",tNow);
                    else
                        ActualRewardDuration% := DelayBasedReward%(attHazardMinTime,attHazardCutoffTime,attHazardMinTime); 
                        SampleText("Delay-based reward, for CR reward duration is minimum of " + Str$(ActualRewardDuration%) + " ms",tNow);                        'Artificially, set this to be the minimum reward
                        trialIsCRForDelayBasedReward% := 0;  'reset
                    endif
                else
                    Reward%();
                endif;
                nTrialsRewarded% += 1;
                queueReward% := 0;  'reset reward
            endif;
        case attOptoUsePulse% = 1 and attOptoState% = 1 then  'it is a pulsed opto trial
            printlog("Trial complete, Pulsed opto trial, time = %f\n",tStateStart);
            'on a pulsed opto ending, we need to turn off the laser and break out of the opto loop
            if attOptoStarted% = 2 then  'the stimulus may already have been turned off in the answer portion
                SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
                SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
                attOptoStarted% := 0;  'opto is now off
            endif;
            if queueReward% = -1 then 'on a miss, go to miss penalty, otherwise we are done
                ChangeStateTo(stateMiss%, tStateStart);
                queueReward% := 0;  'reset value, will not reward
            else
                ChangeStateTo(stateTrialCompletedWaitForBlank%, tStateStart);
            endif;
            SafeSampleKey("X");  'do this in stateCheckTurnOffOpto
            'give out reward, if necessary, in THIS state if opto is off
            if queueReward% = 1 then
                if attUseHazardForReward% = 1 then 
                    if trialIsCRForDelayBasedReward% = 0 then
                        ActualRewardDuration% := DelayBasedReward%(attHazardMinTime,attHazardCutoffTime,trialHazardFunctionTimeCued);  'this only makes sense for stimulus-change trials
                        SampleText("Delay-based reward, reward duration is " + Str$(ActualRewardDuration%) + " ms",tNow);
                    else
                        ActualRewardDuration% := DelayBasedReward%(attHazardMinTime,attHazardCutoffTime,attHazardMinTime); 
                        SampleText("Delay-based reward, for CR reward duration is minimum of " + Str$(ActualRewardDuration%) + " ms",tNow);                        'Artificially, set this to be the minimum reward
                        trialIsCRForDelayBasedReward% := 0;  'reset
                    endif
                else
                    Reward%();
                endif;
                nTrialsRewarded% += 1;
                queueReward% := 0;  'reset reward
            endif;
        else 'otherwise it is an opto trial and we need to turn opto off
            ChangeStateTo(stateTurnOffOpto%, tStateStart);
            printlog("Turning Opto Off at time = %f\n",tStateStart);
        endcase  
        
        
        
    case iState% = stateTurnOffOpto% then
        SafeSampleKey("o");  'turn it off
        tOpt := View(DataWindow%).MaxTime();
        SampleText("OptoOff",tOpt);
        attOptoStarted% := 0;  'opto is now off
        SafeSampleKey("X");  'not done in stateCheckTurnOffOpto if we are actually turning off opto
        'give out reward, if necessary, was not given out in previous state if opto was not off
            if queueReward% = 1 then
                if attUseHazardForReward% = 1 then 
                    if trialIsCRForDelayBasedReward% = 0 then
                        ActualRewardDuration% := DelayBasedReward%(attHazardMinTime,attHazardCutoffTime,trialHazardFunctionTimeCued);  'this only makes sense for stimulus-change trials
                        SampleText("Delay-based reward, reward duration is " + Str$(ActualRewardDuration%) + " ms",tNow);
                    else
                        ActualRewardDuration% := DelayBasedReward%(attHazardMinTime,attHazardCutoffTime,attHazardMinTime); 
                        SampleText("Delay-based reward, for CR reward duration is minimum of " + Str$(ActualRewardDuration%) + " ms",tNow);                        'Artificially, set this to be the minimum reward
                        trialIsCRForDelayBasedReward% := 0;  'reset
                    endif
                else
                    Reward%();
                endif;
                nTrialsRewarded% += 1;
                queueReward% := 0;  'reset reward
            endif;
        ChangeStateTo(stateTrialCompletedWaitForBlank%,tNow);
        
        
    case iState% = stateTrialCompletedWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := View(DataWindow%).NextTime(FrameTriggerChannel%, tLast, vTrigger);
        docase
        case tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateTrialCompleteWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
            DrawFix(0);	' actually this draws the location of the fixpt.
        case tNow > tLast + 5 then
            PrintLog("Waited 5 seconds for blank, giving up and starting next trial!\n");
            SampleText("Waited 5 seconds for blank, giving up and starting next trial!",tNow);
            ChangeStateTo(stateTrialCompleted%, tTrigger);
        endcase
        updateTLast% := 0;  'waiting for a trigger, don't update tLast
              
        
    case iState% = stateTrialCompletedPause% then
        
        if tNow - tStateStart > attInterTrialTimeThisTrial then
            
            PrintLog("stateTrialCompletedPause: inter-trial time is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
    case iState% = stateMiss% then
        
        if tNow - tStateStart > attMissPenaltyTime then
            
            PrintLog("stateMiss: penalty time is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
        
    case iState% = stateTrialCompleted% then
        view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Force main answer window to blue
        if attNumPatches% > 1 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Force distracter1 answer window to blue
        endif;
        if attNumPatches% > 2 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Force distracter2 answer window to blue
        endif;
        if attNumPatches% > 3 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Force distracter3 answer window to blue
        endif;
        if attNumPatches% > 4 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Force distracter4 answer window to blue
        endif;
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        'Things got a bit out of hand in advancing/incrementing as the function got more complex.  Here I am re-simplifying everything.
        'All non-abort states go through stateTrialCompleted as a final step.  Thus, advance and increment in stateTrialCompleted and
        'nowhere else.
        PrintLog("Trial completed.\n");
        nTrialsThisBlockCompleted% += 1;
        nTrialsCompleted% += 1;
        attCurrTrialIndex% += 1;
        'Advance
        SafeSampleKey("a");
        docase
        case nTrialsThisBlockCompleted% = nTrialsThisBlock% then
            ChangeStateTo(stateBlockCompleted%, tNow);
        case nTrialsThisBlockCompleted% > nTrialsThisBlock% then 'This shouldn't happen, but I just can't be sure
            Printlog("Error - trials this block = " + str$(nTrialsThisBlock%) + " but trials completed = " + str$(nTrialsThisBlockCompleted%) + "\n");
            Printlog("Error - we appear to have skipped over final trial of a block!  This should not happen!  Attempting to push forward...\n");
            Message("Possible missed end of block!  Info in log, trying to continue experiment.  Tell Jeff when done!");
        else
            ChangeStateTo(stateStartTrial%, tNow);
        endcase
        
    case iState% = stateBlockCompleted% then
        
        PrintLog("Block completed.\n");
        nBlocksCompleted% := nBlocksCompleted% + 1;
        if nBlocksCompleted% >= attNumberOfSetsOfBlocks%*attBlocksPerSet% then  'again, should never be greater, but just in case...here doing less to fix because obviously we need to quit if that happens
            Stop%();
            iStatus% := 0;
        else
            ChangeStateTo(stateStartBlock%, tNow);
        endif
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        
        'If the eyetracker is recording an output file, stop recording and close the file
        if RecordEyeTrackerOutputFile% = 1 then
            SafeSampleKey("w");  'Stop recording
            yield(0.1);
            SafeSampleKey("i");  'Close the file
            SafeSampleKey("Z");  'zero the DIGLOWs
        endif
        
        halt;
        
    endcase;
    
    
    if updateTLast% = 1 then 
        tLast := tNow;
    endif;
    
    
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareTrial()
    
    var stimTimeRemaining;
    stimTimeRemaining := attCueOffsetTime+attStimOnsetList[attCurrTrialIndex%]+attTrialEndTime[attCurrTrialIndex%];
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;
    
    
	PrintLog("Prepare trial: ");
    

'    docase
'    case attCuedLocChangesList%[attCurrTrialIndex%] = 0 and attUncuedLocChangesList%[attCurrTrialIndex%] = 0 then  
'        JuiceRewardMS% := lowRewardMS%;  'use low reward for no-change trials   
'    else
'        JuiceRewardMS% := origRewardMS%;
'    endcase
    'Originally low-reward was for BLOCKS where the animal does nothing, but this no longer happens, putting it on ice
    JuiceRewardMS% := origRewardMS%;

    ' Fixation time is a random number between attFixationMinTime and attFixationMaxTime. 
    ' This is how long the animal must fixate before we start the opto (if applicable) and animation
    attFixationTime := Rand(attFixationCueMaxTime - attFixationCueMinTime, attFixationCueMinTime);
    PrintLog("Fixation time " + str$(attFixationTime) + "\n");
    
    ' Set hazard function time and time to answer per trial
    ' These two values are only used for sampletexting, so the fact they are relative to grating onset is OK (I hope)
    trialHazardFunctionTimeCued := attCuedLocCCTime[attCurrTrialIndex%];  'hazard time has been pre-calculated for all trials
    trialHazardFunctionTimeUncued := attUncuedLocCCTime[attCurrTrialIndex%];
    'trialHazardFunctionTimeCued := attCueOffsetTime+attStimOnsetList[attCurrTrialIndex%]+attCuedLocCCTime[attCurrTrialIndex%];  'these are measured from the start of the animation, if that's what we need 
    'trialHazardFunctionTimeUncued := attCueOffsetTime+attStimOnsetList[attCurrTrialIndex%]+attUncuedLocCCTime[attCurrTrialIndex%];
    
    ' This value needs to be the time from the point the animation is up until the time the trial ends, now not moving to separate answer window for no-go trials
    ' This is: attCueOffsetTime+attStimOnsetList[trialCount%]+attTrialEndTime[trialCount%]-attContrastChangeDuration
    attTimeTrialEnds := attCueOffsetTime+attStimOnsetList[attCurrTrialIndex%]+attTrialEndTime[attCurrTrialIndex%];  'Time to answer is different on every trial
    cuedResponseWindowCloseTime := attCueOffsetTime+attStimOnsetList[attCurrTrialIndex%]+attCuedLocCCTime[attCurrTrialIndex%]+attResponseWindow;
    uncuedResponseWindowCloseTime := attCueOffsetTime+attStimOnsetList[attCurrTrialIndex%]+attUncuedLocCCTime[attCurrTrialIndex%]+attResponseWindow;
    
    'Record if this trial is Cue-All
    trialIsCueAll% := attIsCueAll%[attCurrTrialIndex%];
       
    'Determine if opto should be on
    if attDoOpto% = 1 then  'if there can be opto
        if nTrialsThisBlockCompleted% >= attEasyTrialsPerBlock% then  'if it's not an easy trial
            if Rand(1,0) <= attOptoPropOpto then
                attOptoState% := 1;  'opto on (random)
                
                'if using PULSED opto, we will need to calculate the number of pulses for this trial
                if attOptoUsePulse% = 1 then
                    stimTimeRemaining := stimTimeRemaining - attPulsedOptoOnset;  'duration of stimulus after onset delay
                    stimTimeRemaining := stimTimeRemaining - attPulsedOptoWidth;  'duration of stimulus after first opto pulse
                    if stimTimeRemaining < 0 then  'if first pulse will extend beyond stimulus duration
                        attOptoNPulses% := 0;  'turn off opto by using no pulses
                        attOptoState% := 0;  'and also kill it the normal way
                        Printlog("Due to stimulus length, no opto pulses can be completed this trial!\n");
                    else
                        tempNPulses% := attOptoNPulses% - 1;  'how many more pulses are left?
                        tempCount% := 1;  'temporary successful pulse count
                        while tempNPulses% > 0 do
                            stimTimeRemaining := stimTimeRemaining - attPulsedOptoWidth - attPulsedOptoIPI;  'subtract duration of one more pulse+IPI
                            if stimTimeRemaining < 0 then  'if this pulse will extend beyond stimulus duration
                                Printlog("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed this trial!\n");
                                attOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                                stimTimeRemaining := stimTimeRemaining + attPulsedOptoWidth + attPulsedOptoIPI;  'add back duration of one more pulse+IPI, gets actual stimulus duration remaining
                                tempNPulses% := 0;  'break while
                            else  'if this pulse is OK
                                tempCount% += 1;  'increment temporary successful pulse count
                            endif;
                            tempNPulses% -= 1;  'decrement temporary pulse count remaining
                        wend
                        'Set number of pulses on sample sequencer
                        SampleSeqVar(6,attOptoNPulses%);  'set number of pulses
                        printlog("Opto N pulses is %d\n",attOptoNPulses%); 
                        'Set post-stimulus duration on sample sequencer
                        tempSeqVarValue := stimTimeRemaining*1000/SequencerPeriodMS;  'do math in float
                        tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
                        SampleSeqVar(10,tempSeqVarValue%);  'set post-pulse stimulus duration in clock ticks
                        'printlog("Opto remaining time is %d\n",tempSeqVarValue%);                        
                    endif;
                endif;
                
            else
                attOptoState% := 0;  'opto off (random)
            endif;
        else
            attOptoState% := 0;  'if it's an easy trial, set opto off
        endif;
    else
        attOptoState% := 0;  'if no opto at all, set opto off
    endif;
    

    
    
    'Determine if contrast is changing (target) or not (nontarget)
    'Under the new scheme, if any contrast changes, it is a target, otherwise it is a nontarget
    docase
    case trialIsCueAll% = -1 then
        trialIsTarget% := 0;  'for no-cue-matches trials, the correct response is ALWAYS no-go, regardless of whether there is a contrast change
        'We do not need to set trialAttendLoc as the CASE where it is used cannot be entered when trialIsTarget% is 0
    case trialIsCueAll% = 1 then
        trialIsTarget% := attCuedLocChangesList%[attCurrTrialIndex%] or attUncuedLocChangesList%[attCurrTrialIndex%];  'This logical operation works in a simple test
        trialAttendLoc% := 100;  'Arbitrary indicator of cue-all
    else
        trialIsTarget% := attCuedLocChangesList%[attCurrTrialIndex%];  
        trialAttendLoc% := attCuedLocList%[attCurrTrialIndex%];  'this is the attend location
    endcase;
    fixColor$ := masterColorList$[attFixColor%[attCurrTrialIndex%]-1];
    
    'Record actual contrast level on this trial, is -1 if contrast does not change
    thisContrastCued% := attContrastCuedList%[attCurrTrialIndex%];
    thisContrastUncued% := attContrastUncuedList%[attCurrTrialIndex%];
    
    
    'Calculate expected answer,  a bit complicated but this should hit all conditions
    docase
    case trialIsTarget% = 0 then
        expectedAnswer% := 0;  'cued grating does not change (or, if cue-all, no grating changes, or no cue matches)
        expectedAnswerUncued% := 0;  'even if uncued grating changes, it's not a target
    'For remainder of cases, trialIsTarget% must be 1    
    case trialAttendLoc% < 100 then 'this is single cue
        expectedAnswer% := trialAttendLoc%;  'expected answer is cued location
        expectedAnswerUncued% := 0;  'even if uncued grating changes, it's not a target
    'For remainder of cases, cue is cue-all, and we know at least one location changes
    else
        docase
        case attCuedLocChangesList%[attCurrTrialIndex%] = 0 then 'cue-all, "cued" loc does not change
            expectedAnswer% := 0;  'cued grating does not change   
            expectedAnswerUncued% := attUncuedLocList%[attCurrTrialIndex%];  'uncued location does change
        case attUncuedLocChangesList%[attCurrTrialIndex%] = 0 then 'cue-all, "uncued" loc does not change
            expectedAnswer% := attCuedLocList%[attCurrTrialIndex%];  'expected answer is cued location
            expectedAnswerUncued% := 0;  'uncued location does not change
        else 'both locations change, either is a valid answer
            expectedAnswer% := attCuedLocList%[attCurrTrialIndex%];
            expectedAnswerUncued% := attUncuedLocList%[attCurrTrialIndex%];
        endcase    
    endcase;
    
    'reset trial flasher count
    if attUseFlashers% = 1 then
        flasherCountThisTrial% := 0;
    endif;
    
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareBlock()
    'This function used to do more, but now that all stimuli are determined in advance, it just kinda does some printlogging now
	PrintLog("Block starting: "); 
    
    docase
    case attBlockList%[attCurrTrialIndex%] = 1 then
        PrintLog("Cue = main location");  'these used to be "grating" but with images coming in, let's call them "locations"
        nTrialsThisBlock% := attTrialsPerBlock%+attEasyTrialsPerBlock%;
    case attBlockList%[attCurrTrialIndex%] = 2 then
        PrintLog("Cue = distracter location 1");
        nTrialsThisBlock% := attTrialsPerBlock%+attEasyTrialsPerBlock%;
    case attBlockList%[attCurrTrialIndex%] = 3 then
        PrintLog("Cue = distracter location 2");
        nTrialsThisBlock% := attTrialsPerBlock%+attEasyTrialsPerBlock%;
    case attBlockList%[attCurrTrialIndex%] = 4 then
        PrintLog("Cue = distracter location 3");
        nTrialsThisBlock% := attTrialsPerBlock%+attEasyTrialsPerBlock%;
    case attBlockList%[attCurrTrialIndex%] = 5 then
        PrintLog("Cue = distracter location 4"); 
        nTrialsThisBlock% := attTrialsPerBlock%+attEasyTrialsPerBlock%;
    case attBlockList%[attCurrTrialIndex%] = 6 then
        PrintLog("Cue = cue all"); 
        nTrialsThisBlock% := attTrialsPerBlock%;
    case attBlockList%[attCurrTrialIndex%] = 7 then
        PrintLog("Cue = random (no cue all)");   
        nTrialsThisBlock% := attTrialsPerBlock%;
    case attBlockList%[attCurrTrialIndex%] = 8 then
        PrintLog("Cue = random (includes cue all)"); 
        nTrialsThisBlock% := attTrialsPerBlock%;        
    endcase
   
	PrintLog("\n");
    'reset block-specific variables
	nTrialsThisBlockCompleted% := 0;
end







''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Start dialog/registry functions
' 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


proc GetAttentionScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG2";
     
    attNumberOfSetsOfBlocks% := GetIntRegistryValue%(key$, "NumberOfSetsOfBlocks", 1); ''
	attTrialsPerBlock% := GetIntRegistryValue%(key$, "TrialsPerBlock", 1); ''
    attEasyTrialsPerBlock% := GetIntRegistryValue%(key$, "EasyTrialsPerBlock", 1); ''
    distracterOffForEasy% := GetIntRegistryValue%(key$, "DistracterOffForEasy", 1); ''
    attNumPatches% := GetIntRegistryValue%(key$, "NumPatches", 1); ''
    attUseFlashers% := GetIntRegistryValue%(key$, "UseFlashers", 1); ''
    attGetGPFromMainStim% := GetIntRegistryValue%(key$, "GetGPFromMainStim", 1);  ''
    attUseCueCircles% := GetIntRegistryValue%(key$, "UseCueCircles", 1); ''
    attCueCircleExtraRadius := GetFloatRegistryValue(key$, "CueCircleExtraRadius", 0.0); ''
    attSelectRandomContrastEachTrial% := GetIntRegistryValue%(key$, "NoBlockRand", 1); ''
	attTrainingContrastCheck% := GetIntRegistryValue%(key$, "TrainingContrastCheck", 0); ''
	attTrainingContrastPct% := GetIntRegistryValue%(key$, "TrainingContrastPct", 0); ''
    attContrastBase% := GetIntRegistryValue%(key$, "ContrastBase", 50); ''
    attNContLevels% := GetIntRegistryValue%(key$, "NContrastLevels", 20); ''
    attMaxContChange := GetFloatRegistryValue(key$, "ContrastMax", 1);  ''
    attMinContChange := GetFloatRegistryValue(key$, "ContrastMin", 1); ''
	attAnswerPointDiameter := GetFloatRegistryValue(key$, "AnswerPointDiameter", 0.5);
	attAnswerPointOffset := GetFloatRegistryValue(key$, "AnswerPointOffset", 5.0);
	'attAnswerPointWindowRadius := GetFloatRegistryValue(key$, "AnswerPointWindowRadius", 2.0); ''
    attSwapCueCircle% := GetIntRegistryValue%(key$, "SwapCueCircle", 0); ''
    attCueCircleStrokeWidth% := GetIntRegistryValue%(key$, "CueCircleStrokeWidth", 0); ''
    attUseLowReward% := GetIntRegistryValue%(key$, "UseLowReward", 0); ''
    attLowReward% := GetIntRegistryValue%(key$, "LowReward", 0); ''
    attDoOpto% := GetIntRegistryValue%(key$, "DoOpto", 0); ''
    attPhaseCheck% := GetIntRegistryValue%(key$, "DoPhase", 1); ''
    attPhaseDeg% := GetIntRegistryValue%(key$, "PhaseDeg", 1); ''
    attStartBlock% := GetIntRegistryValue%(key$, "StartBlock", 1);
    attCuedLocationChangePct% := GetIntRegistryValue%(key$, "CuedLocationChangePct", 1); ''
    attUncuedLocationChangePct% := GetIntRegistryValue%(key$, "UncuedLocationChangePct", 1); ''
    attRequireJoystickResponse% := GetIntRegistryValue%(key$, "RequireJoystickResponse", 0);
    attNoCuesMatchFixpt% := GetIntRegistryValue%(key$, "NoCuesMatchFixpt", 0);
   
end;

proc SaveAttentionScriptParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG2";
    
	SetIntRegistryValue(key$, "NumberOfSetsOfBlocks", attNumberOfSetsOfBlocks%);
	SetIntRegistryValue(key$, "TrialsPerBlock", attTrialsPerBlock%);
    SetIntRegistryValue(key$, "EasyTrialsPerBlock", attEasyTrialsPerBlock%);
    SetIntRegistryValue(key$, "DistracterOffForEasy", distracterOffForEasy%);
    SetIntRegistryValue(key$, "NumPatches", attNumPatches%);
    SetIntRegistryValue(key$, "UseFlashers", attUseFlashers%);
    SetIntRegistryValue(key$, "GetGPFromMainStim", attGetGPFromMainStim%);
    SetIntRegistryValue(key$, "UseCueCircles", attUseCueCircles%);
    SetFloatRegistryValue(key$, "CueCircleExtraRadius", attCueCircleExtraRadius);
    SetIntRegistryValue(key$, "NoBlockRand", attSelectRandomContrastEachTrial%);
	SetIntRegistryValue(key$, "TrainingContrastCheck", attTrainingContrastCheck%);
	SetIntRegistryValue(key$, "TrainingContrastPct", attTrainingContrastPct%);
	SetIntRegistryValue(key$, "ContrastBase", attContrastBase%);
	SetFloatRegistryValue(key$, "ContrastMax", attMaxContChange);
	SetFloatRegistryValue(key$, "ContrastMin", attMinContChange);
    SetIntRegistryValue(key$, "NContrastLevels", attNContLevels%);
	SetFloatRegistryValue(key$, "AnswerPointDiameter", attAnswerPointDiameter);
	SetFloatRegistryValue(key$, "AnswerPointOffset", attAnswerPointOffset);
	'SetFloatRegistryValue(key$, "AnswerPointWindowRadius", attAnswerPointWindowRadius);
    SetIntRegistryValue(key$, "SwapCueCircle", attSwapCueCircle%);  
    SetIntRegistryValue(key$, "CueCircleStrokeWidth", attCueCircleStrokeWidth%);
    SetIntRegistryValue(key$, "UseLowReward", attUseLowReward%);
    SetIntRegistryValue(key$, "LowReward", attLowReward%);     
    SetIntRegistryValue(key$, "DoOpto", attDoOpto%);
    SetIntRegistryValue(key$, "DoPhase", attPhaseCheck%);
    SetIntRegistryValue(key$, "PhaseDeg", attPhaseDeg%);
    SetIntRegistryValue(key$, "StartBlock", attStartBlock%);  
    SetIntRegistryValue(key$, "CuedLocationChangePct", attCuedLocationChangePct%);
    SetIntRegistryValue(key$, "UncuedLocationChangePct", attUncuedLocationChangePct%);
    SetIntRegistryValue(key$, "RequireJoystickResponse", attRequireJoystickResponse%);
    SetIntRegistryValue(key$, "NoCuesMatchFixpt", attNoCuesMatchFixpt%);
    
end;



proc GetTimingDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG2";
    
    
	attFixationCueMinTime := GetFloatRegistryValue(key$, "FixationCueMinTime", 1.0);
	attFixationCueMaxTime := GetFloatRegistryValue(key$, "FixationCueMaxTime", 1.0);
	attHazardMinTime := GetFloatRegistryValue(key$, "HazardMinTime", 0.5);
	attHazardExpMeanTime := GetFloatRegistryValue(key$, "HazardExpMeanTime", 1.0);
   	attHazardCutoffTime := GetFloatRegistryValue(key$, "HazardCutoffTime", 5.0);
	attAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", 1.0);
	attInterTrialTime := GetFloatRegistryValue(key$, "InterTrialTime", 1.0);
	attAbortPenaltyTime := GetFloatRegistryValue(key$, "AbortPenaltyTime", 1.0);
    attContrastChangeDuration := GetFloatRegistryValue(key$, "ContrastChangeDuration", 1.0);
    attResponseWindow := GetFloatRegistryValue(key$, "ResponseWindow", 1.0);
    attMissPenaltyTime := GetFloatRegistryValue(key$, "MissPenalty", 1.0);
    attFalseAlarmPenaltyTime := GetFloatRegistryValue(key$, "FalseAlarmPenaltyTime", 1.0);
    
    attCueOnsetTime := GetFloatRegistryValue(key$, "CueOnsetTime", 1.0);
    attCueOffsetTime := GetFloatRegistryValue(key$, "CueOffsetTime", 2.0);
    attStimOnsetTime := GetFloatRegistryValue(key$, "StimOnsetTime", 2.0);
    attLockUncuedToCued% := GetIntRegistryValue%(key$, "LockUncuedToCued", 0);
    
    attUseHazardForReward% := GetIntRegistryValue%(key$, "UseHazardForReward", 0);
    attHazRewardMin% := GetIntRegistryValue%(key$, "HazRewardMin", 100);
    attHazRewardMax% := GetIntRegistryValue%(key$, "HazRewardMax", 200);
    attFixationOffAtCC% := GetIntRegistryValue%(key$, "FixationOffAtCC", 0);
    
    
end;

proc SaveTimingDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG2";
    
	SetFloatRegistryValue(key$, "FixationCueMinTime", attFixationCueMinTime);
	SetFloatRegistryValue(key$, "FixationCueMaxTime", attFixationCueMaxTime);
	SetFloatRegistryValue(key$, "HazardMinTime", attHazardMinTime);
	SetFloatRegistryValue(key$, "HazardExpMeanTime", attHazardExpMeanTime);
    SetFloatRegistryValue(key$, "HazardCutoffTime", attHazardCutoffTime);
	SetFloatRegistryValue(key$, "AcquisitionTime", attAcquisitionTime);
	SetFloatRegistryValue(key$, "AbortPenaltyTime", attAbortPenaltyTime);
    SetFloatRegistryValue(key$, "ContrastChangeDuration", attContrastChangeDuration);
    SetFloatRegistryValue(key$, "ResponseWindow", attResponseWindow);
    SetFloatRegistryValue(key$, "MissPenalty", attMissPenaltyTime);
    SetFloatRegistryValue(key$, "FalseAlarmPenaltyTime", attFalseAlarmPenaltyTime);
	SetFloatRegistryValue(key$, "InterTrialTime", attInterTrialTime);
    
    SetFloatRegistryValue(key$, "CueOnsetTime", attCueOnsetTime);
    SetFloatRegistryValue(key$, "CueOffsetTime", attCueOffsetTime);
    SetFloatRegistryValue(key$, "StimOnsetTime", attStimOnsetTime);
    SetIntRegistryValue(key$, "LockUncuedToCued", attLockUncuedToCued%);
    
    SetIntRegistryValue(key$, "UseHazardForReward", attUseHazardForReward%);
    SetIntRegistryValue(key$, "HazRewardMin", attHazRewardMin%);
    SetIntRegistryValue(key$, "HazRewardMax", attHazRewardMax%);
    SetIntRegistryValue(key$, "FixationOffAtCC", attFixationOffAtCC%);
   
    
end;



proc GetColorsDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG2";
    

	attBackgroundColor$ := GetStringRegistryValue$(key$, "BackgroundColor", "gray");
    
    if InStr(attBackgroundColor$, "(") = 1 then
        if ParseColor%(attBackgroundColor$, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%) <> 0 then
            attBackgroundColor$ := "gray";
        endif
    endif
    
    attCueCircleContrastAttend% := GetIntRegistryValue%(key$, "CueCircleContrastStim", 0);
    attCueCircleContrastIgnore1% := GetIntRegistryValue%(key$, "CueCircleContrastD1", 0);
    attCueCircleContrastIgnore2% := GetIntRegistryValue%(key$, "CueCircleContrastD2", 0);
    attCueCircleContrastIgnore3% := GetIntRegistryValue%(key$, "CueCircleContrastD3", 0);
    attCueCircleContrastIgnore4% := GetIntRegistryValue%(key$, "CueCircleContrastD4", 0);
    attCueCirclesMatchCueAllFixpt% := GetIntRegistryValue%(key$, "CueCirclesMatchCueAllFixpt", 0); 
    attCustomGratingColorCheck% := GetIntRegistryValue%(key$, "CustomGratingColorsCheck", 0);
    attCustomGratingColorStimFrom%[0] := GetIntRegistryValue%(key$, "CustomGratingColorsStimFromRed", 0);
    attCustomGratingColorStimFrom%[1] := GetIntRegistryValue%(key$, "CustomGratingColorsStimFromGreen", 0);
    attCustomGratingColorStimFrom%[2] := GetIntRegistryValue%(key$, "CustomGratingColorsStimFromBlue", 0);
    attCustomGratingColorStimTo%[0] := GetIntRegistryValue%(key$, "CustomGratingColorsStimToRed", 255);
    attCustomGratingColorStimTo%[1] := GetIntRegistryValue%(key$, "CustomGratingColorsStimToGreen", 255);
    attCustomGratingColorStimTo%[2] := GetIntRegistryValue%(key$, "CustomGratingColorsStimToBlue", 255);
    attCustomGratingColorDistractorFrom%[0] := GetIntRegistryValue%(key$, "CustomGratingColorsDistractorFromRed", 0);
    attCustomGratingColorDistractorFrom%[1] := GetIntRegistryValue%(key$, "CustomGratingColorsDistractorFromGreen", 0);
    attCustomGratingColorDistractorFrom%[2] := GetIntRegistryValue%(key$, "CustomGratingColorsDistractorFromBlue", 0);
    attCustomGratingColorDistractorTo%[0] := GetIntRegistryValue%(key$, "CustomGratingColorsDistractorToRed", 255);
    attCustomGratingColorDistractorTo%[1] := GetIntRegistryValue%(key$, "CustomGratingColorsDistractorToGreen", 255);
    attCustomGratingColorDistractorTo%[2] := GetIntRegistryValue%(key$, "CustomGratingColorsDistractorToBlue", 255);
    attendRGB%[0] := GetIntRegistryValue%(key$, "CueCircleColorAttendR", 0);
    attendRGB%[1] := GetIntRegistryValue%(key$, "CueCircleColorAttendG", 0);
    attendRGB%[2] := GetIntRegistryValue%(key$, "CueCircleColorAttendB", 0);
    ignore1RGB%[0] := GetIntRegistryValue%(key$, "CueCircleColorIgnore1R", 0);
    ignore1RGB%[1] := GetIntRegistryValue%(key$, "CueCircleColorIgnore1G", 0);
    ignore1RGB%[2] := GetIntRegistryValue%(key$, "CueCircleColorIgnore1B", 0);
    ignore2RGB%[0] := GetIntRegistryValue%(key$, "CueCircleColorIgnore2R", 0);
    ignore2RGB%[1] := GetIntRegistryValue%(key$, "CueCircleColorIgnore2G", 0);
    ignore2RGB%[2] := GetIntRegistryValue%(key$, "CueCircleColorIgnore2B", 0);
    ignore3RGB%[0] := GetIntRegistryValue%(key$, "CueCircleColorIgnore3R", 0);
    ignore3RGB%[1] := GetIntRegistryValue%(key$, "CueCircleColorIgnore3G", 0);
    ignore3RGB%[2] := GetIntRegistryValue%(key$, "CueCircleColorIgnore3B", 0);
    ignore4RGB%[0] := GetIntRegistryValue%(key$, "CueCircleColorIgnore4R", 0);
    ignore4RGB%[1] := GetIntRegistryValue%(key$, "CueCircleColorIgnore4G", 0);
    ignore4RGB%[2] := GetIntRegistryValue%(key$, "CueCircleColorIgnore4B", 0);
    cueallRGB%[0] := GetIntRegistryValue%(key$, "CueCircleColorNoAttenR", 0);  'registry key does not match due to Spike2-side nomenclature change
    cueallRGB%[1] := GetIntRegistryValue%(key$, "CueCircleColorNoAttenG", 0);  'registry key does not match due to Spike2-side nomenclature change
    cueallRGB%[2] := GetIntRegistryValue%(key$, "CueCircleColorNoAttenB", 0);  'registry key does not match due to Spike2-side nomenclature change
    nomatchRGB%[0] := GetIntRegistryValue%(key$, "CueCircleColorNoMatchR", 0);
    nomatchRGB%[1] := GetIntRegistryValue%(key$, "CueCircleColorNoMatchG", 0);
    nomatchRGB%[2] := GetIntRegistryValue%(key$, "CueCircleColorNoMatchB", 0);
    
end;

proc SaveColorsDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG2";
    

	SetStringRegistryValue(key$, "BackgroundColor", attBackgroundColor$);
    SetIntRegistryValue(key$, "CueCircleContrastStim", attCueCircleContrastAttend%);
    SetIntRegistryValue(key$, "CueCircleContrastD1", attCueCircleContrastIgnore1%);
    SetIntRegistryValue(key$, "CueCircleContrastD2", attCueCircleContrastIgnore2%);
    SetIntRegistryValue(key$, "CueCircleContrastD3", attCueCircleContrastIgnore3%);
    SetIntRegistryValue(key$, "CueCircleContrastD4", attCueCircleContrastIgnore4%); 
    SetIntRegistryValue(key$, "CueCirclesMatchCueAllFixpt", attCueCirclesMatchCueAllFixpt%);    
    SetIntRegistryValue(key$, "CustomGratingColorsCheck", attCustomGratingColorCheck%);
    SetIntRegistryValue(key$, "CustomGratingColorsStimFromRed", attCustomGratingColorStimFrom%[0]);
    SetIntRegistryValue(key$, "CustomGratingColorsStimFromGreen", attCustomGratingColorStimFrom%[1]);
    SetIntRegistryValue(key$, "CustomGratingColorsStimFromBlue", attCustomGratingColorStimFrom%[2]);
    SetIntRegistryValue(key$, "CustomGratingColorsStimToRed", attCustomGratingColorStimTo%[0]);
    SetIntRegistryValue(key$, "CustomGratingColorsStimToGreen", attCustomGratingColorStimTo%[1]);
    SetIntRegistryValue(key$, "CustomGratingColorsStimToBlue", attCustomGratingColorStimTo%[2]);
    SetIntRegistryValue(key$, "CustomGratingColorsDistractorFromRed", attCustomGratingColorDistractorFrom%[0]);
    SetIntRegistryValue(key$, "CustomGratingColorsDistractorFromGreen", attCustomGratingColorDistractorFrom%[1]);
    SetIntRegistryValue(key$, "CustomGratingColorsDistractorFromBlue", attCustomGratingColorDistractorFrom%[2]);
    SetIntRegistryValue(key$, "CustomGratingColorsDistractorToRed", attCustomGratingColorDistractorTo%[0]);
    SetIntRegistryValue(key$, "CustomGratingColorsDistractorToGreen", attCustomGratingColorDistractorTo%[1]);
    SetIntRegistryValue(key$, "CustomGratingColorsDistractorToBlue", attCustomGratingColorDistractorTo%[2]);
    SetIntRegistryValue(key$, "CueCircleColorAttendR", attendRGB%[0]);
    SetIntRegistryValue(key$, "CueCircleColorAttendG", attendRGB%[1]);
    SetIntRegistryValue(key$, "CueCircleColorAttendB", attendRGB%[2]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore1R", ignore1RGB%[0]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore1G", ignore1RGB%[1]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore1B", ignore1RGB%[2]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore2R", ignore2RGB%[0]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore2G", ignore2RGB%[1]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore2B", ignore2RGB%[2]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore3R", ignore3RGB%[0]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore3G", ignore3RGB%[1]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore3B", ignore3RGB%[2]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore4R", ignore4RGB%[0]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore4G", ignore4RGB%[1]);
    SetIntRegistryValue(key$, "CueCircleColorIgnore4B", ignore4RGB%[2]);
    SetIntRegistryValue(key$, "CueCircleColorNoAttenR", cueallRGB%[0]);  'registry key does not match due to Spike2-side nomenclature change
    SetIntRegistryValue(key$, "CueCircleColorNoAttenG", cueallRGB%[1]);  'registry key does not match due to Spike2-side nomenclature change
    SetIntRegistryValue(key$, "CueCircleColorNoAttenB", cueallRGB%[2]);  'registry key does not match due to Spike2-side nomenclature change
    SetIntRegistryValue(key$, "CueCircleColorNoMatchR", nomatchRGB%[0]);
    SetIntRegistryValue(key$, "CueCircleColorNoMatchG", nomatchRGB%[1]);
    SetIntRegistryValue(key$, "CueCircleColorNoMatchB", nomatchRGB%[2]);

    
end;





func AttentionScriptDialog%() 
	var i%;
    var tempTrialsPerContrast%;
    var tempTotal;  'friggin integer math
    var tempWhoops;
    var tenints%[10];
    var cueCircleList$[4];
  
    cueCircleList$[0] := "No Cue Circles";
    'cueCircleList$[1] := "Cue Circles";
    cueCircleList$[1] := "Cue Squares (not working)";
    cueCircleList$[2] := "Cue Circles + Cue Points";
    cueCircleList$[3] := "Cue Points Only";  'should be ready to go
    
	GetAttentionScriptParameters();
    GetColorsDialogParameters();  'we need to GET the parameters here, or the user will need to open each dialog
    GetTimingDialogParameters();  'this too...
    'Override JuiceRewardMSMin%/JuiceRewardMSMax% with values from dialog, if using hazard for reward
    'The problem is that if Henry doesn't run the Timing dialog box, this calculation isn't done and the
    'values from Config pertain, and they may not be good values.  So we have to calculate them here in case
    'Henry doesn't run the Timing dialog, which, once his values are set, he wouldn't.
    'This really isn't great policy and these numbers really should probably be set from within Config/DAQ as
    'that's where they live, but I guess if Henry complains enough he gets what he wants.  Note that any call
    'to GetDAQParameters() subsequent to this section will restore the values to the state from Config/DAQ, I
    'am NOT saving the values written here to the DAQ registry.  Only overriding values if hazard function used.
    if attUseHazardForReward% = 1 then
        JuiceRewardMSMin% := attHazRewardMin%;
        JuiceRewardMSMax% := attHazRewardMax%;
    endif;
    GetFlasherDialogParameters(); 'and this...
    GetAttOptoParameters();  'and this...
    GetAttCuesToUseParameters();  'and this...
    CreateMasterColorLists();  'and this...
    
    attUseLowReward% := 0;  'Disabling low reward, not being used.  Set check box to 0, disabled changing check box in dialog-changed function
    attUseFlashers% := 0;  'Disabling using flashers, for now, may reinstate.  So, setting check box to 0, disabling check box and flashers dialog button
    
    tenints%[0] := attTrainingContrastCheck%;
    tenints%[1] := attTrainingContrastPct%;
    tenints%[2] := attSelectRandomContrastEachTrial%;
    tenints%[3] := attPhaseCheck%;
    tenints%[4] := attPhaseDeg%;
    tenints%[5] := attNumPatches%;
    tenints%[6] := attGetGPFromMainStim%;
    tenints%[7] := attUseFlashers%;
    tenints%[8] := attUseCueCircles%;
    tenints%[9] := attSwapCueCircle%;

    
	DlgCreate("Attention Training Parameters",31,10);   'on Spike2 v6, must extend height, on v8, will auto-extend height
    DlgGroup("Blocks", 1, 1, 34, 9);
	DlgInteger(1, 7, 1, 1000, 27, 2);  DlgText("Number of SETS of blocks:",2,2);
	DlgInteger(2, 7, 1, 1000, 27, 3);  DlgText("Regular Trials per block:",2,3);
    DlgInteger(3, 7, 0, 1000, 27, 4);  DlgText("Easy Trials per block:",2,4);
    DlgCheck(4, "Distracter Off for Easy Trials", 2, 5);
    DlgInteger(5, 7, 0, 100, 27, 6); DlgText("Cued Loc Chg% (0-100)",2,6);
    DlgInteger(6, 7, 0, 100, 27, 7); DlgText("Uncued Loc Chg% (0-100)",2,7);
    DlgInteger(28, 7, 0, 100, 27, 8); DlgText("No Cues Match Fix% (0-100)",2,8);
    DlgButton(2, "Block Cues To Use", AttCuesToUseDialog%, 2, 9);  
    
    
    'Moving this group to the right, so we have to use DlgText because otherwise CED justifies the text all the way left
    DlgGroup("Contrast",36,1,34,9);
    DlgInteger(7, 7, 0, 100, 62, 2);  DlgText("Base contrast (%)",37,2);
	DlgReal(8, 7, 0, 10, 62, 3);  DlgText("Max dContrast (oct)",37,3);
	DlgReal(9, 7, 0, 10, 62, 4);  DlgText("Min dContrast (oct)",37,4);
    DlgInteger(10, 7, 1, 10, 62, 5);  DlgText("N contrast levels",37,5);
    DlgReal(11, 7, -1, 10, 62, 6);  DlgText("Ans. window rad. (deg)",37,6);
	DlgCheck(12, "Training Contrast", 37, 7);
	DlgInteger(13, 7, 0, 100, 62, 8);  DlgText("Training Contrast(%)",37,8);
    DlgCheck(14, "Random contrast by trial (not block)", 37, 9);  '"Do NOT randomize by block", position WAS 2,10 now swapped 
    'DlgCheck(14, "Select random contrast each trial", 37, 9);  'This is just the old phrasing
    
    DlgGroup("Phase", 1, 10, 34, 3);
    DlgCheck(15, "Set phase at contrast change", 2, 11);
	DlgInteger(16, 7, 0, 360, 27, 12);  DlgText("Phase at cc (deg, 0 = white)",2,12);
    
    DlgGroup("Stimuli", 36, 10, 34, 4);
    DlgInteger(17, 10, 1, 5, 58, 11); DlgText("Num of grating patches",37,11);
    DlgCheck(18, "Get distracter params from main stim", 37, 12);
    DlgCheck(19, "Use Flashers", 37, 13);
    
    DlgGroup("Cue Circles", 1, 13, 34, 5);
    DlgList(20, 30, cueCircleList$[], 4, 4, 14);
    DlgCheck(21, "Swap Cue Circles (if used)", 2, 15);
	DlgReal(22, "Cue extra radius (deg)", 0, 5, 21, 16);
    DlgInteger(23, 4, 0, 20, 30, 17); DlgText("Cue Circle Stroke Width(integer)",2,17);
    
    
    DlgGroup("Reward", 36, 14, 34, 3);
    DlgCheck(24, "Use Low Reward For No-Change Trls", 37, 15);
    DlgInteger(25, 10, 1, 1000, 58, 16); DlgText("Low Reward (ms)",37,16);
    
    DlgGroup("Optogenetics", 1, 18, 68, 2);
    DlgCheck(26,"Opto On",2,19);
    DlgButton(3, "Optogenetics Parameters", AttOptoDialog%, 36, 19);
    
    DlgCheck(27,"Use Joystick",2,20);
    DlgButton(4, "Joystick Dialog", CallJoystickConfigDialog%,36-14,20);
    DlgButton(5, "Colors", ColorsDialog%, 2+36, 20);
    DlgButton(6, "Timing", TimingDialog%, 11+36, 20);  
    DlgButton(7, "Flashers", CallDlgGratingFlashers%, 21+36, 20);  

    DlgAllow(0, 0, AttentionScriptDialogChanged%);
    
	i%:=DlgShow(attNumberOfSetsOfBlocks%, attTrialsPerBlock%, attEasyTrialsPerBlock%, distracterOffForEasy%, attCuedLocationChangePct%, attUncuedLocationChangePct%,
    attContrastBase%, attMaxContChange, attMinContChange, attNContLevels%, attAnswerPointWindowRadius, tenints%[], 
    attCueCircleExtraRadius, attCueCircleStrokeWidth%, attUseLowReward%, attLowReward%, attDoOpto%, attRequireJoystickResponse%, attNoCuesMatchFixpt%);
    
    
	if i% = 1 then
        
        'put tenints values back into variables
        attTrainingContrastCheck% := tenints%[0];
        attTrainingContrastPct% := tenints%[1];
        attSelectRandomContrastEachTrial% := tenints%[2];
        attPhaseCheck% := tenints%[3];
        attPhaseDeg% := tenints%[4];
        attNumPatches% := tenints%[5];
        attGetGPFromMainStim% := tenints%[6];
        attUseFlashers% := tenints%[7];
        attUseCueCircles% := tenints%[8];
        attSwapCueCircle% := tenints%[9];
        
        'Make sure the user doesn't break things by having illegal values in the blocks dialog
        '(OK, technically, the blocks dialog doesn't allow illegal values, but those values can later turn out illegal
        ' if the user decreases the number of stimuli after running the blocks dialog, or without running the blocks dialog)
        docase
        case attNumPatches% = 4 then
            if attNumDistracter4Cues% > 0 then
                attNumDistracter4Cues% := 0;
                message("Distracter 4 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 4 cues to zero!!!");
            endif;
        case attNumPatches% = 3 then
            if attNumDistracter4Cues% > 0 then
                attNumDistracter4Cues% := 0;
                message("Distracter 4 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 4 cues to zero!!!");
            endif;
            if attNumDistracter3Cues% > 0 then
                attNumDistracter3Cues% := 0;
                message("Distracter 3 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 3 cues to zero!!!");
            endif;
        case attNumPatches% = 2 then
            if attNumDistracter4Cues% > 0 then
                attNumDistracter4Cues% := 0;
                message("Distracter 4 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 4 cues to zero!!!");
            endif;
            if attNumDistracter3Cues% > 0 then
                attNumDistracter3Cues% := 0;
                message("Distracter 3 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 3 cues to zero!!!");
            endif;
            if attNumDistracter2Cues% > 0 then
                attNumDistracter2Cues% := 0;
                message("Distracter 2 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 2 cues to zero!!!");
            endif;
        case attNumPatches% = 1 then
            if attNumDistracter4Cues% > 0 then
                attNumDistracter4Cues% := 0;
                message("Distracter 4 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 4 cues to zero!!!");
            endif;
            if attNumDistracter3Cues% > 0 then
                attNumDistracter3Cues% := 0;
                message("Distracter 3 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 3 cues to zero!!!");
            endif;
            if attNumDistracter2Cues% > 0 then
                attNumDistracter2Cues% := 0;
                message("Distracter 2 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 2 cues to zero!!!");
            endif;
            if attNumDistracter1Cues% > 0 then
                attNumDistracter1Cues% := 0;
                message("Distracter 1 cues were requested, but not enough stimuli are specified!!!\nSetting Distracter 1 cues to zero!!!");
            endif;
        endcase
        
        
        
        'calculate cues per set (maybe again) because we might not go into the dialog
        attBlocksPerSet% := attNumMainCues%+attNumDistracter1Cues%+attNumDistracter2Cues%+attNumDistracter3Cues%+attNumDistracter4Cues%+attNumCueAllCues%+attNumRandomNoCACues%+attNumRandomWithCACues%;
        
        
        
        'set low reward if we are using it
        if attUseLowReward% = 1 then
            lowRewardMS% := attLowReward%;
        else
            lowRewardMS% := origRewardMS%;
        endif;
        
        
        if attMinContChange > attMaxContChange then
            message("The maximum contrast change must be MORE than the minimum!  Swapping!");
            tempWhoops := attMinContChange;
            attMinContChange := attMaxContChange;
            attMaxContChange := tempWhoops;
        endif;
        
		SaveAttentionScriptParameters();
        
        'After saving parameters, set phase to 0 if we are not controlling it
        if attPhaseCheck% = 0 then
            attPhaseDeg% := 0;
        endif;
        
        'Fill attStimOnsetList[] with the stim onset time, for now this is NOT variable
        ArrConst(attStimOnsetList[],attStimOnsetTime);
        
        'get contrast list
        docase
        'This is the typical case, multiple contrast levels and base contrast is non-zero
        case attNContLevels% > 1 and attContrastBase% > 0 then  'if base contrast is zero, then the contrast list will be all zeros anyway, do nothing (rather than break GetLogProgression)
            GetLogProgression(attContrastBase%*(pow(2,attMinContChange)),attContrastBase%*(pow(2,attMaxContChange)),attNContLevels%-1,attContrastList[0:attNContLevels%]);  'levels above base
            'Arrconst(attContrastList[attNContLevels%:attNContLevels%],attContrastBase%);  'for no-go, assign the second half of stimuli as identical to the base contrast
            round(attContrastList[]);  'we can only use integer values in the VSG call
        'This is a special case, where we have multiple contrast levels but the base level is zero    
        case  attNContLevels% > 1 and attContrastBase% = 0 then 
            'Here, by request of Hankzilla, we "pretend" the base contrast is 1 for doing the log progression
            GetLogProgression(1*(pow(2,attMinContChange)),1*(pow(2,attMaxContChange)),attNContLevels%-1,attContrastList[0:attNContLevels%]);  'levels above base
            round(attContrastList[]);  'we can only use integer values in the VSG call
        'This is a special case where we have a single contrast level requested and base contrast is non-zero
        case attNContLevels% = 1 and attContrastBase% > 0 then
            'if only one value is requested, this will crash GetLogProgression, so just do it manually
            attContrastList[0] := attContrastBase%*(pow(2,attMaxContChange));
            'attContrastList[1] := attContrastBase%;  'for go/no-go, use the base, not a down contrast, this functionality has been deprecated
        'This is a special case where we have a single contrast level requested and the base contrast is zero
        else
            attContrastList[0] := 1*(pow(2,attMaxContChange));
        endcase;
        
        'get number of trials to run, which is hypothetical "max" number for both test trials and catch trials regardless of catch/test percentage
        tempTotal := attNumberOfSetsOfBlocks%*attBlocksPerSet%*attTrialsPerBlock%;  'total number of non-"easy" trials
        tempTrialsPerContrast% := ceil(tempTotal/(attNContLevels%));  'MAXIMUM number of times we have to repeat the tuning curve to reach the total number of trials, if 0 no-go trials
        
        printlog("number of contrast levels is %d and tempTrialsPerContrast is %d\n",attNContLevels%,tempTrialsPerContrast%);
        
        'It's a bit tricky to try to push the idea of variable No-Go percentage (as opposed to 50%) into the GetRepeatedParameterProgression
        'schematic, but I think I've got a plan.
        'First step - create a list of contrasts as normal in a temporary variable, but only include "go" contrasts 
        if attSelectRandomContrastEachTrial% = 0 then
            'get trial order, attTrialOrder%[] will hold indices into attContrastList[] for all trials
            GetRepeatedParameterProgression%(attNContLevels%,tempTrialsPerContrast%,attTrial[],attTrialOrder%[],0,(attNContLevels%)-1,0,1);
            GetRepeatedParameterProgression%(attNContLevels%,tempTrialsPerContrast%,attTrial[],attTrial2Order%[],0,(attNContLevels%)-1,0,1);
        else 'Henry sez just do true random, selects a random contrast level for every trial for the entire experiment
            Rand(attTrialOrder%[0:attNContLevels%*tempTrialsPerContrast%],attNContLevels%);
            Rand(attTrial2Order%[0:attNContLevels%*tempTrialsPerContrast%],attNContLevels%);
        endif;   
        
        
'        printlog("trial order is: %d\n",attTrialOrder%[0:attNContLevels%*tempTrialsPerContrast%]);
'        printlog("trial2 order is: %d\n",attTrial2Order%[0:attNContLevels%*tempTrialsPerContrast%]);
'        halt;
        
        
        
        '*** BEGIN USEFUL SECTION FOR TESTING CREATION OF TRIAL ORDER ON A MACHINE WITHOUT A 1401 ***
        '*** If this section is active, the program will not run! ***
        
'        'Contrast file test write is important for now, should be same as in Start function
'        'Write contrast file, pulling this out of CreateContrastList so we only have to write once
'        var c$;
'        CreateContrastList(c$,Flashers$,attIsCueAll%[],attCuedLocList%[],attCuedLocChangesList%[],attContrastCuedList%[],attCuedLocCCTime[],
'        attCuedLocReturnTime[],attUncuedLocList%[],attUncuedLocChangesList%[],attContrastUncuedList%[],attUncuedLocCCTime[],attUncuedLocReturnTime[],
'        attTrialEndTime[],attFixColor%[],attCueCircleColor%[][],attOffBitsList%[],attBlockList%[],attSetList%[],attEasyList%[]);',
'        'flasherTimes[][],flasherX[][],flasherY[][],flasherCount%[];
'        ContrastFile$:="E:\\testingshit\\AttentionTrialContrastFile.txt";  'this is for testing on Seager
'        FileOpen(ContrastFile$, 8, 1);
'        'print constructed contrast string to file
'        Print("%s",c$);
'        'close contrast file
'        FileClose(0);
'        
'        'open a file to write the spec file for the VSG
'        var specHandle%;
'        var specFileName$:="E:\\testingshit\\AttentionSpecFile.txt";
'        var Extras$;
'        var stimSpec$;
'        var dist1Spec$;
'        var dist2Spec$;
'        var dist3Spec$;
'        var dist4Spec$;
'        var CueCirc$;
'        var ContrastFileWithFlag$;
'        
'        specHandle% := FileOpen(specFileName$, 8, 1);
'        FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + ",red"; 
'        Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$();
'        'get all these grating parameters
'        stimSpec$ := GetGratingParameters$("Stimulus");
'        ParseGratingParametersBrief%(stimSpec$, xT, yT, wT, hT);  'we may as well just do this every time - 90+% of the time we will anyway, and why put it in the if statements four times?
'        if attNumPatches% > 1 then
'            if attGetGPFromMainStim% = 1 then
'                ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"), xT, yT, wT, hT);
'                dist1Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
'                ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);  'for helping placement of flashers, etc.
'            else
'                dist1Spec$ := GetGratingParameters$("Distractor1");
'                ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);
'            endif;
'        endif;
'        if attNumPatches% > 2 then
'            if attGetGPFromMainStim% = 1 then
'                ParseGratingParametersBrief%(GetGratingParameters$("Distractor2"), xT, yT, wT, hT);
'                dist2Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
'                ParseGratingParametersBrief%(dist2Spec$, xD2, yD2, wD2, hD2);  
'            else
'                dist2Spec$ := GetGratingParameters$("Distractor2");
'                ParseGratingParametersBrief%(dist2Spec$, xD2, yD2, wD2, hD2);
'            endif;
'        endif;
'        if attNumPatches% > 3 then
'            if attGetGPFromMainStim% = 1 then
'                ParseGratingParametersBrief%(GetGratingParameters$("Distractor3"), xT, yT, wT, hT);
'                dist3Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
'                ParseGratingParametersBrief%(dist3Spec$, xD3, yD3, wD3, hD3); 
'            else
'                dist3Spec$ := GetGratingParameters$("Distractor3");
'                ParseGratingParametersBrief%(dist3Spec$, xD3, yD3, wD3, hD3);
'            endif;
'        endif;
'        if attNumPatches% > 4 then
'            if attGetGPFromMainStim% = 1 then
'                ParseGratingParametersBrief%(GetGratingParameters$("Distractor4"), xT, yT, wT, hT);
'                dist4Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
'                ParseGratingParametersBrief%(dist4Spec$, xD4, yD4, wD4, hD4); 
'            else
'                dist4Spec$ := GetGratingParameters$("Distractor4");
'                ParseGratingParametersBrief%(dist4Spec$, xD4, yD4, wD4, hD4);
'            endif;
'        endif;
'        Stim$ := " -s " + stimSpec$;  
'        if attNumPatches% > 1 then
'            Stim$ := Stim$ + " -s " + dist1Spec$;
'        endif;
'        if attNumPatches% > 2 then
'            Stim$ := Stim$ + " -s " + dist2Spec$;
'        endif;
'        if attNumPatches% > 3 then
'            Stim$ := Stim$ + " -s " + dist3Spec$;
'        endif;
'        if attNumPatches% > 4 then
'            Stim$ := Stim$ + " -s " + dist4Spec$;
'        endif;
'        
'        if attUseCueCircles% > 0 then
'            CueCirc$ := CreateCueCircleColorSets$();
'        endif;
'        
'        ContrastFileWithFlag$ := " -n " + ContrastFile$; 'add flag to string containing loc of ContrastFile
'        
'        'No flashers right now, let's leave this...
'        'if attUseFlashers% = 1 then
'        '    flasherSpec$ := GetGratingParameters$("Flasher");
'        '    ParseGratingParametersBrief%(flasherSpec$, xF1, yF1, wF1, hF1);
'        '    Stim$ := Stim$ + " -k " + flasherSpec$;  'This specifies flasher #0, the VSG side software allows more flasher gratings to be spec'ed but as of now we will only use one
'        'endif;
'        
'        'print to spec file
'        if attUseFlashers% = 1 then
'            Print("%s %s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Flashers$,ContrastFileWithFlag$);  'file should be everything starting from FixationArg$ on, use flashers, Flashers$ must come before ContrastFile$!
'        else
'            Print("%s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,ContrastFileWithFlag$);  'file should be everything starting from FixationArg$ on
'        endif;    
'        'close spec file
'        
'        'recap command line to logfile
'        var CommandLine$;
'        CommandLine$ := "cmd /k " + GetBinDir$(1) + "remote.exe " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim -F " + specFileName$;
'        printlog("%s\n",CommandLine$);
'        FileClose(0);
'       
'        halt;
        '*** END USEFUL SECTION FOR TESTING CREATION OF TRIAL ORDER ON A MACHINE WITHOUT A 1401 ***
        
        
        
        'This stuff is...I'm not sure, but not part of the useful testing as of right now
        
'        'This specfile print is not right, but since it's only testing and I don't know if I care to see it...not bothering right now
'        var specFileName$:="E:\\AttentionSpecFile.txt";
'        var specHandle%;
'        specHandle% := FileOpen(specFileName$, 8, 1);
'        'print to spec file
'        Print("%s %s",ContrastFile$,Flashers$);  'file should be everything starting from FixationArg$ on
'        var thingy$;
'        thingy$ := CreateCueCircleColorSets$();
'        Print("\n %s",thingy$);
'        'close spec file
'        FileClose(0);
'       
'        
'
'        'printlog("Temp trial order list is %d\n",attTrialOrderTemp%[0:attNumberOfSetsOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
'        printlog("Contrast list is %d\n",attContrastCuedList%[0:attNumberOfSetsOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
'        'printlog("Valid list is %d\n",attValidList%[0:attNumberOfSetsOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
'        printlog("contrasts are %d\n",attContrastList[]);
'        printlog("*** TESTING CREATION OF TRIAL ORDER, NOW QUITTING BEFORE DOING ANYTHING REQUIRING A 1401! ***\n");
'        halt;
        
        
        
	endif;
	return i%;
end;


' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttentionScriptDialogChanged%(item%)
    var status% := 1;
    
    'DlgEnable(DlgValue(12), 13);  'allow training contrast based on use of training contrast
    DlgEnable(DlgValue(15), 16);  'allow phase value based on use of setting phase
    'DlgEnable(DlgValue(21), 22);  'allow cue circle radius based on use of cue circles  'these two appear to be from a prior syntax and no longer
    'DlgEnable(DlgValue(21), 23);  'allow cue circle width based on use of cue circles   'apply to the current syntax
    DlgEnable(DlgValue(24), 25);  'allow low reward value based on use of low reward
    DlgEnable(DlgValue(19), -7);  'allow flashers button based on use of flashers
    DlgEnable(DlgValue(26), -3);  'allow opto button based on use of opto
    
    DlgEnable(0,24);  'Completely disable low reward, may never use this again
    DlgEnable(0,25);  'etc.
    
    DlgEnable(0,19);  'Completely disable flashers, at least for now
    DlgEnable(0,-7);  'Also disable flashers dialog button
    
    DlgEnable(0,12);  'Training contrast currently doesn't DO anything!
    DlgEnable(0,13);  'etc.
    
    DlgEnable(0,21);  'Cue circle swapping does nothing right now!
    
    DlgEnable(0,11);  'Disabling answer point radius, using grating size instead
    
    return status%;
end




func ParseColor%(s$, &r%, &g%, &b%)
    var status% := -1;
    var n;
    ReadSetup("", "/(", "(", ")");
    n := ReadStr(s$, r%, g%, b%);
    ReadSetup();
    if n = 3 then
        status% := 0;
    endif
    return status%;
end

func EncodeColor$(r%, g%, b%)
    var s$;
    s$ := Print$("(%d/%d/%d)", r%, g%, b%);
    return s$;
end



func TimingDialog%()
    var i%;
    
    GetTimingDialogParameters();
    
	DlgCreate("Attention timing", 25, 10);
	DlgReal(atttimingdlgAcquisitionTime%, "Acquisition time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMinTime%, "Fixation cue hold min time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMaxTime%, "Fixation cue hold max time(s):", .01, 10);  'We will presumably lose the ability to have a variable stimulus onset time when the animation is implemented
    DlgReal(atttimingdlgCueOnsetTime%, "Cue onset time (s):", 0.1, 10);
    DlgReal(atttimingdlgCueOffsetTime%, "Cue offset time (s):", 0.2, 20);
    DlgReal(atttimingdlgStimOnsetTime%, "Grating onset time (rel. cue off) (s):", -5, 20);  'let's allow this to be negative!  Would allow grating to come on before cue goes off
    DlgReal(atttimingdlgHazardMinTime%, "Hazard min time(s):", 0, 10);
	DlgReal(atttimingdlgHazardExpMeanTime%, "Hazard exp mean time(s):", 0, 10);
	DlgReal(atttimingdlgHazardCutoffTime%, "Hazard cutoff time(s):", 0, 10);
    DlgCheck(atttimingdlgUseHazardForReward%, "Use Hazard Function For Reward Duration");
    DlgInteger(atttimingdlgHazRewardMin%, "Hazard Reward, Min (ms)", 10, 2000);
    DlgInteger(atttimingdlgHazRewardMax%, "Hazard Reward, Max (ms)", 10, 2000);
	DlgReal(atttimingdlgContrastChangeDuration%, "ContrastChangeDuration(s):",0.1,10);
    DlgReal(atttimingdlgResponseWindow%, "Response Window(s):",0.1,10);
	DlgReal(atttimingdlgIntertrialTime%, "Intertrial time(s):", .01, 10);
    DlgReal(atttimingdlgPenaltyTime%, "Generic penalty time(s):", .01, 10);
    DlgCheck(atttimingdlgLockUncued%, "Lock Uncued CC to Cued CC");
    'DlgCheck(atttimingdlgFixOffAtCC%, "Turn off fixation at CC");
    
         
    DlgAllow(0, 0, TimingDialogChanged%);
    i%:=DlgShow(attAcquisitionTime, attFixationCueMinTime, attFixationCueMaxTime, attCueOnsetTime, attCueOffsetTime, attStimOnsetTime,
    attHazardMinTime, attHazardExpMeanTime, attHazardCutoffTime, attUseHazardForReward%, attHazRewardMin%, attHazRewardMax%,
    attContrastChangeDuration, attResponseWindow, attInterTrialTime, attAbortPenaltyTime, attLockUncuedToCued%);   ', attFixationOffAtCC%
    if i% = 1 then
        attFalseAlarmPenaltyTime := attAbortPenaltyTime;
        attMissPenaltyTime := attAbortPenaltyTime;
        
        'Override JuiceRewardMSMin%/JuiceRewardMSMax% with values from dialog
        'This really isn't great policy and these numbers really should probably be set from within Config/DAQ as
        'that's where they live, but I guess if Henry complains enough he gets what he wants.  Note that any call
        'to GetDAQParameters() subsequent to this section will restore the values to the state from Config/DAQ, I
        'am NOT saving the values written here to the DAQ registry.  Only overriding values if hazard function used.
        if attUseHazardForReward% = 1 then
            JuiceRewardMSMin% := attHazRewardMin%;
            JuiceRewardMSMax% := attHazRewardMax%;
        endif;
        
        
        SaveTimingDialogParameters();
        
    endif;
    return 1;
end


func TimingDialogChanged%(item%)
    var status% := 1;
    
    DlgEnable(DlgValue(atttimingdlgUseHazardForReward%), atttimingdlgHazRewardMin%);  'allow hazard min reward time based on using hazard function
    DlgEnable(DlgValue(atttimingdlgUseHazardForReward%), atttimingdlgHazRewardMax%);  'allow hazard max reward time based on using hazard function
    
    docase
    case item% = atttimingdlgFixationCueMinTime% or item% = atttimingdlgFixationCueMaxTime% then
        ' max >= min
        if DlgValue(atttimingdlgFixationCueMinTime%) > DlgValue(atttimingdlgFixationCueMaxTime%) then
            status% := 0;
            Message("Fixation cue min time cannot be greater than max time!");
        endif
    case item% = atttimingdlgHazardMinTime% or item% = atttimingdlgHazardExpMeanTime% or item% = atttimingdlgHazardCutoffTime% then
        ' max >= min
        if DlgValue(atttimingdlgHazardMinTime%) > DlgValue(atttimingdlgHazardExpMeanTime%)  or DlgValue(atttimingdlgHazardExpMeanTime%) > DlgValue(atttimingdlgHazardCutoffTime%) then
            status% := 0;
            Message("Hazard min time <= Hazard mean time <= Hazard cutoff time");
        endif
    case item% = atttimingdlgCueOnsetTime% or item% = atttimingdlgCueOffsetTime% then
        if DlgValue(atttimingdlgCueOnsetTime%) >= DlgValue(atttimingdlgCueOffsetTime%) then 
            status% := 0;
            Message("Cue onset time must be < Cue offset time");
        endif;    
    case item% = atttimingdlgContrastChangeDuration% or item% = atttimingdlgResponseWindow% then
        if DlgValue(atttimingdlgContrastChangeDuration%) > DlgValue(atttimingdlgResponseWindow%) then
            status% := 0;
            Message("Response window cannot be < contrast change duration");
        endif
    case item% = atttimingdlgHazRewardMin% or item% = atttimingdlgHazRewardMax% then
        if DlgValue(atttimingdlgHazRewardMin%) > DlgValue(atttimingdlgHazRewardMax%) then 
            status% := 0;
            Message("Hazard reward min must be <= hazard reward max");
        endif;
        
        'The stim onset time is now defined to be in terms of time following cue offset, so this case statement is not relevant, an updated version is above
'    case item% = atttimingdlgCueOnsetTime% or item% = atttimingdlgCueOffsetTime% or item% = atttimingdlgStimOnsetTime% then
'        if DlgValue(atttimingdlgCueOnsetTime%) >= DlgValue(atttimingdlgCueOffsetTime%) or DlgValue(atttimingdlgCueOnsetTime%) >= DlgValue(atttimingdlgStimOnsetTime%) then 
'            status% := 0;
'            Message("Cue onset time < Cue offset time; Cue onset time < Stim onset time");
'        endif;
    
    endcase

    return status%;
end


func ColorsDialog%()
	var i%; var j%;
	var bcl$[4];
	var ibcl%:=0;
    var fiveints%[5];
    var twentyoneints%[21];
    
    GetColorsDialogParameters();
    
    'put defaults into fiveints%[]
    fiveints%[0] := attCueCircleContrastAttend%;
    fiveints%[1] := attCueCircleContrastIgnore1%;
    fiveints%[2] := attCueCircleContrastIgnore2%;  'Ignore2-Ignore4 are currently constrained to be identical by the dialog-changed function,
    fiveints%[3] := attCueCircleContrastIgnore3%;  'but the old syntax still works so it's much easier to change back, if desired,
    fiveints%[4] := attCueCircleContrastIgnore4%;  'just undo the changes (noted) in the dialog-changed function.
    
    'put defaults into twentyoneints%[]
    twentyoneints%[0] := attendRGB%[0];
    twentyoneints%[1] := attendRGB%[1];
    twentyoneints%[2] := attendRGB%[2];
    twentyoneints%[3] := ignore1RGB%[0];
    twentyoneints%[4] := ignore1RGB%[1];
    twentyoneints%[5] := ignore1RGB%[2];
    twentyoneints%[6] := ignore2RGB%[0];
    twentyoneints%[7] := ignore2RGB%[1];
    twentyoneints%[8] := ignore2RGB%[2];
    twentyoneints%[9] := ignore3RGB%[0];
    twentyoneints%[10] := ignore3RGB%[1];
    twentyoneints%[11] := ignore3RGB%[2];
    twentyoneints%[12] := ignore4RGB%[0];
    twentyoneints%[13] := ignore4RGB%[1];
    twentyoneints%[14] := ignore4RGB%[2];
    twentyoneints%[15] := cueallRGB%[0];
    twentyoneints%[16] := cueallRGB%[1];
    twentyoneints%[17] := cueallRGB%[2];
    twentyoneints%[18] := nomatchRGB%[0];
    twentyoneints%[19] := nomatchRGB%[1];
    twentyoneints%[20] := nomatchRGB%[2];

    
	GetAttentionScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    bcl$[3] := "custom";
    if InStr(attBackgroundColor$, "(") = 1 then
        ibcl% := attdlgColorIndexCustom%;
    else
        ibcl% := 2;
        for i%:=0 to 2 do
            if attBackgroundColor$ = bcl$[i%] then
                ibcl% := i%;
            endif
        next;
    endif
    
	DlgCreate("Attention colors", 25, 10);
    DlgAllow(0, 0, ColorsDialogChanged%);
	DlgList(1, "Background color:", bcl$);
    DlgInteger(2, "Background red (0-255)", 0, 255);
    DlgInteger(3, "Background green (0-255)", 0, 255);
    DlgInteger(4, "Background blue (0-255)", 0, 255);
    
    DlgGroup("Cue Circles",1,5,72,9);
    DlgInteger(attcolorsdlgCueContrastAttend%, "Attend Cue Circle Contrast", 0, 100, 27, 7);
    DlgInteger(attcolorsdlgCueContrastIgnore1%, "Ignore1 Cue Circle Contrast", 0, 100, 27, 8);
    DlgInteger(attcolorsdlgCueContrastIgnore2%, "Ignore2 Cue Circle Contrast", 0, 100, 27, 9);
    DlgInteger(attcolorsdlgCueContrastIgnore3%, "Ignore3 Cue Circle Contrast", 0, 100, 27, 10);
    DlgInteger(attcolorsdlgCueContrastIgnore4%, "Ignore4 Cue Circle Contrast", 0, 100, 27, 11);
    DlgCheck(attcolorsdlgAllCueCirclesMatchFix%, "All cue circles match fixpt on Cue All",2,12);
    DlgText("0-100",30,6);
    DlgText("(0/255)       R         G          B",47,6);
    DlgText("FixPt 1",47,7);
    DlgText("FixPt 2",47,8);
    DlgText("FixPt 3",47,9);
    DlgText("FixPt 4",47,10);
    DlgText("FixPt 5",47,11);
    DlgText("Cue All FixPt",41,12);  'no cue circles will match this color if not multiply defined
    DlgText("No-Match FixPt",41,13);  'no cue circles will match this color
    DlgInteger(attcolorsdlgCueCircleColorAttendR%, 5, 0, 255, 55, 7);
    DlgInteger(attcolorsdlgCueCircleColorAttendG%, 5, 0, 255, 61, 7);
    DlgInteger(attcolorsdlgCueCircleColorAttendB%, 5, 0, 255, 67, 7);
    DlgInteger(attcolorsdlgCueCircleColorIgnore1R%, 5, 0, 255, 55, 8);
    DlgInteger(attcolorsdlgCueCircleColorIgnore1G%, 5, 0, 255, 61, 8);
    DlgInteger(attcolorsdlgCueCircleColorIgnore1B%, 5, 0, 255, 67, 8);
    DlgInteger(attcolorsdlgCueCircleColorIgnore2R%, 5, 0, 255, 55, 9);
    DlgInteger(attcolorsdlgCueCircleColorIgnore2G%, 5, 0, 255, 61, 9);
    DlgInteger(attcolorsdlgCueCircleColorIgnore2B%, 5, 0, 255, 67, 9);
    DlgInteger(attcolorsdlgCueCircleColorIgnore3R%, 5, 0, 255, 55, 10);
    DlgInteger(attcolorsdlgCueCircleColorIgnore3G%, 5, 0, 255, 61, 10);
    DlgInteger(attcolorsdlgCueCircleColorIgnore3B%, 5, 0, 255, 67, 10);
    DlgInteger(attcolorsdlgCueCircleColorIgnore4R%, 5, 0, 255, 55, 11);
    DlgInteger(attcolorsdlgCueCircleColorIgnore4G%, 5, 0, 255, 61, 11);
    DlgInteger(attcolorsdlgCueCircleColorIgnore4B%, 5, 0, 255, 67, 11);
    DlgInteger(attcolorsdlgCueCircleColorCueAllR%, 5, 0, 255, 55, 12);
    DlgInteger(attcolorsdlgCueCircleColorCueAllG%, 5, 0, 255, 61, 12);
    DlgInteger(attcolorsdlgCueCircleColorCueAllB%, 5, 0, 255, 67, 12);
    DlgInteger(attcolorsdlgCueCircleColorNoMatchR%, 5, 0, 255, 55, 13);
    DlgInteger(attcolorsdlgCueCircleColorNoMatchG%, 5, 0, 255, 61, 13);
    DlgInteger(attcolorsdlgCueCircleColorNoMatchB%, 5, 0, 255, 67, 13);
    
    
    DlgCheck(attcolorsdlgCustomGratingColorCheck%, "Custom grating colors",2,14);
    DlgGroup("Stimulus", 1, 15, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromRed%, "From Red (0-255)", 0, 255, 20, 16);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromGreen%, "From Green (0-255)", 0, 255, 20, 17);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromBlue%, "From Blue (0-255)", 0, 255, 20, 18);
    DlgInteger(attcolorsdlgCustomGratingColorStimToRed%, "To Red (0-255)", 0, 255, 20, 19);
    DlgInteger(attcolorsdlgCustomGratingColorStimToGreen%, "To Green (0-255)", 0, 255, 20, 20);
    DlgInteger(attcolorsdlgCustomGratingColorStimToBlue%, "To Blue (0-255)", 0, 255, 20, 21);
    DlgGroup("Distractor", 37, 15, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromRed%, 12, 0, 255, 56, 16);  'make these width 12, will match the default ones above for Stim
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromGreen%, 12, 0, 255, 56, 17);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromBlue%, 12, 0, 255, 56, 18);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToRed%, 12, 0, 255, 56, 19);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToGreen%, 12, 0, 255, 56, 20);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToBlue%, 12, 0, 255, 56, 21);  
    attCustomGratingDialogLabel%[0] := DlgText("From Red (0-255)",38,16);  'will match the default labels above from Stim, return value allows us to gray them out
    attCustomGratingDialogLabel%[1] := DlgText("From Green (0-255)",38,17);
    attCustomGratingDialogLabel%[2] := DlgText("From Blue (0-255)",38,18);
    attCustomGratingDialogLabel%[3] := DlgText("To Red (0-255)",38,19);
    attCustomGratingDialogLabel%[4] := DlgText("To Green (0-255)",38,20);
    attCustomGratingDialogLabel%[5] := DlgText("To Blue (0-255)",38,21);
    
	i% := DlgShow(ibcl%, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%, 
    fiveints%,attCustomGratingColorCheck%, 
    attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2], 
    attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2], 
    attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2], 
    attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2], twentyoneints%, attCueCirclesMatchCueAllFixpt%);
    
    
    
    
	' If user cancelled, reload params
	if i% = 1 then
        if ibcl% = attdlgColorIndexCustom% then
            attBackgroundColor$ := EncodeColor$(attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%);
        else
            attBackgroundColor$ := bcl$[ibcl%];
        endif
        
        'unpack the cue circle contrasts
        attCueCircleContrastAttend% := fiveints%[0];
        attCueCircleContrastIgnore1% := fiveints%[1];  
        attCueCircleContrastIgnore2% := fiveints%[2];  'don't need to change old version, the dialog-changed function fixes it
        attCueCircleContrastIgnore3% := fiveints%[3];
        attCueCircleContrastIgnore4% := fiveints%[4];         
        
        
        'unpack the cue circle colors
        'put defaults into twentyoneints%[]
        attendRGB%[0] := twentyoneints%[0];
        attendRGB%[1] := twentyoneints%[1];
        attendRGB%[2] := twentyoneints%[2];
        ignore1RGB%[0] := twentyoneints%[3];
        ignore1RGB%[1] := twentyoneints%[4];
        ignore1RGB%[2] := twentyoneints%[5];
        ignore2RGB%[0] := twentyoneints%[6];
        ignore2RGB%[1] := twentyoneints%[7];
        ignore2RGB%[2] := twentyoneints%[8];
        ignore3RGB%[0] := twentyoneints%[9];
        ignore3RGB%[1] := twentyoneints%[10];
        ignore3RGB%[2] := twentyoneints%[11];
        ignore4RGB%[0] := twentyoneints%[12];
        ignore4RGB%[1] := twentyoneints%[13];
        ignore4RGB%[2] := twentyoneints%[14];
        cueallRGB%[0] := twentyoneints%[15];
        cueallRGB%[1] := twentyoneints%[16];
        cueallRGB%[2] := twentyoneints%[17];
        nomatchRGB%[0] := twentyoneints%[18];
        nomatchRGB%[1] := twentyoneints%[19];
        nomatchRGB%[2] := twentyoneints%[20];
        
        
        'masterColorList$ and masterColorListVSG$ define fixation colors and should have the same progression as cue circle colors
        'but due to the command line need to be in a text format.  Use cue circle colors to fill these variables.
        'This function will allow any integer color values from 0-255 even though the above code currently will not.
        CreateMasterColorLists();
        
        'if the background is not gray, set cue circles to full contrast, if you want to change contrast of cue circles
        'but use a different color background the you will have to adapt FadeColorToGray$()
        if ibcl% <> attdlgColorIndexGray% then
            attCueCircleContrastAttend% := 100;
            attCueCircleContrastIgnore1% := 100;
            attCueCircleContrastIgnore2% := 100;
            attCueCircleContrastIgnore3% := 100;
            attCueCircleContrastIgnore4% := 100;
        endif
        
        
        SaveColorsDialogParameters();
        
        'Test output within colors dialog, allows me to test without crashing on a non-1401 computer
        'Problem is that this does not respect the dialog value for the number of gratings, hard to test...
        'This test can crash stuff if attUseCueCircles% is 0 - note that this value is not UPDATED until OK is 
        'pressed on the main dialog, so testing at this point in the dialog is totally nonideal and only
        'intended for specific purposes, make sure you've got a reasonable attUseCueCircles% value saved, and 
        'disable this testing when done with it!
        
        'if attUseCueCircles% > 0 then
            'var AString$;
            'AString$ := CreateCueCircleColorSetsLite$();  'Lite version only creates one set of cue circles, no rotation
            'printlog("Cue circles list is: %s\n",AString$);
        'endif;
        
	endif
    
	return 1;
end;

func ColorsDialogChanged%(item%)
    var status% := 1;    
    var constantContrast%;
    
    constantContrast% := DlgValue(attcolorsdlgCueContrastIgnore1%);  'get contrast of Ignore stim 1
    'DlgValue(attcolorsdlgCueContrastIgnore2%,constantContrast%);  'and set contrast of Ignore stims 2-4, currently not allowed to vary
    'DlgValue(attcolorsdlgCueContrastIgnore3%,constantContrast%);
    'DlgValue(attcolorsdlgCueContrastIgnore4%,constantContrast%);
    
    'I'm keeping this around in case things change, but it was deprecated before usage -- Update, this dialog space now been used for the No-Match color, and is again active
    'DlgEnable(0,attcolorsdlgCueCircleColorNoMatchR%);
    'DlgEnable(0,attcolorsdlgCueCircleColorNoMatchG%);
    'DlgEnable(0,attcolorsdlgCueCircleColorNoMatchB%);
    
    if item% = 0 or item% = attcolorsdlgBackgroundColor% then
        docase
        case DlgValue(attcolorsdlgBackgroundColor%) = 3 then
            DlgEnable(1, attcolorsdlgBackgroundRed%);
            DlgEnable(1, attcolorsdlgBackgroundGreen%);
            DlgEnable(1, attcolorsdlgBackgroundBlue%);
            DlgEnable(0, attcolorsdlgCueContrastAttend%);  'For now, no changing cue circle contrast if background is not gray
            DlgEnable(0, attcolorsdlgCueContrastIgnore1%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore2%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore3%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore4%);
        case DlgValue(attcolorsdlgBackgroundColor%) = 0 then  
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
            DlgEnable(1, attcolorsdlgCueContrastAttend%);  'Allow changing cue circle contrast if background is gray
            DlgEnable(1, attcolorsdlgCueContrastIgnore1%);
            DlgEnable(1, attcolorsdlgCueContrastIgnore2%);  'Now unsure why this is specifically disallowed.  But until there is a complaint...
            DlgEnable(1, attcolorsdlgCueContrastIgnore3%);
            DlgEnable(1, attcolorsdlgCueContrastIgnore4%);
        else
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
            DlgEnable(0, attcolorsdlgCueContrastAttend%);  'For now, no changing cue circle contrast if background is not gray
            DlgEnable(0, attcolorsdlgCueContrastIgnore1%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore2%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore3%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore4%);
        endcase
    endif
    
    if item% = 0 or item% = attcolorsdlgCustomGratingColorCheck% then
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[0]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[1]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[2]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[3]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[4]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[5]);
    endif
    
    'If we decide to make the different invalid cue circles have different contrasts, get rid of this
    'if statement altogether and uncomment three commented lines above.  
    'if item% = 0 or item% = attcolorsdlgCueContrastIgnore1% then
        'Currently, just don't allow these to change
        'DlgEnable(0, attcolorsdlgCueContrastIgnore2%);
        'DlgEnable(0, attcolorsdlgCueContrastIgnore3%);
        'DlgEnable(0, attcolorsdlgCueContrastIgnore4%);
        'DlgValue(attcolorsdlgCueContrastIgnore2%,DlgValue(attcolorsdlgCueContrastIgnore1%));  'update the other values to whatever the d1 value is
        'DlgValue(attcolorsdlgCueContrastIgnore3%,DlgValue(attcolorsdlgCueContrastIgnore1%));
        'DlgValue(attcolorsdlgCueContrastIgnore4%,DlgValue(attcolorsdlgCueContrastIgnore1%));
    'endif
    
    return status%;
end





func AttOptoDialog%()
	var iReturn% := 1;
	var i%;
'    var labels$[4];
    var stimdur;
    var tempNPulses%;
    var tempCount%;
    stimdur := attFixationCueMaxTime + attHazardCutoffTime + attContrastChangeDuration;  'get stimulus duration value from calling (main) dialog, limit opto period based on this
    
'    labels$[0] := "Opto Off First";
'    labels$[1] := "Opto On First";
'    labels$[2] := "Random First";
'    labels$[3] := "Opto On All Blocks";
	GetAttOptoParameters();
	DlgCreate("Optogenetics Parameters");
    DlgGroup("Common Parameters", 1, 1, 38, 5);
    DlgReal(1, "Opto Voltage Out (V)",0.0002,5,20,2); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    DlgReal(2, "Proportion of Opto Trials (0-1)",0,1,20,3);
    DlgReal(3, "InterBlock Time(s):", 0, 100, 20, 4);  'new, allow really long stimuli
    DlgCheck(4, "Use pulsing opto",2,5);
    DlgCheck(5, "Record Laser Diode",2,6);
    DlgGroup("Wrap-Around Opto", 1, 7, 38, 3);
    DlgReal(6, "PreStimulus Opto On (s)",0,10,20,8);
    DlgReal(7, "PostStimulus Opto On (s)",0,10,20,9);
    DlgGroup("Pulsing Opto", 1, 10, 38, 5);
    DlgInteger(8, "Opto # Pulses ",0,1000,20,11);
    DlgReal(9, "Opto Period Onset (s)",0,stimdur,20,12);
    DlgReal(10, "Opto Pulse Width (s)",0,stimdur,20,13);
    DlgReal(11, "Opto Interpulse Interval (s)",0,100,20,14);
    
    
    DlgAllow(0xffff, 0, AttOptoDialogChanged%);    
    
    i% := DlgShow(attOptoVoltageOut,attOptoPropOpto,attInterBlockTime,attOptoUsePulse%,attLaserDiode%,attPreStimOptoTime,attPostStimOptoTime,attOptoNPulses%,attPulsedOptoOnset,attPulsedOptoWidth,attPulsedOptoIPI);
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 

	if i% = 1 then
		SaveAttOptoParameters();
        
        'do temporary calculation to make sure all pulses will occur during the stimulus
        'unfortunately we will have to do this AGAIN once the script starts because the user could change the stimulus duration after the opto parameters
        'fortunately, the calculation is the same and it all worked on the first try
        if attOptoUsePulse% = 1 then
            stimdur := stimdur - attPulsedOptoOnset;  'duration of stimulus after onset delay
            stimdur := stimdur - attPulsedOptoWidth;  'duration of stimulus after first opto pulse
            if stimdur < 0 then  'if first pulse will extend beyond stimulus duration
                attOptoNPulses% := 0;  'turn off opto by using no pulses
                'tell user to try again
                Message("The first opto pulse will extend beyond the stimulus!  There will be no pulses!  Please try again!");
            else
                tempNPulses% := attOptoNPulses% - 1;  'how many more pulses are left?
                tempCount% := 1;  'temporary successful pulse count
                while tempNPulses% > 0 do
                    stimdur := stimdur - attPulsedOptoWidth - attPulsedOptoIPI;  'subtract duration of one more pulse+IPI
                    if stimdur < 0 then  'if this pulse will extend beyond stimulus duration
                        Message("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed!  You may try again!");
                        attOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                        tempNPulses% := 0;  'break while
                    else  'if this pulse is OK
                        tempCount% += 1;  'increment temporary successful pulse count
                    endif;
                    tempNPulses% -= 1;  'decrement temporary pulse count remaining
                wend
                
            endif;
            
        endif;
        
        
        
	endif;
    
	return iReturn%;
end;



' This function is initially called with a "0" input
func AttOptoDialogChanged%(item%) 
    DlgEnable(0,5);  'Just straight up disable the laser diode recording
    DlgEnable(0,3);  'Just straight up disable the inter block time
    DlgEnable(0,7);  'Just straight up disable post-stimulus wraparound opto - we are not doing it and Henry doesn't want it
    if DlgValue(4) = 1 then
        DlgEnable(1,8);  'enable pulsing dialog values 
        DlgEnable(1,9);
        DlgEnable(1,10);
        DlgEnable(1,11);
        DlgEnable(0,6);  'disable wrap-around dialog values 
        'DlgEnable(0,7);
    else
        DlgEnable(0,8);  'disable pulsing dialog values 
        DlgEnable(0,9);
        DlgEnable(0,10);
        DlgEnable(0,11);
        DlgEnable(1,6);  'enable wrap-around dialog values 
        'DlgEnable(1,7);
    endif;
    
    return 1;
end


proc GetAttOptoParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG\\Opto";
    
    attPreStimOptoTime := GetFloatRegistryValue(key$, "PreStimOptoTime", attPreStimOptoTime);
    attPostStimOptoTime := GetFloatRegistryValue(key$, "PostStimOptoTime", attPostStimOptoTime);
    attOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", attOptoVoltageOut);
    attOptoPropOpto := GetFloatRegistryValue(key$, "OptoPctOpto", attOptoPropOpto);
    attOptoUsePulse% := GetIntRegistryValue%(key$, "OptoUsePulse", attOptoUsePulse%);
    attLaserDiode% := GetIntRegistryValue%(key$, "LaserDiode", attLaserDiode%);
    attOptoNPulses% := GetIntRegistryValue%(key$, "OptoNPulses", attOptoNPulses%);
    attPulsedOptoOnset := GetFloatRegistryValue(key$, "PulsedOptoOnset", attPulsedOptoOnset);
    attPulsedOptoWidth := GetFloatRegistryValue(key$, "PulsedOptoWidth", attPulsedOptoWidth);
    attPulsedOptoIPI := GetFloatRegistryValue(key$, "PulsedOptoIPI", attPulsedOptoIPI);
    attInterBlockTime := GetFloatRegistryValue(key$, "InterBlockTime", attInterBlockTime);

end;

proc SaveAttOptoParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG\\Opto";
    SetFloatRegistryValue(key$, "PreStimOptoTime", attPreStimOptoTime);
    SetFloatRegistryValue(key$, "PostStimOptoTime", attPostStimOptoTime);
    SetFloatRegistryValue(key$, "OptoVoltageOut", attOptoVoltageOut);
    SetFloatRegistryValue(key$, "OptoPctOpto", attOptoPropOpto);
    SetIntRegistryValue(key$, "OptoUsePulse", attOptoUsePulse%);
    SetIntRegistryValue(key$, "LaserDiode", attLaserDiode%);
    SetIntRegistryValue(key$, "OptoNPulses", attOptoNPulses%);
    SetFloatRegistryValue(key$, "PulsedOptoOnset", attPulsedOptoOnset);
    SetFloatRegistryValue(key$, "PulsedOptoWidth", attPulsedOptoWidth);
    SetFloatRegistryValue(key$, "PulsedOptoIPI", attPulsedOptoIPI);
    SetFloatRegistryValue(key$, "InterBlockTime", attInterBlockTime);
    

end;



func AttCuesToUseDialog%()
	var iReturn% := 1;
	var i%;
    var stimdur;
    var tempNPulses%;
    var tempCount%;
    var blockStartList$[9];
    
    
    cuesToUseNGratings% := DlgValue(17);  'get number of gratings
    
    blockStartList$[0] := "Randomize Start Block";
    blockStartList$[1] := "Start Block: Main Stimulus";
    blockStartList$[2] := "Start Block: Distracter 1";
    blockStartList$[3] := "Start Block: Distracter 2";
    blockStartList$[4] := "Start Block: Distracter 3";
    blockStartList$[5] := "Start Block: Distracter 4";
    blockStartList$[6] := "Start Block: Cue All";
    blockStartList$[7] := "Start Block: Cue Random, No Cue All";
    blockStartList$[8] := "Start Block: Cue Random, WITH Cue All";    

	GetAttCuesToUseParameters();
    
	DlgCreate("Select Blocks Of Cues To Use");
    DlgInteger(1, "Cue Main Stimulus (# blocks)",0,100);
    DlgInteger(2, "Cue Distracter 1 (# blocks)",0,100);
    DlgInteger(3, "Cue Distracter 2 (# blocks)",0,100);
    DlgInteger(4, "Cue Distracter 3 (# blocks)",0,100);
    DlgInteger(5, "Cue Distracter 4 (# blocks)",0,100);
    DlgInteger(6, "Cue All Active Locations (# blocks)",0,100);
    DlgInteger(7, "Cue Random (exclude 'all') (# blocks)",0,100);
    DlgInteger(8, "Cue Random (include 'all') (# blocks)",0,100);
    DlgList(9, 30, blockStartList$, 9, 4);
    
    DlgAllow(0xffff, 0, AttCuesToUseDialogChanged%);    
    
 
    i% := DlgShow(attNumMainCues%,attNumDistracter1Cues%,attNumDistracter2Cues%,attNumDistracter3Cues%,attNumDistracter4Cues%,
    attNumCueAllCues%,attNumRandomNoCACues%,attNumRandomWithCACues%,attStartBlock%);
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 

	if i% = 1 then
        
        'calculate cues per block
        attBlocksPerSet% := attNumMainCues%+attNumDistracter1Cues%+attNumDistracter2Cues%+attNumDistracter3Cues%+attNumDistracter4Cues%+attNumCueAllCues%+attNumRandomNoCACues%+attNumRandomWithCACues%;
        
        'make sure we did not request a start block that does not exist, or screw up in some other way
        docase
        'random is OK
        case attStartBlock% = 1 and attNumMainCues% = 0 then
            Message("Requested to start with main stimulus but no main blocks selected!");
        case attStartBlock% = 2 and attNumDistracter1Cues% = 0 then
            Message("Requested to start with distracter 1 but no distracter 1 blocks selected!");
        case attStartBlock% = 3 and attNumDistracter2Cues% = 0 then
            Message("Requested to start with distracter 2 but no distracter 2 blocks selected!");
        case attStartBlock% = 4 and attNumDistracter3Cues% = 0 then
            Message("Requested to start with distracter 3 but no distracter 3 blocks selected!");
        case attStartBlock% = 5 and attNumDistracter4Cues% = 0 then
            Message("Requested to start with distracter 4 but no distracter 4 blocks selected!");
        case attStartBlock% = 6 and attNumCueAllCues% = 0 then
            Message("Requested to start with Cue All but no Cue All blocks selected!"); 
        case attStartBlock% = 7 and attNumRandomNoCACues% = 0 then
            Message("Requested to start with Random (no Cue All) but no Random (no Cue All) blocks selected!");  
        case attStartBlock% = 8 and attNumRandomWithCACues% = 0 then
            Message("Requested to start with Random (with Cue All) but no Random (with Cue All) blocks selected!");
        case attBlocksPerSet% = 0 then
            Message("NO BLOCKS REQUESTED!"); 
        case attStartBlock% = 5 and cuesToUseNGratings% < 5 then
            Message("Requested to start with distracter 4 but fewer than 5 gratings requested in main dialog!");
        case attStartBlock% = 4 and cuesToUseNGratings% < 4 then
            Message("Requested to start with distracter 3 but fewer than 4 gratings requested in main dialog!");
        case attStartBlock% = 3 and cuesToUseNGratings% < 3 then
            Message("Requested to start with distracter 2 but fewer than 3 gratings requested in main dialog!");
        case attStartBlock% = 2 and cuesToUseNGratings% < 2 then
            Message("Requested to start with distracter 1 but fewer than 2 gratings requested in main dialog!");
        endcase
        
        
		SaveAttCuesToUseParameters();

        
        
        
	endif;
    
	return iReturn%;
end;


' This function is initially called with a "0" input
func AttCuesToUseDialogChanged%(item%) 
    if cuesToUseNGratings% < 5 then
        DlgEnable(0,5);  'Disable ability to cue distracter 4 if distracter 4 not shown
        DlgValue(5,0);  'Set number of distracter 4 blocks to 0
    else
        DlgEnable(1,5);  'If shown, enable
    endif;
    if cuesToUseNGratings% < 4 then
        DlgEnable(0,4);  'etc.
        DlgValue(4,0); 
    else
        DlgEnable(1,4);
    endif;
    if cuesToUseNGratings% < 3 then
        DlgEnable(0,3);
        DlgValue(3,0); 
    else
        DlgEnable(1,3);
    endif;
    if cuesToUseNGratings% < 2 then
        DlgEnable(0,2);
        DlgValue(2,0); 
        DlgEnable(0,6);  'if only one grating, cue all makes no sense!
        DlgValue(6,0); 
        DlgEnable(0,7);  'if only one grating, random makes no sense!
        DlgValue(7,0); 
        DlgEnable(0,8);
        DlgValue(8,0); 
    else
        DlgEnable(1,2);
        DlgEnable(1,6);
        DlgEnable(1,7);
        DlgEnable(1,8);
    endif;
    return 1;
end



proc GetAttCuesToUseParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG\\Cues";
    
    attNumMainCues% := GetIntRegistryValue%(key$, "NumMainCues", attNumMainCues%);
    attNumDistracter1Cues% := GetIntRegistryValue%(key$, "NumDistracter1Cues", attNumDistracter1Cues%);
    attNumDistracter2Cues% := GetIntRegistryValue%(key$, "NumDistracter2Cues", attNumDistracter2Cues%);
    attNumDistracter3Cues% := GetIntRegistryValue%(key$, "NumDistracter3Cues", attNumDistracter3Cues%);
    attNumDistracter4Cues% := GetIntRegistryValue%(key$, "NumDistracter4Cues", attNumDistracter4Cues%);
    attNumCueAllCues% := GetIntRegistryValue%(key$, "NumCueAllCues", attNumCueAllCues%);
    attNumRandomNoCACues% := GetIntRegistryValue%(key$, "NumRandomNoCACues", attNumRandomNoCACues%);
    attNumRandomWithCACues% := GetIntRegistryValue%(key$, "NumRandomWithCACues", attNumRandomWithCACues%);
    
end;

proc SaveAttCuesToUseParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG\\Cues";
    SetIntRegistryValue(key$, "NumMainCues", attNumMainCues%);
    SetIntRegistryValue(key$, "NumDistracter1Cues", attNumDistracter1Cues%);
    SetIntRegistryValue(key$, "NumDistracter2Cues", attNumDistracter2Cues%);
    SetIntRegistryValue(key$, "NumDistracter3Cues", attNumDistracter3Cues%);
    SetIntRegistryValue(key$, "NumDistracter4Cues", attNumDistracter4Cues%);
    SetIntRegistryValue(key$, "NumCueAllCues", attNumCueAllCues%);
    SetIntRegistryValue(key$, "NumRandomNoCACues", attNumRandomNoCACues%);
    SetIntRegistryValue(key$, "NumRandomWithCACues", attNumRandomWithCACues%);
   
end;



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' End of dialog/registry functions
' 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Start utility functions - just kind of stuff
' 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



' Replace the color vector spec in a grating with the specified value
func ReplaceGratingColorVector$(gspec$, cvspec$)
    var s$;
    var i1%, i2%;
    var index%:=0;
    var i%;
    ' i1% and i2% are the index positions of the 8th and 9th commas
    PrintLog(gspec$ + "\n");
    for i% := 1 to 10 do
        index% := InStr(gspec$, ",", index%+1);
        PrintLog("%d index %d\n", i%, index%);
    next;
    i1% := InStr(gspec$, ",", index%+1);
    i2% := InStr(gspec$, ",", i1%+1);
    s$ := Mid$(gspec$, 1, i1%) + cvspec$ + Mid$(gspec$, i2%);
    PrintLog(s$ + "\n");
    return s$;
end

' Replace the X and Y positions in the grating spec with new XY positions but leave the rest (including W/H) the same
func ReplaceGratingXY$(sSpec$,x,y);
    var s$;
    var i1%, i2%;
    i1% := InStr(sSpec$, ",");  'get first comma position
    i2% := InStr(sSpec$, ",", i1%+1);  'get second comma position
    s$ := Str$(x) + "," + Str$(y) + "," + Right$(sSpec$,Len(sSpec$)-i2%);  'and put the X and Y values in front
    return s$;
end  



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawFix
' 
' Draws fixation point in xy window (iDraw%==1) or blanks it (0). 
proc DrawFix(iDraw%)
    
	if iDraw% > 0 then
		' Draw fixation point in xy window
		View(XYWindow%).XYAddData(iFixChannel%, FixationX, FixationY);
	else 
		' erase the fixation point from xy view
		View(XYWindow%).XYDelete(iFixChannel%);
	endif
    
end;




'
'
'===== GetLogProgression =====

' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
' There will be a total of nsteps%+1 values entered into vec[], vec[0] will be xmin, vec[nsteps%] will be xmax
Proc GetLogProgression(xmin, xmax, nsteps%, &vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		'PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;




'
'
'======= CreateContrastList =======
'A completely new version of CreateContrastList with an altogether different logical organization - 
'HOPEFULLY one that is a bit more sensible and a bit easier to modify.  What I plan to do is to loop through
'all trials and assign each variable (or, when appropriate, each set of variables) below sequentially, then 
'build the contrast list at the end using the calculated values.  This may result in some "redundant" code, 
'for instance we may have to check if we are currently on an "easy" trial more than once, but if everything
'is compartmentalized it should make things simpler (if not shorter) in the long run

'c$ is the location of the contrast file
'Fill f$ with the flasher specifier
'and *isCueAll%[] with a 0/1 indicator of whether the trial is cue all
'and *cuedLoc%[] with the location of the cue (1 = Stimulus; 2-5 = Distracter 1-4;)  If Cue-All, this is the "cued" location that changes, otherwise it is the actual cued location
'and *cuedLocChanges%[] with a 0/1 indicator of whether the cued location changes
'and *cuedLocContrast%[] with the new contrast at cue location (can be -1 if no change)
'and *cuedLocCCTime[] with the time of the contrast change (can be -1 if no change)
'and *cuedLocReturnTime[] with the time of time of return to baseline contrast (can be -1 if no change, may be equal to trialEnd[] for some trials)
'and *uncuedLoc%[] with the location of the uncued change (1 = Stimulus; 2-5 = Distracter 1-4; 0 = No Uncued Location Changes)
'and *uncuedLocChanges%[] with a 0/1 indicator of whether an uncued location changes (could use uncuedLoc% = 0 but this just makes logic easier in main code)
'and *uncuedLocContrast%[] with the new contrast at uncued location (can be -1 if no change)
'and *uncuedLocCCTime[] with the time of the contrast change (can be -1 if no change)
'and *uncuedLocReturnTime[] with the time of time of return to baseline contrast (can be -1 if no change, may be equal to trialEnd[] for some trials)
'and *trialEnd[] with the time of the trial end
'and *fixColor%[] with the fixation color
'and *cueCircleColor%[trial][cuecircle] with the cue circle color (cuecircle 1 = Stimulus; 2-5 = Distracter 1-4)
'and *offList%[] with a series of off-bits (1=stim 1 off, 2 = dist1 off, 4 = dist2 off, etc.) (not used in main code but nice to have in case)
'and *blockList%[] with the current block value (not used in main code)
'and *setList%[] with the current set-of-blocks value (not used in main code)
'and *easyList%[] with a 0/1 indicator of easy trials (not used in main code)
'and flashTimes[][] with the times of the flashers
'and flashX[][] with the x location of the flashers
'and flashY[][] with the y location of the flashers
'and flashN%[] with the number of flashers per trial
'We can add the below later, but no reason to right now
'BUT NOT cueOnList[] with the actual cue onset time (right now not variable)
'BUT NOT cueOffList[] with the actual cue offset time (right now not variable)
'BUT NOT stimOnList[] with the stimulus onset time (right now not variable)
'Creating all of these here (including easy trials) allows us to just blast through once we get to the actual experiment
'without too much counting going on.
Proc CreateContrastList(&c$,&f$,&isCueAll%[],&cuedLoc%[],&cuedLocChanges%[],&cuedLocContrast%[],&cuedLocCCTime[],
    &cuedLocReturnTime[],&uncuedLoc%[],&uncuedLocChanges%[],&uncuedLocContrast%[],&uncuedLocCCTime[],&uncuedLocReturnTime[],
    &trialEnd[],&fixColor%[],&cueCircleColor%[][],&offList%[],&blockList%[],&setList%[],&easyList%[])',
    '&flashTimes[][],&flashX[][],&flashY[][],&flashN%[])      
    
    var ind%;  'overall trial index
    var ind2%;  'per-block trial index, do we need this?
    var indu%;  'utility index variable
    var regularInd%;  'index variable, only counts "not-easy" trials, allows indexing of attTrialOrder%[], which holds contrasts
    var temp%;
    var i%, j%, k%, L%, m%;  'loops
    var nTrialsThisBlockLocal%;  'same name as variable from main code, just avoiding confusion
    var useEasyThisBlock%;
    var blockOrder%[800];  'can't have more than 800 blocks per set, by block dialog (we won't have this many, of course)
    var alloff%;
    var initPhase%[5];
'    var firstRun := 1;  'for some housekeeping on UpdateFlasherSpecString
'    var tempFlashTimes[attMaxFlashers%];  'For now we are not going to be matching block timing, so these do not need to be matrices
'    var tempFlashX[attMaxFlashers%];
'    var tempFlashY[attMaxFlashers%];
'    var tempNFlashPerTrial%;
    
    
    'calculate the value of alloff%, this is bitwise indicator if all stimuli (cues??) are shut off
    'this is simply 2^0 + 2^1 + 2^2 ... + 2^(n-1), which is (2^n)-1
    alloff% := pow(2,attNumPatches%)-1;
    
    'assign order of blocks in each set, this block order will be repeated in each set
    'build blockOrder%[]
    'this could in principle be done without looping using "arrconst(blockOrder%[indu%:numcues%],n%)" but this fails if called with blockOrder[0:0]
    for i% := 1 to attNumMainCues% do
        blockOrder%[indu%] := 1;
        indu% += 1;
    next;
    for i% := 1 to attNumDistracter1Cues% do
        blockOrder%[indu%] := 2;
        indu% += 1;
    next;
    for i% := 1 to attNumDistracter2Cues% do
        blockOrder%[indu%] := 3;
        indu% += 1;
    next;
    for i% := 1 to attNumDistracter3Cues% do
        blockOrder%[indu%] := 4;
        indu% += 1;
    next;
    for i% := 1 to attNumDistracter4Cues% do
        blockOrder%[indu%] := 5;
        indu% += 1;
    next;
    for i% := 1 to attNumCueAllCues% do
        blockOrder%[indu%] := 6;
        indu% += 1;
    next;
    for i% := 1 to attNumRandomNoCACues% do
        blockOrder%[indu%] := 7;
        indu% += 1;
    next;
    for i% := 1 to attNumRandomWithCACues% do
        blockOrder%[indu%] := 8;
        indu% += 1;
    next; 
    'randomize block order
    ShuffleList%(blockOrder%[0:indu%]);
    'respect requested starting block type, unless random requested
    if attStartBlock% > 0  and attStartBlock% <> blockOrder%[0] then 'if we request a starting block, and didn't randomly get it to start, fix that
        indu% := 0;
        while temp% <> attStartBlock% and indu% <= 800 do 'find first instance of desired starting block, don't allow should-be-impossible endless loop
            temp% := blockOrder%[indu%];
            indu% += 1;
        wend
        'This is just a sanity check
        if indu% = 801 then
            Message("Desired starting block not found - this should not happen!");
        endif;
        'swap the desired starting block with the 0th position randomized block
        blockOrder%[indu%-1] := blockOrder%[0];  
        blockOrder%[0] := temp%;
    endif;
    
    'Loop through each set    
    for i% := 1 to attNumberOfSetsOfBlocks% do
        
        'Loop through each block
        for j% := 0 to attBlocksPerSet%-1 do

            'determine if this block has easy trials, this is only true if we are cueing a single, non-random location and at least one easy trial is set
            if blockOrder%[j%] <= 5  and attEasyTrialsPerBlock% > 0 then
                useEasyThisBlock% := 1;
            else
                useEasyThisBlock% := 0;
            endif;
              
            'determine total number of trials this block
            if useEasyThisBlock% then
                nTrialsThisBlockLocal% := attTrialsPerBlock% + attEasyTrialsPerBlock%;
            else
                nTrialsThisBlockLocal% := attTrialsPerBlock%;
            endif;
            
            'Loop through each trial
            for k% := 1 to nTrialsThisBlockLocal% do
                
                'Fill initPhase with random values, we will update this if there is a specific phase to set
                for m% := 0 to 4 do
                    initPhase%[m%] := floor(rand(360,1));
                next
                
                ''' Fill blockList%[], setList%[], and easyList%[]
                blockList%[ind%] := blockOrder%[j%];  'what block does the current trial belong to?
                setList%[ind%] := i%;  'what set does the current trial belong to?
                if k% <= attEasyTrialsPerBlock% and useEasyThisBlock% = 1 then  'is the current trial "easy"?
                    easyList%[ind%] := 1;
                else
                    easyList%[ind%] := 0;
                endif;
                
                
                ''' Determine cued location (Fill cuedLoc%[], isCueAll%[])
                docase
                case blockOrder%[j%] <= 5 then  'blocks 1-5 are various cue locations
                    cuedLoc%[ind%] := blockOrder%[j%];
                    isCueAll%[ind%] := 0;
                case blockOrder%[j%] = 6 then 'This is cue-all
                    cuedLoc%[ind%] := floor(rand(attNumPatches%,1));  'For cue-all, pick a random location to be "cued location", 1-N
                    isCueAll%[ind%] := 1;
                case blockOrder%[j%] = 7 then  'random cue location, but no cue-all
                    cuedLoc%[ind%] := floor(rand(attNumPatches%,1));  'Pick a random location to cue and change, 1-N
                    isCueAll%[ind%] := 0;
                case blockOrder%[j%] = 8 then  'random cue location, include cue-all 
                    temp% := floor(rand(attNumPatches%+1,0)); 'Pick a value 0-N, if ) interpret as cue-all
                    if temp% > 0 then  'If not cue-all, use this value
                        cuedLoc%[ind%] := temp%;
                        isCueAll%[ind%] := 0;
                    else 'Pick a new random value and set cue-all
                        cuedLoc%[ind%] := floor(rand(attNumPatches%,1));  'Pick a random location to be "cued location", 1-N
                        isCueAll%[ind%] := 1;
                    endif
                endcase
                
                
                ''' Determine uncued location (location that will change that is NOT cued - fill uncuedLoc%[])
                if attNumPatches% > 1 then 'select a random location that is not the cued location
                    temp% := cuedLoc%[ind%];  'we can't select this location
                    while temp% = cuedLoc%[ind%] do
                        temp% := floor(rand(attNumPatches%,1)); 'Pick a value 1-N
                    wend
                    uncuedLoc%[ind%] := temp%;
                else
                    uncuedLoc%[ind%] := 0;  'if there is only one patch, then there can't be an uncued location
                endif
                
                
                ''' Determine which locations change contrast (Fill cuedLocChanges%[], uncuedLocChanges%[])
                'Cued
                docase
                case easyList%[ind%] = 1 then  'on easy trials, cued location always changes
                    cuedLocChanges%[ind%] := 1;
                case floor(rand(100,0)) < attCuedLocationChangePct% then 'these are currently designed as 0-100 integers, could change that if necessary
                    cuedLocChanges%[ind%] := 1;
                else
                    cuedLocChanges%[ind%] := 0;
                endcase
                'Uncued
                docase
                case uncuedLoc%[ind%] = 0  then   'if there's no uncued location, it can't change
                    uncuedLocChanges%[ind%] := 0;
                case easyList%[ind%] = 1 then  'there are no distracters to change on easy trials
                    uncuedLocChanges%[ind%] := 0;
                    uncuedLoc%[ind%] := 0;  'no location is changing
                case floor(rand(100,0)) < attUncuedLocationChangePct% then
                    uncuedLocChanges%[ind%] := 1;
                else
                    uncuedLocChanges%[ind%] := 0;
                    uncuedLoc%[ind%] := 0;  'no location is changing
                endcase
                
                
                ''' Determine cued contrast change and times
                'Cued (Fill cuedLocContrast%[], cuedLocCCTime[], cuedLocReturnTime[])
                if cuedLocChanges%[ind%] = 1 then
                    'get contrast value
                    if easyList%[ind%] = 0 then
                        cuedLocContrast%[ind%] := attContrastList[attTrialOrder%[regularInd%]];
                    else 'on easy trials the contrast change is to 100%
                        cuedLocContrast%[ind%] := 100;
                    endif;
                    'get time of contrast change
                    if easyList%[ind%] = 0 then  'do a draw from the hazard distribution on normal trials
                        cuedLocCCTime[ind%] := RandExp(attHazardExpMeanTime, attHazardMinTime);
                        if cuedLocCCTime[ind%] > attHazardCutoffTime then
                            cuedLocCCTime[ind%] := attHazardMinTime;  'Per Henry 5/21/18
                        endif;
                    else  'for easy trials, set the time to the minimum
                        cuedLocCCTime[ind%] := attHazardMinTime;
                    endif;
                    'get time of contrast return
                    cuedLocReturnTime[ind%] := cuedLocCCTime[ind%] + attContrastChangeDuration;
                else
                    cuedLocContrast%[ind%] := -1;
                    cuedLocCCTime[ind%] := -1;
                    cuedLocReturnTime[ind%] := -1;
                endif;
                'Uncued (Fill uncuedLocContrast%[], uncuedLocCCTime[], uncuedLocReturnTime[])
                if uncuedLocChanges%[ind%] = 1 then  
                    'get contrast value whether we are locking or not
                    uncuedLocContrast%[ind%] := attContrastList[attTrial2Order%[regularInd%]];
                    
                    if attLockUncuedToCued% = 0 or cuedLocChanges%[ind%] = 0 then  'if we are NOT locking, or the cued location is not changing
                        'get time of contrast change
                        'do a draw from the hazard distribution on normal trials
                        uncuedLocCCTime[ind%] := RandExp(attHazardExpMeanTime, attHazardMinTime);
                        if uncuedLocCCTime[ind%] > attHazardCutoffTime then
                            uncuedLocCCTime[ind%] := attHazardMinTime;  'Per Henry 5/21/18
                        endif;
                        'get time of contrast return
                        uncuedLocReturnTime[ind%] := uncuedLocCCTime[ind%] + attContrastChangeDuration;
                    else 'if we ARE locking, and the cued location IS changing, lock to the values for the cued 
                        uncuedLocCCTime[ind%] := cuedLocCCTime[ind%];
                        uncuedLocReturnTime[ind%] := cuedLocReturnTime[ind%]; 
                    endif;
                else
                    uncuedLocContrast%[ind%] := -1;
                    uncuedLocCCTime[ind%] := -1;
                    uncuedLocReturnTime[ind%] := -1;
                endif;
                
                
                
                ''' Ensure no contrast changes overlap - this ensures we get a trigger for every contrast change event, necessary for smooth functioning of trigger-tagging
                docase
                case attLockUncuedToCued% = 1 then
                    'Do nothing, contrast changes WILL overlap, there will be exactly one trigger, this is fixed in TagTrigger...
                'if both onsets are within 50 ms of each other, set the uncued onset to 50 ms AFTER cued onset, update return time as well
                case cuedLocChanges%[ind%] = 1 and abs(cuedLocCCTime[ind%]-uncuedLocCCTime[ind%]) < 0.050 then
                    uncuedLocCCTime[ind%] := cuedLocCCTime[ind%] + 0.050;
                    uncuedLocReturnTime[ind%] := uncuedLocCCTime[ind%] + attContrastChangeDuration;
                'if cued offset and uncued onset are within 50 ms of each other, set uncued onset to 50 ms AFTER cued offset, update return time as well 
                case cuedLocChanges%[ind%] = 1 and abs(cuedLocReturnTime[ind%]-uncuedLocCCTime[ind%]) < 0.050 then
                    uncuedLocCCTime[ind%] := cuedLocReturnTime[ind%] + 0.050;
                    uncuedLocReturnTime[ind%] := uncuedLocCCTime[ind%] + attContrastChangeDuration;
                'if cued onset and uncued offset are within 50 ms of each other, set the cued onset to 50 ms AFTER uncued offset
                case cuedLocChanges%[ind%] = 1 and abs(cuedLocCCTime[ind%]-uncuedLocReturnTime[ind%]) < 0.050 then    
                    cuedLocCCTime[ind%] := uncuedLocReturnTime[ind%] + 0.050;
                    cuedLocReturnTime[ind%] := cuedLocCCTime[ind%] + attContrastChangeDuration;
                endcase;
                
                
                
                ''' Determine end of trial (Fill trialEnd[])
                docase
                case cuedLocCCTime[ind%] = -1 and uncuedLocCCTime[ind%] = -1 then 'if no contrast change, set trial end time using new hazard function draw
                    trialEnd[ind%] := RandExp(attHazardExpMeanTime, attHazardMinTime);
                    if trialEnd[ind%] > attHazardCutoffTime then
                        trialEnd[ind%] := attHazardMinTime;  'Per Henry 5/21/18
                    endif;
                    'This is the time the contrast would change, get time that trial would end (was: contrast would RETURN), use this
                    trialEnd[ind%] := trialEnd[ind%] + attResponseWindow;  ' was: attContrastChangeDuration;
                case isCueAll%[ind%] <> 0 then 'if this trial is cue-all or no-cues-match, the trial ends when all contrast changes are done
                    if cuedLocReturnTime[ind%] > uncuedLocReturnTime[ind%] then  'if cued is later (or uncued is -1!)
                        trialEnd[ind%] := cuedLocCCTime[ind%] + attResponseWindow;  'was cuedLocReturnTime[ind%];
                    else  'if uncued is later (or cued is -1!)
                        trialEnd[ind%] := uncuedLocCCTime[ind%] + attResponseWindow;  'was uncuedLocReturnTime[ind%]
                    endif
                case cuedLocChanges%[ind%] = 1 then 'if cued location changes, set end of trial to end of cued location response window (was: contrast change), even if uncued loc is currently changed
                    trialEnd[ind%] := cuedLocCCTime[ind%] + attResponseWindow;  'was cuedLocReturnTime[ind%];
                else
                    trialEnd[ind%] := uncuedLocCCTime[ind%] + attResponseWindow;  'was uncuedLocReturnTime[ind%]
                endcase
                
                
                
                
                
                
                ''' If any contrast changes come after the end of the trial, erase them
                if trialEnd[ind%] < cuedLocCCTime[ind%] then
                    cuedLocCCTime[ind%] := -1;
                    cuedLocChanges%[ind%] := 0; 'if the cued loc doesn't change due to timing, turn off cuedLocChanges (this could happen on cue-all trials...well, not anymore, oh well)
                endif;
                if trialEnd[ind%] < uncuedLocCCTime[ind%] then
                    uncuedLocCCTime[ind%] := -1;
                    uncuedLocChanges%[ind%] := 0; 'if the uncued loc doesn't change due to timing, turn off uncuedLocChanges
                endif;
                if trialEnd[ind%] < cuedLocReturnTime[ind%] then
                    cuedLocReturnTime[ind%] := -1;
                endif;
                if trialEnd[ind%] < uncuedLocReturnTime[ind%] then
                    uncuedLocReturnTime[ind%] := -1;
                endif;
                
                
                
                'Determine if this trial should be a no-cues-match trial
                'If so, update isCueAll%[] to -1, this will be useful during the experiment as well
                if floor(rand(100,0)) < attNoCuesMatchFixpt% then 'these are currently designed as 0-100 integers, could change that if necessary
                    isCueAll%[ind%] := -1;
                endif
                
                
                ''' Set color of fixation point
                'For now, we are not varying the fixation point or cue circle color 
                'Assigning to one should set color to the specified "attend" color from the colors dialog
                'fixColor%[ind%] := 1;
                
                'This will allow changing the fixpt with the cue color
                docase
                case isCueAll%[ind%] = 1 then
                    fixColor%[ind%] := 6;  'hardcode, 5 is the correct index for cue-all, but all subsequent calls will subtract 1
                case isCueAll%[ind%] = -1 then
                    fixColor%[ind%] := 7;  'hardcode, 6 is the correct index for no-cues-match, but all subsequent calls will subtract 1
                else
                    fixColor%[ind%] := cuedLoc%[ind%];
                endcase;
                
                
                ''' Set color of cue circles (placeholder, trial-by-trial cue circle color is not supported as of yet)
                'for L% := 0 to 4 do
                '    cueCircleColor%[L%][ind%] := 0;  'These can now NOT be changed trial by trial.  Keeping in case it happens in the future.
                'next;
                
                
                ''' Set offList, this assumes that offBits turns off the stimuli, which is not necessary, and seems to be a problem
'                if easyList%[ind%] = 1 then
'                    offList%[ind%] := alloff% - Pow(2,cuedLoc%[ind%]-1);  'turn off all stimuli but the attended one
'                else
'                    offList%[ind%] := 0;
'                endif
                
                ''' Set offList, assuming that offList determines which CUES appear
                if easyList%[ind%] = 1 then
                    offList%[ind%] := alloff% - Pow(2,cuedLoc%[ind%]-1);  'turn off all cues but the intended one
                else
                    if attCueCirclesMatchCueAllFixpt% and isCueAll%[ind%] = 1 then
                        offList%[ind%] := 256;  'if isCueAll% and cues should match fixpt, all cues on, use second set of cue circle colors, these match the CueAll fixpt, second set is offBits+256 (third set would be offBits+512, etc.)
                    else
                        offList%[ind%] := 0;  'all cues on, use first set of cue circle colors
                    endif;
                endif
                
                
                
                '''Create a set of flasher times and locations (also number) for this trial only
'                if attUseFlashers% = 1 then
'                    var flashLoop%;
'                    'create flasher times
'                    CreateFlasherTimes(tempFlashTimes[],tempNFlashPerTrial%,cuedLocCCTime[ind%],trialEnd[ind%]);
'                    flashN%[ind%] := tempNFlashPerTrial%;  'set flasher count for use in main loop
'                    for flashLoop% := 0 to attMaxFlashers%-1 do
'                        flashTimes[ind%][flashLoop%] := tempFlashTimes[flashLoop%];  'set flasher times for use in main loop
'                    next;
'                    'create flasher locations
'                    CreateFlasherLocations(flashN%[ind%],tempFlashX[],tempFlashY[]);
'                    for flashLoop% := 0 to attMaxFlashers%-1 do
'                        flashX[ind%][flashLoop%] := tempFlashX[flashLoop%];
'                        flashY[ind%][flashLoop%] := tempFlashY[flashLoop%];
'                    next;
'                endif;
                
                'to start out for phase, set every value in initPhase% to the value in the grating parameters from config
                for L% := 1 to attNumPatches% do
                    initPhase%[L%-1] := GetStimulusPhase(L%);
                next;
                'Then, overwrite values for stimuli that have a contrast change, if PhaseCheck% is set
                if attPhaseCheck% = 1 then
                    if cuedLocChanges%[ind%] = 1 then
                        'Do not subtract 1 in call to GetStimulusTF, that expects 1-based indexing, just as cuedLoc/uncuedLoc are set in
                        initPhase%[cuedLoc%[ind%]-1] := GetInitialPhase%(attPhaseDeg%,GetStimulusTF(cuedLoc%[ind%]),attCueOffsetTime+attStimOnsetList[ind%]+cuedLocCCTime[ind%]);
                    endif;
                    if uncuedLocChanges%[ind%] = 1 then
                        initPhase%[uncuedLoc%[ind%]-1] := GetInitialPhase%(attPhaseDeg%,GetStimulusTF(uncuedLoc%[ind%]),attCueOffsetTime+attStimOnsetList[ind%]+uncuedLocCCTime[ind%]);
                    endif;
                endif;
                
                
                
                
                
                
                '''Add values to flasher string and trial spec string
                'Note: With massive update to code, this needs to be checked to make sure it works...for now, not being implemented
                'Flasher string
                'UpdateFlasherSpecString(f$,flashN%[ind%],flashX[ind%][],flashY[ind%][],attFlasherWidth,attFlasherHeight,flashTimes[ind%][],attFlasherDur,firstRun)
                UpdateTrialSpecString(c$,ind%,masterColorListVSG$[fixColor%[ind%]-1],initPhase%[],offList%[ind%],attCueOnsetTime,attCueOffsetTime,attStimOnsetTime,easyList%[ind%],
                    cuedLoc%[ind%],cuedLocContrast%[ind%],cuedLocCCTime[ind%],cuedLocReturnTime[ind%],
                    uncuedLoc%[ind%],uncuedLocContrast%[ind%],uncuedLocCCTime[ind%],uncuedLocReturnTime[ind%],trialEnd[ind%]);
                
                'note that stim onset time is relative to the offset of the cues, not the start of the trial.
                'note that hazard time is in reference to the start of the stimulus, not the start of the trial.  
                
                if easyList%[ind%] = 0 then 'increment "not-easy" trial index if appropriate
                    regularInd% += 1;  'This variable indexes the trial-ordered contrast value created in the main dialog, do not draw next contrast value on "easy" trials, which are 100% contrast
                endif;
                ind% += 1;  'increment overall trial index
            next;
        next;      
    next;
    
end


'
'
'======= CreateFlasherTimes =======
'Fill input variable times[] with the flasher times and nFlashers% with the count of flashers
Proc CreateFlasherTimes(&times[],&nFlashers%,hazTime,tMax)
    var tOff;
    var i%;
    var temp;
    
    'Note: With massive update to code, this needs to be checked to make sure it works...for now, not being implemented
    
    nFlashers% := 0;  'Reset this value every time we calculate a new set of flashers, otherwise we can repeat and cause all sorts of problems
    
    tOff := attFlasherTemporalBuffer;  'set first offset to the time of the buffer
    while i% < attMaxFlashers% do
        'get random value with mean distribution which takes into account the buffers (so that attFlasherHazardValue is very ~= Hz of the stimulus) and min of tOff
        temp := RandExp(attFlasherHazardValue,tOff);  'improved logic!
        if (temp + attFlasherDur + attFlasherTemporalBuffer) <= tMax then  'if random value is less than max time
            if abs(temp-hazTime) > 0.1 then  'if the flasher time does not overlap with the contrast change
                times[i%] := temp;  'put random value into times list
                i% += 1;  'increment i%
                nFlashers% += 1;  'increment count of flashers
                tOff := temp + attFlasherDur + attFlasherTemporalBuffer;  'change offset, option to offset with temporal buffer, also option to not allow temporal overlap
            else
                'printlog("Rejected overlapping flasher at %f\n",temp);
            endif
        else 'if the "next" time is after the max time
            i% := attMaxFlashers% + 1;  'break the loop
        endif
    wend
    
end  
    
'
'
'======= CreateFlasherLocations =======
'Will create locations for each flasher on a given trial
Proc CreateFlasherLocations(nFlashers%,&x[],&y[])
    var i%;
    var isOverlap%;
    var isInBounds%;  'technically a "box" around the main grating
    var breakCount%;
    var xBound;
    var yBound;
    
    xBound := screenXmax-wF1-attFlasherSpatialBuffer;
    yBound := screenYmax-hF1-attFlasherSpatialBuffer;
    
'Testing    
'printlog("screenXmax is %f and wF1 is %f and attFlasherSpatialBuffer is %f\n",screenXmax,wF1,attFlasherSpatialBuffer);    
'printlog("Flasher count is %d\n",nFlashers%); 
'printlog("xbound is %f and ybound is %f\n",xBound,yBound);
'printlog("Flasher max dist is %f\n",attFlasherMaxDist); 
    
    'Locations of our non-flasher stimuli have been set in Start%
    
    'For each flasher time
    for i% := 0 to nFlashers%-1 do
        
        breakCount% := 0;
        
        'force while loop to execute at least once
        isOverlap% := 1;  
        isInBounds% := 0; 
        
        'select a random location within the bounds of the screen
        while breakCount% < 10000 and (isOverlap% > 0 or isInBounds% < 1) do
            
            isOverlap% := 0;  'Reset or you'll never get out of the loop!
            isInBounds% := 0;  'Reset
            
            'reassign the X, Y values randomly, use bounds of screen
            x[i%] := Rand(2*xBound,-xBound);
            y[i%] := Rand(2*yBound,-yBound);
        
            'One check for the target patch
            isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xT, yT, wT, hT, attFlasherSpatialBuffer);
            
            'Then several checks against potential distracter patches
            if attNumPatches% > 1 then
                'use xD1, yD1, wD1, hD1
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD1, yD1, wD1, hD1, attFlasherSpatialBuffer);
            endif;
            if attNumPatches% > 2 then
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD2, yD2, wD2, hD2, attFlasherSpatialBuffer);
            endif;
            if attNumPatches% > 3 then
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD3, yD3, wD3, hD3, attFlasherSpatialBuffer);
            endif;
            if attNumPatches% > 4 then
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD4, yD4, wD4, hD4, attFlasherSpatialBuffer);
            endif;
            
            'Check the location of the fixation point
            'FixationX, FixationY, and FixationDiameter ought to be available variables
            isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, FixationX, FixationY, FixationDiameter, FixationDiameter, attFlasherSpatialBuffer);
            
            'And check to see if it is within the bounds that are set - here we actually will use
            'Overlap%() to see if it overlaps the bounds (rather than writing a new function)
            isInBounds% := Overlap%(x[i%], y[i%], wF1, hF1, xT, yT, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);  'use zero spatial buffer

            'The flasher is also legal if it is in the box surrounding any distracter patch
            if attNumPatches% > 1 then
                'use xD1, yD1
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD1, yD1, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            if attNumPatches% > 2 then
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD2, yD2, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            if attNumPatches% > 3 then
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD3, yD3, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            if attNumPatches% > 4 then
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD4, yD4, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            
            'increment breakCount% so we don't get stuck
            breakCount% += 1;
            
        wend;
        
        if breakCount% = 10000 then
            message("Could not find a legal location for flasher after 10000 tries!\nProbably no legal position exists!\nCheck settings of flasher/target/distractors!  Quitting!");
            halt;  'haven't started sampling yet, so halt should be fine
        endif;
        'printlog("Location of flasher is x %f    y %f\n",x[i%],y[i%]);
    next
    
    
end






''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Answer%(EyePosX, EyePosY)
    var ans% := 0;
    var ansptRadius;
    'ansptRadius := Pow(attAnswerPointWindowRadius,2);  'answer point radius is now the size of the grating
    
    'note that in the case statement, we will not consider grating patches that don't exist - see how smart we are!
    docase
    case (Pow(EyePosX-mainX,2) + Pow(EyePosY-(mainY),2)) <= Pow(mainW,2) then 'Looking at main grating location, just assuming mainW = mainH!
        ans% := 1;
    case (Pow(EyePosX-dist1X,2) + Pow(EyePosY-(dist1Y),2)) <= Pow(dist1W,2) and attNumPatches% > 1 then 'Looking at distracter 1 location, just assuming dist1W = dist1H!
        ans% := 2;
    case (Pow(EyePosX-dist2X,2) + Pow(EyePosY-(dist2Y),2)) <= Pow(dist2W,2) and attNumPatches% > 2 then 'Looking at distracter 2 location, just assuming dist2W = dist2H!
        ans% := 3;
    case (Pow(EyePosX-dist3X,2) + Pow(EyePosY-(dist3Y),2)) <= Pow(dist3W,2) and attNumPatches% > 3 then 'Looking at distracter 3 location, just assuming dist3W = dist3H!
        ans% := 4;
    case (Pow(EyePosX-dist4X,2) + Pow(EyePosY-(dist4Y),2)) <= Pow(dist4W,2) and attNumPatches% > 4 then 'Looking at distracter 4 location, just assuming dist4W = dist4H!
        ans% := 5;
    endcase;
    
	return ans%;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func LookingAtCuePoint%(EyePosX, EyePosY, windowRadius)
    'this function is essentially Answer% except with a variable window radius
    var ans% := 0;
    'ansptRadius := Pow(attAnswerPointWindowRadius,2);  'answer point radius is now the size of the grating
    
    'note that in the case statement, we will not consider grating patches that don't exist - see how smart we are!
    docase
    case (Pow(EyePosX-mainX,2) + Pow(EyePosY-(mainY),2)) <= Pow(windowRadius,2) then 'Looking at main grating cue dot
        ans% := 1;
    case (Pow(EyePosX-dist1X,2) + Pow(EyePosY-(dist1Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 1 then 'Looking at distracter 1 cue dot
        ans% := -1;
    case (Pow(EyePosX-dist2X,2) + Pow(EyePosY-(dist2Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 2 then 'Looking at distracter 2 cue dot
        ans% := -2;
    case (Pow(EyePosX-dist3X,2) + Pow(EyePosY-(dist3Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 3 then 'Looking at distracter 3 cue dot
        ans% := -3;
    case (Pow(EyePosX-dist4X,2) + Pow(EyePosY-(dist4Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 4 then 'Looking at distracter 4 cue dot
        ans% := -4;
    endcase;
    
	return ans%;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    DefaultReward();
    'No sample text, just use 'R' from keyboard channel
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' UpdateToolbarText - Print tallies of trials in toolbar
'

proc UpdateToolbarText()
	var s$;
	var allPct$ := "--";
    var num, den, pct;
    
    if (attCountAllTrials% > 0) then
        num := attCountAllTrialsCorrect%;
        den := attCountAllTrials%;
        pct := num/den*100;
		allPct$ := print$("%2.0f", pct);
	endif
    

    'only print stats for conditions that have occurred
    if attCountAllTrials% > 0 or attCountAllTrialsAbort% > 0 then  
        s$ := Print$(" Trials: %d, Correct: %d (%s%%), Aborted: %d ",attCountAllTrials%, attCountAllTrialsCorrect%, allPct$, attCountAllTrialsAbort%);
    endif


    
	ToolbarText(s$);
    
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var tempPrimary$;
    var tempSecondary$;
    
    'creating some lists for output, same as from dialog
    var cueCircleList$[4];
    cueCircleList$[0] := "No Cue Circles";
    cueCircleList$[1] := "Cue Circles";
    cueCircleList$[2] := "Cue Circles + Cue Points";
    cueCircleList$[3] := "Cue Points Only";  'should be ready to go
    
    var blockStartList$[9];
    blockStartList$[0] := "Randomize Start Block";
    blockStartList$[1] := "Start Block: Main Stimulus";
    blockStartList$[2] := "Start Block: Distracter 1";
    blockStartList$[3] := "Start Block: Distracter 2";
    blockStartList$[4] := "Start Block: Distracter 3";
    blockStartList$[5] := "Start Block: Distracter 4";
    blockStartList$[6] := "Start Block: Cue All";
    blockStartList$[7] := "Start Block: Cue Random, No Cue All";
    blockStartList$[8] := "Start Block: Cue Random, WITH Cue All";   
    
    
	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);
    
	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);
    
	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	'Print("Background color           : %s\n", tunBackgroundColor$);
    
	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);
    
	' write stimulus parameters
	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
    Print("\nStimulus\n");  'Master grating
	Print("-------------------\n\n");
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
    Print("Inner Width (degrees)           : %s\n", Tstimiw$);
	Print("Inner Height (degrees)          : %s\n", Tstimih$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    'Print("Initial Phase (degrees)         : %f\n", phase);  'WTF?
    Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
    
    if attUseCueCircles% > 0 then
        Print("Attend Cue Circle Contrast        : %d\n", attCueCircleContrastAttend%);
        Print("Attend Cue Circle Color (r/g/b)   : %d %d %d\n", attendRGB%[0], attendRGB%[1], attendRGB%[2]);
        Print("Cue Circles Match Fixpt In Cue-All: %d\n",attCueCirclesMatchCueAllFixpt%);
    endif;
    
    
    ' write distractor parameters
    if attNumPatches% > 1 then
        Print("\nDistractor1\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor1");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            'Print("Initial Phase (degrees)         : %f\n", phase);  'WTF?
            Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
        
        if attUseCueCircles% > 0 then
            Print("Distractor1 Cue Circle Contrast : %d\n", attCueCircleContrastIgnore1%);
            Print("Dist 1 Cue Circle Color (r/g/b) : %d %d %d\n", ignore1RGB%[0], ignore1RGB%[1], ignore1RGB%[2]);
        endif;        
        
    endif;
    if attNumPatches% > 2 then
        Print("\nDistractor2\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor2");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            'Print("Initial Phase (degrees)         : %f\n", phase);  'WTF?
            Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
        
        if attUseCueCircles% > 0 then
            Print("Distractor2 Cue Circle Contrast : %d\n", attCueCircleContrastIgnore2%);
            Print("Dist 2 Cue Circle Color (r/g/b) : %d %d %d\n", ignore2RGB%[0], ignore2RGB%[1], ignore2RGB%[2]);
        endif;
        
    endif;
    if attNumPatches% > 3 then
        Print("\nDistractor3\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor3");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            'Print("Initial Phase (degrees)         : %f\n", phase);  'WTF?
            Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
        
        if attUseCueCircles% > 0 then
            Print("Distractor3 Cue Circle Contrast : %d\n", attCueCircleContrastIgnore3%);
            Print("Dist3 Cue Circle Color (r/g/b) : %d %d %d\n", ignore3RGB%[0], ignore3RGB%[1], ignore3RGB%[2]);
        endif;
        
    endif;
    if attNumPatches% > 4 then
        Print("\nDistractor4\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor4");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            'Print("Initial Phase (degrees)         : %f\n", phase);  'WTF?
            Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
        
        if attUseCueCircles% > 0 then
            Print("Distractor4 Cue Circle Contrast : %d\n", attCueCircleContrastIgnore4%);
            Print("Dist 4 Cue Circle Color (r/g/b) : %d %d %d\n", ignore4RGB%[0], ignore4RGB%[1], ignore4RGB%[2]);
        endif;
        
    endif;
    
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");
    
	Print("Acquisition time (s)   : %f\n", attAcquisitionTime);
    Print("Min fixation cue time (s)   : %f\n", attFixationCueMinTime);
    Print("Max fixation cue time (s)   : %f\n", attFixationCueMaxTime);
    Print("Cue onset time (s)   : %f\n", attCueOnsetTime);
    Print("Cue offset time (s)   : %f\n", attCueOffsetTime);
    Print("Grating onset time (rel. to cue offset) (s)   : %f\n", attStimOnsetTime);
    Print("Min Hazard time (s)   : %f\n", attHazardMinTime);
    Print("Mean Hazard time (s)   : %f\n", attHazardExpMeanTime);
    Print("Hazard Cutoff time (s)   : %f\n", attHazardCutoffTime);
    Print("Contrast Change dur (s)   : %f\n", attContrastChangeDuration);
    Print("Time to answer (s)   : %f\n", attResponseWindow);
    Print("Intertrial time (s)   : %f\n", attInterTrialTime);
    Print("Abort/miss/FA penalty time (s)   : %f\n", attAbortPenaltyTime);
    Print("Uncued CC locked to Cued?: %d\n", attLockUncuedToCued%);
    Print("Use Joystick for response?: %d\n", attRequireJoystickResponse%);
    
    
    if attUseFlashers% = 1 then
        Print("\nFlasher parameters\n");
        Print("-------------------------\n\n");
        Print("Flasher Duration (s)   : %f\n", attFlasherDur);
        Print("Flasher Temporal Buffer (s)   : %f\n", attFlasherTemporalBuffer);
        Print("Flasher Spatial Buffer (deg)   : %f\n", attFlasherSpatialBuffer);
        Print("Flasher Max Distance From Main Grating (deg)   : %f\n", attFlasherMaxDist);
        Print("Flasher Hazard Value (s)   : %f\n", attFlasherHazardValue);
    endif;
    
    
    
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");    
    
    Print("Number of sets of blocks   : %d\n", attNumberOfSetsOfBlocks%);
    Print("Trials per block   : %d\n", attTrialsPerBlock%);
    Print("Easy trials per block   : %d\n", attEasyTrialsPerBlock%);
    Print("Distracter off for easy trials?   : %d\n", distracterOffForEasy%);
    Print("Cued Location Change Percentage   : %d\n", attCuedLocationChangePct%);
    Print("Uncued Location Change Percentage   : %d\n", attUncuedLocationChangePct%);
    Print("No Cues Match Fixpt Percentage   : %d\n", attNoCuesMatchFixpt%);
    
    
    Print("Select Random Contrast Each Trial   : %d\n", attSelectRandomContrastEachTrial%);
    Print("Base Contrast   : %d\n", attContrastBase%);
    Print("Max contrast change   : %f\n", attMaxContChange);
    Print("Min contrast change   : %f\n", attMinContChange);
    Print("N Contrast levels   : %d\n", attNContLevels%);
    'if attAnswerPointWindowRadius > 0 then
    '    Print("Answer point window radius   : %f\n", attAnswerPointWindowRadius);  
    'else
        Print("Answer point window radius   : Matches Stimulus\n");  
    'endif;
    'Print("Use Training Contrast?   : %d\n", attTrainingContrastCheck%);
    'Print("Training contrast   : %d\n", attTrainingContrastPct%);
    Print("Set phase at contrast change?   : %d\n", attPhaseCheck%);
    Print("Phase at contrast change   : %d\n", attPhaseDeg% );
    Print("Number of Distractors     : %d\n", attNumPatches%);
    Print("Get distractor params from main stim?     : %d\n", attGetGPFromMainStim%);
    Print("Use cue circles?    : %d\n", attUseCueCircles%);
    if attUseCueCircles% > 0 then
        Print("\tUsing: %s\n",cueCircleList$[attUseCueCircles%]);
    endif;
    Print("Cue Circle extra radius    : %f\n", attCueCircleExtraRadius);
    'Print("Start Block     : %d (%s)\n", attStartBlock%,blockStartList$[attStartBlock%]);
    'Print("No Change Condition    : %d\n", attNoChangeCondition%);  'TODO something logical here
    'if attNoChangeCondition% > 0 then
    '    Print("No Change Cue Circle Color (r/g/b) : %d %d %d\n", cueallRGB%[0], cueallRGB%[1], cueallRGB%[2]);
    'endif;
    'Print("No Info Condition     : %d\n", attNoInfoCondition%);
    'if attNoInfoCondition% > 0 then  'NoInfo condition has been deprecated
    '    Print("No Info Cue Circle Color (r/g/b) : %d %d %d\n", noinfoRGB%[0], noinfoRGB%[1], noinfoRGB%[2]);
    'endif;
    'Print("Swap Cue Circle    : %d\n", attSwapCueCircle%);  
    
    
    
    Print("Contrast File: " + ContrastFile$ + "\n");
    Print("\n");
    
    
    
    if attDoOpto% = 1 then
        Print("\nOptogenetics parameters\n");
        Print("-------------------------\n\n");
        'if attLaserDiode% = 1 then  'currently not implemented
        '    Print("Laser Diode recorded\n");
        'endif;
        Print("Opto Voltage Out: %f\n", attOptoVoltageOut);
        var label$[4]; 
        label$[0] := "Opto Off First";
        label$[1] := "Opto On First";
        label$[2] := "Random First";
        label$[3] := "Opto On All Blocks";
        Print("Proportion of Opto Trials : %f\n", attOptoPropOpto);
        if attOptoUsePulse% = 1 then
            Print("Pulsing Opto selected\n");
            Print("Opto#Pulses,OptoPeriodOnset,OptoPulseWidth,OptoInterpulseInterval: %d,%f,%f,%f\n",attOptoNPulses%,attPulsedOptoOnset,attPulsedOptoWidth,attPulsedOptoIPI);
        else
            Print("Wraparound Opto selected\n");
            Print("PreStimulusOptoOn,PostStimulusOptoOn: %f,%f\n",attPreStimOptoTime,attPostStimOptoTime);
        endif;
        
    endif;
    
    
	' close parfile
	FileClose(0);
    
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculates initial phase given params
func GetInitialPhase%(phaseAtCC%,tempFreq,dur)
    'phases in degrees (integer)
    'temporal frequency in Hz
    'duration in seconds
    var Po%;
    var deg;
    var deg%;
    
    deg := (360*((tempFreq*dur)mod 1));
    deg% := round(deg);  'this corrects to nearest degree, non-explicit conversion of real to int results in a floor operation

    'This is the way you would THINK it would work
    'Po% := phaseAtCC% - deg%;
    'Po% := phaseAtCC% - (360*((tempFreq*dur)mod 1));
    'if Po% < 0 then
    '    Po% := Po% + 360;
    'endif;
    
    'This is the way it actually works, because the grating drifts "backwards" - that is to say that if the grating
    'starts at 150 degrees and drifts through 30 degrees, the final grating position is 120 degrees, not 180 degrees.  
    Po% := phaseAtCC% + deg%;
    if Po% >= 360 then
        Po% := Po% - 360;
    endif;
        
    'printlog("Requested initial phase is %d\n",Po%);
    return Po%;
    
end


func GetStimulusTF(stim%)
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var cv$, pattern$, aperture$;
    docase
    case stim% = 1 then
        gr$ := GetGratingParameters$("Stimulus");
    case stim% = 2 then
        gr$ := GetGratingParameters$("Distractor1");
    case stim% = 3 then
        gr$ := GetGratingParameters$("Distractor2");
    case stim% = 4 then
        gr$ := GetGratingParameters$("Distractor3");
    case stim% = 5 then
        gr$ := GetGratingParameters$("Distractor4");  
    endcase;    
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end


func GetStimulusPhase(stim%)
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var cv$, pattern$, aperture$;
    docase
    case stim% = 1 then
        gr$ := GetGratingParameters$("Stimulus");
    case stim% = 2 then
        gr$ := GetGratingParameters$("Distractor1");
    case stim% = 3 then
        gr$ := GetGratingParameters$("Distractor2");
    case stim% = 4 then
        gr$ := GetGratingParameters$("Distractor3");
    case stim% = 5 then
        gr$ := GetGratingParameters$("Distractor4");  
    endcase;    
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    LogStatus("GetStimulusPhase", "phase=" + str$(phase));
    return phase;
end

proc UpdateTrialSpecString(&c$,ind%,col$,phaseList%[],offList%,cueOnsetTime,cueOffsetTime,stimOnsetTime,easy%,
        cuedLoc%,cuedLocContrast%,cuedLocCCTime,cuedLocReturnTime,
        uncuedLoc%,uncuedLocContrast%,uncuedLocCCTime,uncuedLocReturnTime,trialEnd);
    
    var i%;
    
    'Insert trial opener, first line of trial spec
    c$ := c$ + "Trial " + Str$(ind%+1) + "\n";
    
    'For second line of trials spec: Add color of fixpt
    c$ := c$ + col$ + ",";
    
    'Add off-bits
    c$ := c$ + Str$(offList%);  'leave off comma, will add to BEGINNING of phase for convenience
    
    'Add phase specs
    for i% := 1 to attNumPatches% do
        c$ := c$ + "," + Str$(phaseList%[i%-1]);
    next
    
    'Add new line to end second line of trial spec
    c$ := c$ + "\n"; 
    
    'From here on out every statement is its own line and has a new line character
    
    'Add cue onset, there will always be a cue onset 
    c$ := c$ + "Q," + Str$(cueOnsetTime) + "," + Str$(attCueCircleContrastAttend%) + "\n";  'We have been going with kind of one contrast, that would be the attend one.  Cue circle dialog may be something we can cut down a ton
    
    'Add cue offset, there will always be a cue offset
    c$ := c$ + "Q," + Str$(cueOffsetTime) + ",0\n";
    
    'Add stimulus onsets
    'Here, attNumPatches% and attContrastBase% are available globally
    if easy% = 0 or distracterOffForEasy% = 0 then  'For regular trials, or easy trials where distractor is NOT off, turn on all locations
        for i% := 1 to attNumPatches% do
            c$ := c$ + Str$(i%-1) + "," + Str$(cueOffsetTime+stimOnsetTime) + "," + Str$(attContrastBase%) + "\n";
        next
    else  'For easy trials when distractor IS off for easy trials, only turn on cued location
        c$ := c$ + Str$(cuedLoc%-1) + "," + Str$(cueOffsetTime+stimOnsetTime) + "," + Str$(attContrastBase%) + "\n";
    endif;
    
    'Add contrast change and contrast returns, when appropriate
    if cuedLocCCTime > 0 then
        'Contrast change
        c$ := c$ + Str$(cuedLoc%-1) + "," + Str$(cueOffsetTime+stimOnsetTime+cuedLocCCTime) + "," + Str$(cuedLocContrast%) + "\n";
    endif
    if cuedLocReturnTime > 0 then
        'Contrast return
        c$ := c$ + Str$(cuedLoc%-1) + "," + Str$(cueOffsetTime+stimOnsetTime+cuedLocReturnTime) + "," + Str$(attContrastBase%) + "\n";
    endif;
    if uncuedLocCCTime > 0 then
        'Contrast change
        c$ := c$ + Str$(uncuedLoc%-1) + "," + Str$(cueOffsetTime+stimOnsetTime+uncuedLocCCTime) + "," + Str$(uncuedLocContrast%) + "\n";
    endif
    if uncuedLocReturnTime > 0 then
        'Contrast return
        c$ := c$ + Str$(uncuedLoc%-1) + "," + Str$(cueOffsetTime+stimOnsetTime+uncuedLocReturnTime) + "," + Str$(attContrastBase%) + "\n";
    endif;
    
    'Add trial offset, must be final line of trial, put in extra new line
    c$ := c$ + "*," + Str$(cueOffsetTime+stimOnsetTime+trialEnd) + ",0\n\n"
    
    'This function should kind of be done
    'There is only one remaining concern, obviously testing is needed but this isF where there could/will be an issue
    '1) Color spec appears to use color names, e.g. "red", to replace "known" colors.  No reason this shouldn't still work.
    
end


proc UpdateFlasherSpecString(&f$,numFlashers%,x[],y[],w,h,onset[],dur,&fR)
    var ind%;
    
    if fR = 0 then  'check if it's the first run, return this variable
        f$ := f$ + ",";  'if not the first run, put in initial comma
    else
        fR := 0;  'or reset fR on first run!
    endif;
    
    f$ := f$ + Str$(numFlashers%);  'add number of flashers on this trial
    
    'if there are no flashers, do not specify location, etc.
    while numFlashers% > 0 do
        f$ := f$ + ",0,";  'We are only using one flasher, index 0
        f$ := f$ + Str$(x[ind%]) + ",";  'add x position for this flasher
        f$ := f$ + Str$(y[ind%]) + ",";  'add y position for this flasher
        f$ := f$ + Str$(w) + ",";  'add width for this flasher
        f$ := f$ + Str$(h) + ",";  'add height for this flasher
        f$ := f$ + Str$(onset[ind%]) + ",";  'add onset for this flasher
        f$ := f$ + Str$(onset[ind%]+dur);  'add offset for this flasher
        ind% += 1;  'increment index
        numFlashers% -= 1; 'decrement numFlashers%
    wend
    
    
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' FadeColorToGray$(rgb[]%,contrast%)
' 
' (New version)
'
' Takes an RGB direction and applies the value from CONTRAST to fade the color towards gray.  Gray
' is taken to be 128,128,128 in RGB.  Returns a string in the format (255/255/0) which is placed
' directly into the command line.
'
' For this new version all color directions are legal to start.  Contrast will be an integer
' between 0 and 100, where 0 will result in 128,128,128 and 100 will result in the input color
' being unchanged.  Please note that we must round our RGB values to integers.  This means that:
' 1) Contrast steps will not be strictly equal in size.  e.g., the rounding will result in a 100-99-98
'    contrast step giving 255-254-252 in RGB units.
' 2) If the original color is not fully saturated, some small contrast changes may produce no difference
'    e.g., 50,50,206 would produce 73,73,183 for both 71% and 70% contrasts.
' 3) Hues may shift very slightly because the contrast steps are not strictly equal on each channel.
'
' These effects should be very minor and will doubtfully cause any issue - the animal should not be
' expected to be capable of discriminating these small differences and so the idea that a 71% and 70%
' contrast change would be "different" to the experimenter is unlikely.  Henry has signed off on this
' idea.
'
' For super convenience have changed this so that rgb% is 1x3 vector to split into r% g% b%
' No other direction is legal; r%, g%, and b% must have a value of 0 or 1.
' 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


func FadeColorToGray$(rgb%[],contrast%)
    var r$;
    var g$;
    var b$;
    var r%;
    var g%;
    var b%;
    var r2%;
    var g2%;
    var b2%;
    var contrast;  'for non-integer calcs
    var out$;
    
    contrast := contrast%;
    
    r% := rgb%[0];
    g% := rgb%[1];
    b% := rgb%[2];
    
    
    r2% := 128 + (r%-128)*(contrast/100);
    g2% := 128 + (g%-128)*(contrast/100);
    b2% := 128 + (b%-128)*(contrast/100);
    
    'set output string
    out$ := "(" + Str$(r2%) + "/" + Str$(g2%) + "/" + Str$(b2%) + ")";
    return out$;
end



'New version 7/25/16
'
'
'======= CreateCueCircleColorSets =======
'This function creates the cue circle color sets which are the basis of Cue Circle Swapping and
'Start%() places in CueCirc$ for inclusion in the long spec file.

func CreateCueCircleColorSets$()
    
    var CueCircLocal$;
    var RadAndWid$;  'these are all the same for every cue circle
    
    var ContrastList%[5];  
    var RGBList%[5][3];
    var i%;
    var j%;
    var k%;
    var x%;
    var y%;
    var cueFlag$;
    var colIdx%;
    var conIdx%;
    var tempCol%[3];
    
    
    'assign contrasts
    'message(attCueCircleContrastAttend%);
    ContrastList%[0] := attCueCircleContrastAttend%;
    ContrastList%[1] := attCueCircleContrastIgnore1%;
    ContrastList%[2] := attCueCircleContrastIgnore2%;  'note that Ignore 2-4 are identical to Ignore 1
    ContrastList%[3] := attCueCircleContrastIgnore3%;
    ContrastList%[4] := attCueCircleContrastIgnore4%;
    
    'assign RGBs
    RGBList%[0][0] := attendRGB%[0];
    RGBList%[0][1] := attendRGB%[1];
    RGBList%[0][2] := attendRGB%[2];
    RGBList%[1][0] := ignore1RGB%[0];
    RGBList%[1][1] := ignore1RGB%[1];
    RGBList%[1][2] := ignore1RGB%[2];
    RGBList%[2][0] := ignore2RGB%[0];
    RGBList%[2][1] := ignore2RGB%[1];
    RGBList%[2][2] := ignore2RGB%[2];
    RGBList%[3][0] := ignore3RGB%[0];
    RGBList%[3][1] := ignore3RGB%[1];
    RGBList%[3][2] := ignore3RGB%[2];
    RGBList%[4][0] := ignore4RGB%[0];
    RGBList%[4][1] := ignore4RGB%[1];
    RGBList%[4][2] := ignore4RGB%[2];

    'Dan's list of VSG mappings, 8/21/2020
    '-Q cue circles and central dots
    '-q  central dots
    '-r central squares    
    
    'The old list of CED dialog entries
    'cueCircleList$[1] := "Cue Circles";
    'cueCircleList$[2] := "Cue Circles + Cue Points";
    'cueCircleList$[3] := "Cue Points Only"; 
    
    'The (temporary??) new list of CED dialog entries
    'cueCircleList$[1] := "Cue Squares (not working)";
    'cueCircleList$[2] := "Cue Circles + Cue Points";
    'cueCircleList$[3] := "Cue Points Only"; 
    
    'Set cue flag
    docase  'these values changed as of 8/21/2020 due to remapping on VSG side
    case attUseCueCircles% = 1 then
        cueFlag$ := "-r ";  'Henry is reporting that -r is doing nothing.
    case attUseCueCircles% = 2 then
        cueFlag$ := "-Q ";
    case attUseCueCircles% = 3 then
        cueFlag$ := "-q ";  
    else
        message("Error!  UseCueCircles% holds an illegal value!  Quitting!");
        quit%();
    endcase
    
    'Radius and Width includes following commas but NOT leading comma - leading comma is not always used
    RadAndWid$ := Str$(attCueCircleExtraRadius) + "," + Str$(attCueCircleStrokeWidth%) + ",";
    
    'Put in cue circle opener and first cue circle, which always happens
    'CueCircLocal$ := "-Q " + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'This is for old version of cue circle call (as of 6/5/15)
    'This is for new version of cue circle call, adding stroke width, whenever it gets implemented
    'CueCircLocal$ := cueFlag$ + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  
    
    'start building
    CueCircLocal$ := cueFlag$;
    
    for i% := 0 to attNumPatches%-1 do 'loop through outer rotations
        for j% := 0 to attNumPatches%-1 do 'loop through inner rotations
            for k% := 0 to attNumPatches%-1 do 'loop through contrasts
                if i%<>0 or j%<>0 or k%<>0 then
                    CueCircLocal$ := CueCircLocal$ + ",";  'do not insert comma on very first spec, otherwise insert comma
                endif
                CueCircLocal$ := CueCircLocal$ + RadAndWid$;  'insert radius and width, always the same here.
                'get index of correct color
                colIdx% := (i% + k%) mod attNumPatches%;

                tempCol%[0] := RGBList%[colIdx%][0];
                tempCol%[1] := RGBList%[colIdx%][1];
                tempCol%[2] := RGBList%[colIdx%][2];
                
                'put in correct color/contrast, which starts on the very first list as index zero and then is very complicatedly updated to behave as desired
                CueCircLocal$ := CueCircLocal$ + FadeColorToGray$(tempCol%[],ContrastList%[conIdx%]);
                
                
                'update index of correct contrast
                'for each cue circle in an individual set, advance the contrast index, and reset to zero if we go past the end
                conIdx% += 1;
                if conIdx% = attNumPatches% then
                    conIdx% := 0;
                endif
            next
            'update index of correct contrast
            'for each new cue circle set, back the index up once, which makes the high contrast come one position later, reset to the end if go go lower than zero
            conIdx% -= 1;
            if conIdx% = -1 then
                conIdx% := attNumPatches%-1;
            endif
        next
    next
    
    'add NoInfo at the end if we have one - this is actually doing what I want, first try!!
    'NoInfo condition has now been deprecated, no real plans to bring it back, but the code stays for now
'    conIdx% := 0;  'Reset contrast index
'    if attNoInfoCondition% = 1 then
'        for i% := 0 to attNumPatches%-1 do 'loop through outer rotations
'            for j% := 0 to attNumPatches%-1 do 'loop through inner rotations
'                for k% := 0 to attNumPatches%-1 do 'loop through contrasts
'                    CueCircLocal$ := CueCircLocal$ + ",";  'always insert comma for this
'                    CueCircLocal$ := CueCircLocal$ + RadAndWid$;  'insert radius and width, always the same here.
'                    'get index of correct color - here we don't mod based on k%, all the same color!
'                    colIdx% := (j%) mod attNumPatches%;
'                    
'                    tempCol%[0] := RGBList%[colIdx%][0];
'                    tempCol%[1] := RGBList%[colIdx%][1];
'                    tempCol%[2] := RGBList%[colIdx%][2];
'                    
'                    'put in correct color/contrast, which starts on the very first list as index zero and then is very complicatedly updated to behave as desired
'                    'CueCircLocal$ := CueCircLocal$ + FadeColorToGray$(tempCol%[],ContrastList%[conIdx%]);
'                    CueCircLocal$ := CueCircLocal$ + FadeColorToGray$(tempCol%[],ContrastList%[0]);  'Henry is asking for no-info trials to have *all* cues take the contrast value of the attend stimulus
'                    
'                    'update index of correct contrast
'                    'for each cue circle in an individual set, advance the contrast index, and reset to zero if we go past the end
'                    conIdx% += 1;
'                    if conIdx% = attNumPatches% then
'                        conIdx% := 0;
'                    endif
'                next
'                'update index of correct contrast
'                'for each new cue circle set, back the index up once, which makes the high contrast come one position later, reset to the end if go go lower than zero
'                conIdx% -= 1;
'                if conIdx% = -1 then
'                    conIdx% := attNumPatches%-1;
'                endif
'            next
'        next
'    endif;
    
    
    
    'put in closing space
    CueCircLocal$ := CueCircLocal$ + " ";
    
    return CueCircLocal$;
end



'New version 10/1/18
'
'
'======= CreateCueCircleColorSetsLite =======
'This function skips the aspects of Cue Circle Swapping and simply makes a single set of
'cuec circles in CueCircLocal$ for inclusion in the long spec file.
func CreateCueCircleColorSetsLite$()
    var CueCircLocal$;
    var RadAndWid$;  'these are all the same for every cue circle
    
    var ContrastList%[5];  
    var RGBList%[5][3];
    var i%;
    var cueFlag$;
    var tempCol%[3];
    
    'assign contrasts
    'message(attCueCircleContrastAttend%);
    ContrastList%[0] := attCueCircleContrastAttend%;
    ContrastList%[1] := attCueCircleContrastIgnore1%;
    ContrastList%[2] := attCueCircleContrastIgnore2%;  'note that Ignore 2-4 are identical to Ignore 1
    ContrastList%[3] := attCueCircleContrastIgnore3%;
    ContrastList%[4] := attCueCircleContrastIgnore4%;
    
    'assign RGBs
    RGBList%[0][0] := attendRGB%[0];
    RGBList%[0][1] := attendRGB%[1];
    RGBList%[0][2] := attendRGB%[2];
    RGBList%[1][0] := ignore1RGB%[0];
    RGBList%[1][1] := ignore1RGB%[1];
    RGBList%[1][2] := ignore1RGB%[2];
    RGBList%[2][0] := ignore2RGB%[0];
    RGBList%[2][1] := ignore2RGB%[1];
    RGBList%[2][2] := ignore2RGB%[2];
    RGBList%[3][0] := ignore3RGB%[0];
    RGBList%[3][1] := ignore3RGB%[1];
    RGBList%[3][2] := ignore3RGB%[2];
    RGBList%[4][0] := ignore4RGB%[0];
    RGBList%[4][1] := ignore4RGB%[1];
    RGBList%[4][2] := ignore4RGB%[2];
    
    'Set cue flag
    docase
    case attUseCueCircles% = 1 then
        cueFlag$ := "-Q ";
    case attUseCueCircles% = 2 then
        cueFlag$ := "-q ";
    case attUseCueCircles% = 3 then
        cueFlag$ := "-r ";  'this ought to work as of 1/24/18
    else
        message("Error!  UseCueCircles% holds an illegal value!  Quitting!");
        quit%();
    endcase
    
    'Radius and Width includes following commas but NOT leading comma - leading comma is not always used
    RadAndWid$ := Str$(attCueCircleExtraRadius) + "," + Str$(attCueCircleStrokeWidth%) + ",";
    
    'start building
    CueCircLocal$ := cueFlag$;
    
    for i% := 0 to attNumPatches%-1 do 'loop through each patch
        if i%<>0 then
            CueCircLocal$ := CueCircLocal$ + ",";  'do not insert comma on very first spec, otherwise insert comma
        endif
        CueCircLocal$ := CueCircLocal$ + RadAndWid$;  'insert radius and width, always the same here.
        
        tempCol%[0] := RGBList%[i%][0];
        tempCol%[1] := RGBList%[i%][1];
        tempCol%[2] := RGBList%[i%][2];
        
        'put in correct color/contrast, which starts on the very first list as index zero and then is very complicatedly updated to behave as desired
        CueCircLocal$ := CueCircLocal$ + FadeColorToGray$(tempCol%[],ContrastList%[i%]);

    next
    
    'If cue circles match fixpt for Cue-All, write second set of specs
    if attCueCirclesMatchCueAllFixpt% = 1 then
        for i% := 0 to attNumPatches%-1 do 'loop through each patch
            CueCircLocal$ := CueCircLocal$ + ",";  'insert comma in all cases
            CueCircLocal$ := CueCircLocal$ + RadAndWid$;  'insert radius and width, always the same here.
            
            'This is cue-all fixation color
            tempCol%[0] := cueallRGB%[0];
            tempCol%[1] := cueallRGB%[1];
            tempCol%[2] := cueallRGB%[2];
            
            'put in correct color/contrast of cue-all fixation point
            CueCircLocal$ := CueCircLocal$ + FadeColorToGray$(tempCol%[],ContrastList%[0]);
        next
    endif;
    
    'put in closing space
    CueCircLocal$ := CueCircLocal$ + " ";
    
    return CueCircLocal$;
end



func CallDlgGratingFlashers%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    
    attFlasherGratingParams$ := GetGratingParameters$("Flasher");
    i% := GratingParametersDialogFlashers%(label$, attFlasherGratingParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    if i% = 1 then
        SaveGratingParameters("Flasher", attFlasherGratingParams$);
    endif
    
    return 1;
end;


func GratingParametersDialogFlashers%(label$, &param$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$, &ctf)
    
	var i% := 50;  'That's right, 50, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
    ColorVectorList$[1]:="Blue/Yellow";	cvl$[1]:="[0/0/1]-[1/1/0]";
    ColorVectorList$[2]:="Red/Cyan";	cvl$[2]:="[1/0/0]-[0/1/1]";
    ColorVectorList$[3]:="Green/Magenta";	cvl$[3]:="[0/1/0]-[1/0/1]";
	'ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	'ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	'ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[4];
	var pl$[4];
	var ipl% := 0;
	PatternList$[0]:="Gr Sine; Cp Sine";	pl$[0]:="ss";
	PatternList$[1]:="Gr Square; Cp Sine";	pl$[1]:="qs";
    PatternList$[2]:="Gr Sine; Cp Square";	pl$[2]:="sq";
	PatternList$[3]:="Gr Square; Cp Square";	pl$[3]:="qq";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    GetFlasherDialogParameters();
    
    while i% = 50 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 5, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 4, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 2, 0);
            endif
        endif
        
        DlgCreate("Flasher Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        'DlgReal(1, "X:", -40, 40);
        'DlgReal(2, "Y:", -40, 40);
        DlgReal(1, "Outer Width:", .1, 30);  'before button x/y values for dialog elements are not necessary
        DlgReal(2, "Outer Height:", .1, 30);
        DlgReal(3, "Inner Width:", 0, 30);
        DlgReal(4, "Inner Height:", 0, 30);
        DlgInteger(5, "Contrast(%):", -100, 100);
        DlgReal(6, "Spatial Freq:", .01, 10);
        DlgReal(7, "Temporal Freq:", 0, 10);
        DlgReal(8, "Orientation (degrees):", -360, 360);
        DlgReal(9, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(10, "Color:", ColorVectorList$[]);
        DlgList(11, "Pattern (Grating/Counterphase):", PatternList$[]);
        DlgList(12, "Aperture:", ApertureList$[]);
        DlgReal(13, "Counterphase Transition Freq:", 0, 10);
        DlgButton(50, "Copy from Master", TunCopyMasterVals%(param$), 2, 14); 'after the button, use x/y values so button can offset grating params from flasher params
        DlgReal(14, "Flasher Duration (s):", .01, 3, 42, 15);
        DlgReal(15, "Temporal Buffer (s):", .01, 3, 42, 16);
        DlgReal(16, "Spatial Buffer (deg):", .01, 10, 42, 17);
        DlgReal(17, "Max distance from main grating (deg):", 1, 30, 42, 18);
        DlgReal(18, "Hazard Value (s/flasher):", .01, 1000, 42, 19);  'don't know what reasonable values for this will be yet
        
        i% := DlgShow(attFlasherWidth, attFlasherHeight, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%, ctf, attFlasherDur, attFlasherTemporalBuffer, attFlasherSpatialBuffer, attFlasherMaxDist, attFlasherHazardValue);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if attFlasherWidth > iw and attFlasherHeight > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, attFlasherWidth, attFlasherHeight, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
        SaveFlasherDialogParameters();
    endif
    return i%;
end;


func TunCopyMasterVals%(&param$)

    param$ := GetGratingParameters$("Stimulus");

    return 1;
end;


proc GetFlasherDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	attFlasherDur := GetFloatRegistryValue(key$, "FlasherDur", 1.0);
    attFlasherTemporalBuffer := GetFloatRegistryValue(key$, "FlasherTemporalBuffer", 1.0);
    attFlasherSpatialBuffer := GetFloatRegistryValue(key$, "FlasherSpatialBuffer", 1.0);;
    attFlasherMaxDist := GetFloatRegistryValue(key$, "FlasherMaxDist", 1.0);
    attFlasherHazardValue := GetFloatRegistryValue(key$, "FlasherHazardValue", 1.0);
    attFlasherWidth := GetFloatRegistryValue(key$, "FlasherWidth", 1.0);
    attFlasherHeight := GetFloatRegistryValue(key$, "FlasherHeight", 1.0);

end;

proc SaveFlasherDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	SetFloatRegistryValue(key$, "FlasherDur", attFlasherDur);
    SetFloatRegistryValue(key$, "FlasherTemporalBuffer", attFlasherTemporalBuffer);
    SetFloatRegistryValue(key$, "FlasherSpatialBuffer", attFlasherSpatialBuffer);
    SetFloatRegistryValue(key$, "FlasherMaxDist", attFlasherMaxDist);
    SetFloatRegistryValue(key$, "FlasherHazardValue", attFlasherHazardValue);
    SetFloatRegistryValue(key$, "FlasherWidth", attFlasherWidth);
    SetFloatRegistryValue(key$, "FlasherHeight", attFlasherHeight);
    
end;


'Returns 1 if the two patches overlap, 0 if they do not.  Overlap includes a buffer region if BUFFER is non-zero
'Overlap goes to extremes of simplicity in computing (because doing it properly turns out to be VERY DIFFICULT)
'and models potentially elliptical gratings as...rectangles.  The basic effects of this simplification will be:
'1A) The effective buffer will be somewhat larger than the requested buffer
'1B) Tangent/near-tangent gratings will be considered to overlap unless their centers have the same X or Y values
'    (but we weren't TRYING to get tangent gratings, so that's not a biggie)
func Overlap%(x,y,width,height,x2,y2,width2,height2,buffer)
    var overlap;
    var dist;
    
    
    'Check X
    dist := width/2 + width2/2 + buffer; 'this is how far apart the X centers must be, width values are diameters
    'printlog("X Dist is %f\n",dist);
    if abs(x-x2) < dist then
        overlap += 1;
    endif;
    
    'Check Y
    dist := height/2 + height2/2 + buffer; 'this is how far apart the Y centers must be, height values are diameters
    'printlog("Y Dist is %f\n",dist);
    if abs(y-y2) < dist then
        overlap += 1;
    endif;
    
    if overlap = 2 then  'if both x and y overlap, then the rectangles overlap
        return 1;
    else
        return 0;
    endif;
    
end


'Returns max limits (in degrees in variables xmax, ymax) for the screen, used to constrain random x/y position
'use 400 for width and 300 for height unless otherwise specified
'when using recall that width/height definitions are total w/h and distance from the center point is width/2
proc ScreenBounds(scrXmm,scrYmm,&xmax,&ymax)
    var d2s$;
    var d2s; 
    
    d2s$ := GetDistanceToScreenMM$();
    d2s := val(d2s$);
    'printlog("Distance to screen is %f\n",d2s);
    
    xmax := ATan((scrXmm/2)/d2s)*180/(4.0*ATan(1.0));  'maximum x in degrees
    ymax := ATan((scrYmm/2)/d2s)*180/(4.0*ATan(1.0));  'maximum y in degrees
    'printlog("Max x is %f degrees and max y is %f degrees\n",xmax,ymax);
    
end

'This function places a SampleText to indicate the onset/location of flashers or the time of the contrast change
'Since these are on the same channel, it just looks for the nearest expected time to the known trigger.
'Since there is a buffer of 100 ms between any onset, there should be no difficulty, but I will have the
'SampleText indicate a possible problem if the timing is off by more than, say, 2ms
'This function has been changed to a PROC, it does not return a value, but will update the value in cc%
proc TagTriggerWithSampletext(triggerTime,tAnimationOn,trialCount%,&flasherCount%,&cc%,isCueAll%)
    var fTime;  'expected time of next flasher
    var ccTime; 'expected time of cued contrast change
    var ccTimeU; 'expected time of uncued contrast change
    var ccReturnTime; 'expected time of cued contrast change return
    var ccReturnTimeU; 'expected time of uncued contrast change return
    var cueOnTime;
    var cueOffTime;
    var gratingOnTime;
    var allOffTime;
    var diffArray[10];
    var minLoc%;
    var minVal;
    var bothCuesAreLocked%;
    const NoFlashersRightNow% := 1;
    
        
    'OK, so with the complete overhaul in the design of the cue specs, we need a pretty complete overhaul of this function
    'We now expect to find the following triggers:
    '   Trigger                 Literal Time
    '1) Animation Onset:        tAnimationOn
    '2) Cue Onset:              tAnimationOn+attCueOnsetTime
    '3) Cue Offset:             tAnimationOn+attCueOffsetTime
    '4) Grating Onset:          tAnimationOn+attCueOffsetTime+attStimOnsetList[trialCount%]
    '5) Contrast Changes:       tAnimationOn+attCueOffsetTime+attStimOnsetList[trialCount%]+attCuedLocCCTime[trialCount%]  (unless final value is -1)
    '                           tAnimationOn+attCueOffsetTime+attStimOnsetList[trialCount%]+attUncuedLocCCTime[trialCount%]  (unless final value is -1)
    '                           tAnimationOn+attCueOffsetTime+attStimOnsetList[trialCount%]+attCuedLocReturnTime[trialCount%]  (unless final value is -1)
    '                           tAnimationOn+attCueOffsetTime+attStimOnsetList[trialCount%]+attUncuedLocReturnTime[trialCount%]  (unless final value is -1)
    '6) All Offset:             tAnimationOn+attCueOffsetTime+attStimOnsetList[trialCount%]+attTrialEndTime[trialCount%]
    
    'Note that for the time being, there are no flashers, but there's a decent chance those will get built in eventually
    
    'If this trigger is the very first trigger that coincides with the animation onset, do not tag it, just return before doing any other work
    if triggerTime - tAnimationOn < 0.015 then
        return;  'instead return
    endif;
    
    
    
    'For simplicity, we should calculate these values locally first
    cueOnTime := tAnimationOn + attCueOnsetTime;  'Cue onset time is now constant
    cueOffTime := tAnimationOn + attCueOffsetTime;  'Cue offset time is now constant
    gratingOnTime := tAnimationOn + attCueOffsetTime + attStimOnsetList[trialCount%];  'Stim onset (and following timing) is now referenced to cue offset
    if attCuedLocCCTime[trialCount%] > -1 then  'This value should always be positive if there is a contrast change ... -1 indicates no contrast change
        ccTime := tAnimationOn + attCueOffsetTime + attStimOnsetList[trialCount%] + attCuedLocCCTime[trialCount%];
    else
        ccTime := 9999999;  'Place time corresponding to nonexistent contrast change safely into the future
    endif;
    if attUncuedLocCCTime[trialCount%] > -1 then 
        ccTimeU := tAnimationOn + attCueOffsetTime + attStimOnsetList[trialCount%] + attUncuedLocCCTime[trialCount%];
    else
        ccTimeU := 9999999;  'Place time corresponding to nonexistent contrast change safely into the future
    endif;
    if attCuedLocReturnTime[trialCount%] > -1 then
        ccReturnTime := tAnimationOn + attCueOffsetTime + attStimOnsetList[trialCount%] + attCuedLocReturnTime[trialCount%];
    else
        ccReturnTime := 9999999;  'Place time corresponding to nonexistent contrast change safely into the future
    endif;
    if attUncuedLocReturnTime[trialCount%] > -1 then 
        ccReturnTimeU := tAnimationOn + attCueOffsetTime + attStimOnsetList[trialCount%] + attUncuedLocReturnTime[trialCount%];
    else
        ccReturnTimeU := 9999999;  'Place time corresponding to nonexistent contrast change safely into the future
    endif;
    allOffTime := tAnimationOn + attCueOffsetTime + attStimOnsetList[trialCount%] + attTrialEndTime[trialCount%];
    'All times are now locally calculated
    'One last fix, if uncued is locked to cued and they both change, eliminate the uncued time, indicate both cues are locked
    if attCuedLocCCTime[trialCount%] > -1 and attUncuedLocCCTime[trialCount%] > -1 and attLockUncuedToCued% = 1 then
        ccTimeU := 9999999;
        ccReturnTimeU := 9999999;
        bothCuesAreLocked% := 1;
    endif;
    
        
    
    'Set a flasher time for the upcoming flasher, if it exists - this is currently shorted out via NoFlashersRightNow%
    if flasherTimes[trialCount%][flasherCount%] > 0 and NoFlashersRightNow% = 0 then  'this will not evaluate true right now
        fTime := tAnimationOn + flasherTimes[trialCount%][flasherCount%];
    else 'Currently no flashers, fTime is always set to 9999999
        fTime := 9999999; 'Place time corresponding to nonexistent flasher safely into the future
    endif;
    
    
    'Fill diffArray with differences between time of current trigger and known event times
    diffArray[0] := abs(tAnimationOn - triggerTime);  'for now we are short circuiting and not tagging tAnimationOn, but this will allow easy tagging if desired
    diffArray[1]:= abs(allOffTime - triggerTime);
    diffArray[2] := abs(cueOnTime - triggerTime);
    diffArray[3] := abs(cueOffTime - triggerTime);
    diffArray[4] := abs(gratingOnTime - triggerTime);
    diffArray[5] := abs(ccTime - triggerTime);  'contrast change time goes first, because this has priority, if there is a tie, min will take the first value
    diffArray[6] := abs(ccTimeU - triggerTime);
    diffArray[7]:= abs(ccReturnTime - triggerTime);
    diffArray[8]:= abs(ccReturnTimeU - triggerTime);
    diffArray[9] := abs(fTime - triggerTime);
    
    minLoc% := min(diffArray);  'find index of smallest difference
    minVal := diffArray[minLoc%];
    
'printlog("*** Tag Trigger - Flasher count is %d, expected flasher time is %f, expected ccTime is %f, trigger time is %f, delta was %f\n",flasherCount%,fTime,ccTime,triggerTime,Min(diffF,diffCC));    
    
    
    docase
    case minVal > 0.05 then 'trigger is not within 50 ms of any expected time
        if diffArray[1] < 0.1 then 'use big tolerance for end of window 
            SampleText("End of animation",triggerTime);
        else
            SampleText("Error - trigger time not recognized!",triggerTime);
        endif;
    case minLoc% = 1 then 'This is stimulus offset, moved to top, because it will coincide with grating offsets, want this to take priority
        SampleText("End of animation",triggerTime);
    case minLoc% = 2 then 'this is cue on
        SampleText("Cue On",triggerTime);
    case minLoc% = 3 then 'this is cue off
        SampleText("Cue Off",triggerTime);
    case minLoc% = 4 then 'this is grating on
        SampleText("Grating On",triggerTime); 
    case minLoc% = 5 and bothCuesAreLocked% = 0 then 'this is a contrast change in the cued location
        cc% += 1;  'Increment cc% by 1
        if isCueAll% = -1 then
            SampleText("Cued Location CC, window open, no cues match",triggerTime);
        else    
            SampleText("Cued Location CC, window open",triggerTime);
        endif
    case minLoc% = 5 and bothCuesAreLocked% = 1 then 'this is a contrast change in BOTH locations simultaneously
        cc% += 1;  'Increment cc% by 1
        if isCueAll% = -1 then
            SampleText("BOTH Locations CC, window open, no cues match",triggerTime);
        else 
            SampleText("BOTH Locations CC, window open",triggerTime); 
        endif
    case minLoc% = 6 then 'this is a contrast change in the uncued location
        docase
        case isCueAll% = -1 then
            cc% += 10;  'Increment cc% by 10
            SampleText("Uncued Location CC, window open, no cues match",triggerTime);
        case isCueAll% = 1 then
            cc% += 10;  'Increment cc% by 10
            SampleText("Uncued Location CC, window open",triggerTime);
        else
            'do NOT increment CC, this contrast change is not a target, NO!  We need to know the change happened, not a target is dealt with by caller
            cc% += 10;  'Increment cc% by 10
            SampleText("Uncued Location CC, not a target",triggerTime);
        endcase;
    case minLoc% = 7 and bothCuesAreLocked% = 0 then 'this is a contrast return in the cued location
        cc% += 1;  'Increment cc% by 1
        if isCueAll% = -1 then
            SampleText("Cued Location return to baseline, window closed, no cues match",triggerTime);
        else
            SampleText("Cued Location return to baseline, window closed",triggerTime); 
        endif
    case minLoc% = 7 and bothCuesAreLocked% = 1 then 'this is a contrast return in BOTH locations simultaneously
        cc% += 1;  'Increment cc% by 1
        if isCueAll% = -1 then
            SampleText("BOTH locations return to baseline, window closed, no cues match",triggerTime);
        else
            SampleText("BOTH locations return to baseline, window closed",triggerTime); 
        endif
    case minLoc% = 8 then 'this is a contrast return in the uncued location
        docase
        case isCueAll% = -1 then
            cc% += 10;  'Increment cc% by 10
            SampleText("Uncued Location return to baseline, window closed, no cues match",triggerTime);
        case isCueAll% = 1 then
            cc% += 10;  'Increment cc% by 10
            SampleText("Uncued Location return to baseline, window closed",triggerTime);
        else
            'do NOT increment CC, this contrast change is not a target, NO!  We need to know the change happened, not a target is dealt with by caller
            cc% += 10;  'Increment cc% by 10
            SampleText("Uncued Location return to baseline, not a target",triggerTime);
        endcase;    
    case minLoc% = 9 then 'this is a flasher (not currently in use)
        SampleText("Flasher X = " + Str$(flasherX[trialCount%][flasherCount%]) + " Y = " + Str$(flasherY[trialCount%][flasherCount%]) + " Note, trigger time more than 2ms off!",triggerTime);
        flasherCount% += 1;
    
    endcase

    
    return;
end





'masterColorList$ and masterColorListVSG$ define fixation colors and should have the same progression as cue circle colors
'but due to the command line need to be in a text format.  Use cue circle colors to fill these variables.
'This function will allow any integer color values from 0-255 even though the dialog box code currently will not.
proc CreateMasterColorLists()
    var temp%[3][7];  'our list of colors
    var i%;
    var r%;
    var g%;
    var b%;
    var mystr$;
    
    temp%[0][0] := attendRGB%[0];
    temp%[1][0] := attendRGB%[1];
    temp%[2][0] := attendRGB%[2];
    temp%[0][1] := ignore1RGB%[0];
    temp%[1][1] := ignore1RGB%[1];
    temp%[2][1] := ignore1RGB%[2];
    temp%[0][2] := ignore2RGB%[0];
    temp%[1][2] := ignore2RGB%[1];
    temp%[2][2] := ignore2RGB%[2];
    temp%[0][3] := ignore3RGB%[0];
    temp%[1][3] := ignore3RGB%[1];
    temp%[2][3] := ignore3RGB%[2];
    temp%[0][4] := ignore4RGB%[0];
    temp%[1][4] := ignore4RGB%[1];
    temp%[2][4] := ignore4RGB%[2];
    temp%[0][5] := cueallRGB%[0];
    temp%[1][5] := cueallRGB%[1];
    temp%[2][5] := cueallRGB%[2];
    temp%[0][6] := nomatchRGB%[0];
    temp%[1][6] := nomatchRGB%[1];
    temp%[2][6] := nomatchRGB%[2];
    
    'not ready to do this yet
    for i% := 0 to 6 do
        r% := temp%[0][i%];
        g% := temp%[1][i%];
        b% := temp%[2][i%];
        
        mystr$ := "(" + str$(r%) + "/" + str$(g%) + "/" + str$(b%) + ")";
        
        masterColorListVSG$[i%] := mystr$;
        
        docase
        case r% = 255 and g% = 255 and b% = 255 then
            masterColorList$[i%] := "white";
        case r% = 0 and g% = 0 and b% = 0 then
            masterColorList$[i%] := "black";
        case r% = 255 and g% = 0 and b% = 0 then
            masterColorList$[i%] := "red";
        case r% = 0 and g% = 255 and b% = 0 then
            masterColorList$[i%] := "green";
        case r% = 0 and g% = 0 and b% = 255 then
            masterColorList$[i%] := "blue";
        case r% = 255 and g% = 255 and b% = 0 then
            masterColorList$[i%] := "yellow";
        case r% = 0 and g% = 255 and b% = 255 then
            masterColorList$[i%] := "cyan";
        case r% = 255 and g% = 0 and b% = 255 then
            masterColorList$[i%] := "magenta";
        else
            masterColorList$[i%] := mystr$;
        endcase
    next
    
    
    
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end



func CallJoystickConfigDialog%()
    'This function was written simply to prevent "odd" autonaming of files when saving joystick calibration data
    'Unfortunately, there doesn't seem to be a way to *not* save the data as SampleStop automatically saves it, so
    'this is the next best thing.  Should work for either dialog-based or toolbar-based calls of Joystick config
    
    var key$;
    var primaryTxt$;
    var secondaryTxt$;
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";    
    
    
    'Set autoname to use a joystick-based name
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    'if UseTwo1401s% = 0 then
    DoSampleAutoName(key$,"joystick","joy",primaryTxt$,secondaryTxt$);    
    
    JoystickConfigDialogUD%();  'this needs to be the Up/Down version
    
    'Set autoname back to what it should be once we return
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    'if UseTwo1401s% = 0 then
    DoSampleAutoName(key$,"atn","atn",primaryTxt$,secondaryTxt$);
    
    return 1;
end