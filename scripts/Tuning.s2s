' $Id$
' Update 11/8/11 Jeff, includes multi-juicer updates

const tunCVSID$ := "$Id$";




' Hello again

#include "../util/ChannelUtilities.s2s"
#include "../util/UsreyUtil.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "TuningDialogs.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var StimHandleSlave%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameChannel%;
'var FrameSlaveChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;
'var ReadySlaveChannel%;
'var FixationPointSlaveChannel%;
'var StimSlaveChannel%;
'var DigitalLaserChannel%;
var OptoCopyChannel%;
var SequencerPeriodMS;
var ButtonChannel%;
var ButtonPort%;
var StimulatorChannel%;
var UtilityChannel%;
var JoyChannel%;
var TimingChannel%;
var IntanTrialChannel%;

' xy windows for plotting (TuningWindow) and PSTH. 
var TuningWindow%[16];	' one for each wavemark channel
var PSTHWindow%[16];    ' used for f1 and f2. Will be made invisible when in use. 

' XY window stuff
var XYWindow%;			' 
var iEyePosChannel%;  'channel number for eye position
var iFixptChannel%;	' channel number for fixation point in xy window
var iFixptWindowChannel%;' channel number for fixation point window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var XYDotSize%[200];  'holds size of each dot for XY coordinate plot
var XYDataCount%[200];  'holds number of presentations at each XY coordinate
var XYSpikeRate[200];  'hold cumulative "rate" ( = rate on trial 1 + rate on trial 2 ...) at each XY coordinate
var plotF0Ch% := 1;  'hard code; the first channel is the F0 channel
var plotF0MeanCh%;   'the remainder of these channels will be assigned in InitializeWindows as needed
var plotF1Ch%;
var plotF1MeanCh%;
var plotF2Ch%;
var plotF2MeanCh%;

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;


var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tStimulusDown;      ' hold time the previous stimulus was taken down, useful for the fixpt jump experiment, could find another use?
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 
var tStimSequence := -1;    ' time that stim sequence started; followed by pulses on frame channels
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before fix point is presented)
var tRise, tFall;
'var tKludge := 0.06;    ' Add to Fixation time to account for stim sequence. Ugly hack, admittedly, but one does what one must. 
var tKludge := 0;        'I don't know what this was, and it's making our stimuli 60 ms longer, so...???
var HBCycle% := 1;

var tbtFix% := 0;    'By default, we will NOT be using trial-by-trial fixation location
var tbtFixX;         'But if we do...
var tbtFixY;

'button stuff
var button1Press;
var button2Press;
var button1Release;
var button2Release;
var button1Thresh := 1.1;  'crossing level (downwards) for button 1, this is LEFT button
var button2Thresh := 2.0;  'crossing level (upwards) for button 2, this is RIGHT button
var buttonHysteresis := 0.05; 'how much noise we're allowing in the steady state voltage level; this may be high
var buttonMinTime := 0.005;  'five millisecond minimum
var buttonTime;  'the time of the most recent button event
var buttonStatus%;  'if 0, all buttons up, if 1, LEFT button currently pressed, if 2, RIGHT button currently pressed
var buttonDuringXHair%;
var buttonDuringSequence%;
var buttonError%;
var tButtonStart;   ' start time on button check

' Constants for states
const stateStartTrial%:=0;		' Start trial state
const stateWaitForFixPtOn%:=1;		' Waiting for fixation point return trigger (on)
const stateWaitForBlank%:=2;		' Waiting for fixation point return trigger (off)
const stateWaitForStimOn%:=3;		' Wait for stimulus return trigger (on)
const stateWaitForStimOff%:=4;		' Wait for stimulus return trigger (off)
const stateWaitForAcquisition%:=5;	' Waiting for subject to acquire fixation point
const stateHoldFixation%:=6;		' Holding fixation point
const stateAbort%:=7;			' Failed trial state
const stateMaintainFixation%:=8;	' Maintaining fixation (stim off period)
const stateInterTrialInterval%:=9;	' time out after failed trial
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' wait for vsg to send ready signal #2
const stateTrialCompleted%:=12;		' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForStimTrigger% := 14; ' Rising edge indicating start of stim sequence
const stateWaitForStimOffDSS%:=15;		' Wait for stimulus return trigger (off) during DSS sequence
const stateInterTrialIntervalFixAlreadyUp%:=16;  'use intertrial interval after giving fixation reward in maintain fixation mode
const stateWaitStimulusOnsetDelay%:=17;  'if there is a stimulus onset delay, wait for the correct time
const stateStartOpto%:=18;
const stateWaitOptoPrestim%:=19;
const stateCheckTurnOnOpto%:=20;
const stateCheckTurnOffOpto%:=21;
const stateTurnOffOpto%:=22;
const stateWaitOptoPoststim%:=23;
const statePulsedOpto%:=24;
const stateWaitPulsedOpto%:=25;
const stateRequestStimulus%:=26;
const stateJumpFixpt%:=27;
const stateWaitForJumpAcquisition%:=28;
const statePause%:=29;
var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var trialIndex%:=0;  'index to trial-by-trial opto and condition labels, etc., need to wrap it if we RepeatForever, will now replace nTrialsCompleted% in many contexts
var nTrialsAborted% :=0;		
var nTrialsRewarded% :=0;
var giveReward%;  'we are going to be moving the reward later so that opto is turned off first.

var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
var pulseFound%;
var pulseFoundSlave%;
var tOpt;
var stimulusHoldTime;


'variables for reading tuning files
var tunFileLen%;
var tun1FileLen%;
var tun2FileLen%;
var BDFullText$; 
var BDNumStim%;
var SampleTextStr$;
'var BDOCFullText$;


' Init logging
LogInit(1);

' Check if always looking flag is set. If so, issue a warning. 
if tunAlwaysLooking% = 1 then
    if Query("Always looking is SET. Unset?") = 1 then
        tunAlwaysLooking% := 0;
    endif
endif


' run parameters script....
tunContext$ := tunContextDAQ$;
tunType$ := tunTypeNone$;

ResizeOnCurrentMonitor(30, 0, 100, 95);
GetTuningCurveScriptParameters();
iScript% := TuningCurveScriptDialog%();
if iScript% = 1 then
	if tunType$ = tunTypeNone$ then
		LogInfo("No tuning type selected, exit gracefully\n");
		Halt;
	else
		LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ. DoRivalry = " + str$(tunDoRivalry%));
	endif;
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' When TF/CRG curve, don't do f1 and f2. 
' Also Dots. Also Stationary
if tunType$ = tunTypeTemporal$ or tunType$ = tunTypeCRG$ or tunType$ = tunTypeDots$ or tunType$ = tunTypeBakersDozen$ or tunSetStationary% = 1 then
    tunDoF12% := 0;
endif

' Read in CRG sequence file (SEQ) if doing contrast reversing grating, get length, make sure it's kosher
if tunType$ = tunTypeCRG$ then
    'Getting sequence lengths, number of flips, checking files against each other, if two
    LogStatus("Check Seq File", tunCRGSeqFile$);
    tunCRGNSeq1% := CheckSeqFile%(tunCRGSeqFile$,tunCRGNFlips1%);
    if tunCRGNSeq1% < 0 then
        Message("ERROR!|Cannot open seq file " + tunCRGSeqFile$);
        halt;
    endif
    
    if tunType1$ = tunTypeCRG$ then  'If secondary grating is CRG as well, read second grating
        tunCRGNSeq2% := CheckSeqFile%(tunCRGSeqFile2$,tunCRGNFlips2%);
        if tunCRGNSeq2% < 0 then
            Message("ERROR!|Cannot open seq file " + tunCRGSeqFile2$);
            halt;
        endif
        if tunCRGNSeq1% <> tunCRGNSeq2% then
            Message("ERROR!|The number of sequences must be the same in each file!");
            halt;
        endif;
        if tunCRGNFlips1% <> tunCRGNFlips2% then
            Message("ERROR!|The number of flips must be the same in each file!");
            halt;
        endif
        'if there is a CRG on both screens, set tunFixationDuration to 0; used in Idle processing to determine
        'when to advance the stimulus, don't want this value to interfere if it's not being used.
        tunFixationDuration := 0;   
    endif;
    
    'Calculate duration of stimulus
    tunCRGSecsPerSeq := tunCRGFramesPerFlip%*tunCRGNFlips1%/dataScreenHz;
    'printlog("duration of CRG stim is %f seconds\n",tunCRGSecsPerSeq);
    
    

endif;



' Assign channel numbers for eye X,Y and trigger. 
'here are old values
'XChannel% := 21;
'YChannel% := 22;
'FixationPointChannel% := 24;
'StimChannel% := 25;
'ReadyChannel% := 27;            ' Look for ready signal on port 2 (same as fixpt). 
'FixationPointSlaveChannel% := 28;
'StimSlaveChannel% := 29;
'FrameChannel% := 19;
'FrameSlaveChannel% := 20;
'ButtonChannel% := 23;

XChannel% := 25;
YChannel% := 26;
JoyChannel% := 28;

' djs 9-18-14 renumber these channels - save this stanza in case the extracts suffer....
'FixationPointChannel% := 28;
'StimChannel% := 29;
'ReadyChannel% := 33;            ' Look for ready signal on port 2 (same as fixpt). 
'ReadySlaveChannel% := 38;
'FixationPointSlaveChannel% := 34;
'StimSlaveChannel% := 35;
'FrameChannel% := 36;
'FrameSlaveChannel% := 37;

ReadyChannel% := 40;
FrameChannel% := 41;
FixationPointChannel% := 42;
StimChannel% := 43;
'ReadySlaveChannel% := 44;
'FrameSlaveChannel% := 45;
'FixationPointSlaveChannel% := 46;
'StimSlaveChannel% := 47;
'DigitalLaserChannel% := 48;  'is 32 on Acute tuning, but let's not shove it in the midst of other stuff
OptoCopyChannel% := 49;
StimulatorChannel% := 39;
UtilityChannel% := 38;
TimingChannel% := 37;
IntanTrialChannel% := 36;

ExcludedChans%[0] := 25;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 49;  'OptoCopyChannel% is highest non-electrode channel used by this function  


ButtonChannel% := 27;
'ButtonPort% := 5;  'No longer used, now uses UtilityPort% from config

' Fetch information about whether we are going to be using two 1401s 
UseTwo1401s% := DoWeUseTwo1401s%();


' Get number of wavemark ports/continuous ports on the primary 1401
' Note that the info we gather here is basically used for display, which is only done on the primary 1401.  The
' secondary 1401 is kinda humming along passively collecting data and doing nothing else.
' The thing is, the Wavemark info here is used for spike plotting, the continuous info is unused.  OK, maybe it will be useful someday.
GetPortsAndNumWMsWFs%(tunNWavemarks%,tunNContinuous%,tunWavemarkPorts%[],tunContinuousPorts%[]);



''Create sampling configuration
'CreateSampleConfiguration();
'
'
'' Get display windows ready
'InitializeWindows();
'
'tic := View(DataWindow%).BinSize(ReadyChannel%);
'
'' Prepare the toolbar buttons
'InitializeToolbar();



'If we are not linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the dual-1401 setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401/SLAVE 1401 (the second, non-dominant instance of Spike2) FIRST and on the 
'MICRO 1401/MASTER 1401 (the first,  dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run 
'the VSG program (Fixstim) which gives the sampling trigger and sets the experiment in motion.
if UseTwo1401s% = 0 then
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();
    
    tic := View(DataWindow%).BinSize(ReadyChannel%);
    
    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



func IdleProcessing%()
	var iStatus% := 1;	
    var xval;
    var yval;
    var xind%;
    var yind%;
    var i%;
    var tempNTC1%;
    var tempNTC2%;
    
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    if tLast < 0 then
        tLast := 1;
        return 1;
    endif
    
    
	xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
	yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(iEyePosChannel%,xEye,yEye);
		tLastUpdate := tNow;
        'if we're collecting a rivalry button, get button status and time here
        'OK, so the amazing thing is that for as complicated as this code is, the outputs ARE COMPLETELY UNUSED.  100%.  So until that changes, let's not go through the CPU time to analyze the button channel every 5 ms. -jj 9/22/16
        'if tunButtonCollect% = 1 then
        '    buttonError% := WhichButton%(tButtonStart,tNow,buttonStatus%,buttonTime);
        '    if buttonError% = -1 then
        '        FlushButton(tButtonStart,tNow,buttonStatus%,buttonTime);  'flush out all button events on error
        '    endif;
        'endif;
	endif

	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        'if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tRise, tFall) = 1 then
        pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        
        if tunDoRivalry% = 0 then
            if pulseFound% = 1 then
                LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
                
                if tunSendINTANPulse% = 1 then
                    'sequencer variable 11 is already set to the correct session-start pulse length for this tuning curve type
                    SafeSampleKey("T");  'Send a pulse
                endif;
                
                Yield(1.0);  'Note, this yield is useful for giving a delay following the INTAN pulse, but it was present before that was added
                tLastTrigger := tFall;
                ChangeStateTo(stateStartTrial%, tFall);
                if RecordEyeTrackerOutputFile% = 1 then
                    'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                    SafeSampleKey("1");
                    yield(0.2);
                endif;
                ToolbarEnable(4,1);  'Once the sequence has started, enable pause
            else
                if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                    LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                    tLastTrigger := tFall;
                endif;
            endif;
'        else
'            pulseFoundSlave% := View(DataWindow%).FindPulseUp%(ReadySlaveChannel%, tLastTrigger+tic, tRise, tFall);
'            if pulseFound% = 1 and pulseFoundSlave% = 1 then
'                LogStatus("VSGWait", "Got SLAVE Ready Pulse from VSG at " + str$(tRise));
'                Yield(1.0);
'                tLastTrigger := tFall;
'                ChangeStateTo(stateStartTrial%, tFall);
'                if RecordEyeTrackerOutputFile% = 1 then
'                    'Give pattern of four pulses - this is the initializing pattern for both the NIC EEG file and the eyetracker file
'                    SafeSampleKey("1");
'                    yield(0.2);
'                    SafeSampleKey("1");
'                    yield(0.2);
'                    SafeSampleKey("1");
'                    yield(0.2);
'                    SafeSampleKey("1");
'                    yield(0.2);
'                endif;
'            else
'                ' TODO - do this for slave also
'                if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
'                    LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
'                    tLastTrigger := tFall;
'                endif;
'            endif;
        endif

    case iState% = stateStartTrial% then
        
        'put timing marker in both eyetracker file, smr file
        if RecordEyeTrackerOutputFile% = 1 then
            'SafeSampleKey("1");
            docase
            case HBCycle% = 1 then
                SafeSampleKey("1");
            case HBCycle% = 2 then
                SafeSampleKey("2");
            case HBCycle% = 3 then
                SafeSampleKey("3");
            case HBCycle% = 4 then
                SafeSampleKey("4");
            case HBCycle% = 5 then
                SafeSampleKey("5");
            case HBCycle% = 6 then
                SafeSampleKey("6");
            case HBCycle% = 7 then
                SafeSampleKey("7");
            endcase
            HBCycle% += 1;  'increment HBCycle%
            if HBCycle% = 8 then  'and cycle when necessary
                HBCycle% := 1;
            endif
            yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
        endif;
        
        docase
        case tbtFix% = 1 then  'there is fixpt tuning in Baker's Dozen
            tbtFixX := Val(tunBDTuningValues$[trialIndex%][13]);  'trialIndex% is a zero-based index here
            tbtFixY := Val(tunBDTuningValues$[trialIndex%][14]);  'Values 13 and 14 are X and Y, respectively
        case tbtFix% = 2 then  'this is the Fixpt Jump experiment
            tbtFixX := tunFPJFixptX[trialIndex%];
            tbtFixY := tunFPJFixptY[trialIndex%];
        endcase
        

        ' Start trial. Put up fixation point.
        LogStatus("StartTrial", "Request fixpt");
        SafeSampleKey("F");
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
        
    
    case iState% = stateWaitForFixPtOn% then
        
        ' DJS 2015-02-12 Change from tLast to tStateStart.
        ' Attempting to fix bug where the on trigger for fixpt is not found.
        if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 0 then
            ' Fixation point is up
            LogStatus("WaitForFixPtOn", "Fixpt on at " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitForAcquisition%, tTrigger);
            if tbtFix% = 0 then
                DrawFix(1);	' draws the location of the constant fixpt in the Spike2 fixation display window
            else
                DrawFix(2);	' draws the location of the moving fixpt in the Spike2 fixation display window
            endif;
            
            
'        else
'           LogStatus("WaitForFixPtOn", "Waiting at " + str$(tLast));        
        endif

    case iState% = stateWaitForAcquisition% then

        ' Waiting for eye to fall inside of fixation window
        if Looking%(xEye, yEye) = 1 and Pause% = 0 then  'if looking and not paused, move forward
            if tunSendINTANPulse% = 1 then
                'set sequencer variable 11 to 3 to indicate 3-ms trial-start pulse
                SampleSeqVar(11,3);
                SafeSampleKey("T");  'Send a pulse
            endif
            if tunStimulusOnsetDelay = 0 then
                'LogStatus("WaitForAcquisition", "Eye in fixation window; request stim");
                'docase
                'case TunType$ = tunTypeBoxODonuts$ or TunType$ = tunTypeCRG$ or TunType$ = tunTypeXYPos$ then
                '    GetPlotXYCoord(nTrialsCompleted%,xval,yval,xind%,yind%);  'fill xval, yval
                '    SampleText("T," + str$(xval) + ",T2," + str$(yval));  'Just a guess at what will work
                'else
                '    SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)));
                'endcase;
                
                'SafeSampleKey("S");  'request stimulus
                'if tunType$ = tunTypeDSS$ and tunDSSCurrPeriod% = 0 then  'initialize DSS stimulus if necessary
                '    InitializeDSSTrial(tNow);
                'endif;
                'ChangeStateTo(stateWaitForStimTrigger%, tNow);
                LogStatus("WaitForAcquisition", "Eye in fixation window; checking opto status");
                ChangeStateTo(stateCheckTurnOnOpto%, tNow);
                
            else
                LogStatus("WaitForAcquisition", "Eye in fixation window; wait through onset delay");
                ChangeStateTo(stateWaitStimulusOnsetDelay%, tNow);
            endif;
        else 
            if tNow - tStateStart > tunAcquisitionTime or Pause% = 1 then  'if time is up, or pause has been called, go to abort
                ' failed to acquire target. 
                tInterTrialTime := tunAcqFailTime;
                LogStatus("WaitForAcquisition", "Failed.");
                ChangeStateTo(stateAbort%, tNow);
            endif
        endif
        
        
    case iState% = stateWaitStimulusOnsetDelay% then
        'make sure eye stays in fixation window
        if Looking%(xEye, yEye) = 1 and Pause% = 0 then
            'if it's time to start the stimulus
            if tNow - tStateStart > tunStimulusOnsetDelay then
                LogStatus("WaitStimulusOnsetDelay", "Eye in fixation window; checking opto status");
                ChangeStateTo(stateCheckTurnOnOpto%, tNow);
            endif;
        else 
            ' failed to hold fixation through onset delay, or pause is called
            tInterTrialTime := tunAcqFailTime;
            LogStatus("WaitStimulusOnsetDelay", "Failed to maintain fixation through delay.");
            ChangeStateTo(stateAbort%, tNow);
        endif
        
    case iState% = stateCheckTurnOnOpto% then
        if doTBTopto% = 1 then  'if we're doing trial-byt-trial opto, get this trial's opto state, from here, just proceed as normal
            tunOptoState% := tunTBTOpto%[trialIndex%];
        endif
        docase
        case tunDoOpto% = 0 then 'if this is not an opto trial, just start it
            ChangeStateTo(stateRequestStimulus%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tNow);
        case tunOptoUsePulse% = 1 and tunOptoState% = 0 then 'if this is a pulsed opto scenario, but not an opto trial, just start it
            'This is the same as the above step, separated to make the logic of the case statement easier
            ChangeStateTo(stateRequestStimulus%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tNow);
        case tunOptoUsePulse% = 1 and tunOptoState% = 1 then  'it is a pulsed opto trial, the sequencer will time this
            SampleSeqVar(6,tunOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens.  Failsafe this right here before going to pulsed opto.
            ChangeStateTo(statePulsedOpto%,tNow);
        case tunOptoStaysOn% = 1 and (nTrialsCompleted% mod (tunNAdvances%+1)) <> 0 then 'this is for when we're keeping the opto on and it's mid block
            ChangeStateTo(stateRequestStimulus%, tNow);
            printlog("Opto is already on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",tunOptoStaysOn%,(nTrialsCompleted% mod (tunNAdvances%+1)),tNow);
        else 'otherwise it is a wraparound opto trial and we will determine whether to turn opto on in the next state (we need to SampleKey regardless of opto state)
            ChangeStateTo(stateStartOpto%, tNow);
            printlog("Turning Opto On at time = %f\n",tNow);
        endcase
        
        
    case iState% = stateStartOpto% then
        if tunOptoState% = 1 then 'this is an opto-on trial
            SafeSampleKey("O");  'turn on opto
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("OptoOn",tOpt);
        else 'this is an opto-off trial
            SafeSampleKey("N");  'don't turn on opto
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("NoOpto",tOpt);
        endif;
        
        ChangeStateTo(stateWaitOptoPrestim%, tNow);
        
        
    case iState% = stateWaitOptoPrestim% then
        if tNow > tStateStart + tunPreStimOptoTime then
            ChangeStateTo(stateRequestStimulus%, tNow);
        endif;      
        
        
    case iState% = statePulsedOpto% then
        SafeSampleKey("P");  'start pulsed opto, the whole sequence is controlled by the sequencer, this does the "S" implicitly
        tOpt := View(DataWindow%).MaxTime();
        SampleText("T," + str$(GetPlotXCoord(trialIndex%)),tOpt);
        printlog("Started opto trial at %f\n",tOpt);
        'ChangeStateTo(stateWaitPulsedOpto%, tOpt);
        ChangeStateTo(stateWaitForStimTrigger%, tOpt);
        
        
'    case iState% = stateWaitPulsedOpto% then 'wait for sequencer-controlled timing to complete
'        if tNow > tStateStart + tunStimulusDuration + 0.1 then 'wait an extra tenth of a second just in case
'            ChangeStateTo(stateTrialCompleted%,tNow);
'            'the "X" is not necessary as the pulsed opto sequence does the stimulus-off.  But maybe somebody someday will want to SEE the "X"...can uncomment if so
'            'SafeSampleKey("X"); 
'            'Advance, this we DO have to do
'            SafeSampleKey("a");
'            nTrialsCompleted% += 1;  'trial is complete
'            SampleSeqVar(6,tunOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens on trial #2
'            printlog("Completed opto trial at %f\n",tNow);
'        endif;        
        
        
    case iState% = stateRequestStimulus% then

        ' Start trial. Put up stimulus.
        LogStatus("StartTrial", "Request stimulus");
        docase
        case TunType$ = tunTypeFixptColor$ then
            SampleText("T," + GetFixptColorThisTrial$(trialIndex%,tunValues[],tunValuesIndices%[]));
        case TunType$ = tunTypeFixptJump$ then
            SampleText("FP," + str$(tunFPJFixptX[trialIndex%]) + "," + str$(tunFPJFixptY[trialIndex%]) + ",Gr," + str$(tunFPJGratingX[trialIndex%]) + "," + str$(tunFPJGratingY[trialIndex%]) + ",Jump=" + Str$(tunFPJIsJump%));
            tunFPJIsJump% := 0;  'reset the is-jump variable, if there is a fixation break from here on out and we get back here, the "jump" is lost
        case TunType$ = tunTypePolkaDot$ then
            SampleText("T," + tunPDDotSpecsPerTrial$[trialIndex%]);
        case TunType$ = tunTypeBoxODonuts$ and TunType1$ = tunTypeFixptColor$ then
            GetPlotXYCoord(trialIndex%,xval,yval,xind%,yind%);  'fill xval, yval even though we only use yval
            SampleText("T," + GetFixptColorThisTrial$(trialIndex%,tun1Values[],tun1ValuesIndices%[]) + ",T2," + str$(yval));
        case TunType$ = tunTypeBoxODonuts$ and TunType2$ = tunTypeFixptColor$ then
            GetPlotXYCoord(trialIndex%,xval,yval,xind%,yind%);  'fill xval, yval even though we only use xval
            SampleText("T," + str$(xval) + ",T2," + GetFixptColorThisTrial$(trialIndex%,tun2Values[],tun2ValuesIndices%[]));
        case TunType$ = tunTypeBoxODonuts$ and TunType2$ = tunTypePolkaDot$ then
            GetPlotXYCoord(trialIndex%,xval,yval,xind%,yind%);  'fill xval, don't worry about yval
            SampleText("T," + str$(xval) + ",T2," + tunPDDotSpecsPerTrial$[trialIndex%]);
        case TunType$ = tunTypeBoxODonuts$ or TunType$ = tunTypeCRG$ or TunType$ = tunTypeXYPos$ or (tunType$ = tunTypeContrast$ and tunContrastDualScreenCombo% = 1) or (tunType$ = tunTypeArea$ and tunAreaDualScreenCombo% = 1) then
            GetPlotXYCoord(trialIndex%,xval,yval,xind%,yind%);  'fill xval, yval
            SampleText("T," + str$(xval) + ",T2," + str$(yval));  'Just a guess at what will work
        case TunType$ = tunTypeBakersDozen$ then  'We want to give the stimulus number
            'Creates the sampletext string for all values that are changed
            SampleTextStr$ := "";
            if tunBDImGrType%[trialIndex%] > 0 then  'create sample text for images, trialIndex% is still in "index mode" here
                SampleTextStr$ := tunBDImageList$[tunBDImageIndex%[trialIndex%]];
            else  'create sample text for gratings
                for i% := 0 to tunNumBDCurvesAllowed%-1 do
                    if tunBDWhichTunCurve[i%] = 1 then
                        SampleTextStr$ := SampleTextStr$ + tunBDTunCurveLabel$[i%] + "," + tunBDTuningValues$[trialIndex%][i%] + ",";
                        if i% = 7 or i% = 10 or i% = 13 or i% = 17 then
                            SampleTextStr$ := SampleTextStr$ + tunBDTuningValues$[trialIndex%][i%+1] + ",";
                        endif
                        if i% = 17 then
                            SampleTextStr$ := SampleTextStr$ + tunBDTuningValues$[trialIndex%][i%+2] + ",";
                        endif
                    endif
                next
                SampleTextStr$ := Left$(SampleTextStr$,Len(SampleTextStr$)-1);
            endif;
            if tunBDUseOCFile% = 1 then  'add condition label
                'SampleText("T," + str$((nTrialsCompleted% mod BDNumStim%)+1) + "," + SampleTextStr$ + ",Condition: " + tunBDConditionLabel$[trialIndex%]);
                SampleText("T," + str$(nTrialsCompleted%+1) + "," + SampleTextStr$ + ",Condition: " + tunBDConditionLabel$[trialIndex%]);  'probably should not wrap trial count?
            else 'no condition label specified
                'SampleText("T," + str$((nTrialsCompleted% mod BDNumStim%)+1) + "," + SampleTextStr$); 
                SampleText("T," + str$(nTrialsCompleted%+1) + "," + SampleTextStr$);  'probably should not wrap trial count?
            endif            
        else
            SampleText("T," + str$(GetPlotXCoord(trialIndex%)));
        endcase;
        
        'Determine how long the stimulus will be up
        docase
        case tunCRGSecsPerSeq > 0 then  'will only be non-zero is tunType$ = tunTypeCRG$
            stimulusHoldTime := tunCRGSecsPerSeq;
        case tunBDImGrType%[trialIndex%] = 0 then  'if grating, use standard time
            stimulusHoldTime := tunFixationDuration;
        else  'else it's an image, use image duration
            stimulusHoldTime := tunImageDur;
        endcase
        
         
        SafeSampleKey("S");  'request stimulus
        if tunType$ = tunTypeDSS$ and tunDSSCurrPeriod% = 0 then  'initialize DSS stimulus if necessary
            InitializeDSSTrial(tNow);
        endif; 
        ChangeStateTo(stateWaitForStimTrigger%, tNow);        
        
    case iState% = stateWaitForStimTrigger% then

        ' DJS 2015-02-16 Change from tLast to tStateStart.
        ' Attempting to fix bug where the on trigger is not found.
        if View(DataWindow%).FindRisingEdge%(StimChannel%, tStateStart, tTrigger) = 0 then
            ' Stim is up
            LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tTrigger));
            tStimOn := tTrigger;
            tStimSequence := tTrigger;      ' TODO remove tStimOn ref above - see stateWaitForStimOn
            tLastTrigger := tTrigger;
            ChangeStateTo(stateHoldFixation%, tTrigger);
            
        endif

        
   ' case iState% = stateWaitForStimOn% then
        
        ' Starting from tStimSequence, look for pulses in FrameChannel% and FrameSlaveChannel%
   '     LogStatus("WaitForStimOn", "NOT IMPLEMENTED!");
        
    case iState% = stateAbort% then

        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        docase
        case tunOptoUsePulse% = 1 and tunOptoState% = 1 then  'it is a pulsed opto trial
            'on a pulsed opto abort, we need to turn off the laser and break out of the opto loop
            SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
            SafeSampleKey("X");  'just turn off stimulus, follow up to get fixation channel down
        case tunDoOpto% = 1 and tunOptoUsePulse% = 0 then  'any other opto trial, kill opto on abort
            if tunOptoState% = 1 then
                SafeSampleKey("o");  'turn it off
                tOpt := View(DataWindow%).MaxTime();
                'printlog("OptoOff at %f\n",tOpt);
                SampleText("OptoOff",tOpt);
            else
                SafeSampleKey("n");  'turn it off
                tOpt := View(DataWindow%).MaxTime();
                'printlog("OptoOff at %f\n",tOpt);
                SampleText("NoOptoSoNoOff",tOpt);
            endif;
            SafeSampleKey("X");  'just turn off stimulus
        else
            SafeSampleKey("X");  'just turn off stimulus
        endcase;
        if Pause% = 1 then
            ChangeStateTo(statePause%, tNow);
        else            
            ChangeStateTo(stateWaitForBlank%, tNow);
        endif;
        

    case iState% = stateWaitForBlank% then

        ' we just wait for fix point off signal in this case. 
        ' DJS 2015-02-16 Change from tLast to tStateStart.
        ' Attempting to fix bug where the on trigger for fixpt/stim/off is not found.

        if View(DataWindow%).FindFallingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 1 then
            ' Fixation point is off
            tLastTrigger := tTrigger;
            ChangeStateTo(stateInterTrialInterval%, tTrigger);
            DrawFix(0);	' this erases the fixpt in the spike2 fixation display
        endif

    case iState% = stateInterTrialInterval% then
        
        docase
        case tNow - tStateStart > tInterTrialTime and Pause% = 0 then
            ChangeStateTo(stateStartTrial%, tNow);
        case Pause% = 1 then
            ChangeStateTo(statePause%, tNow);
        endcase
        
        
    case iState% = stateInterTrialIntervalFixAlreadyUp% then
        
        if Looking%(xEye, yEye) = 0 or Pause% = 1 then  'if not looking or pause is called, go to abort
            
            LogStatus("InterTrialIntervalFixAlreadyUp", "Fixation broken, aborting trial.");
            tInterTrialTime := tunHoldFailTime;
            SampleText("-");
            ChangeStateTo(stateAbort%, tNow);
        else
            'if tNow - tStateStart > tunMaintainITI then  'now can have different times to create "image series"
            if tNow - tStateStart > tunStdInterTrialTime then
                '            SafeSampleKey("S");  'request stimulus
                '            ChangeStateTo(stateWaitForStimTrigger%, tNow);
                
                'put timing marker in both eyetracker file, smr file
                'if RecordEyeTrackerOutputFile% = 1 then
                '    SafeSampleKey("1");
                '    yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
                'endif;
                
                'put timing marker in both eyetracker file, smr file
                if RecordEyeTrackerOutputFile% = 1 then
                    'SafeSampleKey("1");
                    docase
                    case HBCycle% = 1 then
                        SafeSampleKey("1");
                    case HBCycle% = 2 then
                        SafeSampleKey("2");
                    case HBCycle% = 3 then
                        SafeSampleKey("3");
                    case HBCycle% = 4 then
                        SafeSampleKey("4");
                    case HBCycle% = 5 then
                        SafeSampleKey("5");
                    case HBCycle% = 6 then
                        SafeSampleKey("6");
                    case HBCycle% = 7 then
                        SafeSampleKey("7");
                    endcase
                    HBCycle% += 1;  'increment HBCycle%
                    if HBCycle% = 8 then  'and cycle when necessary
                        HBCycle% := 1;
                    endif
                    yield(0.01);  'this will likely be positioned very close to the "F" below, so give a tiny bit of time, 10 ms should be enough
                endif;
                
                'going to stateWaitForAcqusition allows opto to happen
                ChangeStateTo(stateWaitForAcquisition%, tNow-tunAcquisitionTime);  'do not allow acquisition window, if animal is not fixating during maintain, this is an abort
            endif    
        endif

    case iState% = stateHoldFixation% then

        if Looking%(xEye, yEye) = 0 or Pause% = 1 then  'if fixation broken or pause is called, abort
            
            LogStatus("WaitForFixation", "Fixation broken, aborting trial.");
            tInterTrialTime := tunHoldFailTime;
            SampleText("-");
            ChangeStateTo(stateAbort%, tNow);

        else 
            'Now calculating stimulusHoldTime for each trial above
            if tNow - tStateStart > stimulusHoldTime + tKludge then
            'tunCRGSecsPerSeq will be 0 unless there is a CRG; tunFixationDuration will be 0 if both screens are CRG
            'if tNow - tStateStart > tunFixationDuration + tKludge and tNow - tStateStart > tunCRGSecsPerSeq + tKludge then  

                ' turn off stimulus and advance it
                SampleText("+");
                LogStatus("HoldFixation", "Turn off and advance stimulus.");
                
                ' djs If NoMaintain was chosen, then turn EVERYTHING off (stim and fixpt) now.
                ' Otherwise just turn off stim.
                docase    
                case tunUseMaintainMode% = 1 or tunUseMaintainMode% = 2 then
                    SafeSampleKey("s");  'Turn off donut, also turn off core on danish
                case tunUseMaintainMode% >= 3 then
                    SafeSampleKey("v");  'Toggle donut only, will leave core on danish 
                else  'tunUseMaintainMode% is 0
                    SafeSampleKey("X");  'Turn off all
                    DrawFix(0);	' this erases the fixpt in the spike2 fixation display
                endcase;
                
                Yield();
                
                if tunSendINTANPulse% = 1 then  'if using the INTAN system, our reward is a bit more complicated
                    'set sequencer variable 11 to 6 to indicate 6-ms trial-success pulse
                    SampleSeqVar(11,6);
                    SafeSampleKey("T");  'Send a pulse
                endif
                
                ' Note that reward is to be given
                if tunBDImGrType%[trialIndex%] <> 1 then 'give reward for grating and terminal images
                    giveReward% := 1;
                else
                    giveReward% := 0;  'do not give reward for non-terminal images in an image series
                endif;
                
                ' Process Spikes
                if tunDoTuningHist% = 1 then
                    docase
                    case TunType$ = tunTypeBoxODonuts$ then
                        GetPlotXYCoord(trialIndex%,xval,yval,xind%,yind%);  'fill xval, yval
                        PlotSpikes2TunCurves(tStimOn, tNow, 1, xval, yind%);
                    case TunType$ = tunTypeCRG$ then
                        GetPlotXYCoord(trialIndex%,xval,yval,xind%,yind%);  'fill xval, yval
                        PlotSpikes(tStimOn, tNow, 1, yval, trialIndex%);  'yes, yval
                    case TunType$ = tunTypeXYPos$ then
                        GetPlotXYCoord(trialIndex%,xval,yval,xind%,yind%);  'fill xval, yval
                        PlotDots(tStimOn, tNow, xind%, yind%); 
                    else
                        'PlotSpikes(tStimOn, tNow, 1, GetPlotXCoord(trialIndex%), trialIndex%);
                        PlotSpikesAverage(tStimOn, tNow, 1, GetPlotXCoord(trialIndex%), trialIndex%, GetPlotXInd%(trialIndex%), tunNAdvances%);
                    endcase; 
                endif;
                

                ' Now wait until stim is off
                if tunType$ = tunTypeDSS$ then
                    ChangeStateTo(stateWaitForStimOffDSS%, tNow);  'must look at Fixation channel in this case
                else
                    ChangeStateTo(stateWaitForStimOff%, tNow);
                endif;
                
                
            else  'if fixation is maintained, and the stimulus is not over, and we are doing dynamic surround suppression...
                if tunType$ = tunTypeDSS$ and tNow > tunNextDSSTime then 'if it's time to do something
                    if tunDSSIsOn% = 1 then
                        'SafeSampleKey("s");  'turn donut off
                        SafeSampleKey("v");  'toggle donut off
                        tunDSSIsOn% := 0;  'reset
                        
                        'determine if it is time for a reward
                        'This will give reward after first, and every nth flash, (for last flash, reward will come when stimulus is turned off)
                        'if tunDSSFlashesUntilReward% = 0 or tunDSSCurrPeriod% = tunDSSNPeriods% then
                        if tunDSSFlashesUntilReward% = 0 then    
                            DefaultReward();
                            nTrialsRewarded% += 1;
                            tunDSSFlashesUntilReward% := tunDSSNFlashesPerReward%-1;  'reset flashes count
                        else
                            tunDSSFlashesUntilReward% := tunDSSFlashesUntilReward% - 1;  'decrement flashes count
                        endif;
                        
                        'determine time of next change
                        tunNextDSSTime := tNow + tunDSSDuration; 'when we turn back on
                        tunDSSCurrPeriod% += 1;  'increment current period
                        'if there are any blanks, add more duration
                        while tunDSSFlashOrBlank%[tunDSSCurrPeriod%] = 0  and tunDSSCurrPeriod% < tunDSSNPeriods% do  '0 is blank
                            tunNextDSSTime := tunNextDSSTime + tunDSSDuration + tunDSSDuration;
                            tunDSSCurrPeriod% += 1;  'increment current period
                        wend

                    else 'if donut is currently off
                        if tunDSSCurrPeriod% = tunDSSNPeriods% then
                            'tunFixationDuration := 0;  'Allow trial to finish
                            stimulusHoldTime := 0;  'Allow trial to finish
                            tunDSSCurrPeriod% := 0;  'Allow next trial to initialize
                        else 
                            'SafeSampleKey("S");  'turn donut on
                            SafeSampleKey("v");  'toggle donut on
                            tunDSSIsOn% := 1;  'reset
                            tunNextDSSTime := tNow + tunDSSDuration;
                        endif
                    endif                    
                    
                    
                endif
                
                
            endif

        endif

    case iState% = stateWaitForStimOff% then

        if tunOptoUsePulse% = 1 and tunOptoState% = 1 then  'it is a pulsed opto trial 
            if View(DataWindow%).FindFallingEdge%(StimChannel%, tLastTrigger, tTrigger) = 1 then  'needs to be tLastTrigger if pulsing opto
                ' Advance
                SafeSampleKey("a");
                
                tLastTrigger := tTrigger;
                tStimulusDown := tTrigger;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            else
                if tunType$ = tunTypeDanish$ and tunUseMaintainMode% >= 3 and View(DataWindow%).FindRisingEdge%(FrameChannel%, tLast, tTrigger) then
                    ' Advance, in specific case that we are doing danishes and maintaining the core - there will not be a falling edge on the stim channel in this case
                    SafeSampleKey("a");
                    
                    tLastTrigger := tTrigger;
                    ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                endif
            endif
        else
            if View(DataWindow%).FindFallingEdge%(StimChannel%, tLast, tTrigger) = 1 then
                tLastTrigger := tTrigger;
                tStimulusDown := tTrigger;
                
                if tunType$ = tunTypeFixptJump$ then
                    'For a Fixpt Jump experiment, we need to determine if we will do a jump or not
                    if tunFPJProbSaccade > rand() then 'do jump, increment nTrialsCompleted%
                        nTrialsCompleted% += 1;
                        trialIndex% := (nTrialsCompleted% mod (tunNAdvances%+1));  'index to trial-by-trial opto and conditions, need to do mod operation for RepeatForever to keep working right past the first pass  
                        tunFPJIsJump% := 1;
                        'but do not advance yet, because that will move the fixpt
                    else 'don't jump
                        'Do nothing
                    endif
                    ChangeStateTo(stateTrialCompleted%, tNow);  'There is no opto and nTrialsCompleted% is right, can skip to stateTrialCompleted%
                else  'for a "standard" experiment, advance and go to stateCheckTurnOffOpto, which will increment nTrialsCompleted%
                    ' Advance
                    SafeSampleKey("a");
                    ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                endif
                
                
            else
                if tunType$ = tunTypeDanish$ and tunUseMaintainMode% >= 3 and View(DataWindow%).FindRisingEdge%(FrameChannel%, tLast, tTrigger) then
                    ' Advance, in specific case that we are doing danishes and maintaining the core - there will not be a falling edge on the stim channel in this case
                    SafeSampleKey("a");
                    
                    tLastTrigger := tTrigger;
                    ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                endif
            endif
        endif
        
    case iState% = stateWaitForStimOffDSS% then
        
        ' djs 2-16-2015 Modified to use tStateStart instead of tLast, hoping this will fix bug where 
        ' certain signals from vsg not being picked up by this script. 
        if View(DataWindow%).FindFallingEdge%(FixationPointChannel%, tStateStart, tTrigger) = 1 then
            ' Advance
            SafeSampleKey("a");

            tLastTrigger := tTrigger;
            ChangeStateTo(stateCheckTurnOffOpto%, tNow);
        endif   
        
        
    case iState% = stateCheckTurnOffOpto% then
        nTrialsCompleted% += 1;  'trial is complete, change of count here makes logic easier
        trialIndex% := (nTrialsCompleted% mod (tunNAdvances%+1));  'index to trial-by-trial opto and conditions, need to do mod operation for RepeatForever to keep working right past the first pass        
        docase
        case tunDoOpto% = 0 or (tunOptoState% = 0 and tunOptoUsePulse% = 1) then 'if this is not an opto trial, trial is complete
            ChangeStateTo(stateTrialCompleted%, tStateStart);
            printlog("Trial complete, Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tStateStart);
        case tunOptoStaysOn% = 1 and (nTrialsCompleted% mod (tunNAdvances%+1)) <> 0 then 'this is for when we're keeping the opto on and it's mid block
            ChangeStateTo(stateTrialCompleted%, tStateStart);
            printlog("Opto is staying on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",tunOptoStaysOn%,(nTrialsCompleted% mod (tunNAdvances%+1)),tStateStart);
        case tunOptoUsePulse% = 1 and tunOptoState% = 1 then  'it is a pulsed opto trial
            printlog("Trial complete, Pulsed opto trial, time = %f\n",tStateStart);
            ChangeStateTo(stateTrialCompleted%, tStateStart);
            SampleSeqVar(6,tunOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
        else 'otherwise it is an opto trial and we need to turn opto off (or a wraparound opto, we need to wait through poststim)
            ChangeStateTo(stateWaitOptoPoststim%, tStateStart);
            printlog("Turning Opto Off at time = %f\n",tStateStart);
        endcase
        
        
        
    case iState% = stateWaitOptoPoststim% then
        if tNow > tStateStart + tunPostStimOptoTime then
            ChangeStateTo(stateTurnOffOpto%, tNow);
        endif;
        
        
    case iState% = stateTurnOffOpto% then
        if tunOptoState% = 1 then
            SafeSampleKey("o");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOff at %f\n",tOpt);
            SampleText("OptoOff",tOpt);
        else
            SafeSampleKey("n");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOff at %f\n",tOpt);
            SampleText("NoOptoSoNoOff",tOpt);
        endif;
        
        ChangeStateTo(stateTrialCompleted%,tNow); 
        
        

    case iState% = stateTrialCompleted% then
        
        'nTrialsCompleted% += 1;  'now done above in stateCheckTurnOffOpto% (or in stateWaitForStimOff% if we are doing fixpt jump
        printlog("number of trials completed is %d\n",nTrialsCompleted%);
		ToolbarText(str$(nTrialsCompleted%) + "/" + str$(tunNValues%) + " trials completed."); 
        
        ' Reward
        if giveReward% = 1 then
            DefaultReward();
            nTrialsRewarded% += 1;
            giveReward% := 0;
        endif
        
        ' Check for end of stimuli, if we're done just get out
        if nTrialsCompleted% >= tunNValues% and not(tunRepeatForever% = 1 and tunType$ = tunTypeBakersDozen$) then  'right now tunRepeatForever is only available on Baker's Dozen (Henry will ask for more, I know it)
            ChangeStateTo(stateDone%, tNow);  'stateDone% doesn't really happen because we just go to Stop()%
            Stop%();
            iStatus% := 0;
        endif
    
        ' Check for change in condition if we are pausing on condition change, note nTrialsCompleted has been incremented
        if nTrialsCompleted% > 0 and (nTrialsCompleted% mod (tunNAdvances%+1)) = 0 then
            tempNTC1% := tunNAdvances%;
            tempNTC2% := 0;
        else
            tempNTC1% := trialIndex%-1;
            tempNTC2% := trialIndex%;
        endif;
        if tunPauseOnConditionChange% = 1 and tunBDConditionLabel$[tempNTC1%] <> tunBDConditionLabel$[tempNTC2%] then
            Pause% := 1;
            message("Pause called because condition is changing from " + tunBDConditionLabel$[tempNTC1%] + " to " + tunBDConditionLabel$[tempNTC2%] + ", press 'resume' to continue");
        endif
        
        ' Check to see if we need to toggle opto at the end of a block, if not determine where to go next
        if nTrialsCompleted% > 0 and (nTrialsCompleted% mod (tunNAdvances%+1)) = 0 and not(tunRepeatForever% = 1 and tunType$ = tunTypeBakersDozen$) then 'toggle tunOptoState at the end of a block, use interblock time
            if tunDoOpto% = 1 and dontToggleOpto% = 0 and doTBTopto% = 0 then
                tunOptoState% := 1-tunOptoState%;  'but only toggle if we're actually doing opto, and we haven't been told to not toggle opto, and we're not doing trial-by-trial
            endif;
            if tunUseMaintainMode% >= 1 then
            SafeSampleKey("X");  'turn everything off, fixation wasn't turned off previously because of maintain mode
            DrawFix(0);
            endif;
            if tunDoOpto% = 1 and doTBTopto% = 0 then
                tInterTrialTime := tunStdInterTrialTime + tunInterBlockTime;
            else
                tInterTrialTime := tunStdInterTrialTime;
            endif;
            'Go to intertrial interval - through pause if one has been called, or go to WaitForBlank if in MaintainMode
            docase
            case tunUseMaintainMode% >= 1 then
                ChangeStateTo(stateWaitForBlank%, tNow);  'Need to wait for blank here, fixation wasn't turned off previously because of maintain mode
            case Pause% = 1 then
                ChangeStateTo(statePause%, tNow);
            else
                ChangeStateTo(stateInterTrialInterval%, tNow);  'at end of block, we do not maintain fixation, it will start again for next time
            endcase;
        else
            docase
            case Pause% = 1 then
                ChangeStateTo(statePause%, tNow);
            case tunFPJIsJump% = 1 then  'can only get here in fixpt jump experiment
                ChangeStateTo(stateJumpFixpt%, tStimulusDown);  'start "counting" at the time the stimulus went down
            case tunType$ = tunTypeFixptJump$ then
                ChangeStateTo(stateMaintainFixation%, tStimulusDown);  'maintain fixation, but start "counting" at the time the stimulus went down
            case tunUseMaintainMode% >= 1 then
                if tunBDImGrType%[tempNTC1%] <> 1 then 'if the previous stimulus was either a grating or a terminal image, use standard ITI
                    'tunMaintainITI := tunStdInterTrialTime;
                    tunMaintainITI := tunMaintainFixation;
                else
                    tunMaintainITI := tunImageDelay;  'if the previous stimulus was a non-terminal image, use alternate (short) ITI to create "image series"
                endif;
                ChangeStateTo(stateMaintainFixation%, tNow);
            else
                tInterTrialTime := tunStdInterTrialTime;
                ChangeStateTo(stateInterTrialInterval%, tNow);
            endcase
        endif
        
        
    case iState% = stateJumpFixpt% then
        docase
        case tNow > tStateStart + tunFPJtFixptMove and Pause% = 0 then  'wait until time fixpt is supposed to move - but don't go forward if pause called
            SafeSampleKey("a");  'Advance the stimulus/fixation point, will move fixpt immediately - not gonna check a trigger line on this one
            tbtFixX := tunFPJFixptX[trialIndex%];
            tbtFixY := tunFPJFixptY[trialIndex%];
            DrawFix(2);  'update fixation point location on CED screen
            ChangeStateTo(stateWaitForJumpAcquisition%, tStimulusDown);  'should we use tNow (and then a standard acquisition window) or tStimulusDown (and give until next grating woudl appear)?
        case Looking%(xEye, yEye) = 0 or Pause% = 1 then  'fixation was not maintained prior to the jump, or pause was called
            nTrialsCompleted% -= 1;  'Decrement, was incremented in wait for stim off but jump was not completed, keep fixpt where it was
            trialIndex% -= 1;  'Also decrement
            tunFPJIsJump% := 0;  'Reset jump variable, this is no longer a legit jump because the fixpt will come down
            tInterTrialTime := tunMaintainFailTime;
    
            LogStatus("JumpFixpt", "Fixation broken before fixpt jump; aborting trial");
            ChangeStateTo(stateAbort%, tNow);
        endcase;
        
        
    case iState% = stateWaitForJumpAcquisition% then    
        docase
        case Looking%(xEye, yEye) = 1 and Pause% = 0 then  'acquired new fixation point, don't move forward if pause is called
            LogStatus("WaitForJumpAcquisition", "Acquired fixation point in new position, trial continues");
            ChangeStateTo(stateMaintainFixation%, tStimulusDown);
        case tNow > tStateStart + tunMaintainITI or Pause% = 1 then  'failure to acquire fixation point, abort! will also take this route if pause is called
            tunFPJIsJump% := 0;  'Reset jump variable, this is no longer a legit jump because the fixpt will come down
            tInterTrialTime := tunMaintainFailTime;
    
            LogStatus("WaitForJumpAcquisition", "Failure to acquire new fixation after fixpt jump; aborting trial");
            ChangeStateTo(stateAbort%, tNow);
        endcase
        
        
    case iState% = stateMaintainFixation% then

        if Looking%(xEye, yEye) = 0 or Pause% = 1 then  'if not looking or pause is called, go to abort
            tunFPJIsJump% := 0;  'Reset jump variable, this is no longer a legit jump because the fixpt will come down (only relevant in fixpt jump experiment)
            tInterTrialTime := tunMaintainFailTime;
    
            LogStatus("MaintainFixation", "Broken; aborting trial");
            ChangeStateTo(stateAbort%, tNow);

        else 
            if tNow - tStateStart > tunMaintainITI then

                LogStatus("MaintainFixation", "success");
                
                if (tunUseMaintainMode% = 2 or tunUseMaintainMode% = 4) and tunBDImGrType%[tempNTC1%] <> 1 then  'Only give juice if requested in original dialog; Give maintain-reward for gratings and terminal images, but not intermediate images in an image series
                    if tunSendINTANPulse% = 1 then  'if using the INTAN system, our reward is a bit more complicated
                        'set sequencer variable 11 to 8 to indicate 8-ms pre-secondary-reward pulse
                        SampleSeqVar(11,8);
                        SafeSampleKey("T");  'Send a pulse
                    endif
                    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
                        DeliverReward();
                    else
                        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
                            DeliverRewardNumber();
                        endif;
                    endif;
                endif;    
                
                docase
                case tunType$ = tunTypeFixptJump$ then
                    ChangeStateTo(stateRequestStimulus%,tNow);  'in Fixpt Jump expt, on successful Jump Acquisition OR successful Maintain Fixation go straight to stim request, there's no need to acquire and no opto anyway.
                case (tunUseMaintainMode% = 2 or tunUseMaintainMode% = 4) and tunBDImGrType%[tempNTC1%] <> 1 then  'this will allow a "break" after giving a reward, uses intertrial interval
                    ChangeStateTo(stateInterTrialIntervalFixAlreadyUp%, tNow);                
                else  'if no reward, try going to acquisition step first, this allows opto to happen, also penalizes for fixation break after second reward
                    ChangeStateTo(stateWaitForAcquisition%, tNow-tunAcquisitionTime);  'do not allow acquisition window, if animal is not fixating during maintain, this is an abort
                endcase;
                

            endif 
        endif
        
    case iState% = statePause% then
        'Wait in statePause% until the "resume" button is pressed
        if Pause% = 1 then
            ToolbarEnable(4,0);  'Disable pause
            ToolbarEnable(5,1);  'Enable resume
            Pause% := -5;  'whatever, we'll stay in here until Resume is pressed
        endif;
        if Pause% = 0 then
            ChangeStateTo(stateInterTrialInterval%,tNow);
            LogStatus("Pause", "Resume Stimuli");
        endif
 
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        
        'If the eyetracker is recording an output file, stop recording and close the file
        if RecordEyeTrackerOutputFile% = 1 then
            SafeSampleKey("w");  'Stop recording
            yield(0.1);
            SafeSampleKey("i");  'Close the file
            SafeSampleKey("Z");  'zero the DIGLOWs
        endif
        
        halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
    if UseTwo1401s% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    '	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
    ToolbarSet(6,"Select Wavemarks",SelectWavemarkDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);  'Pause was at one point disabled entirely, I am re-enabling it
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
    'Updated to include ability to have a fixation point that moves on every trial
    var localX, localY;
    if tunAlwaysLooking% = 1 then 
        return 1; 
    endif;
    
    if tbtFix% = 0 then  'Constant fixation point at the CONFIG defined location
        localX := FixationX;
        localY := FixationY;
    else 'Trial-by-trial changes in fixation point location
        localX := tbtFixX;
        localY := tbtFixY;
    endif
    
	if (Pow(EyePosX-localX,2) + Pow(EyePosY-localY,2)) <= Pow(WindowRadius,2) then 
        return 1; 
    else 
        return 0; 
    endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()  'note that this function is only used for Toolbar-based juice delivery
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverReward();
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNumber();
        endif;
    endif;
    return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



func GetPlotXCoord(nTrials%)  
    return tunValues[tunValuesIndices%[nTrials%]];
end;

func GetPlotXInd%(nTrials%)  
    return tunValuesIndices%[nTrials%];
end;

func GetPlotXYCoord(nTrials%,&xval,&yval,&xind%,&yind%)  'new for Box O' Donuts
    xval := tun1Values[tun1ValuesIndices%[nTrials%]];
    yval := tun2Values[tun2ValuesIndices%[nTrials%]];
    xind% := tun1ValuesIndices%[nTrials%];  'at time of writing, xind is not used (may as well put it in)
    yind% := tun2ValuesIndices%[nTrials%];  'but yind is used in PlotSpikes2TunCurves
end;

func GetFixptColorThisTrial$(nTrials%,tValues[],tValuesIndices%[])  'This function is written assuming integer gun values, should be easy enough to adapt for 0-1 gun values if necessary
    'In order to use this function to get fixpt colors in both regular and Box'O'Donuts version, we have to pass the proper tunValues/tunValuesIndices%[]
    var val%;
    var f$;
    val% := tValues[tValuesIndices%[nTrials%]];
    docase
    case tunFPCGunIndex% = 0 then  'if tuned gun is red
        f$ := "(" + Str$(val%) + "/" + Str$(tunFPCGreenValue%) + "/" + Str$(tunFPCBlueValue%) + ")";
    case tunFPCGunIndex% = 1 then  'if tuned gun is green
        f$ := "(" + Str$(tunFPCRedValue%) + "/" + Str$(val%) + "/" + Str$(tunFPCBlueValue%) + ")";
    case tunFPCGunIndex% = 2 then  'if tuned gun is blue
        f$ := "(" + Str$(tunFPCRedValue%) + "/" + Str$(tunFPCGreenValue%) + "/" + Str$(val%) + ")";
    case tunFPCGunIndex% = 3 then  'if tuning is on luminance
        f$ := "(" + Str$(val%) + "/" + Str$(val%) + "/" + Str$(val%) + ")";
    endcase
    return f$;
end;


proc PlotDots(t1,t2,xind%,yind%)
    var rate;
    var count% := 1;
    var i%;
    var j%;
    var k%;
    var ind%;
    var maxdot;
    var temp[200];  'this holds the average
    'get index to which channel is current
    ind% := yind% + (xind%*(tunXYPosNYSteps%+1));
    'for i% := 0 to tunNWavemarks%-1 do ...for now I want this to work for one electrode before trying to do multiples
    rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
    printlog("Current rate is %f\n",rate);
    XYSpikeRate[ind%] += rate;  'add in the current rate
    XYDataCount%[ind%] += 1;   'increment the counter
    'now determine the dot size - make 0 = 0, make biggest dot = 50
    ArrConst(temp[],XYSpikeRate[]);  'fill temp with "rate"
    ArrDiv(temp[],XYDataCount%[]);   'divide by number of trials at each point to get actual rate, divide by zero should be OK and just give no change (so still 0)
    maxdot := temp[Max(temp)];  'get value of maximum rate
    if maxdot > 0 then
        ArrConst(XYDotSize%[],temp[]);  'put actual rate into dot size variable 
        ArrMul(XYDotSize%,50/maxdot);   'multiply by factor to make max rate = 50
        printlog("Dotsize is %f\n",XYDotSize%);
        for j% := 0 to tunXYPosNXSteps% do
            for k% := 0 to tunXYPosNYSteps% do
               ' View(TuningWindow%[i%]).XYDrawMode(count%+1,2,XYDotSize%[count%-1]);  'set size of dots to proper size, I'm not sure why channel has to be count+1...?
                count% += 1;
            next;
        next;
    endif;

    'end;
end;


proc PlotSpikes(t1, t2, vOnOff%, x, index%)
	var rate;
    var i%;
    var tSweep;
    var fftData[16];        ' size of this array should be same as number of bins!
    
 '   x := tunValues[tunValuesIndices%[nTrials%]];
 '   ind% := tunValuesIndices%[nTrials%];
    
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				View(TuningWindow%[i%]).XYAddData(plotF0Ch%, x, rate);    ' channel 1 is data; channel 2 is background
			endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
        
        if tunDoF12% = 1 and vOnOff% = 1 then
            ' Process for each cycle of the stimulus. A single cycle of the stim takes 1/tf
			View(PSTHWindow%[i%]);
			Process(t1, t2, 1, 1);
			for tSweep := t1+1/tunTF to t2-1/tunTF step 1/tunTF do 
				Process(tSweep, tSweep+1/tunTF, 0, 1);
			next
			ArrConst(fftData[], View(PSTHWindow%[i%]).[]);
			ArrFFT(fftData[], 4); 
            tunF1Sum[i%][index%] += fftData[1];  'store sum of F1/F2
            tunF2Sum[i%][index%] += fftData[2];
            View(TuningWindow%[i%]).XYAddData(plotF1Ch%, x, fftData[1]);  'this is adding the actual value to the plot
            'View(TuningWindow%[i%]).XYAddData(plotF2Ch%, x, fftData[2]);  'Henry requested turning F2 off
            
        endif
        
	next
end;

proc PlotSpikesAverage(t1, t2, vOnOff%, x, index%, index2%, nAdvances%)
	var rate;
    var i%;
    var j%;
    var tSweep;
    var fftData[16];        ' size of this array should be same as number of bins!
    
 '   x := tunValues[tunValuesIndices%[nTrials%]];
 '   ind% := tunValuesIndices%[nTrials%];
    
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				View(TuningWindow%[i%]).XYAddData(plotF0Ch%, x, rate);    ' channel 1 is data; channel 2 is background
			endif
            tunF0ActualSum[i%][index2%] += rate;  'store sum of rate
            tunF0Count%[i%][index2%] += 1;  'increment count
            View(TuningWindow%[i%]).XYDelete(plotF0MeanCh%);
            for j% := 0 to nAdvances% do
                if tunF0Count%[i%][j%] > 0 then  'don't try to do this before there is any data for a particular point
                    View(TuningWindow%[i%]).XYAddData(plotF0MeanCh%, tunValues[j%], tunF0ActualSum[i%][j%]/tunF0Count%[i%][j%]);  'this is adding the average value
                endif
            next;
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
        
        if tunDoF12% = 1 and vOnOff% = 1 then
            ' Process for each cycle of the stimulus. A single cycle of the stim takes 1/tf
			View(PSTHWindow%[i%]);
			Process(t1, t2, 1, 1);
			for tSweep := t1+1/tunTF to t2-1/tunTF step 1/tunTF do 
				Process(tSweep, tSweep+1/tunTF, 0, 1);
			next
			ArrConst(fftData[], View(PSTHWindow%[i%]).[]);
			ArrFFT(fftData[], 4); 
            'add actual value to plot
            View(TuningWindow%[i%]).XYAddData(plotF1Ch%, x, fftData[1]);  'this is adding the actual value to the plot
            'View(TuningWindow%[i%]).XYAddData(plotF2Ch%, x, fftData[2]);  'Henry requested turning F2 off
            tunF1Sum[i%][index%] += fftData[1];  'store value of F1/F2
            tunF2Sum[i%][index%] += fftData[2];
            tunF1ActualSum[i%][index2%] += fftData[1];  'store sum of F1/F2
            tunF2ActualSum[i%][index2%] += fftData[2];
            tunF1Count%[i%][index2%] += 1;  'increment count
            tunF2Count%[i%][index2%] += 1;
            View(TuningWindow%[i%]).XYDelete(plotF1MeanCh%);
            'View(TuningWindow%[i%]).XYDelete(plotF2MeanCh%);  'use for F2, currently disabled
            for j% := 0 to nAdvances% do
                if tunF1Count%[i%][j%] > 0 then  'don't try to do this before there is any data for a particular point
                    View(TuningWindow%[i%]).XYAddData(plotF1MeanCh%, tunValues[j%], tunF1ActualSum[i%][j%]/tunF1Count%[i%][j%]);  'this is adding the average value, but we need to make the other values "disappear"
                    'View(TuningWindow%[i%]).XYAddData(plotF2MeanCh%, tunValues[j%], tunF2ActualSum[i%][j%]/tunF2Count%[i%][j%]);  'this would be the average F2 if we turned it on
                endif
            next;
            
        endif
        
	next
end;


proc PlotSpikes2TunCurves(t1, t2, vOnOff%, x, yind%)
	var rate;
    var i%;
        
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then  'This apparently allows us to not update if we call the update function...weird...no matter, as it's hard coded to 1 in the call.
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				View(TuningWindow%[i%]).XYAddData(yind%+1, x, rate);    'will plot different-colored "lines" based on yind% (I hope), must add 1 to yind% because first chan in XYplot is 1, not 0
			endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
	next
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
    Pause% :=1;
    ToolbarEnable(4,0);
    ToolbarEnable(5,1);
    printlog("Stimulus pause requested at %f\n",tNow);
    return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
    Pause% :=0;
    ToolbarEnable(4,1);
    ToolbarEnable(5,0);
    printlog("Stimulus resume requested at %f\n",tNow);
    return 1;
end





proc InitializeWindows()
    var i%;
    var WindowStep;
    'var ch1%, ch2%;
    
    ' Get tf of stim
    tunTF := GetStimulusTF();

	'Open the data sampling window
    DataWindow% := FileNew(0,4);
    if DataWindow% < 0 then
        PrintLog("FileNew Error: %s\n", Error$(DataWindow%));
    endif

	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
    
    'Inelegant hack - can't really do tuning histograms for DSS (no tuning), but don't want to interfere with dialog
    'Can't really do tuning for Polka Dots either, three parameters varying, and we can't easily refer back to see what they were
    if tunType$ = tunTypeDSS$ or tunType$ = tunTypePolkaDot$ then
        tunDoTuningHist% := 0;
    endif
    
    
	' open xy window to display tuning results
    if tunDoTuningHist% = 1 then
        if tunNWavemarks% > 0 then
            WindowStep := 100/tunNWavemarks%;
        endif
        for i% := 0 to tunNWavemarks%-1 do
            TuningWindow%[i%] := FileNew(12);
            Window(50, i%*WindowStep, 100, (i%+1)*WindowStep);
            ChanTitle$(0, "Spikes/s");
            TuningCurveLabels(tunWavemarkPorts%[i%]);
            plotF0MeanCh% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f0 mean
            'XYColour(plotF0MeanCh%,17);  'don't change color
            XYDrawMode(plotF0MeanCh%,1,4);  'use circles for F0
            XYDrawMode(plotF0MeanCh%,2,15);  'make them bigger
            WindowVisible(1);
            
            ' Create psth window if f1 and f2 analysis needed
            if tunDoF12% = 1 then
                
                plotF1Ch% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1
                XYColour(plotF1Ch%,25);
                plotF2Ch% := View(TuningWindow%[i%]).XYSetChan(0);   ' used to plot f2
                XYColour(plotF2Ch%,30);
                plotF1MeanCh% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1 mean
                XYColour(plotF1MeanCh%,25);
                XYDrawMode(plotF1MeanCh%,1,6);  'use diamonds for F1
                XYDrawMode(plotF1MeanCh%,2,15);  'make them bigger
                XYJoin(plotF1MeanCh%,1);  'and connect the F1 lines
                plotF2MeanCh% := View(TuningWindow%[i%]).XYSetChan(0);   ' used to plot f2 mean
                XYColour(plotF2MeanCh%,30);
                XYDrawMode(plotF2MeanCh%,1,5);  'use triangles for F2
                XYDrawMode(plotF2MeanCh%,2,15);  'make them bigger
                LogStatus("InitializeWindows", "Channel " + str$(i%+1) + " " + str$(plotF1Ch%) + " " + str$(plotF2Ch%));
                PSTHWindow%[i%] := View(DataWindow%).SetPSTH(i%+1, 16, 1 /(tunTF*16), 0, 0, 3);  'So it seems like this should cause issues because it assumes that WaveMark channels go from 1 to N, and they don't necessarily.  But so far, it's OK?
                View(PSTHWindow%[i%]).WindowVisible(0);
            endif        
        next
    endif;
    

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
    iEyePosChannel% := 1;  'We are defining the first channel (automatically created) as the eye position channel
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);
	XYSize(1,-1);


	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iFixptWindowChannel% := XYSetChan(0);
	XYColour(iFixptWindowChannel%,13);  'was "2" instead of iFixptWindowChannel%, etc.
	XYDrawMode(iFixptWindowChannel%,2,1);
	XYJoin(iFixptWindowChannel%,1);
	'Draw the fixation window - update, do not draw fixation window except when fixation point is on screen (due to moving fixpt)
	'XYAddData(iFixptWindowChannel%, FixWindowX[], FixWindowY[]);

	'Create a new channel in the XY view to display the fixation point
	iFixptChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);  'was "4" instead of iMonitorChannel%, etc.
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
	XYAddData(iMonitorChannel%,-9,-7);
	XYAddData(iMonitorChannel%,9,-7);
	XYAddData(iMonitorChannel%,9,7);
	XYAddData(iMonitorChannel%,-9,7);
    
    'Tuning does not currently draw the location of the STIMULUS, but such could be added as above

end;

proc ResizeOnCurrentMonitor(xlo, ylo, xhi, yhi)

    var n%, i%;
    var currentMonitor% := 0;
    var currentXlo% := 0;
    var currentXhi% := 100;
    var sz%[4];

    n% := System(1, 0, sz%);
    for i% := 0 to n% do
        View(App()).WindowGetPos(xlo, ylo, xhi, yhi, i%, 1);
        if xlo >= 0 and xlo < 100 then
            currentMonitor% := i%;
            currentXlo% := xlo;
            currentXhi% := xhi;
        endif
    next

    View(App()).Window(currentXlo%, 0, currentXhi%, 95, currentMonitor%);

end;


proc TuningCurveLabels(iport%)
    
    var i%;  'looping variables to set XY channels for XY position tuning plot
    var j%;
    var count%;
    
    var s$;
    s$ := "Port " + str$(iport%);
	docase
        
    case tunType$ = tunTypeDots$ then
        
        WindowTitle$("Dots, Orientation Tuning - " + s$);
        XUnits$("Orientation (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunDotsMinOrientation, tunDotsMaxOrientation);
        
    case tunType$ = tunTypeContrast$ then
        
        WindowTitle$("Contrast Tuning - " + s$);
        XUnits$("Contrast (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunContrastMinContrast, tunContrastMaxContrast);
        
    case tunType$ = tunTypeOrientation$ then
        
        WindowTitle$("Orientation Tuning - " + s$);
        XUnits$("Orientation (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunOriMinOrientation, tunOriMaxOrientation);
        
    case tunType$ = tunTypeSpatial$ then
        
        WindowTitle$("Spatial Frequency Tuning - " + s$);
        XUnits$("Spatial Frequency");
        ChanTitle$(1, "Chan 1");
        XRange(tunSpatialMinSF, tunSpatialMaxSF);
        
    case tunType$ = tunTypeTemporal$ then
        
        WindowTitle$("Temporal Frequency Tuning - " + s$);
        XUnits$("Temporal Frequency");
        ChanTitle$(1, "Chan 1");
        XRange(tunTemporalMinTF, tunTemporalMaxTF);
        
    case tunType$ = tunTypeArea$ then
        
        WindowTitle$("Aperture Area Tuning - " + s$);
        XUnits$("Aperture Diameter");
        ChanTitle$(1, "Chan 1");
        XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
    case tunType$ = tunTypeXPos$ then
        
        WindowTitle$("X Position Tuning - " + s$);
        XUnits$("X Position");
        ChanTitle$(1, "Chan 1");
        XRange(tunXPosMinXPos, tunXPosMaxXPos);
        
    case tunType$ = tunTypeXYPos$ then
        
        WindowTitle$("XY Position Tuning - " + s$);
        XTitle$("X Position");
        ChanTitle$(0,"Y Position");  'Not an intuitive way to change the y title: ChanTitle$(0,...)
        XRange(tunXYPosMinXPos-1, tunXYPosMaxXPos+1);
        YRange(-1,tunXYPosMinYPos-1, tunXYPosMaxYPos+1);  'again, X and Y not the same.  Grr.  -1 for all channels
        'set up channels, one for each point in the grid
        for i% := 0 to tunXYPosNXSteps% do
            for j% := 0 to tunXYPosNYSteps% do
                count% := XYSetChan(0,1); 'create a channel with only one data point, return
                XYAddData(count%,tun1Values[i%],tun2values[j%]);  'put in a data point at the correct x,y coordinate
                XYDrawMode(count%,1,0);  'set draw mode to dots
                XYDrawMode(count%,2,5);  'set size of dots to invisible, will change later
            next;
        next;
        
        
    case tunType$ = tunTypeDisparity$ then
        
        WindowTitle$("Disparity Tuning - " + s$);
        XUnits$("Disparity (deg)");
        ChanTitle$(1, "Chan 1");
        XRange(2*tunDisparityCenterXPos-tunDisparityMaxXPos, tunDisparityMaxXPos);
        
    case tunType$ = tunTypeDonut$ then
        
        WindowTitle$("Donut Area Tuning - " + s$);
        XUnits$("Outer Diameter");
        ChanTitle$(1, "Chan 1");
        XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
    case tunType$ = tunTypeBerliner$ then
        
        WindowTitle$("Berliner Procedure - " + s$);
        XUnits$("Stim Type");
        ChanTitle$(1, "Chan 1");
        XRange(0,5);
        
    case tunType$ = tunTypeBoxODonuts$ then  
        
        WindowTitle$("Box O' Donuts Procedure - " + s$);
        docase
        case tunType1$ = tunTypeContrast$ then
            XUnits$("Contrast (%)");
            XRange(tunContrastMinContrast, tunContrastMaxContrast);
        case tunType1$ = tunTypeOrientation$ then
            XUnits$("Orientation (degrees)");
            XRange(tunOriMinOrientation, tunOriMaxOrientation);
        case tunType1$ = tunTypeSpatial$ then
            XUnits$("Spatial Frequency");
            XRange(tunSpatialMinSF, tunSpatialMaxSF);
        case tunType1$ = tunTypeTemporal$ then
            XUnits$("Temporal Frequency");
            XRange(tunTemporalMinTF, tunTemporalMaxTF);
        case tunType1$ = tunTypeArea$ then
            XUnits$("Aperture Diameter");
            XRange(tunAreaMinDiam, tunAreaMaxDiam);
        case tunType1$ = tunTypeXPos$ then
            XUnits$("X Position");
            XRange(tunXPosMinXPos, tunXPosMaxXPos);
        case tunType1$ = tunTypeNullTest$ then
            XUnits$("Phase/Null");
            XRange(tunNullTestMinPhase, tunNullTestMaxPhase);
        endcase
        ChanTitle$(1, "Chan 1");
        
    case tunType$ = tunTypeCRG$ then  'I don't know if Ben will use this much, I'm going to go rogue and use the SECOND (tuning curve) for the X axis
        
        WindowTitle$("Contrast Reversing Grating Procedure - " + s$);
        docase
        case tunType1$ = tunTypeContrast$ then  'note that here tunType1$ is the SECOND...
            XUnits$("Contrast (%)");
            XRange(tunContrastMinContrast, tunContrastMaxContrast);
        case tunType1$ = tunTypeOrientation$ then
            XUnits$("Orientation (degrees)");
            XRange(tunOriMinOrientation, tunOriMaxOrientation);
        case tunType1$ = tunTypeSpatial$ then
            XUnits$("Spatial Frequency");
            XRange(tunSpatialMinSF, tunSpatialMaxSF);
        case tunType1$ = tunTypeTemporal$ then
            XUnits$("Temporal Frequency");
            XRange(tunTemporalMinTF, tunTemporalMaxTF);
        case tunType1$ = tunTypeArea$ then
            XUnits$("Aperture Diameter");
            XRange(tunAreaMinDiam, tunAreaMaxDiam);
        case tunType1$ = tunTypeXPos$ then
            XUnits$("X Position");
            XRange(tunXPosMinXPos, tunXPosMaxXPos);
        case tunType1$ = tunTypeBlank$ then
            XUnits$("Blank");
            XRange(-1, 1);
        case tunType1$ = tunTypeGratingOnly$ then
            XUnits$("Grating Off(0)/On(100)");
            XRange(0, 100);
        case tunType1$ = tunTypeCRG$ then
            XUnits$("CRG Secondary Off(0)/On(1)");
            XRange(0, 1);
        endcase
        ChanTitle$(1, "Chan 1");
        
    case tunType$ = tunTypeDanish$ then
        
        WindowTitle$("Danish Area Tuning - " + s$);
        XUnits$("Contrast (%)");
        XRange(tunGonzagoMinContrast, tunGonzagoMaxContrast);
        ChanTitle$(1, "Chan 1");
        
        
        
    case tunType$ = tunTypeGonzago$ then
        
        WindowTitle$("Gonzago Tuning - " + s$);
        XUnits$("Outer Diameter");
        ChanTitle$(1, "Chan 1");
        XRange(tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter);
        
'But there's no tuning curve for DSS!  At least right now...        
'    case tunType$ = tunTypeDSS$ then
'        
'        WindowTitle$("Danish Area Tuning - " + s$);
'        XUnits$("Outer Diameter");
'        ChanTitle$(1, "Chan 1");
'        XRange(tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter);        
        
    case tunType$ = tunTypeNullTest$ then
        
        'myTitle$ := s$ + " - Phase = ";  'these may not apply to tuning
        'myTitle2$ := " - Phase = ";
        WindowTitle$("Null Test Phase Tuning - " + s$);
        XUnits$("Phase (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunNullTestMinPhase, tunNullTestMaxPhase);   
    
    case tunType$ = tunTypeBakersDozen$ then
        WindowTitle$("Baker's Dozen: NO Tuning - " + s$);
        XUnits$("No Tuning");
        ChanTitle$(1, "Chan 1");
        XRange(0, 100); 
        
    case tunType$ = tunTypeFixptColor$ then
        
        WindowTitle$("Fixpt Color Tuning - " + s$);
        docase
        case tunFPCGunIndex% = 0 then
            XUnits$("Red Value (0-255)");
        case tunFPCGunIndex% = 1 then
            XUnits$("Green Value (0-255)"); 
        case tunFPCGunIndex% = 2 then
            XUnits$("Blue Value (0-255)");   
        case tunFPCGunIndex% = 3 then
            XUnits$("Luminance Value (0-255)");            
        endcase
        ChanTitle$(1, "Chan 1");
        XRange(tunFPCMinValue, tunFPCMaxValue);    
        
    case tunType$ = tunTypeFixptJump$ then
        'TODO - decide whether to do anything here or skip like polka dots
        tunDoTuningHist% := 0;  'For now assume NO tuning histogram
        
    case tunType$ = tunTypePolkaDot$ then
        
        'This is going to be too tricky, going to skip it, Henry seems OK with this decision, for now
        
    else
        
        Message("TuningCurveLabels Error - unknown value for tunType$: " + tunType$);
        
	endcase;
    
end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
    var jj%, kk%, mm%;
    var temp1$;
    var temp2$;
    var od;
    var key$;
    var eof% := 1;
    var tunXYNValues%;
    
    var primaryTxt$;
    var secondaryTxt$;
    
    SetPrimarySecondaryTxt(primaryTxt$,secondaryTxt$);
    
    
	SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    'read tuning file, if one is specified (but don't do this if we are using tunfile1/tunfile2)
    if tunUseFile% = 1 and tunUseFile1% = 0 and tunType$ <> tunTypeBakersDozen$ then
        eof%:=1;
        readsetup(",","	 ","","","	");  'Standard read setup
        FileOpen(tunTuningFile$,8,0);  'open specified file
        while eof% > 0 do
            eof% := read(tunValues$[tunFileLen%]);  'read to end of file, must put each value on a new line to count number of stimuli in a block
            tunFileLen%+=1;  'increment tuning file length
        wend
        tunFileLen%-=1;  'decrement tuning file length because we increment when we find EOF.
        FileClose();  'close the file
        'Now deal out the values to tun1Values and tun2Values
        tun1FileLen% := 0;
        tun2FileLen% := 0;
        eof% := 0;  'Just reusing this variable, no longer is end of file, is now a label for tunValues1 or tunValues2
        for i% := 0 to tunFileLen%-1 do
            docase
            case tunValues$[i%] = "-" then
                eof% := 1;  'change to tunValues2[] on the "-"
            case eof% = 0 then  'otherwise it is expected to be a number
                tunValues[tun1FileLen%] := Val(tunValues$[i%]);  'may use tunValues or tun1Values later, let's not worry about which right now, fill both
                tun1Values[tun1FileLen%] := Val(tunValues$[i%]);  'this bizarreness is done for the probably defunct dual-screen-combo (dual VSG) - in any case tunUseFile1% will be 0 in that case so we will get into this IF
                tun1FileLen%+=1;  'increment tuning file length
            case eof% = 1 then
                tun2Values[tun2FileLen%] := Val(tunValues$[i%]);
                tun2FileLen%+=1;  'increment tuning file length
            endcase
        next;
    endif 
    
    
    'read tuning file for box'o'donuts curve 1, if one is specified
    if tunUseFile1% = 1 then
        eof%:=1;
        readsetup(",","	 ","","","	");  'Standard read setup
        FileOpen(tunTuningFile1$,8,0);  'open specified file
        while eof% > 0 do
            eof% := read(tun1Values[tun1FileLen%]);  'read to end of file, must put each value on a new line to count number of stimuli in a block
            tun1FileLen%+=1;  'increment tuning file length
        wend
        tun1FileLen%-=1;  'decrement tuning file length because we increment when we find EOF.
        FileClose();  'close the file
    endif
    
    
    'read tuning file for box'o'donuts curve 2, if one is specified
    if tunUseFile2% = 1 then
        eof%:=1;
        readsetup(",","	 ","","","	");  'Standard read setup
        FileOpen(tunTuningFile2$,8,0);  'open specified file
        while eof% > 0 do
            eof% := read(tun2Values[tun2FileLen%]);  'read to end of file, must put each value on a new line to count number of stimuli in a block
            tun2FileLen%+=1;  'increment tuning file length
        wend
        tun2FileLen%-=1;  'decrement tuning file length because we increment when we find EOF.
        FileClose();  'close the file
    endif
    
    
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    
    docase
        
    case tunType$ = tunTypeDots$ then 
        DoSampleAutoName(key$,"dots","dot",primaryTxt$,secondaryTxt$);
        
        tunNAdvances% := tunDotsNSteps%;
        tunNRepeats% := tunDotsNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        GetRepeatedParameterProgression%(tunDotsNSteps%+1, tunDotsNRepeats%, tunValues[], tunValuesIndices%[], tunDotsMinOrientation, tunDotsMaxOrientation, 0, tunDotsProgression%);  'Note - linear spacing for orientation, not log
        tunNValues% := (tunDotsNSteps%+1)*tunDotsNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);        
    case tunType$ = tunTypeContrast$ then 
        'this is the old way...might need to look back if the new way doesn't work!
'        if UseTwo1401s% = 0 then
'            SampleAutoName$(dataCellName$ + "_con_000");  'NOTE: maximum of 13 characters!!!
'        else
'            EqualizeSMRFilenumbers(dataPathRoot$ + "\\" + dataDataSet$,dataCellName$+"_conMICRO_",dataCellName$+"_conPOWER_");
'            SampleAutoName$(dataCellName$ + "_conMICRO_000");  'NOTE: maximum of 13 characters!!!
'            SetStringRegistryValue(key$, "pref", "con");
'        endif;
        DoSampleAutoName(key$,"con","con",primaryTxt$,secondaryTxt$);
        
        'this is the old way...might need to look back if the new way doesn't work!
        'tunNAdvances% := tunContrastNSteps%;  'this...
        'tunNRepeats% := tunContrastNRepeats%; '...and this are only used in a printlog statement
        'GetRepeatedParameterProgression%(tunContrastNSteps%+1, tunContrastNRepeats%, tunValues[], tunValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, tunContrastProgression%);
        'tunNValues% := (tunContrastNSteps%+1)*tunContrastNRepeats%;
        'tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        tunNRepeats% := tunContrastNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunContrastDualScreenCombo% = 0 then
            if tunUseFile% = 1 then
                tunNAdvances% := tunFileLen%-1;
                ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunContrastProgression%);
            else
                tunNAdvances% := tunContrastNSteps%;
                GetRepeatedParameterProgression%(tunContrastNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, tunContrastProgression%);
            endif;
            'tunNValues% := (tunContrastNSteps%+1)*tunContrastNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
            tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  'shorter, should work the same as above commented line, keeping old line for contrast only just in case...
            tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        else 'do the dual-screen combo version
            if tunUseFile% = 1 then
                'ShuffleAndExpand(tunFileLen%,1,tunValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
                GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
                tun1NValues% := (tunContrastNSteps%+1); 
                tun2NValues% := (tunContrastNSteps%+1); 
            endif;
            tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
            tunNValues% := tun1NValues%*tun2NValues%*tunContrastNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
            'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
            GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunContrastProgression%,tunContrastNRepeats%); 
            'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
            tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunContrastNRepeats%, tun1Values[], tun1ValuesIndices%[]);
            tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunContrastNRepeats%, tun2Values[], tun2ValuesIndices%[]);  
        endif;        
        
        
    case tunType$ = tunTypeOrientation$ then 
        DoSampleAutoName(key$,"ori","ori",primaryTxt$,secondaryTxt$);
        
        tunNRepeats% := tunOriNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunOriProgression%);
        else
            tunNAdvances% := tunOriNSteps%;
            GetRepeatedParameterProgression%(tunOriNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, tunOriProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeSpatial$ then 
        DoSampleAutoName(key$,"spa","spa",primaryTxt$,secondaryTxt$);
        
        tunNRepeats% := tunSpatialNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunSpatialProgression%);
        else
            tunNAdvances% := tunSpatialNSteps%;
            GetRepeatedParameterProgression%(tunSpatialNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, tunSpatialProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeTemporal$ then 
        DoSampleAutoName(key$,"tem","tem",primaryTxt$,secondaryTxt$);
        
        tunNRepeats% := tunTemporalNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunTemporalProgression%);
        else
            tunNAdvances% := tunTemporalNSteps%;
            GetRepeatedParameterProgression%(tunTemporalNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 0, tunTemporalProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeFixptColor$ then 
        DoSampleAutoName(key$,"fpc","fpc",primaryTxt$,secondaryTxt$);
        
        tunNRepeats% := tunFPCNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunFPCProgression%);
        else
            tunNAdvances% := tunFPCNSteps%;
            GetRepeatedParameterProgression%(tunFPCNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunFPCMinValue, tunFPCMaxValue, 0, tunFPCProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyColorProgression$(tunNValues%, tunValues, tunValuesIndices%); 
        'printlog("TunValuesStringified is %s\n",tunValuesStringified$);
        
    case tunType$ = tunTypeFixptJump$ then
        DoSampleAutoName(key$,"fpj","fpj",primaryTxt$,secondaryTxt$);
        tunNRepeats% := 1;
        tunNAdvances% := tunFPJNAdvances%;
        tunNValues% := tunFPJNAdvances%+1;  'There's a first value and then N jumps
        if tunDoOpto% > 0 then
            tunDoOpto% := 0;
            message("Opto was set on, but Fixpt Jump is not designed for opto! Opto has been turned off!");
        endif
        'do we stringify anything here?  Stringify can be done in dialog, easier to test.  Where do we write the file?  Written below in the Start%() function
        
    case tunType$ = tunTypePolkaDot$ then
        DoSampleAutoName(key$,"pd","pd",primaryTxt$,secondaryTxt$);
        
        ''Here is the XY position, which is basically identical to XYPos
        if tunPDNXSteps% = 0 then  'this allows for no x movement
            tunPDXValues[0] := tunPDMinXPos;
            tunPDXValuesIndices%[0] := 1;
        else
            GetRepeatedParameterProgression%(tunPDNXSteps%+1, 1, tunPDXValues[], tunPDXValuesIndices%[], tunPDMinXPos, tunPDMaxXPos, 0, 0);
        endif;
        tunPDXNValues% := (tunPDNXSteps%+1);
        
        if tunPDNYSteps% = 0 then  'this allows for no y movement
            tunPDYValues[0] := tunPDMinYPos;
            tunPDYValuesIndices%[0] := 1;
        else
            GetRepeatedParameterProgression%(tunPDNYSteps%+1, 1, tunPDYValues[], tunPDYValuesIndices%[], tunPDMinYPos, tunPDMaxYPos, 0, 0);
        endif;
        tunPDYNValues% := (tunPDNYSteps%+1);       
        
        'tunXYNAdvances% := tunPDXNValues%*tunPDYNValues%-1;  'this gives the correct number of advances
        tunXYNValues% := tunPDXNValues%*tunPDYNValues%*1;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        GridStimuli(tunPDXValues[],tunPDYValues[],tunPDXNValues%,tunPDYNValues%,tunPDXValuesIndices%[],tunPDYValuesIndices%[],0,1);         
        
        'StringifyProgression$ will work just fine on tunPDX/YValues and tunPDX/YValuesIndices
        tunPDXValuesStringified$ := StringifyProgression$(tunXYNValues%, tunPDXValues[], tunPDXValuesIndices%[]);
        tunPDYValuesStringified$ := StringifyProgression$(tunXYNValues%, tunPDYValues[], tunPDYValuesIndices%[]);
        
        'printlog("X values are %s\n",tunPDXValuesStringified$);
        'printlog("Y values are %s\n",tunPDYValuesStringified$);
        
        'This is the Color, have already renamed PolkaDot
        docase
            'This seems a bit silly, but it has to look like this to work with the subsequent functions we call
        case tunPDNColorSteps% = 0 and tunPDGunIndex% = 0 then  'this allows for no color change, red gun selected
            tunValues[0] := tunPDRedValue%;
            tunValuesIndices%[0] := 0;
        case tunPDNColorSteps% = 0 and tunPDGunIndex% = 1 then  'this allows for no color change, green gun selected
            tunValues[0] := tunPDGreenValue%;
            tunValuesIndices%[0] := 0;
        case tunPDNColorSteps% = 0 and tunPDGunIndex% = 2 then  'this allows for no color change, blue gun selected
            tunValues[0] := tunPDBlueValue%;
            tunValuesIndices%[0] := 0;
        case tunPDNColorSteps% = 0 and tunPDGunIndex% = 3 then  'this allows for no color change, luminance
            tunValues[0] := tunPDMinGunValue;
            tunValuesIndices%[0] := 0;
        else 'the color is changing
            GetRepeatedParameterProgression%(tunPDNColorSteps%+1, 1, tunValues[], tunValuesIndices%[], tunPDMinGunValue, tunPDMaxGunValue, 0, tunPDProgression%);
        endcase  
        tunNAdvances% := tunPDNColorSteps%;            
        tunNColorValues% := (tunNAdvances%+1)*1;  
        
        tunValuesStringified$ := StringifyPolkaDotProgression$(tunNColorValues%, tunValues[], tunValuesIndices%[]);
        'printlog("Color String is %s\n",tunValuesStringified$);
        
        
        'Now we need to Interleave the X string, the Y string, the Diameter, and the color string.  Diameter is a constant.
        tunNRepeats% := tunPDNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        tunValuesStringified$ := InterleavePDStrings$(tunPDXValuesStringified$,tunPDYValuesStringified$,Str$(tunPDDiameter),tunValuesStringified$,tunNRepeats%);
        'printlog("Polka Dot string is %s\n",tunValuesStringified$);
        
        tunNValues% := tunXYNValues%*tunNColorValues%*tunNRepeats%;
        'printlog("Total number of values is %d\n",tunNValues%);
            
        'Randomization of the above would be very complicated.  The easiest thing to do here will be to write a function
        'to randomize the VSG string.  This would require parsing the VSG string down using the semicolon as a token.
        'Easy enough.  But, since we also need to tag each trial with the dot specs, rather than break down the VSG string
        'every trial, we should just break it down once at the beginning and store the result.
        
        if tunPDProgression% = 1 then
            'Fill tunValuesIndices with shuffled values, but *shuffle by block*
            GetRepeatedParameterProgression%(tunNColorValues%*tunXYNValues%,tunNRepeats%,tunValues[],tunValuesIndices%[],0,1,0,1);  'tunValues will be unused
            'tunValuesIndices%[] has repeated indices in each block, add block N to each block to hold the correct "blocked" indices
            for jj% := 0 to tunNRepeats%-1 do
                for kk% := 0 to (tunNColorValues%*tunXYNValues%)-1 do
                    tunValuesIndices%[mm%] += jj%*tunNColorValues%*tunXYNValues%;
                    mm% += 1;
                next
            next
            'printlog("Number of pre-repeat values is %d\n",tunNColorValues%*tunXYNValues%);
            'printlog("tunValuesIndices is %d\n",tunValuesIndices%[0:tunNValues%]);
            'printlog("tunValues is %f\n",tunValues[0:tunNValues%]);
        else
            'Fill tunValuesIndices with unshuffled index
            for jj% := 0 to tunNvalues%-1 do
                tunValuesIndices%[jj%] := jj%;
            next
        endif
        
        'We run this even if we are not scrambling, because we are filling tunPDDotSpecsPerTrial$[]
        tunvaluesStringified$ := ShufflePDTuningString$(tunNValues%,tunValuesIndices%[],tunvaluesStringified$,tunPDDotSpecsPerTrial$[]);
    
        'Update tunNAdvances%, used in idle loop
        tunNAdvances% := (tunXYNValues%*(tunPDNColorSteps%+1))-1; 
    
        'printlog("Randomized string is %s\n",tunValuesStringified$);
        'printlog("Order is %d\n",tunValuesIndices%[0:tunNValues%]);
        'printlog("Individual dot specs are %s\n",tunPDDotSpecsPerTrial$[0:tunNValues%]);
        
        
    case tunType$ = tunTypeArea$ then 
        DoSampleAutoName(key$,"area","are",primaryTxt$,secondaryTxt$);
        
        tunNRepeats% := tunAreaNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunAreaDualScreenCombo% = 0 then
            if tunUseFile% = 1 then
                tunNAdvances% := tunFileLen%-1;
                ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunAreaProgression%);
            else
                tunNAdvances% := tunAreaNSteps%;
                GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
            endif;
            'tunNValues% := (tunAreaNSteps%+1)*tunAreaNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
            tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  'shorter, should work the same as above commented line, keeping old line for contrast only just in case...
            tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        else 'do the dual-screen combo version
            if tunUseFile% = 1 then
                'ShuffleAndExpand(tunFileLen%,1,tunValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
                GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
                tun1NValues% := (tunAreaNSteps%+1); 
                tun2NValues% := (tunAreaNSteps%+1); 
            endif;
            tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
            tunNValues% := tun1NValues%*tun2NValues%*tunAreaNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
            'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
            GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunAreaProgression%,tunAreaNRepeats%); 
            'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
            tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunAreaNRepeats%, tun1Values[], tun1ValuesIndices%[]);
            tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunAreaNRepeats%, tun2Values[], tun2ValuesIndices%[]);  
        endif;        
        
    case tunType$ = tunTypeNullTest$ then 
        DoSampleAutoName(key$,"nulltest","nul",primaryTxt$,secondaryTxt$);
        
        tunNRepeats% := tunNullTestNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunNullTestProgression%);
        else
            tunNAdvances% := tunNullTestNSteps%;
            GetRepeatedParameterProgression%(tunNullTestNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunNullTestMinPhase, tunNullTestMaxPhase, 0, tunNullTestProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%); 
    case tunType$ = tunTypeLag$ then 
        DoSampleAutoName(key$,"lag","lag",primaryTxt$,secondaryTxt$);
        
        'this is the old way...might need to look back if the new way doesn't work!
        'tunNAdvances% := tunLagNSteps%;  'this...
        'tunNRepeats% := tunLagNRepeats%; '...and this are only used in a printlog statement
        'GetRepeatedParameterProgression%(tunLagNSteps%+1, tunLagNRepeats%, tunValues[], tunValuesIndices%[], tunLagMinLagFrames, tunLagMaxLagFrames, 0, tunLageProgression%);
        'tunNValues% := (tunLagNSteps%+1)*tunLagNRepeats%;
        'tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        tunNRepeats% := tunLagNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunLagProgression%);
        else
            tunNAdvances% := tunLagNSteps%;
            GetRepeatedParameterProgression%(tunLagNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunLagMinLagFrames, tunLagMaxLagFrames, 0, tunLagProgression%);
        endif;
        'tunNValues% := (tunLagNSteps%+1)*tunLagNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  'shorter, should work the same as above commented line, keeping old line for contrast only just in case...
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeXPos$ then 
        DoSampleAutoName(key$,"xpos","xps",primaryTxt$,secondaryTxt$);
        
        tunNAdvances% := tunXPosNSteps%;
        tunNRepeats% := tunXPosNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        GetRepeatedParameterProgression%(tunXPosNSteps%+1, tunXPosNRepeats%, tunValues[], tunValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 0, tunXPosProgression%);  'Note - linear spacing for position, not log
        tunNValues% := (tunXPosNSteps%+1)*tunXPosNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);   
        
    case tunType$ = tunTypeXYPos$ then 
        DoSampleAutoName(key$,"xypos","xyp",primaryTxt$,secondaryTxt$);
        
        'for tun1, use X
        if tunXYPosNXSteps% = 0 then  'this allows for no x movement
            tun1Values[0] := tunXYPosMinXPos;
            tun1ValuesIndices%[0] := 1;
        else
            GetRepeatedParameterProgression%(tunXYPosNXSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunXYPosMinXPos, tunXYPosMaxXPos, 0, 0);
        endif;
        tun1NValues% := (tunXYPosNXSteps%+1);
        
        'for tun2, use Y
        if tunXYPosNYSteps% = 0 then  'this allows for no y movement
            tun2Values[0] := tunXYPosMinYPos;
            tun2ValuesIndices%[0] := 1;
        else
            GetRepeatedParameterProgression%(tunXYPosNYSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunXYPosMinYPos, tunXYPosMaxYPos, 0, 0);
        endif;
        tun2NValues% := (tunXYPosNYSteps%+1);       
        
        tunNRepeats% := tunXYPosNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics   
        tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
        tunNValues% := tun1NValues%*tun2NValues%*tunXYPosNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunXYPosProgression%,tunXYPosNRepeats%);         
        
        'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
        tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunXYPosNRepeats%, tun1Values[], tun1ValuesIndices%[]);
        tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunXYPosNRepeats%, tun2Values[], tun2ValuesIndices%[]);
        
        printlog("X values are %s\n",tun1ValuesStringified$);
        printlog("Y values are %s\n",tun2ValuesStringified$);
        tunValuesStringified$ := InterleaveStrings$(tun1ValuesStringified$,tun2ValuesStringified$);
        printlog("XY values are %s\n",tunValuesStringified$);
        
    case tunType$ = tunTypeDisparity$ then 
        DoSampleAutoName(key$,"disprity","dis",primaryTxt$,secondaryTxt$);
        
        tunNAdvances% := tunDisparityNSteps%;
        tunNRepeats% := tunDisparityNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        GetRepeatedSymmetricParameterProgression%(tunDisparityNSteps%+1, tunDisparityNRepeats%, tunValues[], tunValuesIndices%[], tunDisparityCenterXPos, tunDisparityMaxXPos, 0, tunDisparityProgression%);  'linear spacing only
        'GetRepeatedSymmetricParameterProgression%(tunDisparityNSteps%+1, tunDisparityNRepeats%, tunValues[], tunValuesIndices%[], tunDisparityCenterXPos, tunDisparityMaxXPos, 1-tunDisparityLinear%, tunDisparityProgression%);  'allow log spacing
        tunNValues% := (2*tunDisparityNSteps%+1)*tunDisparityNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);         
    case tunType$ = tunTypeDonut$ then 
        DoSampleAutoName(key$,"donut","don",primaryTxt$,secondaryTxt$);
        
        tunNAdvances% := tunAreaNSteps%;
        tunNRepeats% := tunAreaNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunAreaNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunDonutProgression%);
        tunNValues% := (tunAreaNSteps%+1)*tunAreaNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        'PrintLog("nsteps %d nrepeats %d nvalues %d\n", tunAreaNSteps%, tunAreaNRepeats%, tunNValues%);
        'for i% := 0 to tunNValues%-1 do
        '    PrintLog("%d %f\n", i%, tunValues[tunValuesIndices%[i%]]);
        'next
    case tunType$ = tunTypeBerliner$ then 
        DoSampleAutoName(key$,"berliner","ber",primaryTxt$,secondaryTxt$);
        
        tunNAdvances% := tunBerlinerNSteps%-1;  'subtract one because tunBerlinerNSteps% is literal (that is, n stims)
        tunNRepeats% := tunBerlinerNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        GetRepeatedParameterProgression%(tunBerlinerNSteps%, tunBerlinerNRepeats%, tunValues[], tunValuesIndices%[], 1, tunBerlinerNSteps%, 0, tunBerlinerProgression%);
        tunNValues% := (tunBerlinerNSteps%)*tunBerlinerNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeBoxODonuts$ then
        
        'here we can do a GRPP for each of the two tuning curves (using one repeat, one repeat only) to get the values
        'then we have to randomize (or not) before stringifying
        
        docase
        case tuntype1$ = tunTypeContrast$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else                
                GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
                tun1NValues% := (tunContrastNSteps%+1);
            endif;
            temp1$ := "_con";
        case tuntype1$ = tunTypeOrientation$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else
                GetRepeatedParameterProgression%(tunOriNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, 0); 
                tun1NValues% := (tunOriNSteps%+1); 
            endif;            
            temp1$ := "_ori";            
        case tuntype1$ = tunTypeSpatial$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else
                GetRepeatedParameterProgression%(tunSpatialNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, 0);
                tun1NValues% := (tunSpatialNSteps%+1);
            endif;
            temp1$ := "_spa";
        case tuntype1$ = tunTypeTemporal$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else
                GetRepeatedParameterProgression%(tunTemporalNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, 0);
                tun1NValues% := (tunTemporalNSteps%+1);
            endif;
            temp1$ := "_tem";
        case tuntype1$ = tunTypeArea$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else
                GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
                tun1NValues% := (tunAreaNSteps%+1);
            endif;
            temp1$ := "_area";
        case tuntype1$ = tunTypeXPos$ then
            GetRepeatedParameterProgression%(tunXPosNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 0, 0);
            tun1NValues% := (tunXPosNSteps%+1);
            temp1$ := "_xpos";
        case tuntype1$ = tunTypeLag$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else                
                GetRepeatedParameterProgression%(tunLagNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunLagMinLagFrames, tunLagMaxLagFrames, 0, 0);
                tun1NValues% := (tunLagNSteps%+1);
            endif;
            temp1$ := "_lag";
        case tuntype1$ = tunTypeNullTest$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else                
                GetRepeatedParameterProgression%(tunNullTestNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunNullTestMinPhase, tunNullTestMaxPhase, 0, 0);
                tun1NValues% := (tunNullTestNSteps%+1);
            endif;
            temp1$ := "_null";
        case tuntype1$ = tunTypeFixptColor$ then
            if tunUseFile1% = 1 then
                ShuffleAndExpand(tun1FileLen%,1,tun1ValuesIndices%[],0);
                tun1NValues% := tun1FileLen%;
            else                
                GetRepeatedParameterProgression%(tunFPCNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunFPCMinValue, tunFPCMaxValue, 0, 0);
                tun1NValues% := (tunFPCNSteps%+1);
            endif;
            temp1$ := "_fpc";    
        endcase;
        
        docase
        case tuntype2$ = tunTypeContrast$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
                tun2NValues% := (tunContrastNSteps%+1); 
            endif;
            temp2$ := "_con";
        case tuntype2$ = tunTypeOrientation$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunOriNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, 0);
                tun2NValues% := (tunOriNSteps%+1);
            endif;            
            temp2$ := "_ori";            
        case tuntype2$ = tunTypeSpatial$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunSpatialNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, 0);
                tun2NValues% := (tunSpatialNSteps%+1);
            endif;
            temp2$ := "_spa";
        case tuntype2$ = tunTypeTemporal$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunTemporalNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, 0);
                tun2NValues% := (tunTemporalNSteps%+1);
            endif;
            temp2$ := "_tem";
        case tuntype2$ = tunTypeArea$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
                tun2NValues% := (tunAreaNSteps%+1);
            endif;
            temp2$ := "_area";
        case tuntype2$ = tunTypeXPos$ then
            GetRepeatedParameterProgression%(tunXPosNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 0, 0);
            tun2NValues% := (tunXPosNSteps%+1);
            temp2$ := "_xpos";
        case tuntype2$ = tunTypeLag$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else
                GetRepeatedParameterProgression%(tunLagNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunLagMinLagFrames, tunLagMaxLagFrames, 0, 0);
                tun2NValues% := (tunLagNSteps%+1); 
            endif;
            temp2$ := "_lag";
        case tuntype2$ = tunTypeNullTest$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else                
                GetRepeatedParameterProgression%(tunNullTestNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunNullTestMinPhase, tunNullTestMaxPhase, 0, 0);
                tun2NValues% := (tunNullTestNSteps%+1);
            endif;
            temp2$ := "_null";
        case tuntype2$ = tunTypeFixptColor$ then
            if tunUseFile2% = 1 then
                ShuffleAndExpand(tun2FileLen%,1,tun2ValuesIndices%[],0);
                tun2NValues% := tun2FileLen%;
            else                
                GetRepeatedParameterProgression%(tunFPCNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunFPCMinValue, tunFPCMaxValue, 0, 0);
                tun2NValues% := (tunFPCNSteps%+1);
            endif;
            temp2$ := "_fpc"; 
        case tunType2$ = tunTypePolkaDot$ then
            tunBoxODonutsNumGratingOption% := 2;  'This special value is used in the Start%() function to correctly set up the strings for the command line
            temp2$ := "_plkd";
            
            ''Here is the XY position, which is basically identical to XYPos
            if tunPDNXSteps% = 0 then  'this allows for no x movement
                tunPDXValues[0] := tunPDMinXPos;
                tunPDXValuesIndices%[0] := 1;
            else
                GetRepeatedParameterProgression%(tunPDNXSteps%+1, 1, tunPDXValues[], tunPDXValuesIndices%[], tunPDMinXPos, tunPDMaxXPos, 0, 0);
            endif;
            tunPDXNValues% := (tunPDNXSteps%+1);
            
            if tunPDNYSteps% = 0 then  'this allows for no y movement
                tunPDYValues[0] := tunPDMinYPos;
                tunPDYValuesIndices%[0] := 1;
            else
                GetRepeatedParameterProgression%(tunPDNYSteps%+1, 1, tunPDYValues[], tunPDYValuesIndices%[], tunPDMinYPos, tunPDMaxYPos, 0, 0);
            endif;
            tunPDYNValues% := (tunPDNYSteps%+1);       
            
            'tunXYNAdvances% := tunPDXNValues%*tunPDYNValues%-1;  'this gives the correct number of advances
            tunXYNValues% := tunPDXNValues%*tunPDYNValues%*1;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
            
            'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
            GridStimuli(tunPDXValues[],tunPDYValues[],tunPDXNValues%,tunPDYNValues%,tunPDXValuesIndices%[],tunPDYValuesIndices%[],0,1);         
            
            'StringifyProgression$ will work just fine on tunPDX/YValues and tunPDX/YValuesIndices
            tunPDXValuesStringified$ := StringifyProgression$(tunXYNValues%, tunPDXValues[], tunPDXValuesIndices%[]);
            tunPDYValuesStringified$ := StringifyProgression$(tunXYNValues%, tunPDYValues[], tunPDYValuesIndices%[]);
            
            'printlog("X values are %s\n",tunPDXValuesStringified$);
            'printlog("Y values are %s\n",tunPDYValuesStringified$);
            
            'This is the PolkaDot
            docase
                'This seems a bit silly, but it has to look like this to work with the subsequent functions we call
            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 0 then  'this allows for no color change, red gun selected
                tunValues[0] := tunPDRedValue%;
                tunValuesIndices%[0] := 0;
            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 1 then  'this allows for no color change, green gun selected
                tunValues[0] := tunPDGreenValue%;
                tunValuesIndices%[0] := 0;
            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 2 then  'this allows for no color change, blue gun selected
                tunValues[0] := tunPDBlueValue%;
                tunValuesIndices%[0] := 0;
            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 3 then  'this allows for no color change, luminance
                tunValues[0] := tunPDMinGunValue;
                tunValuesIndices%[0] := 0;
            else 'the color is changing
                GetRepeatedParameterProgression%(tunPDNColorSteps%+1, 1, tunValues[], tunValuesIndices%[], tunPDMinGunValue, tunPDMaxGunValue, 0, tunPDProgression%);
            endcase  
            tunNAdvances% := tunPDNColorSteps%;            
            tunNColorValues% := (tunNAdvances%+1)*1;  
            
            tunValuesStringified$ := StringifyPolkaDotProgression$(tunNColorValues%, tunValues[], tunValuesIndices%[]);
            'printlog("Color String is %s\n",tunValuesStringified$);
            
            
            'Now we need to Interleave the X string, the Y string, the Diameter, and the color string.  Diameter is a constant.
            tunValuesStringified$ := InterleavePDStrings$(tunPDXValuesStringified$,tunPDYValuesStringified$,Str$(tunPDDiameter),tunValuesStringified$,1);
            'printlog("Polka Dot string is %s\n",tunValuesStringified$);
            
            tun2NValues% := tunXYNValues%*tunNColorValues%*1;
            'printlog("Total number of values is %d\n",tun2NValues%);
            
        endcase;
              
        DoSampleAutoName(key$,"boxodonuts" + temp1$ + temp2$,"boxodonuts" + temp1$ + temp2$,primaryTxt$,secondaryTxt$);  'Note that this does not reflect the correct number of characters...it may not work properly?
        
        tunNRepeats% := tunBoxODonutsNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics   
        tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
        tunNValues% := tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        if tuntype2$ <> tunTypePolkaDot$ then  'we don't do this if we are using polka dots, there's a different method below
            GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunBoxODonutsProgression%,tunBoxODonutsNRepeats%); 
        endif;

        'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
        docase
        case tuntype2$ = tunTypePolkaDot$ then
            ExpandGratingIndices(tun2NValues%,tunNRepeats%,tun1NValues%,tun1ValuesIndices%[]);
            'printlog("After expansion, Tun1ValuesIndices are %d\n",tun1ValuesIndices%[0:tunNValues%]);  'this is right, but not scrambled
            tunValuesStringified$ := ExpandPDTuningString$(tunNRepeats%*tun1NValues%,tunValuesStringified$);
            'printlog("Expanded polka dot string is %s\n",tunValuesStringified$); 'this is right, but not scrambled
            'So now, we have an unscrambled polka string and an unscrambled set of grating indices
            'Have to scramble both within blocks
            tun2ValuesStringified$ := ShufflePDTuningStringBox$(tunNRepeats%,tun1NValues%*tun2NValues%,tun1ValuesIndices%[],tunvaluesStringified$,tunPDDotSpecsPerTrial$[]);
            'Use scrambled tun1ValuesIndices%[] to create grating string
            tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun1Values[], tun1ValuesIndices%[]);  ' this is the grating tuning curve

            
'        case tuntype1$ = tunTypeFixptColor$ then 'These are now deprecated
'            tun1ValuesStringified$ := StringifyColorProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun1Values[], tun1ValuesIndices%[]);
'            'printlog("TunValuesStringified is %s\n",tun1ValuesStringified$);
'            tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun2Values[], tun2ValuesIndices%[]);
'        case tuntype2$ = tunTypeFixptColor$ then
'            tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun1Values[], tun1ValuesIndices%[]);
'            tun2ValuesStringified$ := StringifyColorProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun2Values[], tun2ValuesIndices%[]);
        else
            tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun1Values[], tun1ValuesIndices%[]);
            tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun2Values[], tun2ValuesIndices%[]);
        endcase
        
        
    case tunType$ = tunTypeCRG$ then
        
        'GetRepeatedParameterProgression%(n%, nr%, result[], indices%[], firstval, lastval, ilog%, irandom%)
        'Generate one list for the CRG on the "main" (rather than master/slave) screen
        GetRepeatedParameterProgression%(tunCRGNSeq1%,1,tun1Values[],tun1ValuesIndices%[],0,tunCRGNSeq1%-1,0,tunCRGProgression%);
        tun1NValues% := tunCRGNSeq1%;
        
        'Generate a second list for the tuning curve on the "secondary" (rather than master/slave) screen
        'Note the ugly mix of tuntype1$, temp2$, and tun2NValues%, etc., and then try to forget about it.  Not worth fixing.
        'All of these are the same as for Box O' Donuts except for CRG2, Blank (Static is treated as contrast)
        docase
        case tuntype1$ = tunTypeContrast$ then
            GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
            tun2NValues% := (tunContrastNSteps%+1); 
            temp2$ := "_con";
        case tuntype1$ = tunTypeOrientation$ then
            GetRepeatedParameterProgression%(tunOriNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, 0);
            tun2NValues% := (tunOriNSteps%+1);  
            temp2$ := "_ori";            
        case tuntype1$ = tunTypeSpatial$ then
            GetRepeatedParameterProgression%(tunSpatialNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, 0);
            tun2NValues% := (tunSpatialNSteps%+1);
            temp2$ := "_spa";
        case tuntype1$ = tunTypeTemporal$ then
            GetRepeatedParameterProgression%(tunTemporalNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, 0);
            tun2NValues% := (tunTemporalNSteps%+1);
            temp2$ := "_tem";
        case tuntype1$ = tunTypeArea$ then
            GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
            tun2NValues% := (tunAreaNSteps%+1);
            temp2$ := "_area";
        case tuntype1$ = tunTypeXPos$ then
            GetRepeatedParameterProgression%(tunXPosNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 1, 0);
            tun2NValues% := (tunXPosNSteps%+1);
            temp2$ := "_xpos";
        case tuntype1$ = tunTypeLag$ then
            GetRepeatedParameterProgression%(tunLagNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunLagMinLagFrames, tunLagMaxLagFrames, 0, 0);
            tun2NValues% := (tunLagNSteps%+1);
            temp2$ := "_lag";
        case tuntype1$ = tunTypeBlank$ then
            tun2NValues% := 1;
            temp2$ := "_blank";
        case tuntype1$ = tunTypeGratingOnly$ then
            GetRepeatedParameterProgression%(2, 1, tun2Values[], tun2ValuesIndices%[], 0, 100, 0, 0);
            tun2NValues% := 2;
            temp2$ := "_grat";
        case tuntype1$ = tunTypeCRG$ then
            'OK, the trick here is going to be in the StringifyProgression, and not here
            GetRepeatedParameterProgression%(2, 1, tun2Values[], tun2ValuesIndices%[], 0, 100, 0, 0);
            tun2NValues% := 2;
            temp2$ := "_crg";
        endcase;
        
        DoSampleAutoName(key$,"crg" + temp2$,"crg" + temp2$,primaryTxt$,secondaryTxt$);
        
        
        tunNRepeats% := tunCRGNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
        tunNValues% := tun1NValues%*tun2NValues%*tunCRGNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunCRGProgression%,tunCRGNRepeats%);
        
        'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
        tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunCRGNRepeats%, tun1Values[], tun1ValuesIndices%[]);
        if tuntype1$ = tunTypeCRG$ then 'but we need to call a "special" stringify function if CRG on secondary screen
            tun2ValuesStringified$ := StringifyProgressionCRG2$(tun1NValues%*tun2NValues%*tunCRGNRepeats%, tun2Values[], tun2ValuesIndices%[], tun1Values[], tun1ValuesIndices%[]);
        else
            tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunCRGNRepeats%, tun2Values[], tun2ValuesIndices%[]);
        endif;
        
        
    case tunType$ = tunTypeDanish$ then 
        DoSampleAutoName(key$,"dan","dan",primaryTxt$,secondaryTxt$);
        
        tunNAdvances% := tunDanishNSteps%;
        tunNRepeats% := tunDanishNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunDanishIncludeBlank% = 0 then
            GetRepeatedParameterProgression%(tunDanishNSteps%+1, tunDanishNRepeats%, tunValues[], tunValuesIndices%[], tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, 1, tunDanishProgression%); 
            tunNValues% := (tunDanishNSteps%+1)*tunDanishNRepeats%;
        else  'include blank, include one blank of "0" per tuning cycle, 0 will result in no donut being drawn
            GetRepeatedParameterProgressionWithConstant%(tunDanishNSteps%+1, 1, 0, tunDanishNRepeats%, tunValues[], tunValuesIndices%[], tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, 1, tunDanishProgression%); 
            tunNValues% := (tunDanishNSteps%+2)*tunDanishNRepeats%;
        endif        
        
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);  
        
        
    case tunType$ = tunTypeGonzago$ then     
        DoSampleAutoName(key$,"gz","gz",primaryTxt$,secondaryTxt$);
        
        'By definition, tuntype1 is contrast (on the core)  
        GetRepeatedParameterProgression%(tunGonzagoCoreContrastNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunGonzagoMinContrast, tunGonzagoMaxContrast, 1, 0);
        tun1NValues% := 2*(tunGonzagoCoreContrastNSteps%+1);  'By mutiplying the NValues by 2, we trick GridStimuli into gridding out the zeros that fill the empty parts of tun1Values[]

        
        'By definition, tuntype2 is area (on the donut)
        GetRepeatedParameterProgression%(tunGonzagoDonutAreaNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunGonzagoMinOuterDiameter, tunGonzagoMaxOuterDiameter, 1, 0);
        tun2NValues% := 2*(tunGonzagoDonutAreaNSteps%+1);   'By mutiplying the NValues by 2, we trick GridStimuli into gridding out the zeros that fill the empty parts of tun2Values[]

        
        tunNRepeats% := tunGonzagoNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics   
        tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
        tunNValues% := tun1NValues%*tun2NValues%*tunGonzagoNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunGonzagoProgression%,tunGonzagoNRepeats%); 
        
        'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
        tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunGonzagoNRepeats%, tun1Values[], tun1ValuesIndices%[]);
        tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunGonzagoNRepeats%, tun2Values[], tun2ValuesIndices%[]);
        
        
    case tunType$ = tunTypeDSS$ then
        DoSampleAutoName(key$,"dss","dss",primaryTxt$,secondaryTxt$);
        
        tunNValues% := tunDSSNTrials%;   '*(1+tunDoOpto%);  'double number of blocks if doing optogenetics?????  Not sure how that would work with DSS.  If it's ever a question we'll have to work that logic out, but it might not ever be...
        od := GetDonutOD();  'get the outer diameter of the donut
        'ArrConst(tunValues[0],od); 'only need to assign the outer diameter for index 0, that's all we'll access
        tunValues[0] := od;  'weird - the above line doesn't work due to "incompatible procedure types"!
        ArrConst(tunValuesIndices%[0:tunNValues%],0);  'fill tunValuesIndices% with 0 to index tunNValues% (should be zeroes but whatever) 
        
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%); 
        
        'hard code pReward to 1, logic is different for DSS
        pReward := 1;
        'tunUseMaintainMode% := 0;  'also hard code tunUseMaintainMode%, this could be 1 once that's implemented, but NOT 3/4
        
        
    else    
        DoSampleAutoName(key$,"tun","tun",primaryTxt$,secondaryTxt$);
    endcase;
    
    
    SampleAutoFile(1);
    
    ' Text marks make extraction easier
    SampleTextMark(200);  'Channel 30 is textmark channel
    
    ' These channels indicate a stim is armed when using dual rigs
'    if tunDoRivalry% <> 0 then
'        
'        SampleEvent(98, 5, 2, 3600);
'        SampleComment$(98, "Marmed");
'        SampleTitle$(98, "Marmed");
'
'        SampleEvent(99, 5, 2, 3600);
'        SampleComment$(99, "Sarmed");
'        SampleTitle$(99, "Marmed");
'        
'    endif
    

	'----Event Channel recording definitions----
    
   	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");

	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"Ready");
	SampleTitle$(ReadyChannel%,"Ready");
    
	SampleEvent(FixationPointChannel%, 2, 2, 3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixpt");
	SampleTitle$(FixationPointChannel%,"Fixpt");
	
	SampleEvent(StimChannel%, 3, 2, 3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
'	SampleEvent(FrameSlaveChannel%, 4, 2, 3600);
'	SampleComment$(FrameSlaveChannel%,"Frame-Slave");
'	SampleTitle$(FrameSlaveChannel%,"Frame-Slave");
    
'	SampleEvent(ReadySlaveChannel%, 5, 2, 3600); 'Trigger channel, level
'	SampleComment$(ReadySlaveChannel%,"Ready-Slave");
'	SampleTitle$(ReadySlaveChannel%,"Ready-Slave");
    
    ' djs Add channels to capture slave fixpt and stim onset
'	SampleEvent(FixationPointSlaveChannel%, 6, 2, 3600); 'Trigger channel, level
'	SampleComment$(FixationPointSlaveChannel%,"Fixpt-Slave");
'	SampleTitle$(FixationPointSlaveChannel%,"Fixpt-Slave");
	
'	SampleEvent(StimSlaveChannel%, 7, 2,3600); 'Trigger channel, level
'	SampleComment$(StimSlaveChannel%,"Stim-Slave");
'	SampleTitle$(StimSlaveChannel%,"Stim-Slave");
    
    
    'Add a digital marker channel for pulsing optogenetics OR eye tracker output file
    'Do it for every opto, easy enough to add this into the wraparound calls in the PLS
    'Will record a '1' for laser on and a '0' for laser off
    'Will record a '101' for eyetracker timing pulses.
    'Note that Opto and eyetracker output are not exclusive.  If both, the channel will be
    'labeled as the laser channel, but both pulses will be present.
    docase
    case tunDoOpto% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        'SampleTitle$(DigitalLaserChannel%,"Laser On");
        SampleTitle$(32,"Laser On");  'Digital marker is by definition channel 32
    case RecordEyeTrackerOutputFile% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"EyeFilePulse");  'Digital marker is by definition channel 32
    case UseTwo1401s% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"Timing");  'Digital marker is by definition channel 32
    endcase
    
    if UseTwo1401s% = 1 then
        SampleEvent(TimingChannel%, 6, 2, 3600); 'Trigger channel, level
        SampleComment$(TimingChannel%,"Handshake");
        SampleTitle$(TimingChannel%,"Hndshk");
    endif;
    
    if tunSendINTANPulse% = 1 then
        SampleEvent(IntanTrialChannel%, 5, 2, 3600); 'Trigger channel, level
        SampleComment$(IntanTrialChannel%,"INTAN-T");
        SampleTitle$(IntanTrialChannel%,"INTAN-T");
        
        'Under the new conception, we will not be receiving a pulse from the INTAN machine
'        SampleEvent(IntanMarkChannel%, 6, 2, 3600); 'Trigger channel, level
'        SampleComment$(IntanMarkChannel%,"INTAN-M");
'        SampleTitle$(IntanMarkChannel%,"INTAN-M");
    endif
    
    
    '----Analog, non-spiking electrode recording conditions
    'Add a waveform channel for efference copy.  This can come from either the 1401 itself or
    'from the stimulator, it doesn't really matter.
    'It would be nice to have these as level channels on event inputs, but that does not fly with the VSG box. (Several months later, I do not know how to interpret that comment...jj)
    if tunOptoUsePulse% = 1 and tunDoOpto% = 1 and OptoEffCopyPort% > -1 then
        SampleWaveform(OptoCopyChannel%,OptoEffCopyPort%,5000); 
        SampleTitle$(OptoCopyChannel%,OptoPortLabel$);
    endif;
    
    docase
    case tunButtonCollect% = 1 and UtilityPort% > -1 then  'use utility port for button
'        SampleWaveform(ButtonChannel%,ButtonPort%,10000);  'Giving 0.1 ms resolution for now
'        SampleComment$(ButtonChannel%,"Raw Button");
'        SampleTitle$(ButtonChannel%,"Raw Button");
        SampleWaveform(ButtonChannel%, UtilityPort%, 1000);
        SampleTitle$(ButtonChannel%,"Button");  'We ought to title the button channel something, right? -jj 9/22/16
    case tunButtonCollect% = 1 and UtilityPort% = -1 then  'if utility port is undefined, this is an error
        Message("You must set a UtilityPort in Config->DAQ to use the rivalry button!  Quitting!");
        halt
    case UtilityPort% > -1 then  'otherwise, utility port is a utility port
        SampleWaveform(UtilityChannel%,UtilityPort%,30000);        
        SampleTitle$(UtilityChannel%,UtilityPortLabel$);   
    endcase;    
    
    
    'if we are recording the laser output, turn off any electrode channels
    'this will not happen currently, as the laser diode collection has been disabled at the dialog box
    'If we re-implement this, test to see if it actually works as intended!
    docase
    case tunLaserDiode% = 1 and StimEffCopyPort% > -1 then
        SampleWaveform(StimulatorChannel%,StimEffCopyPort%,50000);       
        SampleTitle$(StimulatorChannel%,StimPortLabel$);

        tunNWavemarks% := 0;  'no wavemarks!
        tunNContinuous% := 0;  'no continuous!
        'SampleWaveform(1,0,50000);  'on waveform port 0
        'SampleTitle$(1,"Diode output (laser)");
    case tunLaserDiode% = 1 and StimEffCopyPort% = -1 then
        message("tunLaserDiode is set to 1 but no StimEffCopyPort is set!  Quitting!");
        halt
    endcase;
    
    if tunAlwaysLooking% = 0 then
        SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
        SampleTitle$(XChannel%,EyeXPortLabel$);
        SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
        SampleTitle$(YChannel%,EyeYPortLabel$);
    endif;
    
    if JoystickPort% > -1 then
        printlog("Joy channel is %d and joystick port is %d\n", JoyChannel%, GetJoystickPort%());
        SampleWaveform(JoyChannel%, GetJoystickPort%(), 1000);
        SampleTitle$(JoyChannel%, JoystickPortLabel$);
    endif

    
    
    
    '----Set up "spiking" Electrode Channels----
    'This function will set up standard sampling as well as various pre-set samplings including the Plexon setups
    SetUpElectrodeConfiguration(numWavemarkPorts%,ExcludedChans%[]);
    
    if UseTwo1401s% = 0 then
        SampleSequencer(script$ + "Tuning.pls");
    else
        SampleSequencer(script$ + "TuningSendTrigger.pls");
    endif;
    
    
    DoSampleOptimise();
	
	SampleMode(1); 'Continuous sampling
    
end;

' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, j%, m%;
    var chanToExport%[30];
    var fn$;
    var mylen%;
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if tunDoOpto% = 1 then
        SafeSampleKey("o");
    endif;
    
    'If the eyetracker is recording an output file, stop recording and close the file
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("w");  'Stop recording
        yield(0.1);
        SafeSampleKey("i");  'Close the file
        SafeSampleKey("Z");  'zero the DIGLOWs
    endif
    
    'If we are sending INTAN pulses, send one last pulse before closing down
    if tunSendINTANPulse% = 1 then
        'set sequencer variable 11 to 10 to indicate the end-of-session pulse
        SampleSeqVar(11,10);
        SafeSampleKey("T");
        SampleText("End of session");
        yield(0.2); 'wait for the 10 ms pulse to be complete before stopping sampling
    endif
    
    ' Tell stim app to shut down.
    ' DJS - removed the 'X' sample key here. 
    ' In general this X cannot be seen by the vsg application if neither stim is up,
    ' which is the case at the end of an expt for example. In dual stim configuration,
    ' that leads to the script hanging, because the sequencer is waiting for the vsg
    ' app to set its "ready" bits, which will never get set.... 
    ' extraneous X?    SafeSampleKey("X");
	SafeSampleKey("Q");
	SampleStop();
    
    if tunDoRivalry% = 0 then
        ProgKill(StimHandle%);
        while ProgStatus(StimHandle%) > 0 do
            Yield();
        wend
    else
        ProgKill(StimHandle%);
        while ProgStatus(StimHandle%) > 0 do
            Yield();
        wend
        ProgKill(StimHandleSlave%);
        while ProgStatus(StimHandleSlave%) > 0 do
            Yield();
        wend
    endif
    
'	ProgRun(bin$ + "\\ClearTrigger",0);
    
    'For some reason, Tuning never had Matlab export set up before the Plexon update...
    '''As of now, Henry does not want there to be .mat file output on tuning (3/21/16 jj) 
    '''Not sure whether Joe will want it or not - we might have to make it an option    
    '''Note that I've updated the syntax here in other code to make sure the eye channels
    '''actually come out, check CuedAtten.s2s for details
'    View(DataWindow%);
'    ExportChanList(); 
'    chanToExport%[1] := 30;  'channels to export go in elements 1:...'30 is the textmark channel
'    chanToExport%[2] := 31;  '31 is the keyboard channel
'    chanToExport%[3] := 32;  '32 is the digital marker channel
'    chanToExport%[4] := StimChannel%;  'stim channel
'    docase
'    case UsePlexon18WM24WF% = 1 then  'use hardcoded Plexon values - 18 WaveMarks and 24 LFPs for now, on the micro it's 
'        for i% := 0 to 12 do
'            chanToExport%[i%+5] := i%+1;  'wavemark channels are in order
'        next;
'        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
'    case UsePlexon7WM15CN% = 1 then  'use hardcoded Plexon values - 7 WaveMarks and 15 LFPs
'        for i% := 0 to 13 do
'            chanToExport%[i%+5] := i%+1;  'wavemark channels are in order
'        next;
'        for i% := 14 to 21 do
'            chanToExport%[i%+5] := i%+3;  'wavemark channels are in order, but we're skipping eye channels
'        next;
'        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
'    else
'        for i% := 0 to NumWavemarkPorts% do
'            chanToExport%[i%+5] := i%+1;  'wavemark channels are in order
'        next;
'        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
'    endcase;
'    
'    ExportChanList(0,view(datawindow%).maxtime(),chanToExport%[]);
'    
'    'Code for putting other various channels into the Matlab extraction, Ben doesn't want them but they will be useful for other code    
'    ExportChanList(0,maxtime(),XChannel%);  'Eye position channel, X
'    ExportChanList(0,maxtime(),YChannel%);  'Eye position channel, Y
'    'for i% := 0 to NumWavemarkPorts%-1 do
'    '    ExportChanList(0,maxtime(),i%+1);  'Wavemark channel(s)
'    'next;
'    
'    
'    fn$ := FileName$();  'get current file name
'    mylen% := Len(fn$);
'    fn$ := Left$(fn$,mylen%-4);
'    if Right$(fn$,1) = "." then  'if the file is an .smrx, we need to adjust further
'        fn$ := Left$(fn$,Len(fn$)-1);
'    endif;
'    fn$ := fn$ + ".mat";
'    FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag    
    
    
    
    
	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsCompleted%;
	TotalRewards% += nTrialsRewarded%;
	SaveDailyTotals();
    
    ' Figure out max F1 values
    if tunDoF12% = 1 then
        for i% := 0 to tunNWavemarks%-1 do
            m% := Max(tunF1Sum[i%][]);
            LogStatus("F1 Max", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F1 at x=" + str$(tunValues[m%]));
        next
    endif    
    
    halt;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var tempPrimary$;
    var tempSecondary$;
    
	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);
    
	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);
    
	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
    Print("Eye coil offset, V (X)     : %f\n", XVoltOffset);
    Print("Eye coil offset, V (Y)     : %f\n", YVoltOffset);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	Print("Background color           : %s\n", tunBackgroundColor$);
    
	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);
    
	' write stimulus parameters
	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
    Print("\nStimulus\n");  'Master grating
	Print("-------------------\n\n");
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	if tunSetStationary% = 1 then
        Tstimtf$ := "0";
    endif
    Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
    Print("Inner Width (degrees)           : %s\n", Tstimiw$);
	Print("Inner Height (degrees)          : %s\n", Tstimih$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %s\n", Tstimphase$);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
    
    if tunDoRivalry% = 1 then  'Do slave grating only if we're using it
        Print("\Slave Stimulus\n");  'Slave grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("SlaveStimulus");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        if tunSetStationary% = 1 then
            Tstimtf$ := "0";
        endif
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        Print("Width (degrees)                 : %s\n", Tstimw$);
        Print("Height (degrees)                : %s\n", Tstimh$);
        Print("Inner Width (degrees)           : %s\n", Tstimiw$);
        Print("Inner Height (degrees)          : %s\n", Tstimih$);
        Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
        Print("Temporal frequency              : %s\n", Tstimtf$);
        Print("Spatial frequency               : %s\n", Tstimsf$);
        Print("Orientation (degrees)           : %s\n", Tstimorientation$);
        Print("Initial Phase (degrees)         : %f\n", Tstimphase$);
        Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
        Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
        Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);  
    endif;        
    
    if tunType$ = tunTypeDanish$ or tunType$ = tunTypeDSS$ then  'Do donut grating only if we're using it
        Print("\Donut Stimulus\n");  'Donut grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor1");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        if tunSetStationary% = 1 then
            Tstimtf$ := "0";
        endif
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        Print("Width (degrees)                 : %s\n", Tstimw$);
        Print("Height (degrees)                : %s\n", Tstimh$);
        Print("Inner Width (degrees)           : %s\n", Tstimiw$);
        Print("Inner Height (degrees)          : %s\n", Tstimih$);
        Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
        Print("Temporal frequency              : %s\n", Tstimtf$);
        Print("Spatial frequency               : %s\n", Tstimsf$);
        Print("Orientation (degrees)           : %s\n", Tstimorientation$);
        Print("Initial Phase (degrees)         : %f\n", Tstimphase$);
        Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
        Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
        Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);  
    endif;
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");
    
	'Print("Fixation time(s)       : %f\n", tunFixationDuration);  'cleaning these up!
	'Print("Maintain fixation (s)  : %f\n", tunMaintainFixation);
	'Print("Time out (s)           : %f\n", tunTimeOutTime);
	'Print("Acquisition time (s)   : %f\n", tunAcquisitionTime);
    Print("Stimulus Duration(s)   : %f\n", tunFixationDuration);
	Print("Maintain fixation (s)  : %f\n", tunMaintainFixation);
	Print("Time out (s)           : %f\n", tunHoldFailTime);
	Print("Acquisition time (s)   : %f\n", tunAcquisitionTime);
    Print("Stationary is set to   : %f\n", tunSetStationary%);
    
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");
	docase 
    case tunType$ = tunTypeBakersDozen$ then
        Print("Type                  : BakersDozen\n");
        Print("File                  : " + tunBakersDozenFileLoc$ + "\n");
        Print("Values are            : " + BDFullText$ + "\n");
        
        if tunBDUseImageFile% = 1 then
            Print("Image File            : " + tunBDImageFile$ + "\n");
            Print("Image Duration        : " + Str$(tunImageDur) + "\n");
            Print("Image Series ITI      : " + Str$(tunImageDelay) + "\n");
            Print("N Image in Series     : " + Str$(tunNImagesInSeries%) + "\n");
            Print("N Image Color Levels  : " + Str$(tunImageNLevels%) + "\n");
        endif
        
        Print("\n");
        
        
    case tunType$ = tunTypeContrast$ then
        
        Print("Type:                  : Contrast\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
        if tunContrastDualScreenCombo% = 0 then
            Print("Values: " + tunValuesStringified$ + "\n");
        else
            Print("Master Values: " + tun1ValuesStringified$ + "\n");
            Print("Slave Values: " + tun2ValuesStringified$ + "\n");
        endif;
        Print("\n");
        
        
    case tunType$ = tunTypeOrientation$ then
        
        Print("Type:                  : Orientation\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeSpatial$ then
        
        Print("Type:                  : Spatial Frequency\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeTemporal$ then
        
        Print("Type:                  : Temporal Frequency\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeFixptColor$ then
        
        Print("Type:                  : Fixpt Color\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunFPCMinValue, tunFPCMaxValue, tunFPCNSteps%, tunFPCNRepeats%);
        docase
        case tunFPCGunIndex% = 0 then
            Print("Color Tuned:       Red\n");
        case tunFPCGunIndex% = 1 then
            Print("Color Tuned:     Green\n");
        case tunFPCGunIndex% = 2 then
            Print("Color Tuned:      Blue\n");
        case tunFPCGunIndex% = 2 then
            Print("Color Tuned: Luminance\n");
        endcase
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeFixptJump$ then
        Print("Type:                  : Fixpt Jump\n");
        Print("#Jumps: %d\n", tunFPJNAdvances%);
        Print("Fixpt X offset from center: %f\n",tunFPJXOffset);
        Print("Fixpt Y offset from center: %f\n", tunFPJYOffset);
        Print("Probability of jump: %f\n", tunFPJProbSaccade);
        Print("Time of fixpt jump: %f\n", tunFPJtFixptMove);
        Print("Fixpt X/Y Values: " + tunFPJFixptStr$ + "\n");
        Print("Grating X/Y Values: " + tunFPJGratingStr$ + "\n");
        Print("\n");

        
    case tunType$ = tunTypePolkaDot$ then
        
        Print("Type:                  : Polka Dot\n");
        Print("#Repeats: %d\n", tunPDNRepeats%);
        Print("Diameter: %f\n", tunPDDiameter);
        Print("Show Grating: %d\n", tunPDShowGrating%);  'This will not apply to Box'o'Donuts, on that assume you're tuning a grating!
        if tunPDNXSteps% = 0 then
            Print("No X position tuning, X position: %f\n",tunPDMinXPos);
        else
            Print("X position Min,Max,#Steps: %f,%f,%d\n",tunPDMinXPos,tunPDMaxXPos,tunPDNXSteps%);
        endif
        if tunPDNYSteps% = 0 then
            Print("No Y position tuning, Y position: %f\n",tunPDMinYPos);
        else
            Print("Y position Min,Max,#Steps: %f,%f,%d\n",tunPDMinYPos,tunPDMaxYPos,tunPDNYSteps%);
        endif
        if tunPDNColorSteps% = 0 then
            Print("No color tuning, R/G/B: %d,%d,%d\n",tunPDRedValue%,tunPDGreenValue%,tunPDBlueValue%);
        else
            docase
            case tunPDGunIndex% = 0 then
                Print("Color Tuned:       Red\n");
                Print("Green, Blue: %d,%d\n",tunPDGreenValue%,tunPDBlueValue%);
            case tunPDGunIndex% = 1 then
                Print("Color Tuned:     Green\n");
                Print("Red, Blue: %d,%d\n",tunPDRedValue%,tunPDBlueValue%);
            case tunPDGunIndex% = 2 then
                Print("Color Tuned:      Blue\n");
                Print("Red, Green: %d,%d\n",tunPDRedValue%,tunPDGreenValue%);
            case tunPDGunIndex% = 2 then
                Print("Color Tuned: Luminance\n");
            endcase
            Print("Color Min,Max,Steps: %f,%f,%d\n",tunPDMinGunValue,tunPDMaxGunValue,tunPDNColorSteps%); 
        endif
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeArea$ then
        
        Print("Type:                  : Aperture Area\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
        if tunAreaDualScreenCombo% = 0 then
            Print("Values: " + tunValuesStringified$ + "\n");
        else
            Print("Master Values: " + tun1ValuesStringified$ + "\n");
            Print("Slave Values: " + tun2ValuesStringified$ + "\n");
        endif;
        Print("\n");
        
    case tunType$ = tunTypeNullTest$ then
        
        Print("Type:                  : Null Test Phase Tuning\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunNullTestMinPhase, tunNullTestMaxPhase, tunNullTestNSteps%, tunNullTestNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeXPos$ then
        
        Print("Type:                  : X Position\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeXYPos$ then
        
        Print("Type:                  : XY Position\n");
        Print("MinX,MaxX,#XSteps,#Repeats: %f,%f,%d,%d\n", tunXYPosMinXPos, tunXYPosMaxXPos, tunXYPosNXSteps%, tunXPosNRepeats%);
        Print("MinY,MaxY,#YSteps,#Repeats: %f,%f,%d,%d\n", tunXYPosMinYPos, tunXYPosMaxYPos, tunXYPosNYSteps%, tunXPosNRepeats%);
        Print("XValues: " + tun1ValuesStringified$ + "\n");
        Print("YValues: " + tun2ValuesStringified$ + "\n");
        Print("\n");        
        
    case tunType$ = tunTypeDisparity$ then
        
        Print("Type:                  : Disparity\n");
        Print("Center,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDisparityCenterXPos, tunDisparityMaxXPos, tunDisparityNSteps%, tunDisparityNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeDonut$ then
        
        ' djs - 10/15/2014 - Added Optimal diameter to parameter file
        Print("Type:                  : Donut Area\n");
        Print("Optimal,Min,Max,#Steps,#Repeats: %f,%f,%f,%d,%d\n", tunDonutOptimalDiam, tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeBerliner$ then
        
        Print("Type:                  : Berliner Area\n");
        Print("Optimal,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDonutOptimalDiam, tunBerlinerMaximalDiam, tunBerlinerNSteps%, tunBerlinerNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeBoxODonuts$ then
        
        Print("Type:                  : Box O' Donuts\n");
        Print("#Repeats: %d\n", tunBoxODonutsNRepeats%);
        Print("\n");
        docase 
        case tunType1$ = tunTypeContrast$ then
            
            Print("Type 1:                  : Contrast\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
            Print("Values: " + tun1ValuesStringified$ + "\n");
            Print("\n");
            
            
        case tunType1$ = tunTypeOrientation$ then
            
            Print("Type 1:                  : Orientation\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
            Print("Values: " + tun1ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeSpatial$ then
            
            Print("Type 1:                  : Spatial Frequency\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
            Print("Values: " + tun1ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeTemporal$ then
            
            Print("Type 1:                  : Temporal Frequency\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
            Print("Values: " + tun1ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeFixptColor$ then
            
            Print("Type 1:                  : Fixpt Color\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunFPCMinValue, tunFPCMaxValue, tunFPCNSteps%, tunFPCNRepeats%);
            docase
            case tunFPCGunIndex% = 0 then
                Print("Color Tuned:       Red\n");
            case tunFPCGunIndex% = 1 then
                Print("Color Tuned:     Green\n");
            case tunFPCGunIndex% = 2 then
                Print("Color Tuned:      Blue\n");
            case tunFPCGunIndex% = 2 then
                Print("Color Tuned: Luminance\n");
            endcase
            Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypePolkaDot$ then
            
			Print("Type:                  : Polka Dot\n");
            Print("#Repeats: ,%d\n", tunPDNRepeats%);
            Print("Diameter: %f\n", tunPDDiameter);
            if tunPDNXSteps% = 0 then
                Print("No X position tuning, X position: %f\n",tunPDMinXPos);
            else
                Print("X position Min,Max,#Steps: %f,%f,%d\n",tunPDMinXPos,tunPDMaxXPos,tunPDNXSteps%);
            endif
            if tunPDNYSteps% = 0 then
                Print("No Y position tuning, Y position: %f\n",tunPDMinYPos);
            else
                Print("Y position Min,Max,#Steps: %f,%f,%d\n",tunPDMinYPos,tunPDMaxYPos,tunPDNYSteps%);
            endif
            if tunPDNColorSteps% = 0 then
                Print("No color tuning, R/G/B: %d,%d,%d\n",tunPDRedValue%,tunPDGreenValue%,tunPDBlueValue%);
            else
                docase
                case tunPDGunIndex% = 0 then
                    Print("Color Tuned:       Red\n");
                    Print("Green, Blue: %d,%d\n",tunPDGreenValue%,tunPDBlueValue%);
                case tunPDGunIndex% = 1 then
                    Print("Color Tuned:     Green\n");
                    Print("Red, Blue: %d,%d\n",tunPDRedValue%,tunPDBlueValue%);
                case tunPDGunIndex% = 2 then
                    Print("Color Tuned:      Blue\n");
                    Print("Red, Green: %d,%d\n",tunPDRedValue%,tunPDGreenValue%);
                case tunPDGunIndex% = 2 then
                    Print("Color Tuned: Luminance\n");
                endcase
                Print("Color Min,Max,Steps: %f,%f,%d\n",tunPDMinGunValue,tunPDMaxGunValue,tunPDNColorSteps%); 
            endif
            Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
            
        case tunType1$ = tunTypeArea$ then
            
            Print("Type 1:                  : Aperture Area\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
            Print("Values: " + tun1ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeXPos$ then
            
            Print("Type 1:                  : X Position\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
            Print("Values: " + tun1ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeNullTest$ then
            
            Print("Type 1:                  : Null/Phase\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunNullTestMinPhase, tunNullTestMaxPhase, tunNullTestNSteps%, tunNullTestNRepeats%);
            Print("Values: " + tun1ValuesStringified$ + "\n");
            Print("\n");
        endcase
        
        docase 
        case tunType2$ = tunTypeContrast$ then
            
            Print("Type 2:                  : Contrast\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
            
        case tunType2$ = tunTypeOrientation$ then
            
            Print("Type 2:                  : Orientation\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType2$ = tunTypeSpatial$ then
            
            Print("Type 2:                  : Spatial Frequency\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType2$ = tunTypeTemporal$ then
            
            Print("Type 2:                  : Temporal Frequency\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType2$ = tunTypeFixptColor$ then
            
            Print("Type 2:                  : Fixpt Color\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunFPCMinValue, tunFPCMaxValue, tunFPCNSteps%, tunFPCNRepeats%);
            docase
            case tunFPCGunIndex% = 0 then
                Print("Color Tuned:       Red\n");
            case tunFPCGunIndex% = 1 then
                Print("Color Tuned:     Green\n");
            case tunFPCGunIndex% = 2 then
                Print("Color Tuned:      Blue\n");
            case tunFPCGunIndex% = 2 then
                Print("Color Tuned: Luminance\n");
            endcase
            Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
            
        case tunType2$ = tunTypePolkaDot$ then
            
			Print("Type:                  : Polka Dot\n");
            Print("#Repeats: ,%d\n", tunPDNRepeats%);
            Print("Diameter: %f\n", tunPDDiameter);
            if tunPDNXSteps% = 0 then
                Print("No X position tuning, X position: %f\n",tunPDMinXPos);
            else
                Print("X position Min,Max,#Steps: %f,%f,%d\n",tunPDMinXPos,tunPDMaxXPos,tunPDNXSteps%);
            endif
            if tunPDNYSteps% = 0 then
                Print("No Y position tuning, Y position: %f\n",tunPDMinYPos);
            else
                Print("Y position Min,Max,#Steps: %f,%f,%d\n",tunPDMinYPos,tunPDMaxYPos,tunPDNYSteps%);
            endif
            if tunPDNColorSteps% = 0 then
                Print("No color tuning, R/G/B: %d,%d,%d\n",tunPDRedValue%,tunPDGreenValue%,tunPDBlueValue%);
            else
                docase
                case tunPDGunIndex% = 0 then
                    Print("Color Tuned:       Red\n");
                    Print("Green, Blue: %d,%d\n",tunPDGreenValue%,tunPDBlueValue%);
                case tunPDGunIndex% = 1 then
                    Print("Color Tuned:     Green\n");
                    Print("Red, Blue: %d,%d\n",tunPDRedValue%,tunPDBlueValue%);
                case tunPDGunIndex% = 2 then
                    Print("Color Tuned:      Blue\n");
                    Print("Red, Green: %d,%d\n",tunPDRedValue%,tunPDGreenValue%);
                case tunPDGunIndex% = 2 then
                    Print("Color Tuned: Luminance\n");
                endcase
                Print("Color Min,Max,Steps: %f,%f,%d\n",tunPDMinGunValue,tunPDMaxGunValue,tunPDNColorSteps%); 
            endif
            Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
            
        case tunType2$ = tunTypeArea$ then
            
            Print("Type 2:                  : Aperture Area\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType2$ = tunTypeXPos$ then
            
            Print("Type 2:                  : X Position\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType2$ = tunTypeNullTest$ then
            
            Print("Type 2:                  : Null/Phase\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunNullTestMinPhase, tunNullTestMaxPhase, tunNullTestNSteps%, tunNullTestNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
        endcase
        
    case tunType$ = tunTypeCRG$ then
        
        Print("Type:                  : Contrast Reversing Grating\n");
        Print("#Repeats: %d\n", tunCRGNRepeats%);
        Print("\n");
        
        if tunCRGOnSlave% = 0 then
            tempPrimary$ := "Master";
            tempSecondary$ := "Slave";
        else
            tempPrimary$ := "Slave";
            tempSecondary$ := "Master";
        endif;
        
        Print(tempPrimary$ + ":                  : CRG\n");
        Print("FramesPerFlip,#Repeats: %d,%d\n", tunCRGFramesPerFlip%, tunCRGNRepeats%);
        Print("SEQFile: " + tunCRGSeqFile$ + "\n");
        Print("Values: " + tun1ValuesStringified$ + "\n");
        Print("\n");        
        
        docase 
        case tunType1$ = tunTypeContrast$ then
            
            Print(tempSecondary$ + ":                  : Contrast\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
            
        case tunType1$ = tunTypeOrientation$ then
            
            Print(tempSecondary$ + ":                  : Orientation\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeSpatial$ then
            
            Print(tempSecondary$ + ":                  : Spatial Frequency\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeTemporal$ then
            
            Print(tempSecondary$ + ":                  : Temporal Frequency\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeArea$ then
            
            Print(tempSecondary$ + ":                  : Aperture Area\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeXPos$ then
            
            Print(tempSecondary$ + ":                  : X Position\n");
            Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeBlank$ then
            
            Print(tempSecondary$ + ":                  : Blank\n");
            Print("\n");
            
        case tunType1$ = tunTypeGratingOnly$ then
            
            Print(tempSecondary$ + ":                  : Grating Only\n");
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        case tunType1$ = tunTypeCRG$ then
            
            Print(tempSecondary$ + ":                  :CRG\n");
            Print("SEQFile: " + tunCRGSeqFile2$ + "\n");
            Print("Values: " + tun2ValuesStringified$ + "\n");
            Print("\n");
            
        endcase
        
    case tunType$ = tunTypeDots$ then
        
        Print("Type:                  : Dots\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDotsMinOrientation, tunDotsMaxOrientation, tunDotsNSteps%, tunDotsNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n");
        
    case tunType$ = tunTypeDanish$ then
        
        Print("Type:                  : Danish\n");
        Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, tunDanishNSteps%, tunDanishNRepeats%);
        Print("Values: " + tunValuesStringified$ + "\n");
        Print("\n"); 
        
    case tunType$ = tunTypeDSS$ then
        
        Print("Type:                  : DSS\n");
        Print("#Trials,#Flashes,#Blanks,#FlashesPerReward: %d,%d,%d,%d\n", tunDSSNTrials%, tunDSSNPeriods%, tunDSSNBlanks%, tunDSSNFlashesPerReward%);
        Print("\n");        
        
        
    case tunType$ = tunTypeGonzago$ then
        
        Print("Type:                  : Gonzago\n");
        Print("Core Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunGonzagoMinContrast, tunGonzagoMaxContrast, tunGonzagoCoreContrastNSteps%, tunGonzagoNRepeats%);
        Print("Core Values: " + tun2ValuesStringified$ + "\n");
        Print("Donut Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunGonzagoMinOuterDiameter, tunGonzagoMaxOuterDiameter, tunGonzagoDonutAreaNSteps%, tunGonzagoNRepeats%);
        Print("Donut Values: " + tun1ValuesStringified$ + "\n");
        Print("\n");
        
    else
        
        Print("TuningCurve Error - unknown value for tunType$: %s\n", tunType$);
        
	endcase;
    
    if tunDoOpto% = 1 then
        Print("\nOptogenetics parameters\n");
        Print("-------------------------\n\n");
        if tunLaserDiode% = 1 then
            Print("Laser Diode recorded\n");
        endif;
        Print("Opto Voltage Out: %f\n", tunOptoVoltageOut);
        var label$[4]; 
        label$[0] := "Opto Off First";
        label$[1] := "Opto On First";
        label$[2] := "Random First";
        label$[3] := "Opto On All Blocks";
        Print("Order of blocks : %s\n", label$[tunOptoStartState%]);
        if tunOptoUsePulse% = 1 then
            Print("Pulsing Opto selected\n");
            Print("Opto#Pulses,OptoPeriodOnset,OptoPulseWidth,OptoInterpulseInterval: %d,%f,%f,%f\n",tunOptoNPulses%,tunPulsedOptoOnset,tunPulsedOptoWidth,tunPulsedOptoIPI);
        else
            Print("Wraparound Opto selected\n");
            Print("PreStimulusOptoOn,PostStimulusOptoOn,KeepOptoOnBetweenStims: %f,%f,%d\n",tunPreStimOptoTime,tunPostStimOptoTime,tunOptoStaysOn%);
        endif;
        
    endif;    
    
    
	' close parfile
	FileClose(0);
    
end;


' Gets the temporal freq of the current stimulus. 
' Make sure to call this only after all user dialogs have been completed (so you know that the stim parameters will not change)

func GetStimulusTF()
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var cv$, pattern$, aperture$;
    
	'if tunType$ = tunTypeNullTest$ then 'get the temporal frequency of the counterphase shift, grating does not drift
    '    tf := tunNullTestTF;
    'else  'get the temporal frequency of the grating
    '	 gr$ := GetGratingParameters$("Stimulus");
    '    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    'endif;
    
    'if CTF is nonzero, return CTF, otherwise return TF
    gr$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    if ctf > 0 then
        tf := ctf;
    endif
    
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end



' Gets the outer diameter of the current stimulus. 
' Make sure to call this only after all user dialogs have been completed (so you know that the stim parameters will not change)
' Please note that although this is called "outer diameter" it is actually returning the width - width and height
' are the same in all cases right now.

func GetDonutOD()
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var cv$, pattern$, aperture$;
	gr$ := GetGratingParameters$("Distractor1");
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    LogStatus("GetDonutOD", "OD=" + str$(w));
    return w;
end




'This is to get ready for each DSS "Trial", which is a series of donut flashes/blanks
'We will NOT re-initialize if the entire number of flashes is not completed
func InitializeDSSTrial(tNow)
    
    tunFixationDuration := 1000000000;  'We will not allow to break out of DSS stimulus until it is over
    stimulusHoldTime := tunFixationDuration;  'update for new code above
    tunDSSCurrPeriod% := 0;  ' current period is yet to start
    tunDSSFlashesUntilReward% := 0;  ' reward will come now
    tunDSSIsOn% := 1;  'donut will start in ON state
    ArrConst(tunDSSFlashOrBlank%[0:tunDSSNPeriods%-tunDSSNBlanks%],1);  'fill with correct number of flashes == 1
    ArrConst(tunDSSFlashOrBlank%[tunDSSNPeriods%-tunDSSNBlanks%:tunDSSNBlanks%],0);  'fill with correct number of blanks == 0
    Shuffle%(tunDSSNPeriods%, tunDSSFlashOrBlank%[]);  'And shuffle
    tunNextDSSTime := tNow + tunDSSDuration;
    
end




func StartPlexon%()
    
    var fp$;  'to hold current file path
    
    
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();    
    
    fp$ := SetPathToScriptDirectory$();
    StartSecondInstanceOfSpike2();
    
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar
    

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var cmdLine$;
    var cmdLineM$;
    var cmdLineS$;
    var tailM$, tailS$;
    var fileM$, fileS$;
    var Opener$;
    var OpenerM$;
    var OpenerS$;
    var ProgName$;
    var ProgNameM$;
    var ProgNameS$;
    var RemoteArg$:="";     'Extra arg needed if vsg is not on local machine...
    var RemoteArgM$:="";     'Extra arg needed if vsg is not on local machine...
    var RemoteArgS$:="";     'Extra arg needed if vsg is not on local machine...
    var XHairArg$:="";  'Note that all variables are used to construct cmdLine$, if unused, must be empty
    var BGColor$;
    var Dist2Screen$;
    var TriggerPort$;
    var Verbose$:=" -v ";  'For now, verbose is always on
    var RefrLock$:="";
    var OffsetFile$:="";
    var StimDur$:="";
    var MGrat$:=" -s ";
    var M2Grat$:="";  'start this empty, fill it only if necessary
    var SGrat$:=" -s ";
    var DGrat$:="";
    var MGratParam$:="";
    var M2GratParam$:="";
	var SGratParam$:="";
    var DGratParam$:="";  'for donut stimulus, uses Distractor1
    var MasterIndicator$:="";  'Do not use Master Indicator
    var SlaveIndicator$:="";  'or Slave Indicator for fixstim, set if needed
    var KlugeArg$:=" -H ";  'this is for a Jerry-rigged "hole" in Box O' Donuts slave stimuli 
    var MValues$:="";
    var M2Values$:="";
    var SValues$:="";   
    var S2Values$:="";  'won't be used except for Box O' Donuts, rivalry
    var DValues$:="";  'won't be used except for Box O' Donuts, two-grating version
    var KlugeValues$:="";  'this is for a Jerry-rigged "hole" in Box O' Donuts slave stimuli
    var MConstantLag$:="";  
    var SConstantLag$:=""; 
    var key$;
    var i%;
    'var CRGPrimaryArg$;  'This is always "-R", hard code
    var CRGPrimaryValues$;
    var CRGSecondaryArg$;
    var CRGSecondaryValues$;
    'vars for opto setup
    var voltageInteger%;
    var stimRemaining;
    stimRemaining := tunFixationDuration;
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;
    var specFileName$;
    var specHandle%;
    var startSecs := 5;
    
    specFileName$ := GetScriptDir$(0)+"..\\..\\TuningSpecFile.txt";
    
    
	
	'start sampling
    if UseTwo1401s% = 1 then
        'SampleStart(1);  'set sampling to start on a trigger
        'while SampleStatus() <> 2 and startSecs > 0 do
        '    yield(1);
        '    startSecs := startSecs - 1;
        'wend
        SampleStart(0);  'Set sampling to start immediately
        Yield(0.5);  'Wait half a second
        'Look for handshake, unless disabled
        while pulseFound% < 1 and startSecs > 0 and Dual1401IgnoreHandshake% = 0 do
            pulseFound% := View(DataWindow%).FindPulseUp%(TimingChannel%, 0, tRise, tFall);
            yield(0.1);
            startSecs := startSecs - 0.1;
        wend
        'Send timing pulse
        SampleSeqVar(11,20);  'set for 20 ms pulse (Was not specified!  Two 1401s has been inactive for years and "T" may have been accidentally co-opted?)
        SafeSampleKey("T");
    else
    	SampleStart(0); 'Start sampling now
    endif;

    if startSecs <= 0 then
        message("Handshake not found in 5 seconds!  Quitting!");
        halt
    endif

    ' djs Set sequencer variable 5 if this is rivalry
    if tunDoRivalry% = 1 then
        SampleSeqVar(5, 1);
    else
        SampleSeqVar(5, 0);
    endif
    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");  'this is DIGOUT
    SafeSampleKey("Z");  'this is DIGLOW
    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
    
    if tunDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable. Use vdac32% to get the right value.
        voltageInteger% := vdac32%(tunOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
        printlog("Voltage integer is %d\n",voltageInteger%);
        
        'If pulsing, because the user could have changed the duration of the stimulus after setting the opto
        'parameters, we need to check the parameters again (even though the opto dialog box did it already)
        if tunOptoUsePulse% = 1 then
            
            
            stimRemaining := stimRemaining - tunPulsedOptoOnset;  'duration of stimulus after onset delay
            stimRemaining := stimRemaining - tunPulsedOptoWidth;  'duration of stimulus after first opto pulse
            if stimRemaining < 0 then  'if first pulse will extend beyond stimulus duration
                'tunOptoNPulses% := 0;  'turn off opto by using no pulses, no, that is bad.  But it should quit, so...
                tunDoOpto% := 0;  'this is how you turn off opto
                'tell user they blew it
                Message("The first opto pulse will extend beyond the stimulus!  Quitting!!!");
                Quit%();
            else
                tempNPulses% := tunOptoNPulses% - 1;  'how many more pulses are left?
                tempCount% := 1;  'temporary successful pulse count
                while tempNPulses% > 0 do
                    stimRemaining := stimRemaining - tunPulsedOptoWidth - tunPulsedOptoIPI;  'subtract duration of one more pulse+IPI
                    if stimRemaining < 0 then  'if this pulse will extend beyond stimulus duration
                        Message("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed!");
                        tunOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                        stimRemaining := stimRemaining + tunPulsedOptoWidth + tunPulsedOptoIPI;  'add back duration of one more pulse+IPI, gets actual stimulus duration remaining
                        tempNPulses% := 0;  'break while
                    else  'if this pulse is OK
                        tempCount% += 1;  'increment temporary successful pulse count
                    endif;
                    tempNPulses% -= 1;  'decrement temporary pulse count remaining
                wend
            endif;
        endif;
        
        'If pulsing, set sample sequencer variables
        if tunOptoUsePulse% = 1 then  'yes, this is the same "if" as above, just seems cleaner this way
            SampleSeqVar(6,tunOptoNPulses%);  'set number of pulses
            printlog("Opto N pulses is %d\n",tunOptoNPulses%);
            'For below calculations, the standard numbers we are getting are in seconds, sequencer period is in MS (because that's how it comes)
            
            tempSeqVarValue := tunPulsedOptoWidth*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-2;  'now convert to integer, subtract two ticks for sequencer instructions
            if tempSeqVarValue% < 0 then  'Do not give sequencer variable a negative duration, minimum opto width is 3 ticks
                tempSeqVarValue% := 0;
            endif;
            SampleSeqVar(7,tempSeqVarValue%);  'set duration of pulse in clock ticks
            printlog("Opto width is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := tunPulsedOptoIPI*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-4;  'now convert to integer, subtract three ticks for sequencer instructions
            if tempSeqVarValue% < 0 then  'Do not give sequencer variable a negative duration, minimum IPI width is 5 ticks
                tempSeqVarValue% := 0;
            endif;
            SampleSeqVar(8,tempSeqVarValue%);  'set interpulse interval in clock ticks
            printlog("Opto IPI width is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := tunPulsedOptoOnset*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-1;  'now convert to integer, subtract one tick for sequencer instructions
            if tempSeqVarValue% < 0 then  'Do not give sequencer variable a negative duration, minimum onset delay is 2 ticks
                tempSeqVarValue% := 0;
            endif;
            SampleSeqVar(9,tempSeqVarValue%);  'set pre-pulse stimulus duration in clock ticks
            printlog("Opto onset is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := stimRemaining*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
            if tempSeqVarValue% < 0 then  'Do not give sequencer variable a negative duration, minimum stimulus following pulse offset is 4 ticks
                tempSeqVarValue% := 0;
            endif;
            SampleSeqVar(10,tempSeqVarValue%);  'set post-pulse stimulus duration in clock ticks
            printlog("Opto remaining time is %d\n",tempSeqVarValue%);
        endif;
        
    endif;
    
    
    
    
    
    'Begin building the command line argument
    Opener$ := "cmd /k " + bin$;
    OpenerM$ := Opener$;
    'OpenerS$ := "cmd/k D:\\work\\PsTools\\psexec \\\\192.168.1.2 -w c:\\work -i -f -c " + bin$;
    OpenerS$ := "cmd /k " + bin$;
    
    ' Get remote args if needed
    if GetUseRemoteStimulus%() = 1 then
        RemoteArg$  := " " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim ";
        RemoteArgM$ := " " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim ";
        RemoteArgS$ := " " + GetSlaveStimulusIP$() + " " + GetSlaveStimulusPort$() + " fixstim ";
    endif;
    
    
    'Get grating parameters, do this first so we can clear the SGratParam$ if Slave monitor is unused
    if tunSetStationary% = 0 then
        ' Stimulus is always used
        MGratParam$ := GetGratingParameters$("Stimulus");
        ' Slave Stimulus is not always used, but get it anyway
        SGratParam$ := GetGratingParameters$("SlaveStimulus");
    else
        ' Stimulus is always used
        MGratParam$ := GetGratingParameters$("StatStimulus");
        ' Slave Stimulus is not always used, but get it anyway
        SGratParam$ := GetGratingParameters$("StatSlaveStimulus");
    endif;    
    
    'Set rivalry options
    if tunDoRivalry% = 0 then
        RefrLock$ := "";  'do not lock frame refresh
        if GetUseRemoteStimulus%() = 1 then
            ProgName$ := "\\remote.exe "; 'set program name for one VSG
        else
            ProgName$ := "\\fixstim.exe "; 'set program name for one VSG
        endif;
        
        'I don't really like doing this (in principle these should start empty and be filled if they are being
        'used), but I'd have to do another "if tunSetStationary" statement, so this cuts down on total code
        SGrat$ := "";  'clear Slave grating indicator, we won't use it
        SGratParam$ := "";  'clear slave grating parameters, we won't use them
        
    else  'for rivalry (dualstim.exe), we need some extra commands that must be empty for a fixstim.exe call
    
        ProgName$ := "\\remote.exe ";
        
        ' Fetch the offset filename
        key$ := GetRegistryKey$(1) + "\\Rivalry";
        OffsetFile$ := GetStringRegistryValue$(GetRegistryKey$(1), "OffsetFile", "file_not_found");
'        if OffsetFile$ = "file_not_found" then
'            message("The offset file has not been defined in the registry!  Most likely you have created a new animal config.  Ask Jeff or Dan to update the registry for you!");
'            halt;
'        endif;
        OffsetFile$ := " -r " + OffsetFile$;
        
        ' Fetch the stimulus duration (in dualstim, stimoff is done by counting frames because of VSG frame synching)
        StimDur$ := " -t " + Str$(tunFixationDuration) + " ";  'add stimulus duration in seconds
        
        ' Set monitor indicators, required for Dualstim
        MasterIndicator$ := " -M ";  'master monitor indicator
        SlaveIndicator$ := " -V ";  'slave monitor indicator
    endif;
    
    'Fixation arguments are set by UsreyFixationPoint.s2s and need not be done here
    
    'Set crosshair options, if required
    'if tunUseXHairs% = 1 and (tunType$ = tunTypeBerliner$ or tunType$ = tunTypeDonut$) then 'Construct command line with crosshair argument, only for DUALSTIM, FIXSTIM won't do this (but now anything can be dualstim)
    if tunUseXHairs% = 1 and (tunDoRivalry% > 0) then 'Construct command line with crosshair argument, only for DUALSTIM, FIXSTIM won't do this
        'split XHairArg$ construction into two lines due to length
        'Note that XHair flag has changed to "-h" (from "-X") as of 1-20-12 jj
        XHairArg$ := " -h " + Str$(FixationX) + "," + Str$(FixationY) + "," + Str$(tunXHairInnerRadiusOffset) + "," + Str$(tunXHairMiddleRadiusOffset) + ","; 
        XHairArg$ := XHairArg$ + Str$(tunXHairOuterRadiusOffset) + "," + Str$(tunXHairNumGridDivisions%) + "," + Str$(tunXHairTicInnerOffset) + "," + Str$(tunXHairTicOuterOffset) + " ";
    endif;
    
    'Set background color
    BGColor$ := " -b " + tunBackgroundColor$;
    
    'Set distance to screen
    Dist2Screen$ := " -d " + GetDistanceToScreenMM$();
    
    'Set trigger port
    TriggerPort$ := " -p 2 ";  'This one's hard-coded for now
    
    'Turn on verbose
    Verbose$ := " -v ";
    
    'Set constant lag, will only be used if needed
    if tunType$ <> tunTypeLag$ and tunType1$ <> tunTypeLag$ and tunType2$ <> tunTypeLag$ then  'if we're NOT using a lag tuning curve anywhere....
        tunLagMasterIsLagged% := -1; 'set this to a negative value to avoid any accidental counterfeit from the default value of this variable
    endif;
    docase
    'case tunUseConstantLag% = 1 and tunLagMasterIsLagged% <> 1 then  'master is constant, master does not have a lag tuning curve
    case tunUseConstantLag% = 1 and tunLagMasterIsLagged% = -1 then  'master is constant, nobody is lagged
        MConstantLag$ := " -E " + Str$(tunConstantLagFrames%);
        SConstantLag$ := " -E 0";  'Must use lag on both screens, per Dan, set non-lagged to 0
    'case tunUseConstantLag% = 2 and tunLagMasterIsLagged% <> 0 then  'slave is constant, slave does not have a lag tuning curve
    case tunUseConstantLag% = 2 and tunLagMasterIsLagged% = -1 then  'slave is constant, nobody is lagged
        MConstantLag$ := " -E 0";  'Must use lag on both screens, per Dan, set non-lagged to 0
        SConstantLag$ := " -E " + Str$(tunConstantLagFrames%);
    else  'don't use it, this includes both tunUseConstantLag% = 0 and instances where the lag tuning and constant lag are on the same monitor
        MConstantLag$ := "";
        SConstantLag$ := "";
    endcase
    
    
    if tunSendINTANPulse% =  1 then
        'set sequencer variable 11 to default 0, no pulse.  Pulse durations for various tuning curves will be set in CASE below
        SampleSeqVar(11,0);
    endif
    
     
    'Get default tuning curve values - these may get changed!
    MValues$ := tunValuesStringified$;  
    
    'Run a case statement to do tuning-curve-specific stuff, this is simple except for Donuts, etc.
	docase 
    case tunType$ = tunTypeContrast$ then
        TunCurveMArg$ := " -C ";
        
        if tunContrastDualScreenCombo% = 0 then
            if tunDoRivalry% = 1 then
                TunCurveSArg$ := " -C ";  'Set slave to run same tuning curve...
                SValues$ := MValues$;  '...with same values as Master tuning curve
                'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
                ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
            endif;
        else
            TunCurveSArg$ := " -C ";
            MValues$ := tun1ValuesStringified$;
            SValues$ := tun2ValuesStringified$;
        endif;
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 35, the duration of the initial "Contrast" indicator pulse
            SampleSeqVar(11,35);
        endif
        
   
        
    case tunType$ = tunTypeOrientation$ then
        TunCurveMArg$ := " -O ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -O ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 30, the duration of the initial "Orientation" indicator pulse
            SampleSeqVar(11,30);
        endif

    case tunType$ = tunTypeSpatial$ then
        TunCurveMArg$ := " -S ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -S ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 45, the duration of the initial "Spatial Frequency" indicator pulse
            SampleSeqVar(11,45);
        endif

    case tunType$ = tunTypeTemporal$ then
        TunCurveMArg$ := " -T ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -T ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 50, the duration of the initial "Temporal Frequency" indicator pulse
            SampleSeqVar(11,50);
        endif
        
    case tunType$ = tunTypeFixptColor$ then
        TunCurveMArg$ := " -U ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -U ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;
        
    case tunType$ = tunTypeFixptJump$ then
        'do nothing, but we have to avoid the ELSE breaking
        
    case tunType$ = tunTypeArea$ then
        TunCurveMArg$ := " -A ";
        
        if tunAreaDualScreenCombo% = 0 then
            if tunDoRivalry% = 1 then
                TunCurveSArg$ := " -A ";  'Set slave to run same tuning curve...
                SValues$ := MValues$;  '...with same values as Master tuning curve
                'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
                ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
            endif;
        else
            TunCurveSArg$ := " -A ";
            MValues$ := tun1ValuesStringified$;
            SValues$ := tun2ValuesStringified$;
        endif;  
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 40, the duration of the initial "Area" indicator pulse
            SampleSeqVar(11,40);
        endif        
        
        
    case tunType$ = tunTypeXPos$ then
        TunCurveMArg$ := " -X ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ :="  -X ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;
        
    case tunType$ = tunTypeXYPos$ then
        tunCurveMArg$ := " -Z ";
        'tunDoRivalry cannot be 1 in this case because dualstim does not have this function
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 55, the duration of the initial "XY Position" indicator pulse
            SampleSeqVar(11,55);
        endif
        
    case tunType$ = tunTypePolkaDot$ then
        tunCurveMArg$ := " -D ";
        if tunPDShowGrating% = 0 then  'typically I suspect we will want to clear the grating, but it can be shown
            MGrat$ := "";  
            MGratParam$ := "";
        endif;
        if tunPDLagFrames% = 0 then
            MConstantLag$ := "";
        else
            MConstantLag$ := " -E " + Str$(tunPDLagFrames%) + " ";
        endif;
        'tunDoRivalry cannot be 1 in this case because dualstim does not have this function    
        
    case tunType$ = tunTypeLag$ then
        'tunDoRivalry will be 1
        if tunLagMasterIsLagged% = 1 then
            TunCurveMArg$ := " -E "; 'lag is -E!
            TunCurveSArg$ := " -E ";  'must use lag on both screens, just make it 0 for slave
            SValues$ := "0";  'lag 0 for slave
        else
            TunCurveMArg$ := " -E "; 'must use lag on both screens, just make it 0 for master
            TunCurveSArg$ := " -E ";
            SValues$ := MValues$;
            MValues$ := "0";  'lag 0 for master
        endif;
        'won't do ClearMasterOrSlave... because there's no point in running lag tuning with an empty screen on the other side
        
    case tunType$ = tunTypeDisparity$ then
        if tunDisparityOnMaster% = 1 then
            TunCurveMArg$ := " -X "; 'do disparity by moving master
            SGrat$ := " -g ";  'Change slave grating variable to -g because it doesn't change
            TunCurveSArg$ := "";  'clear the slave tuning curve argument
            SValues$ := "";  'clear the slave tuning curve values 
        else
            TunCurveSArg$ := " -X "; 'do disparity by moving slave
            SValues$ := MValues$;  'get values from "Master" tuning curve (assigned earlier)
            MGrat$ := " -g ";  'Change master grating variable to -g because it doesn't change
            TunCurveMArg$ := "";  'clear the master tuning curve argument
            MValues$ := "";  'clear the master tuning curve values
        endif;       
        
    case tunType$ = tunTypeDonut$ then
        
        TunCurveMArg$ := " -A ";  'Donuts do area on Master
        TunCurveSArg$ := " -M ";  'And "hole" stimuli on Slave.
        
        ' The args for the stim must be constructed here. 
        var areaArg$, donutArg$;
        for i% := 0 to tunNValues%-1 do
            if tunValues[tunValuesIndices%[i%]] <= tunDonutOptimalDiam then
                areaArg$ += str$(tunValues[tunValuesIndices%[i%]]) + ",";
                donutArg$ += "0,0,";
            else
                areaArg$ += str$(tunDonutOptimalDiam) + ",";
                donutArg$ += str$(tunValues[tunValuesIndices%[i%]]) + "," + str$(tunDonutOptimalDiam) + ",";
            endif
        next
        areaArg$ := Left$(areaArg$, Len(areaArg$)-1);
        donutArg$ := Left$(donutArg$, Len(donutArg$)-1);
        
        'Now put the constructed stim sets into standard variables
        MValues$ := areaArg$;
        SValues$ := donutArg$;
        
        ' Now if the core should be on the slave, we swap tunCurveMArg$/tunCurveSArg$ and MValues$/SValues$
        if tunDonutCoreOnSlave% <> 0 then
            var sd$;
            sd$ := tunCurveMArg$;
            TunCurveMArg$ := TunCurveSArg$;
            TunCurveSArg$ := sd$;
            sd$ := MValues$;
            MValues$ := SValues$;
            SValues$ := sd$;
        endif
        
    case tunType$ = tunTypeBerliner$ then
        
        TunCurveMArg$ := " -A ";  'Donuts do area on Master
        TunCurveSArg$ := " -M ";  'And "hole" stimuli on Slave
        
        ' The args for the stim must be constructed here. 
        var areaArgBerliner$, donutArgBerliner$; 
        for i% := 0 to tunNValues%-1 do
            docase
            case tunValues[tunValuesIndices%[i%]] = 1 then  'stim 1 is optimal center on master, no donut on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += "0,0,";
            case tunValues[tunValuesIndices%[i%]] = 2 then  'stim 2 is maximal center on master, no donut on slave
                areaArgBerliner$ += str$(tunBerlinerMaximalDiam) + ",";
                donutArgBerliner$ += "0,0,";   
            case tunValues[tunValuesIndices%[i%]] = 3 then  'stim 3 is optimal center on master, donut one step larger on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += str$(tunDonutOptimalDiamPlusOne) + "," + str$(tunDonutOptimalDiam) + ","; 
            case tunValues[tunValuesIndices%[i%]] = 4 then  'stim 4 is optimal center on master, maximal donut on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += str$(tunBerlinerMaximalDiam) + "," + str$(tunDonutOptimalDiam) + ",";   
            case tunValues[tunValuesIndices%[i%]] = 5 then  'stim 5 is optimal center on master, optimal center on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += str$(tunDonutOptimalDiam) + "," + str$(0) + ","; 
            case tunValues[tunValuesIndices%[i%]] = 6 then  'stim 6 is maximal center on master, maximal center on slave
                areaArgBerliner$ += str$(tunBerlinerMaximalDiam) + ",";
                donutArgBerliner$ += str$(tunBerlinerMaximalDiam) + "," + str$(0) + ",";      
            else
                Message("Error - unknown value for tunValues: " + str$(tunValues[tunValuesIndices%[i%]]));
                Halt;   
            endcase
        next
        areaArgBerliner$ := Left$(areaArgBerliner$, Len(areaArgBerliner$)-1);
        donutArgBerliner$ := Left$(donutArgBerliner$, Len(donutArgBerliner$)-1);
        
        'Now put the constructed stim sets into standard variables
        MValues$ := areaArgBerliner$;
        SValues$ := donutArgBerliner$;   
        
        ' Now if the core should be on the slave, we swap tunCurveMArg$/tunCurveSArg$ and MValues$/SValues$
        if tunBerlinerCoreOnSlave% <> 0 then
            var sb$;
            sb$ := tunCurveMArg$;
            TunCurveMArg$ := TunCurveSArg$;
            TunCurveSArg$ := sb$;
            sb$ := MValues$;
            MValues$ := SValues$;
            SValues$ := sb$;
        endif

        
    case tunType$ = tunTypeBoxODonuts$ then
        
        'If tunBoxODonutsNumGratingOption% is 0, do as current, if 1, we are doing curve 1 on "stim" and curve 2 on "distractor"
        'if 2, we are doing a grating tuning curve on "stim" in curve 1 and polka dots in curve 2
        'Since I don't know quite how we would ever work this (syntax-wise OR from a logical experimental point of view)
        'we will short circuit and force rivalry version to be on one grating no matter what the value says.
        
        docase
        case tunBoxODonutsNumGratingOption% = 0 or tunDoRivalry% = 1 then
            
            'Set slave values, do this first because master values may be set to slave values
            TunCurveSArg$ := " -" + TunType1$ + " ";
            TunCurveS2Arg$ := " -" + TunType2$ + " ";
            SValues$ := tun1ValuesStringified$;
            S2Values$ := tun2ValuesStringified$;
            
            'Set master values, based on whether the master should vary with TunCurve1 on slave or not
            if tunMasterFollowsCurve1% = 0 then        
                MGrat$ := " -g ";  'Change master grating variable to -g because it doesn't change
                TunCurveMArg$ := "";  'clear the tuning curve argument
                MValues$ := "";  'clear the tuning curve values
            else
                'Do not change master grating variable to -G
                TunCurveMArg$ := TunCurveSArg$;  'Set master tuning curve argument same as slave 1
                MValues$ := SValues$;  'Set master tuning curve values same as slave 1
            endif;    
            
            if tunDoRivalry% = 0 then
                MGrat$ := " -s ";  'change this back if we are not doing rivalry...the logic to get this to go is a bit ugly, but...
            endif;
            
        case tunBoxODonutsNumGratingOption% = 1 then
            
            'In principle this is what we need...note that the actual build of the command line is not done yet...
            
            'Set values for "Stimulus"
            TunCurveMArg$ := " -" + TunType1$ + " ";
            MValues$ := tun1ValuesStringified$;
            MGrat$ := " -s ";
            MGratParam$ := GetGratingParameters$("Stimulus");  'this would undo the setting of tunSetStationary
            
            'Set values for second grating, use "Distractor1" for values
            TunCurveM2Arg$ := " -" + TunType2$ + " ";
            M2Values$ := tun2ValuesStringified$;
            M2Grat$ := " -s ";
            M2GratParam$ := GetGratingParameters$("Distractor1");
            
            'Blank out values for "Slave"
            TunCurveSArg$ := ""; 
            SValues$ := "";
            SGrat$ := "";
            SGratParam$ := "";
            
        else 'tunBoxODonutsNumGratingOption% = 2, this is Polka Dots on Curve 2 (Polka Dots not allowed on Curve 1)
            
            'Set values for "Stimulus"
            TunCurveMArg$ := " -" + TunType1$ + " ";
            MValues$ := tun1ValuesStringified$;  
            MGrat$ := " -s ";
            MGratParam$ := GetGratingParameters$("Stimulus");  'this would undo the setting of tunSetStationary
            
            'Set values for Polka Dots
            TunCurveM2Arg$ := " -D ";
            M2Values$ := tun2ValuesStringified$; 
        
            'Set lag
            if tunPDLagFrames% = 0 then
                MConstantLag$ := "";
            else
                MConstantLag$ := " -E " + Str$(tunPDLagFrames%) + " ";
            endif;
        
            'Blank out values for M2Grat, "Slave"
            M2Grat$ := "";
            M2GratParam$ := "";
            TunCurveSArg$ := ""; 
            SValues$ := "";
            SGrat$ := "";
            SGratParam$ := "";
            
        endcase;
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 15, the duration of the initial "Box'O'Donuts" indicator pulse
            SampleSeqVar(11,15);
        endif
        
        
    case tunType$ = tunTypeGonzago$ then
        'set this up like BoxODonuts
        TunCurveSArg$ := " -" + TunType1$ + " ";
        TunCurveS2Arg$ := " -" + TunType2$ + " ";
        SValues$ := tun1ValuesStringified$;
        S2Values$ := tun2ValuesStringified$;
        
        'we kill this, and just use the "slave" (even though this is not rivalry
        MGrat$ := " -s ";  'Change master grating variable to -g because it doesn't change
        TunCurveMArg$ := "";  'clear the tuning curve argument
        MValues$ := "";  'clear the tuning curve values
        
        
    case tunType$ = tunTypeCRG$ then
        'Assign Primary/Secondary screen values, Secondary tuning curve argument
        ' 
        ' Deal with the confusion over the names of the two screens. 
        ' The "master" and "slave" screens refer to physical screens and do not change. Historically, they were the screens
        ' attached to the "master" and "slave" VSG cards, respectively. Now that we have moved to using dual VisAGE cards
        ' the "master" refers to the Visage on the same machine as the 1401 (the one running this script) resides. The "slave"
        ' refers to the second computer, which holds the second Visage card. 
        ' 
        ' For the CRG we have the notion of the "primary" screen - the one which runs the CRG, and the "secondary" screen, 
        ' which runs the other stim. 
        ' 
        ' There is a problem with the "slave" machine when the args to fixstim require a filename be passed. That machine
        ' MUST have its Z: drive mapped to the "master" machine's D: drive (DATA share). Also, the CRG input files must
        ' reside on the "master" computer's D: drive. When a CRG txt file must be passed as input to the slave machine, 
        ' its filename is modified so that D: becomes Z:, and the file should be found and used. This kinda sucks, and 
        ' it could be far more elegant, but I'm not into that right now. Make it work. 
        '
        ' So below we have to determine when to use the name of the seq file as-is, or when to change its drive letter. Yech.
        
        CRGPrimaryValues$ := Str$(tunCRGFramesPerFlip%) + "," + tunCRGSeqFile$ + "," + tun1ValuesStringified$;
        docase
        case tunType1$ = tunTypeContrast$ then
            CRGSecondaryArg$ := " -C ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeOrientation$ then
            CRGSecondaryArg$ := " -O ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeSpatial$ then
            CRGSecondaryArg$ := " -S ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeTemporal$ then
            CRGSecondaryArg$ := " -T ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeArea$ then
            CRGSecondaryArg$ := " -A ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeXPos$ then
            CRGSecondaryArg$ := " -X ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
            
        case tunType1$ = tunTypeCRG$ then
            CRGSecondaryArg$ := " -Y ";
            CRGSecondaryValues$ := Str$(tunCRGFramesPerFlip%) + "," + tunCRGSeqFile2$;
            ' DJS WARNING: i DON'T THINK THIS WORKS AS EXPECTED!?!
        'case tunType1$ = tunTypeBlank$ then  'Do nothing here, blank out values once we know which screen is which

        case tunType1$ = tunTypeGratingOnly$ then
            CRGSecondaryArg$ := " -C ";  'Yes, we do in fact treat it as contrast, the values should be 100 or 0 for on/off
            CRGSecondaryValues$ := tun2ValuesStringified$; 
        endcase;
         
        'Determine whether primary is master or slave screen, set master/slave values
        if tunCRGOnSlave% = 0 then 'primary on master
            TunCurveMArg$ := " -Y ";
            TunCurveSArg$ := CRGSecondaryArg$;
            MValues$ := CRGPrimaryValues$;
            SValues$ := CRGSecondaryValues$;
            if tunType1$ = tunTypeBlank$ then
                TunCurveSArg$ := "";
                SValues$ := "";
                SGrat$ := " -n ";
                SGratParam$ := "";
                'SlaveIndicator$ := "";
            else 
                if tunType1$ = tunTypeCRG$ then
                    ' oh-oh! CRG on slave, better change the drive letter in the filename. 
                    SValues$ := Str$(tunCRGFramesPerFlip%) + ",Z" + Mid$(tunCRGSeqFile2$, 2); 
                endif
            endif;
        else 'primary on slave
            TunCurveSArg$ := " -Y ";
            TunCurveMArg$ := CRGSecondaryArg$;
            SValues$ := Str$(tunCRGFramesPerFlip%) + ",Z" + Mid$(tunCRGSeqFile$, 2) + "," + tun1ValuesStringified$;
            MValues$ := CRGSecondaryValues$;
            if tunType1$ = tunTypeBlank$ then
                TunCurveMArg$ := "";
                MValues$ := "";
                MGrat$ := " -n ";
                MGratParam$ := "";
                'MasterIndicator$ := "";
            endif;
        endif;
        
    case tunType$ = tunTypeDots$ then
        'Dots is a fairly different beast, we'll need to do thing a bit differently than the others
        'build different background gray level string
        BGColor$ := " -b " +  "(" + Str$(tunDotsBGR%) + "/" + Str$(tunDotsBGG%) + "/" + Str$(tunDotsBGB%) + ") ";
        TunCurveMArg$ := " -D ";  'Dots on Master
        'holding on to trigger port for now, maybe needs to be cleared?
        MGrat$ := "";  'but clearing MGrat$
        MGratParam$ := "";  'and MGratParam$
        MasterIndicator$ := "";  'and MasterIndicator$
        'then buidling the grating spec
        MValues$ := "(" + Str$(tunDotsFGR%) + "/" + Str$(tunDotsFGG%) + "/" + Str$(tunDotsFGB%) + ")," 
                  + Str$(tunDotsX) + "," + Str$(tunDotsY) + "," + Str$(tunDotsDiameter) + "," 
                  + Str$(tunDotsSpeed) + "," + Str$(tunDotsDensity) + "," + Str$(tunDotsSize%) + ",";
        MValues$ := MValues$ + tunValuesStringified$;
        
    case tunType$ = tunTypeDanish$ then
        TunCurveMArg$ := " -H ";
        'Only set DGrat/DGratParam if we're using them
        DGrat$ := " -s ";
        DGratParam$ := GetGratingParameters$("Distractor1");  'the donut - this goes FIRST
        
    case tunType$ = tunTypeDSS$ then
        TunCurveMArg$ := " -H ";
        'Only set DGrat/DGratParam if we're using them
        DGrat$ := " -s ";
        DGratParam$ := GetGratingParameters$("Distractor1");  'the donut - this goes FIRST    
        
    case tunType$ = tunTypeNullTest$ then
        'if tunNullTestStepFunc% = 0 then
        '   TunCurveMArg$ := " -P " + Str$(tunNullTestTF) + ",s,";
        'else
        '    TunCurveMArg$ := " -P " + Str$(tunNullTestTF) + ",q,";
        'endif;
        TunCurveMArg$ := " -P ";  'New syntax turns null test into "phase tuning"      
        
    case tunType$ = tunTypeBakersDozen$ then
        'Do nothing here, file has been specified
        if tunSendINTANPulse% =  1 then
            'set sequencer variable 11 to 25, the duration of the initial "Baker's Dozen" indicator pulse
            SampleSeqVar(11,25);
        endif
        
    else

        Message("Error - unknown value for tunType$: " + tunType$);
        Halt;

	endcase;
	
    

    'Build command line, any values that are unnecessary will be empty, so the build should work no matter what type of command line is required
    docase
    case tunType$ = tunTypeFixptJump$ then
        'This is a specialized Baker's Dozen
        
        'We will create a file for this locally - different than usual BD which assumes a file has been created
        'This means we DO need to create stimulus lists, but we DON'T need to parse the file
        'The syntax for the file will be " -y arg1,arg2,...,argN -Z arg1,arg2,...,argN " <-- Note that the closing space following the final argument is OBLIGATORY and will result in a syntax error if omitted
        'Be sure that the text is printed on one line (no new lines/carriage returns) and to enclose the entire text with a single pair of double quotes as shown
        'Type           Flag    [min max] of argument, units
        'XYPosition     -Z      [-14 14], degrees from center. For XYPos args are paired and comma separated: x1,y1,x2,y2,...xN,yN
        'FixPtPosition  -y      [-14 14], degrees from center. For FixPtPos args are paired and comma separated: x1,y1,x2,y2,...xN,yN
        
        var tempstrFPJ$;

        FileOpen(tunFPJFileLoc$,8,1);  'Open file for writing loc, file loc is defined in TuningDialogs at declaration
        
        'Use tempstrFPJ$ to hold arguments
        tempstrFPJ$ := FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + Verbose$; 'prelim stuff
        tempstrFPJ$ := tempstrFPJ$ + MGrat$ + MGratParam$;  'Master grating only
        
        'Print tempstrFPJ$ and FPJ argument lists to the new file, this file is passed to FIXSTIM
        print("%s %s %s ",tempstrFPJ$,tunFPJFixptStr$,tunFPJGratingStr$);  'TODO, argument list not created, needs different variable name

        FileClose();
        
        tbtFix% := 2;  'Set trial-by-trial fixation location to ON, 2
        
        'Create command line, referencing new file
        cmdLine$ := Opener$ + ProgName$ + RemoteArg$ + " -F " + tunFPJFileLoc$;
        
 
    case tunType$ = tunTypeBakersDozen$ then
        'We will simply assume we need a file for this
        'The syntax for the file will be " -Flag1 arg1,arg2,...,argN -Flag2 arg1,arg2,...,argN ... -FlagN arg1,arg2,...,argN " <-- Note that the closing space following the final argument is OBLIGATORY and will result in a syntax error if omitted
        'Be sure that the text is printed on one line (no new lines/carriage returns) and to enclose the entire text with a single pair of double quotes as shown
        'Type           Flag    [min max] of argument, units
        'Orientation    -O      [0 360], degrees
        'Temporal Freq  -T      [0 100], Hz
        'Spatial Freq   -S      [0.01 100], cyc/deg
        'Contrast       -C      [0.1 100], percent contrast
        'Fixpt Color    -U      argument is a color vector of 0-255 in parens as (255/128/128) or 0-1 in square brackets as [0.5/0.5/1]
        'Area           -A      [0.1 100], degrees diameter
        'Phase          -P      [0 360], degrees phase 
        'XYPosition     -Z      [-14 14], degrees from center. For XYPos args are paired and comma separated: x1,y1,x2,y2,...xN,yN
        'XPosition      -X      [-14 14], degrees from center
        'Width/Height   --wh    [0.01 100], degrees width/height.  For W/H args are paired and comma separated: w1,h1,w2,h2,...wN,hN
        'DonutHole      -M      [0 100], degrees diameter of center hole
        'ColorVector    --colorvector    [b,l,m,s,[.2/.2/.8]-[.8/.8/.2],(220/15/220)-(15/220/15)], (b)lack/white,(l)-cone-iso,(m)-cone-iso,(s)-cone-iso, or color vector endpoints (two ways!)
        'CPTransFreq    -I      [0 100], Hz; for counterphase transition frequency
        '---Non-Grating values---
        'FixPtPosition  -y      [-14 14], degrees from center. For FixPtPos args are paired and comma separated: x1,y1,x2,y2,...xN,yN
        'StimDelay      -E      [0 100], seconds of stimulus onset delay
        'StimDuration   -t      [0 100], seconds of stimulus duration
        'Sweep          --sweep [?? ??]. For --sweep arguments come in triplets and are comma separated: dur1,dir1,deg/s1...durN,dirN,deg/sN
        'BMPImages      --bmp-image-order   [-1 N], is index of image in image input file, -1 indicates to present the grating, any other value presents an image
        
        'BakersDozen is NOT currently implemented for rivalry, dual-VSG, distractor gratings, or other nonsense like that!  Just one damn grating!
        
        'Read BakersDozen file from disk, write corresponding control file
        var BakersDozenLoc2$;
        var tempstr$;
        var tempchar$;
        var numRead%;
        var spaceLoc%;
        var commaLoc%;
        var valsPerSpec%;
        var curveIndex%;
        var fh%;
        var imageCount%;
        var XPos, YPos, tempW, tempH;  'To hold values from ParseGratingParametersBrief
        var ImagesArg$;
        
        'Get default x/y position of stimulus
        ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"), XPos, YPos, tempW, tempH);
        
        
        'Confirm presence of BakersDozen file
        ReadSetup(Chr$(7),Chr$(7));  'Setting hard/soft separators to nonsense "bell" character so no sepaarator will be found, empty 3/4 arg defaults to string delimited by double quotes
        fh% := FileOpen(tunBakersDozenFileLoc$,8,0);  'Open user-generated file, is NOT command-line ready
        if fh% < 0 then
            message("File open of %s returned error code %d, error is: %s\n",tunBakersDozenFileLoc$,fh%,Error$(fh%));
            printlog("File open of %s returned error code %d, error is: %s\n",tunBakersDozenFileLoc$,fh%,Error$(fh%));
            halt;
        endif;
        'Ensure user-generated Baker's Dozen file has a single string
        numRead% := Read(BDFullText$);  'place file contents into BDFullText$
        FileClose();  'Close file once it's read, we have a copy
        if numRead% <> 1 then
            message("Expected one string in Bakers Dozen file, got " + Str$(numRead%) + "!!  Quitting!!");
            halt;
        endif;
        
        '***
        '
        'Parse BDFullText$, necessary for changing fixation point location, but since we did it, also to SampleText the actual specs of each trial
        'Place values into tunBDTuningValues$[trial][whichTuningProperty], can remain as string, because in most cases we will be
        'SampleTexting, so it never has to be numeric; we will have to change the fixation to a numeric.
        'With the addition of interdigitated images to the Baker's Dozen capabilities, this parse has been moved
        'up in the code, it has to happen before we build the command line pieces we put into the copy of the BD file
        tempstr$ := BDFullText$;  'Make copy of the Baker's Dozen string
        
        'First space should be in location 1 of the string
        spaceLoc% := InStr(tempstr$," ");
        if spaceLoc% = 1 then
            tempstr$ := DelStr$(tempstr$,1,spaceLoc%);  'remove leading space
        else
            printlog("Problem with Baker's Dozen file syntax, did not find expected leading space!  Quitting!\n");
            halt
        endif
        
        'Now, alternately find grating specs and fill tunBDTuningValues$[][] until we run out of grating specs
        spaceLoc% := InStr(tempstr$," ");  'Find next space
        while spaceLoc% < Len(tempstr$) do
            if spaceLoc% > 0 then
                tempchar$ := Left$(tempstr$,spaceLoc%-1);  'Get leading character(s) corresponding to tuning type
                tempstr$ := DelStr$(tempstr$,1,spaceLoc%);  'Decrement string
                'printlog("Grating spec is %s\n",tempchar$);
                'printlog("Spec remainder is %s\n",tempstr$);
            else
                printlog("Problem with Baker's Dozen file syntax, did not find expected grating spec!  Quitting!\n");
                halt
            endif
            
            'Determine the type of tuning curve and number of values per grating spec
            docase
            case tempchar$ = "-O" then
                curveIndex% := 0;   'Curve index for orientation
                valsPerSpec% := 1;  'These grating specs have a single value per spec
            case tempchar$ = "-T" then 
                curveIndex% := 1;   'Curve index for temporal frequency
                valsPerSpec% := 1;  'These grating specs have a single value per spec
            case tempchar$ = "-S" then 
                curveIndex% := 2;   'Curve index for spatial frequency
                valsPerSpec% := 1;  'These grating specs have a single value per spec
            case tempchar$ = "-C" then
                curveIndex% := 3;   'Curve index for contrast
                valsPerSpec% := 1;  'These grating specs have a single value per spec
            case tempchar$ = "-U" then 
                curveIndex% := 4;   'Curve index for fixpt color
                valsPerSpec% := 1;  'These grating specs have a single value per spec
            case tempchar$ = "-A" then
                curveIndex% := 5;   'Curve index for area
                valsPerSpec% := 1;  'These grating specs have a single value per spec
            case tempchar$ = "-P" then
                curveIndex% := 6;   'Curve index for phase
                valsPerSpec% := 1;  'These grating specs also have a single value per spec
            case tempchar$ = "-X" then
                curveIndex% := 9;   'Curve index for x position
                valsPerSpec% := 1;  'These grating specs also have a single value per spec
            case tempchar$ = "-M" then
                curveIndex% := 12;  'Curve index for donut hole
                valsPerSpec% := 1;  'These grating specs also have a single value per spec
            case tempchar$ = "-E" then 
                curveIndex% := 15;  'Curve index for stimulus delay
                valsPerSpec% := 1;  'These grating specs also have a single value per spec
            case tempchar$ = "-t" then
                curveIndex% := 16;  'Curve index for stimulus duration
                valsPerSpec% := 1;  'These grating specs also have a single value per spec
            case tempchar$ = "-Z" then 
                curveIndex% := 7;   'Curve index for XY Position (7 is X, 8 is Y)
                valsPerSpec% := 2;  'These grating specs have a pair of values per spec
            case tempchar$ = "--wh" then
                curveIndex% := 10;  'Curve index for width/height (10 is width, 11 is height)
                valsPerSpec% := 2;  'These grating specs have a pair of values per spec
            case tempchar$ = "-y" then
                curveIndex% := 13;  'Curve index for Fixpt position (13 is X, 14 is Y)
                valsPerSpec% := 2;  'These grating specs have a pair of values per spec
                tbtFix% := 1;       'And set trial-by-trial fixation location to ON
                if tunUseMaintainMode% > 0 then
                    tunUseMaintainMode% := 0;
                    message("Maintain Fixation is incompatible with moving fixation points, Maintain Fixation has been turned OFF!");
                endif
            case tempchar$ = "--sweep" then
                curveIndex% := 17;  'Curve index for duration/direction/degPerSec (17 is duration, 18 is direction, 19 is degPerSec)
                valsPerSpec% := 3;  'These grating specs have a trio of values per spec
            case tempchar$ = "--colorvector" then
                curveIndex% := 20;  'Curve index for colorvector
                valsPerSpec% := 1;  'These grating specs have a single value per spec
            case tempchar$ = "--bmp-image-order" then
                curveIndex% := 21;  'Curve index for BMP image
                valsPerSpec% := 1;  'These grating specs have a single value per spec    
            case tempchar$ = "-I" then
                curveIndex% := 22;  'Curve index for Counterphase transition frequency
                valsPerSpec% := 1;  'These grating specs have a single value per spec 
            else
                'printlog("Grating spec " + tempchar$ + " unknown!  Quitting!\n");
                halt
            endcase
            tunBDWhichTunCurve[curveIndex%] := 1;
            
            'Count number of values in spec list
            BDNumStim% := 0;  'Is currently a zero-based index, reset every time through, last time through will persist, if lengths are not the same VSG will crash anyway
            'Find next space, there should always be one
            spaceLoc% := InStr(tempstr$," ");
            'Find next comma, there should always be one
            commaLoc% := InStr(tempstr$,",");
            while commaLoc% > 0 and commaLoc% < spaceLoc% do
                tempchar$ := Left$(tempstr$,commaLoc%-1);  'Get leading character(s) corresponding to tuning value
                tempstr$ := DelStr$(tempstr$,1,commaLoc%);  'Decrement string
                'printlog("Tuning value is %s\n",tempchar$);
                'printlog("Spec remainder is %s\n",tempstr$);
                tunBDTuningValues$[BDNumStim%][curveIndex%] := tempchar$;
                
                'If we are reading the image file specs, we need to know what kind of image we are looking at
                'Since we can have series, we need to know where the end is
                if curveIndex% = 21 then
                    tunBDImageIndex%[BDNumStim%] := Val(tempchar$);  'just keep the index
                    if Val(tempchar$) < 0 then  'not an image
                        tunBDImGrType%[BDNumStim%] := 0; '0 for not an image
                        imageCount% := 0;  'reset image count, in case?
                    else 
                        imageCount% += 1;  'it's an image, increment image count
                        if imageCount% < tunNImagesInSeries% then
                            tunBDImGrType%[BDNumStim%] := 1; '1 for primary/intermediate image
                        else
                            tunBDImGrType%[BDNumStim%] := 2; '2 for final image
                            imageCount% := 0;  'reset image count
                        endif
                    endif
                endif;
                
                if valsPerSpec% > 1 then  'if there are two values in this spec, read the second
                    'Find next comma, if we are at the last one in the entire sequence the value will be 0
                    commaLoc% := InStr(tempstr$,",");  
                    'Find next space, there should always be one
                    spaceLoc% := InStr(tempstr$," ");
                    if commaLoc% > 0 and commaLoc% < spaceLoc% then
                        tempchar$ := Left$(tempstr$,commaLoc%-1);  'Get leading character(s) corresponding to tuning value
                        tempstr$ := DelStr$(tempstr$,1,commaLoc%);  'Decrement string
                        tunBDTuningValues$[BDNumStim%][curveIndex%+1] := tempchar$;
                    endif
                endif
                
                if valsPerSpec% > 2 then  'if there are three values in this spec, read the third
                    'Find next comma, if we are at the last one in the entire sequence the value will be 0
                    commaLoc% := InStr(tempstr$,",");  
                    'Find next space, there should always be one
                    spaceLoc% := InStr(tempstr$," ");
                    if commaLoc% > 0 and commaLoc% < spaceLoc% then
                        tempchar$ := Left$(tempstr$,commaLoc%-1);  'Get leading character(s) corresponding to tuning value
                        tempstr$ := DelStr$(tempstr$,1,commaLoc%);  'Decrement string
                        tunBDTuningValues$[BDNumStim%][curveIndex%+2] := tempchar$;
                    endif
                endif
                
                'Increment number of stims, increment once for either single-value or dual-value specs, is now actual value
                BDNumStim% += 1;
                'Find next comma, if we are at the last one in the entire sequence the value will be 0
                commaLoc% := InStr(tempstr$,",");
                'Find next space, there should always be one
                spaceLoc% := InStr(tempstr$," ");
            wend
            'The FINAL value didn't get read, because either commaLoc% > spaceLoc% (more specs coming) or commaLoc% = 0 (final spec)
            'So read it!  SpaceLoc% finds the end for us
            tempchar$ := Left$(tempstr$,spaceLoc%-1);  'Get leading character(s) corresponding to tuning value
            tempstr$ := DelStr$(tempstr$,1,spaceLoc%);  'Decrement string
            'printlog("Final tuning value is %s\n",tempchar$);
            'printlog("Final spec remainder is %s\n",tempstr$);
            
            docase
            case valsPerSpec% = 1 then
                tunBDTuningValues$[BDNumStim%][curveIndex%] := tempchar$;  'BDNumStim% has been incremented, but not used for the final trial; it is the correct index for the final trial
                BDNumStim% += 1;  'Change BDNumStim% to the actual number of stimuli
            case valsPerSpec% = 2 then
                'printlog("BDNumStim-1 is %d and curveIndex+1 is %d\n",BDNumStim%-1,curveIndex%+1);
                tunBDTuningValues$[BDNumStim%-1][curveIndex%+1] := tempchar$;  'CurveIndex% adjusted for final value in spec; 
                                                                               'BDNumStim% has been updated and used for previous value in spec, then updated again, so it is the actual # of stimuli, must adjust indexing   
                'BDNumStim% is already actual number of stimuli
            case valsPerSpec% = 3 then 
                tunBDTuningValues$[BDNumStim%-1][curveIndex%+2] := tempchar$;  'CurveIndex% adjusted for final value in spec; 
                                                                               'BDNumStim% has been updated and used for previous value in spec, then updated again, so it is the actual # of stimuli, must adjust indexing 
                'BDNumStim% is already actual number of stimuli
            endcase
            
            
            'printlog("Number of stims is %d\n",BDNumStim%);
            
            'Find next space, if there is one
            spaceLoc% := InStr(tempstr$," ");
        wend
        'Done parsing BDFullText$
        '
        '***
        
        
        '***
        '
        'Open tunBakersDozenOCFileLoc$ if appropriate        
        'File format is:
        '
        '1 String1
        '0 String2
        '...
        '1 StringN
        '
        'Where the first column should be 0/1 only (indicates absence/presence of opto this trial) and the second
        'column is a string condition label.  Columns are separated by ANY combination of white space (single space
        'or tab is probably preferred, but Read() will deal with anything.  The ReadSetup() settings used here will
        'also accept spaces within StringN, but not tabs.  Anything following a tab delimiter in the StringN portion
        'will be ignored, but is not an error.  There are various ways of making this go wrong, like putting the
        'StringN portion first or putting something that is not a 0/1 in the first column, etc.  Just...don't?
        readsetup(""," ","","","	");
        var bailout%;
        var readCount%;
        'numRead% is reused from above, that's OK.
        if tunBDUseOCFile% = 1 then
            
            fh% := FileOpen(tunBakersDozenOCFileLoc$,8,0);  'Open user-generated opto/condition file
            if fh% < 0 then
                printlog("File open of %s returned error code %d, error is: %s\n",tunBakersDozenOCFileLoc$,fh%,Error$(fh%));
                return 0;
            endif;
            
            'Loop through file line by line
            while numRead% >= 0 and bailout% < 10000 do 'numRead% will be a negative error once EOF is reached
                numRead% := Read(tunTBTOpto%[readCount%],tunBDConditionLabel$[readCount%]);  'place file contents into tunTBTopto%[] and tunBDConditionLabel$[]
                bailout% += 1;  'don't get stuck in WHILE if something weird happens
                'Make sure we read the right number of fields.  Note that if there are too many fields, we will ignore.
                'If there are zero fields (blank line), we will gracefully skip.  So really, make sure that if there are
                'ANY fields at all on this line, there aren't too few.
                docase
                case numRead% = 2 then
                    readCount% += 1;
                case numRead% > 0 then
                    message("Read " + Str$(numRead%) + " fields from Opto/Condition file, this is wrong!  Quitting!");
                    halt;
                endcase
            wend
            FileClose();  'Close file once it's read, we have a copy
            if bailout% >= 10000 then
                message("Bailed out of WHILE loop while reading Opto/Condition file, either something went wrong or there were over 10000 lines!");
                halt;
            endif;
            if readCount% <> BDNumStim% then
                message("Read " + Str$(readCount%) + " stimuli from Opto/Condition file, expected " +  Str$(BDNumStim%) + ", this is wrong!  Quitting!");
                halt;
            endif;
        endif;
        'Done reading tunBakersDozenOCFileLoc$
        '
        '***
        
        
        '***
        '
        'Read image file, if specified
        if tunBDUseImageFile% = 1 then
            var imageStr$;
            'Open text file for reading
            fh% := FileOpen(tunBDImageFile$,8,0);
            if fh% < 0 then
                printlog("File open of %s returned error code %d, error is: %s\n",tunBDImageFile$,fh%,Error$(fh%));
                return 0;
            endif;
            i% := 0;
            'Read images
            readsetup(""," ","","","	");
            numRead% := Read(imageStr$);
            while numRead% > 0 do
                'fill tunBDImageList$[i%] with image name
                tunBDImageList$[i%] := imageStr$;
                i% += 1; 'increment index
                numRead% := Read(imageStr$);
            wend
            
            FileClose();
            
            if i% = 0 then
                printlog("No images successfully read from file %s, check file, do not allow blank space at beginning!\n",tunBDImageFile$);
                return 0;
            endif
            
            ImagesArg$ := " --bmp-image-list " + tunBDImageFile$ + "," + Str$(XPos) + "," + Str$(YPos) + "," + Str$(tunImageNLevels%) + " ";
            
        endif
        'Done reading image file
        '
        '***
        
        
        'Add "_bakersdozen_ctrl" to end of file name, if extension is 3 chars, will slide in before extension
        'otherwise (no extension, or 2/4/etc. char extension) will just tack on to end
        tempstr$ := Right$(tunBakersDozenFileLoc$,4);  'Get putative extension (probably .txt), assume . + 3 chars; can just reuse tempstr$
        tempchar$ := Left$(tempstr$,1);  'Get first char of putative extension
        if tempchar$ = "." then
            BakersDozenLoc2$ := Left$(tunBakersDozenFileLoc$,Len(tunBakersDozenFileLoc$)-4) + "_bakersdozen_ctrl" + tempstr$;
        else
            BakersDozenLoc2$ := tunBakersDozenFileLoc$ + "_bakersdozen_ctrl";
        endif;
        
        'Open new file for writing, rather than overwrite user-generated file, user-generated file can be reused.
        FileOpen(BakersDozenLoc2$,8,1);
        
        'Reuse tempstr$ again to hold arguments
        tempstr$ := FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + Verbose$ + ImagesArg$; 'prelim stuff
        tempstr$ := tempstr$ + MGrat$ + MGratParam$;  'Master grating only, tuning curve values are in the file
        
        'Print to the new file, this file is passed to FIXSTIM
        print("%s %s",tempstr$,BDFullText$);
        FileClose();        
        

        
        'printlog("BDNumStim is %d\n",BDNumStim%);
        tunNAdvances% := BDNumStim%;
        tunNValues% := BDNumStim%;
        
        
        'Create command line, referencing new file
        cmdLine$ := Opener$ + ProgName$ + RemoteArg$ + " -F " + BakersDozenLoc2$;
        
        
    case tunDoRivalry% = 0 then
        cmdLine$ := Opener$ + ProgName$ + RemoteArg$ + FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + Verbose$; 'prelim stuff
        cmdLine$ := cmdLine$ + RefrLock$ + OffsetFile$ + StimDur$;  'Dual VSG stuff
        cmdLine$ := cmdLine$ + MasterIndicator$ + DGrat$ + DGratParam$ + MGrat$ + MGratParam$ + TunCurveMArg$ + MValues$ + MConstantLag$;  'Master grating stuff
        cmdLine$ := cmdLine$ + M2Grat$ + M2GratParam$ + TunCurveM2Arg$ + M2Values$;  'Master grating stuff, second grating (only box o' donuts on two gratings)
        cmdLine$ := cmdLine$ + SlaveIndicator$ + SGrat$ + SGratParam$ + TunCurveSArg$ + SValues$;  'Slave grating stuff
        cmdLine$ := cmdLine$ + TunCurveS2Arg$ + S2Values$;  'Second slave parameters (for Box O' Donuts, more possible)
                
        
        ' Initial text marks
        ' djs Always version 3. NO difference if maintainmode is used or not. 
        SampleText("Tuning,3," + str$(Len(cmdLine$)));
        SampleText(tunCVSID$);
        for i% := 1 to Len(cmdLine$) step 100 do
            SampleText(Mid$(cmdLine$, i%, 100));
        next

    else
        fileM$ := GetDataPathRoot$() + "\\tunMaster.txt";
        fileS$ := GetDataPathRoot$() + "\\tunSlave.txt";         ' Will change this below, once file has been created, to the "slave" version
        tailM$ := FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + " -V 128,FS " + Verbose$ + DGrat$ + DGratParam$ + MGrat$ + MGratParam$ + TunCurveMArg$ + MValues$ + MConstantLag$;
        tailS$ := FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + " -V 128,FS " + Verbose$ + SGrat$ + SGratParam$ + TunCurveSArg$ + SValues$ + TunCurveS2Arg$ + S2Values$ + SConstantLag$;
        
        if createCmdTextFile%(fileM$, tailM$) <> 1 or createCmdTextFile%(fileS$, tailS$) <> 1 then
            Message("ERROR!|Cannot create tunMaster.txt or tunSlave.txt");
            halt;
        endif
        fileS$ := GetDataPathRootSlave$() + "\\tunSlave.txt";         ' Will change this below, once file has been created, to the "slave" version
        LogInfo("Master tuning parameters file: " + fileM$);
        LogInfo("Slave tuning parameters file: " + fileS$);
        
        cmdLineM$ := OpenerM$ + ProgName$ + RemoteArgM$ + " -F " + fileM$;
        cmdLineS$ := OpenerS$ + ProgName$ + RemoteArgS$ + " -F " + fileS$;
        
        'djs hack 4-22-2016
        ' The -l ### arg (l as in ell, not one) specifies a delay, in ms, prior to fixstim issuing the ready pulse. 
        ' I send it to the SLAVE so it waits until after sampling has started. This is not guaranteed to work - if the 
        ' MASTER dallies long enough before issuing the trigger to start sampling, then this delay on the SLAVE may not 
        ' be enough. A more robust, and complex, way to make it work would be to look for the MASTER ready pulse, and when
        ' received, THEN start the slave fixstim program. Sounds like a lot of hassle to me. 
        cmdLineS$ += " -l 500";
        
        'cmdLineM$ := OpenerM$ + ProgName$ + FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + " -V 128 " + Verbose$;
        'cmdLineM$ := cmdLineM$ + DGrat$ + DGratParam$ + MGrat$ + MGratParam$ + TunCurveMArg$ + MValues$;
        'cmdLineS$ := OpenerS$ + ProgName$ + " -c 192.168.1.2:7000 " + FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + " -n -V 128 " + Verbose$;
        'cmdLineS$ := cmdLineS$ + SGrat$ + SGratParam$ + TunCurveSArg$ + SValues$ + TunCurveS2Arg$ + S2Values$;
        
        PrintLog("Master: " + cmdLineM$ + "\n");
        PrintLog("tunMaster.txt: %s\n", tailM$);
        PrintLog("Slave: " + cmdLineS$ + "\n");
        PrintLog("tunSlave.txt: %s\n", tailS$);
        
        ' Initial text marks
        
        docase
        case tunType$ = tunTypeBoxODonuts$ then    
            if tunUseMaintainMode% >= 1 then  'if fixation point stays on, extraction is version 6
                SampleText("Tuning,6," + str$(Len(tailM$)) + "," + str$(Len(tailS$)));
            else 'value is 0, fixation point goes off, extraction is version 7
                SampleText("Tuning,7," + str$(Len(tailM$)) + "," + str$(Len(tailS$)));
            endif;
        case tunType$ = tunTypeCRG$ then
            SampleText("Tuning,8," + str$(Len(tailM$)) + "," + str$(Len(tailS$)));
        else
            ' djs Always version 3. NO difference if maintainmode is used or not. 
            SampleText("Tuning,3," + str$(Len(tailM$)) + "," + str$(Len(tailS$)));
        endcase;
        
        SampleText(tunCVSID$);
        
        for i% := 1 to Len(tailM$) step 100 do
            SampleText(Mid$(tailM$, i%, 100));
        next
        for i% := 1 to Len(tailS$) step 100 do
            SampleText(Mid$(tailS$, i%, 100));
        next
        
    endcase
        
    ' Record initial text marks. The command line may need to be broken into pieces.
    ' For tuning: Version 6,7 are always box--o-donuts
    ' Version 8 is CRG.
    
'    docase
'    case tunType$ = tunTypeBoxODonuts$ then    
'        if tunUseMaintainMode% >= 1 then  'if fixation point stays on, extraction is version 6
'            SampleText("Tuning,6," + str$(Len(cmdLine$)));
'        else 'value is 0, fixation point goes off, extraction is version 7
'            SampleText("Tuning,7," + str$(Len(cmdLine$)));
'        endif;
'    case tunType$ = tunTypeCRG$ then
'        SampleText("Tuning,8," + str$(Len(cmdLine$)));
'    else
'        ' djs Always version 3. NO difference if maintainmode is used or not. 
'        SampleText("Tuning,3," + str$(Len(cmdLine$)));
'    endcase;
'    
'    SampleText(tunCVSID$);
'    for i% := 1 to Len(cmdLine$) step 100 do
'        SampleText(Mid$(cmdLine$, i%, 100));
'    next
    
    'if command line is too long, do file version
    if Len(cmdLine$) > 8000 then
        cmdLine$ := "cmd /k " + bin$ + ProgName$ + RemoteArg$ + " -F " + specFileName$;
        'open a file to write the trial-by-trial specs for the VSG
        specHandle% := FileOpen(specFileName$, 8, 1);
        'print to spec file
        Print("%s",FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + Verbose$);  'file should be everything starting from FixationArg$ on, prelim stuff
        Print("%s",RefrLock$ + OffsetFile$ + StimDur$);  'Dual VSG stuff
        Print("%s",MasterIndicator$ + DGrat$ + DGratParam$ + MGrat$ + MGratParam$ + TunCurveMArg$ + MValues$ + MConstantLag$);  'Master grating stuff
        Print("%s",M2Grat$ + M2GratParam$ + TunCurveM2Arg$ + M2Values$);  'Master grating stuff, second grating (only box o' donuts on two gratings)
        Print("%s",SlaveIndicator$ + SGrat$ + SGratParam$ + TunCurveSArg$ + SValues$);  'Slave grating stuff
        Print("%s",TunCurveS2Arg$ + S2Values$);  'Second slave parameters (for Box O' Donuts, more possible)
        'close spec file
        FileClose(0);
    endif;
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",tunNAdvances%,tunNRepeats%);
    
    if tunDoRivalry% = 0 then
        StimHandle% := ProgRun(cmdLine$, 1);
        if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
    else
        StimHandle% := ProgRun(cmdLineM$, 1);       
        StimHandleSlave% := ProgRun(cmdLineS$, 1);
    endif
    
    
    
    'If we are asking the eyetracker to record an output file, open the file and start recording
    if RecordEyeTrackerOutputFile% = 1 then
        SafeSampleKey("I");  'Open the file (this is done by setting a DIGLOW bit), file name will be saved in a sampletext
        yield(0.5);
        SafeSampleKey("W");  'Begin recording the file
        yield(0.5);
    endif
    
    
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(5);
return 1;
end;


func createCmdTextFile%(filename$, cmd$)
    if FileOpen(filename$, 8, 1) > 0 then
        Print(cmd$);
        FileClose();
        return 1;
    else
        return -1;
    endif
    return -1;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawFix
' 
' Draws fixation point/window in xy window (iDraw%==1 or 2) or blanks it (0). 
proc DrawFix(iDraw%)
    'Updated to allow trial-by-trial fixation point location, put up and take down fixation window with fixation point
    var localX, localY;
    'Calcuate the fixation window
	var index%;
	var twopi;
    var localFixWindowX[36],localFixWindowY[36];
	twopi := 2.0*4.0*ATan(1.0);
	
    docase
    case iDraw% = 2 then
        ' erase the central dot and window from xy view
        View(XYWindow%).XYDelete(iFixptChannel%);
        View(XYWindow%).XYDelete(iFixptWindowChannel%);
        
        localX := tbtFixX;
		localY := tbtFixY;
        'Create fixation window
        for index% := 0 to 35 do
            localFixWindowX[index%] := localX + WindowRadius * Cos(index% * twopi/36.0);
            localFixWindowY[index%] := localY + WindowRadius * Sin(index% * twopi/36.0);
        next;
		'Draw stimulus in xy window
		View(XYWindow%).XYAddData(iFixptChannel%, localX, localY);
        'Draw the fixation window
        View(XYWindow%).XYAddData(iFixptWindowChannel%, localFixWindowX[], localFixWindowY[]);
	case iDraw% = 1 then
		localX := FixationX;
		localY := FixationY;
        'Create fixation window
        for index% := 0 to 35 do
            localFixWindowX[index%] := localX + WindowRadius * Cos(index% * twopi/36.0);
            localFixWindowY[index%] := localY + WindowRadius * Sin(index% * twopi/36.0);
        next;
		'Draw stimulus in xy window
		View(XYWindow%).XYAddData(iFixptChannel%, localX, localY);
        'Draw the fixation window
        View(XYWindow%).XYAddData(iFixptWindowChannel%, localFixWindowX[], localFixWindowY[]);
	else 
		' erase the fixpt and the window from xy view
		View(XYWindow%).XYDelete(iFixptChannel%);
        View(XYWindow%).XYDelete(iFixptWindowChannel%);
	endcase

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
	'	PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
    
    if n% > tunMaxTrials% then
        message("You have requested " + Str$(n%) + " trials, max is " + Str$(tunMaxTrials%) + "!  Quitting!");
        halt
    endif;
    
    
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += str$(vec[ind%[i%]]);
	next
	return s$;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of color vectors into a comma separated string
' This will only work for integer (0-255) color vectors, will have to adapt or write a new function for [0-1] color vectors
Func StringifyColorProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
    
    if n% > tunMaxTrials% then
        message("You have requested " + Str$(n%) + " trials, max is " + Str$(tunMaxTrials%) + "!  Quitting!");
        halt
    endif;
    
    
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += GetFixptColorThisTrial$(i%,vec[],ind%[]);
	next
	return s$;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
' Here we will use a "reference" vector to determine whether to pass a value or not
' This is designed for the 2-screen CRG experiments.  The progression for the secondary screen will be
' a series of zeros and 100s.  If 0, we want the secondary screen to be blank, so we insert -1.  If non-zero,
' we want the secondary screen to have the same SEQfile index as the main screen, so we refer back to the
' main screen value.
Func StringifyProgressionCRG2$(n%, refvec[], refind%[], vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
        if refvec[refind%[i%]] = 0 then
            s$ += str$(-1);
        else
            s$ += str$(vec[ind%[i%]]);
        endif;
	next
	return s$;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of color vectors into a comma separated string
' This will only work for integer (0-255) color vectors, will have to adapt or write a new function for [0-1] color vectors
Func StringifyPolkaDotProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
    
    if n% > tunMaxTrials% then
        message("You have requested " + Str$(n%) + " trials, max is " + Str$(tunMaxTrials%) + "!  Quitting!");
        halt
    endif;
    
    
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += GetPolkaDotColorThisTrial$(i%,vec[],ind%[]);
	next
	return s$;
end;

func GetPolkaDotColorThisTrial$(n%,tValues[],tValuesIndices%[])  'This function is written assuming integer gun values, should be easy enough to adapt for 0-1 gun values if necessary
    'In order to use this function to get fixpt colors in both regular and Box'O'Donuts version, we have to pass the proper tunValues/tunValuesIndices%[]
    var val%;
    var f$;
    val% := tValues[tValuesIndices%[n%]];
    docase
    case tunPDGunIndex% = 0 then  'if tuned gun is red
        f$ := "(" + Str$(val%) + "/" + Str$(tunPDGreenValue%) + "/" + Str$(tunPDBlueValue%) + ")";
    case tunPDGunIndex% = 1 then  'if tuned gun is green
        f$ := "(" + Str$(tunPDRedValue%) + "/" + Str$(val%) + "/" + Str$(tunPDBlueValue%) + ")";
    case tunPDGunIndex% = 2 then  'if tuned gun is blue
        f$ := "(" + Str$(tunPDRedValue%) + "/" + Str$(tunPDGreenValue%) + "/" + Str$(val%) + ")";
    case tunPDGunIndex% = 3 then  'if tuning is on luminance
        f$ := "(" + Str$(val%) + "/" + Str$(val%) + "/" + Str$(val%) + ")";
    endcase
    return f$;
end;



'InterleavePDStrings$ will do the string interleave for creating a PolkaDot spec.
'The PolkaDot spec is dot1;dot2;dot3;...dotN 
'where "dotN" is x,y,d,(RRR/GGG/BBB)
'Inputs will be x$, y$ (must be same length), d$ (must be single value), c$, n%
'Note that this function assumes that the x$/y$ strings are already "gridded"
'd$ is the diameter, just a single value
'c$ is a comma-separated string of color specs
'n% is the number of repeats
'This function runs color on the outside loop, so without randomization it
'will progress through position before color

func InterleavePDStrings$(x$,y$,d$,c$,n%)
    var i%;
    var cind%;
    var xind%;
    var yind%;
    var out$;
    var xcopy$;
    var ycopy$;
    var ccopy$;
    var mycount%;
    c$ := c$ + ",";  'Add comma to end of c$
    x$ := x$ + ",";  'Add comma to end of x$
    y$ := y$ + ",";  'Add comma to end of y$
    xcopy$ := x$;  'keep copy of x$, we will be cutting original
    ycopy$ := y$;  'keep copy of y$, we will be cutting original
    ccopy$ := c$;  'keep copy of c$, we will be cutting original, will reuse for each repeat
    
    for i% := 1 to n% do
        c$ := ccopy$;  'refresh c$ for every repeat
        cind% := InStr(c$,",");  'get index of first comma remaining in c$
        'loop through each color spec
        while cind% > 0 and mycount% < 10000 do 
            x$ := xcopy$;  'refresh x$ for every color spec
            y$ := ycopy$;  'refresh y$ for every color spec
            xind% := InStr(x$,","); 'get index of first comma remaining in x$
            'loop through each x position
            while xind% > 0 and mycount% < 10000 do
                yind% := InStr(y$,","); 'get index of first comma remaining in y$
                out$ += Left$(x$,xind%-1);  'add xval to output
                out$ += ",";  'add comma to output
                out$ += Left$(y$,yind%-1);  'add yval to output
                out$ += ",";  'add comma to output
                out$ += d$;  'add diameter to output
                out$ += ",";  'add comma to output
                out$ += Left$(c$,cind%-1);  'add color to output
                out$ += ";";  'add semicolon to output to separate Dot specs
                
                x$ := DelStr$(x$,1,xind%); 'remove xval and comma from x$
                y$ := DelStr$(y$,1,yind%); 'remove yval and comma from y$
                
                'get next xind
                xind% := InStr(x$,",");
                mycount% += 1;
            wend;
            mycount% += 1;  'just in case it's the inner loop
            c$ := DelStr$(c$,1,cind%); 'remove color spec and comma from c$
            cind% := InStr(c$,",");  'get index of first comma remaining in c$
        wend;
    next
    
    if mycount% >= 10000 then
        printlog("In InterleavePDStrings, mycount is %d\n",mycount%);
        printlog("This either indicates that the function got stuck in a WHILE loop or there were too many trials requested!\n");
        message("Too many trial requested!")
    endif
    
    
    'Then there will be one extra semicolon left over
    out$ := Left$(out$,len(out$)-1);
    
    return out$;
    
    
end;




'This function shuffles a Polka Dot tuning string based on the
'provided indices, returning a shuffled string.  Also, fills
'the provided dotSpecs$[] array with the SHUFFLED trial specs.
'Thus, when we ask for the dot specs on each trial we will index
'with the trial number, not for indices%[trial number%]
func ShufflePDTuningString$(n%,ind%[],origString$,&dotSpecs$[])
    var outString$;
    var i%;
    var scind%;
    var temp$;
    var ind2%;
    var arr%[n%];
    
    'Deconstruct origString$
    for i% := 0 to n%-2 do  'final value will not have a semicolon
        ArrConst(arr%[0:n%],ind%[0:n%]);  'cut off excess zeroes at end of ind%[]
        ArrSub(arr%[],i%);  'Subtract current index, location of current index will be 0
        Abs(arr%[]);  'Take ABS, location of all non-current indices will be positive
        ind2% := Min(arr%[]);  'Find the zero with MIN
        scind% := InStr(origString$,";");  'get index of first semicolon remaining in origString$
        dotSpecs$[ind2%] := Left$(origString$,scind%-1); 'place dot spec into correct index of dotSpecs$[]
        origString$ := DelStr$(origString$,1,scind%); 'remove dot spec and semicolon from origString$
    next
    ArrConst(arr%[0:n%],ind%[0:n%]);  'cut off excess zeroes at end of ind%[]
    ArrSub(arr%[],n%-1);
    Abs(arr%[]);
    ind2% := Min(arr%[]);
    'dotSpecs$[ind%[n%-1]] := origString$;  'Place final value (no semicolon at end) into final index
    dotSpecs$[ind2%] := origString$;  'Place final value (no semicolon at end) into final index
    
    'Reconstruct outString$
    for i% := 0 to n%-2 do 'final value will not get a semicolon
        outString$ += dotSpecs$[i%];  'add ith dot spec
        outString$ += ";";  'add separating semicolon
    next
    outString$ += dotSpecs$[n%-1]; 'add final dot spec
    
    return outString$;
end;




'This function differs from the original version because it is designed to work
'in the box-o-donuts case.
'n% - the total number of repeats
'nb%  - the number of stimuli in a block (shuffle will be done within block)
'grInd%[] - the grating values indices (will be shuffled)
'pStr$ -  the unscrambled polka dot string
'dotSpecs$[] - will be filled with the dot specs for each trial
'Will return the shuffled version of the polka dot string, for the command line
'as well as fill a dotSpec string array (index by trial index N-1 to get polka
'dot value on trial N) and shuffle the grating values indices with the same
'shuffle.  Note that the stringified version of the gratings is not made here.
'Note that indexing of grating value is as normal: tunValues[tunValuseIndices%[N-1]]
func ShufflePDTuningStringBox$(n%,nb%,&grInd%[],pStr$,&dotSpecs$[]);
    var outString$;
    var shuffInd%[nb%];  'shuffled indices, length of block
    var arr%[nb%];  'temporary array to manipulate shuffled indices
    var grIndCopy%[nb%];
    var i%, j%;
    var ind%;  'index into grInd%[]
    var ind2%;  'index into dotSpecs$[]
    var scind%;
    
    for i% := 0 to n%-1 do
        ArrConst(grIndCopy%[0:nb%],grInd%[(i%*nb%):nb%]);  'Copy grating indices for this block
        Shuffle%(nb%,shuffInd%[]);  'Put shuffled indices into shuffInd%[]
        
        for j% := 0 to nb%-1 do
            'Shuffle grating indices
            grInd%[ind%] := grIndCopy%[shuffInd%[j%]];  'easy
            ind% += 1;  'increment index into grInd%[]
            
            'Shuffle string of polka dot specs
            'Final value in pStr$ does not have a trailing semicolon, so code has to be slightly different
            if j% = nb%-1 and i% = n%-1 then 'this is the final entry
                ArrConst(arr%[0:nb%],shuffInd%[0:nb%]);  're-fill arr%[]
                ArrSub(arr%[],j%);  'Subtract current index, location of current index will be 0
                Abs(arr%[]);  'Take ABS, location of all non-current indices will be positive
                ind2% := Min(arr%[]);  'Find the zero with MIN
                dotSpecs$[ind2%+(i%*nb%)] := pStr$;  'Place final value (no semicolon at end) into final index                  
            else 'this is the standard case
                ArrConst(arr%[0:nb%],shuffInd%[0:nb%]);  're-fill arr%[]
                ArrSub(arr%[],j%);  'Subtract current index, location of current index will be 0
                Abs(arr%[]);  'Take ABS, location of all non-current indices will be positive
                ind2% := Min(arr%[]);  'Find the zero with MIN
                scind% := InStr(pStr$,";");  'get index of first semicolon remaining in pStr$
                dotSpecs$[ind2%+(i%*nb%)] := Left$(pStr$,scind%-1); 'place dot spec into correct index of dotSpecs$[]
                pStr$ := DelStr$(pStr$,1,scind%); 'remove dot spec and semicolon from origString$
            endif;
            
        next

    next
    
    'reconstruct shuffled polka dot string from ordered dot specs
    for i% := 0 to (n%*nb%)-2 do
        outString$ += dotSpecs$[i%];  'add current dot spec
        outString$ += ";";  'add separating semicolon
    next
    outString$ += dotSpecs$[(n%*nb%)-1];  'add current dot spec
    
    
    return outString$;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'A function to concatenate copies of the grating indices, for the Box-o-Donuts version
'n% - number of times to expand to match polka dot string
'nR% - number of repeats
'len% - number of values in grating tuning curve
'ind%[] - original index list, will be filled with new expanded indices 
func ExpandGratingIndices(n%,nR%,len%,&ind%[]);
    var temp%[len%];
    var x%;  'to index ind%[]
    var i%, j%;
    ArrConst(temp%[0:len%],ind%[0:len%]); 'get a copy of indices
    
    for i% := 1 to len%*nR% do
        j% := i% mod len%;
        if j% = 0 then
            j% := len%;
        endif;
        ArrConst(ind%[x%:n%],temp%[j%-1]);
        x% += n%;
    next

    return 0;
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'A function to concatenate copies of the polka dot string, for the Box-o-Donuts version
func ExpandPDTuningString$(n%,inStr$);
    var out$;
    var i%;
    
    for i% := 1 to n% do
        out$ := out$ + inStr$;
        if i% < n% then
            out$ := out$ + ";"; 'inStr$ will not have a trailing semicolon, add trailing semicolon to all except final copy, which is expected to lack it
        endif
    next
    
    
    return out$
end







func SelectWavemarkDialog%()
	var iReturn%:=1;
	var i%;
    var whichWaveMark% := 1;
	DlgCreate("Select Wavemark");
	DlgInteger(1, "Input Wavemark to view, -1 for all", -1, 256);  'max is based on highest possible wavemark value
    
	i% := DlgShow(whichWaveMark%);

	if i% = 1 then
		PrintLog("SelectWavemarkDialog - user hit OK\n");
        for i% := 0 to tunNWavemarks%-1 do  'for each wavemark channel
            View(DataWindow%).MarkMask(i%+1,0,0,-1);  'exclude all codes on layer 0
            View(DataWindow%).MarkMask(i%+1,0,1,whichWaveMark%);  'then include requested code (or all, if -1) on layer 0
        next;       
	endif;
	if i% = 0 then
		PrintLog("SelectWavemarkDialog - user hit Cancel\n");
	endif;
    'PrintLog("Return value is %d\n", iReturn%);  'always return 1, so don't bother reporting this
	return iReturn%;
end;


proc ClearMasterOrSlaveIfNecessary(&SGrat$,&SGratParam$,&SlaveIndicator$,&TunCurveSArg$,&SValues$,&MGrat$,&MGratParam$,&MasterIndicator$,&TunCurveMArg$,&MValues$)
    'Clear master/slave if there is only one tuning curve to do. 
    'Note that SlaveIndicator$ and MasterIndicator$ are no longer changed, but still in the subject line so I don't have to change everything else
    'djs - Changing to use fixstim for everything. Null stim set uses -N arg - this will use any fixpt and xhair arg, but no grating.
    if tunDualTuningType% = 1 then        
        SGrat$ := "";  'clear slave grating
        SGratParam$ := "";  'clear slave grating params
        TunCurveSArg$ := " -N ";  'tuning curve argument for no tuning curve
        SValues$ := "";  'clear the tuning curve values
    endif
    if tunDualTuningType% = 2 then        
        MGrat$ := "";  'clear master grating
        MGratParam$ := "";  'clear master grating params
        TunCurveMArg$ := " -N ";  'clear the tuning curve argument
        MValues$ := "";  'clear the tuning curve values
    endif;
end;



func CheckSeqFile%(fileIn$,&nFlips%);
    var fh0%;
    var numRead%;
    var readLine$[2];
    var keepGoing% := 1;
    var nFlipsFirst%;
    var nFlipsSubsequent%;
    var loopedOnce%;
    var lineLength%;
    var expectStr%[50];
    var i%;
    var nCh%;  'number of characters
    var lineCount%;
    
    fh0%:=FileOpen(fileIn$,8,0);
    nFlips% := 0;
    lineCount% := 0;
    
    ' Make sure file was opened. If it wasn't leave lineCount% == 0. We return lineCount%-1 later, so 
    ' this will lead to a negative return code. 
    if fh0% < 0 then
        message("ERROR! Cannot open sequence file " + fileIn$);
    else
        
        ' OK file open. Lets read. 
        readsetup(""," ","","","	");
        
        while keepGoing% do
            'Read the next line in the file, return line and number of fields read
            numRead% := read(readLine$[0:2]);
            'And update the number of lines read
            lineCount% += 1;
            
            'Here we expect exactly one field per line, if there is more than one, this is an error, quit
            if numRead% > 1 then
                message("ERROR!!!|Expected exactly one field on line " + Str$(lineCount%) + ",\ngot " + Str$(numRead%) + " fields!");
                fileclose();  'close fh0%, the currently open file             
                halt;
            endif;
            
            'Get the number of flips in the line
            docase
            case loopedOnce% = 0 then
                nFlipsFirst% := Len(readLine$[0]);
                loopedOnce% := 1;  'don't do this again
            case numRead% >= 0 then 'Make sure all lines are the same length
                nFlipsSubsequent% := Len(readLine$[0]);
                if nFlipsFirst% <> nFlipsSubsequent% then
                    message("ERROR!!!|On line " + Str$(lineCount%) + " expected " + Str$(nFlipsFirst%) + " flips,\ngot " + Str$(nFlipsSubsequent%) + "!");
                    fileclose();  'close fh0%, the currently open file
                    halt;
                endif;
            case numRead%<0 then
                keepGoing% := 0;
            endcase;    
            
            'Make sure there are nothing but zeros or ones
            for i% := 0 to len(readLine$[0])-1 do
                if mid$(readLine$[0],i%+1,1) <> "1" and mid$(readLine$[0],i%+1,1)  <> "0" then
                    message("ERROR!!!|On line " + Str$(lineCount%) + " found unexpected character " + mid$(readLine$[0],i%+1,1) + "!");
                    fileclose();  'close fh0%, the currently open file
                    halt;
                endif;
            next;
            
        wend;    
        
        fileclose();  'close fh0%, the currently open file
        
        printlog("Successfully read file %s, contained %d lines with %d flips per line!\n",fileIn$,lineCount%-1,nFlipsFirst%);
        
        nFlips% := nFlipsFirst%;  'set nFlips%, which sets the flips variable sent in the call    
        
    endif
    return lineCount%-1;
    
end



func WhichButton%(&startT,endT,&bStatus%,&buttonT)
	'Determine which button is pressed, if any
    'Read the button channel, of course
    'Note - another very ad-hoc function, which assumes lots of variables we know exist
    'Man, this function does a lot of stuff, hopefully it will all be useful 
    
    
    'Clear the button press arrays
    button1Press := -1;
    button2Press := -1;
    button1Release := -1;
    button2Release := -1;

    'Each check will return -1 if there are no events of that type, time of event if there is one
    'Check for button 1 (left) press
    button1Press := View(DataWindow%).ChanSearch(ButtonChannel%,8,startT+tic,endT,button1Thresh,buttonHysteresis,buttonMinTime);
    
    'Check for button 1 (left) release
    button1Release := View(DataWindow%).ChanSearch(ButtonChannel%,7,startT+tic,endT,button1Thresh,buttonHysteresis,buttonMinTime); 
    
    'Check for button 2 (right) press
    button2Press := View(DataWindow%).ChanSearch(ButtonChannel%,7,startT+tic,endT,button2Thresh,buttonHysteresis,buttonMinTime);
    
    'Check for button 2 (right) release
    button2Release := View(DataWindow%).ChanSearch(ButtonChannel%,8,startT+tic,endT,button2Thresh,buttonHysteresis,buttonMinTime);
    
        
    'OK, I'm trying to take out the startT := endT lines when nothing happens - it's possible things are being missed
    'due to buttonMinTime and then skipped because the tiem moves forward.
    
    'Now do a whole bunch of checking to make sure there aren't any errors, update startT and bStatus% if necessary,
    'and hopefully return success
    'This is all nice and complicated, but thorough check and a response matrix of all possible press combos suggests
    'that every contingency is dealt with.  Even under most error conditions it returns a value.  I need to consider
    'what happens in the case that something goes wrong...a flush might not work depending on return values/states and
    'what is expected.
    docase
    case button1Press = -1 and button2Press = -1 and button1Release = -1 and button2Release = -1 then 'nothing happened on this check
        'startT := endT;
        buttonT := -1;
        return 1;
    case bStatus% = 0 then  'initial status is no button pressed
        'check for either button press
        docase
        case button1Press <= -1 and button2Press <= -1 then  'no button pressed
            'startT := endT;  'no change
            buttonT := -1;
            docase
            case button1Release > -1 then
                printlog("Error!  Button 1 release occurred without a recorded press!\n");
                startT := button1Release;  'fast-forward to time of "false" release
                buttonT := startT;
                return -1;
            case button2Release > -1 then
                printlog("Error!  Button 2 release occurred without a recorded press!\n");
                startT := button2Release;  'fast-forward to time of "false" release
                buttonT := startT;
                return -1;  
            else
                return 1;  'success, no change
            endcase
        case button1Press > -1 and button2Press > -1 then  'both buttons pressed!
            if button1Press < button2Press then
                bStatus% := 1;  'consider it a button 1 press
                startT := button1Press;
                buttonT := startT;
                printlog("Recorded button 1 press at " + Str$(startT) + "\n");
                SampleText("Button 1 pressed",startT);
                docase 
                case button1Release > -1 and button1Release < button1Press then
                    printlog("Error!  Button 1 release occurred before Button 1 press when initial status was no button pressed!\n");
                    return -1;
                case button2Release > -1 and button2Release < button1Press then
                    printlog("Error!  Button 2 release occurred before Button 1 press when initial status was no button pressed!\n");
                    return -1;  
                else
                    return 1
                endcase;
            else  'button2Press > button1Press
                bStatus% := 2;  'consider it a button 2 press
                startT := button2Press;
                buttonT := startT;
                printlog("Recorded button 2 press at " + Str$(startT) + "\n");
                SampleText("Button 2 pressed",startT);
                docase 
                case button1Release > -1 and button1Release < button2Press then
                    printlog("Error!  Button 1 release occurred before Button 2 press when initial status was no button pressed!\n");
                    return -1;
                case button2Release > -1 and button2Release < button2Press then
                    printlog("Error!  Button 2 release occurred before Button 2 press when initial status was no button pressed!\n");
                    return -1;  
                else
                    return 1
                endcase;
            endif;
        case button1Press > -1 then  'no button 2 press, would trigger prior case
            bStatus% := 1;  'it's a button 1 press
            startT := button1Press;
            buttonT := startT;
            printlog("Recorded button 1 press at " + Str$(startT) + "\n");
            SampleText("Button 1 pressed",startT);
            docase 
            case button1Release > -1 and button1Release < button1Press then
                printlog("Error!  Button 1 release occurred before Button 1 press when initial status was no button pressed!\n");
                return -1;
            case button2Release > -1 and button2Release < button1Press then
                printlog("Error!  Button 2 release occurred before Button 1 press when initial status was no button pressed!\n");
                return -1;  
            else
                return 1
            endcase;
        case button2Press > -1 then  'no button 1 press, would trigger prior case
            bStatus% := 2;  'it's a button 2 press
            startT := button2Press;
            buttonT := startT;
            printlog("Recorded button 2 press at " + Str$(startT) + "\n");
            SampleText("Button 2 pressed",startT);
            docase 
            case button1Release > -1 and button1Release < button2Press then
                printlog("Error!  Button 1 release occurred before Button 2 press when initial status was no button pressed!\n");
                return -1;
            case button2Release > -1 and button2Release < button2Press then
                printlog("Error!  Button 2 release occurred before Button 2 press when initial status was no button pressed!\n");
                return -1;  
            else
                return 1
            endcase;
        else
            printlog("Error - shouldn't ever get in here!\n"); 'logically all states should be accounted for, but just in case
            startT := max(button1Press,button2Press,button1Release,button2Release);  'just clear it all out
            buttonT := startT;
            docase  'And set the button status based on the last recorded event
            case startT = button1Release or startT = button2Release then
                bStatus% := 0;
            case startT = button1Press then
                bStatus% := 1;
            case startT = button2Press then
                bStatus% := 2;
            endcase;
            return -1;
        endcase;
            
    case bStatus% = 1 then  'initial status is LEFT button pressed
        'check for left button release
        docase
        case button1Release > -1 then
            bStatus% := 0;  'Button is released
            startT := button1Release;
            buttonT := startT;
            printlog("Recorded button 1 release at " + Str$(startT) + "\n");
            SampleText("Button 1 released",startT);
        case button1Press > -1 or button2Press > -1 or button2Release > -1 then
            printlog("Error!  Recorded something other than button 1 release when button 1 believed to be pressed!\n");
            startT := max(button1Press,button2Press,button2Release);
            buttonT := startT;
            docase
            case startT = button1Press then
                bStatus% := 1;
            case startT = button2Press then
                bStatus% := 2;
            case startT = button2Release then
                bStatus% := 0;
            endcase;
            return -1;
        else
            'startT := endT;  'no change 
            buttonT := -1;            
        endcase;
        
        'check for crazy errors
        docase
        case button1Press > -1 and button1Press < button1Release then
            printlog("Error!  Button 1 press occurred before release when initial status was Button 1 down!\n");
            return -1;
        case button2Press > -1 and button2Press < button1Release then
            printlog("Error!  Button 2 press occurred before Button 1 release when initial status was Button 1 down!\n");
            return -1;
        case button2Release > -1 and button2Release < button1Release then   
            printlog("Error!  Button 2 release occurred before Button 1 release when initial status was Button 1 down!\n");
            return -1;
        case button1Release = -1 and (button1Press > -1 or button2Press > -1 or button2Release > -1) then
            printlog("Error!  Button 1 release expected, another event detected!\n");
            return -1;
        else
            return 1;  'success
        endcase;
    
    case bStatus% = 2 then  'initial status is RIGHT button pressed
        'check for right button release
        docase
        case button2Release > -1 then
            bStatus% := 0;  'Button is released
            startT := button2Release;
            buttonT := startT;
            printlog("Recorded button 2 release at " + Str$(startT) + "\n");
            SampleText("Button 2 released",startT);
        case button1Press > -1 or button2Press > -1 or button1Release > -1 then
            printlog("Error!  Recorded something other than button 2 release when button 2 believed to be pressed!\n");
            startT := max(button1Press,button2Press,button1Release);
            buttonT := startT;
            docase
            case startT = button1Press then
                bStatus% := 1;
            case startT = button2Press then
                bStatus% := 2;
            case startT = button1Release then
                bStatus% := 0;
            endcase;
            return -1;
        else
            'startT := endT;  'no change
            buttonT := -1;            
        endcase;
        
        'check for crazy errors
        docase
        case button2Press > -1 and button2Press < button2Release then
            printlog("Error!  Button 2 press occurred before release when initial status was Button 2 down!\n");
            return -1;
        case button1Press > -1 and button1Press < button2Release then
            printlog("Error!  Button 1 press occurred before Button 2 release when initial status was Button 2 down!\n");
            return -1;
        case button1Release > -1 and button1Release < button2Release then   
            printlog("Error!  Button 1 release occurred before Button 2 release when initial status was Button 2 down!\n");
            return -1;
        case button2Release = -1 and (button1Press > -1 or button2Press > -1 or button1Release > -1) then
            printlog("Error!  Button 2 release expected, another event detected!\n");
            return -1;
        else
            return 1;  'success
        endcase;
        
    endcase;
    

end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc FlushButton(&startT,endT,&bStatus%,&buttonT)
    'Used to flush out the status of the button until all button events are in the past relative to endT (typically tNow)
    'Useful in the case of a button error, to just clear out and start over
    while buttonT > -1 do
        WhichButton%(startT,endT,bStatus%,buttonT);
    wend;
    printlog("Button Flush complete at " + Str$(endT) + "\n");
    'When this is done we will have no idea when the last event occured or necessarily what it was, but bStatus% 
    'ought to be correct for time endT and we will be ready to try reading the button again.
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end
