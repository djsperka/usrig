' $Id$
'
' This file contains dialog functions for the alert tuning script Tuning.s2s.
#include "../util/UsreyUtil.s2s"
#include "../util/LogUtilities.s2s"
#include "../util/MiscUtilities.s2s"
#include "UsreyGratings.s2s"
#include "UsreyDAQ.s2s"

const tunMaxTrials% := 10000;

const tunTypeNone$ := "None";
const tunTypeOrientation$ := "O";
const tunTypeContrast$ := "C";
const tunTypeSpatial$ := "S";
const tunTypeTemporal$ := "T";
const tunTypeArea$ := "A";
const tunTypeDonut$ := "H";  '(H)ole in stimulus
const tunTypeBerliner$ := "B";
const tunTypeBoxODonuts$ := "G";  '(G)rid of stimuli
const tunTypeXPos$ := "X";
const tunTypeXYPos$ := "Z";
const tunTypeDots$ := "D";
const tunTypeDisparity$ := "DX";
const tunTypeCRG$ := "R";
const tunTypeBlank$ := "BLANK";
const tunTypeGratingOnly$ := "GO";
const tunTypeDanish$ := "DN";
const tunTypeGonzago$ := "GZ";
const tunTypeDSS$ := "DSS";
const tunTypeNullTest$ := "NULL";
const tunTypeLag$ := "LAG";
const tunTypeBakersDozen$ := "BAKER";
const tunTypeFixptColor$ := "U";
const tunTypeFixptJump$ := "J";
const tunTypePolkaDot$ := "PD";
var tunType$:=tunTypeNone$;
var tunType1$:=tunTypeNone$;  'for first of two tuning curves, if Box O' Donuts, or for non-CRG curve in CRG scenarios
var tunType2$:=tunTypeNone$;  'for second of two tuning curves, if Box O' Donuts
var tunDualTuningType%;  'Determines whether, on dual tuning, both (0), Master (1), or Slave (2) screen varies.
var tunUseFile%;        ' Overall variables so we don't have to check 7 different ones in the main file.
var tunTuningFile$;     ' Location of tuning file
var tunUseFile1%;        ' for first of two tuning curves, if Box o' Donuts
var tunTuningFile1$;
var tunUseFile2%;        ' for second of two tuning curves, if Box o' Donuts
var tunTuningFile2$;

const tunContextDAQ$ := "DAQ";
const tunContextConfig$ := "Config";
var tunContext$ := tunContextConfig$;

const tundlgXHairButton% := 8;
const tundlgOrientationButton% := 9;
const tundlgContrastButton% := 10;
const tundlgSpatialButton% := 11;
const tundlgTemporalButton% := 12;
const tundlgAreaButton% := 13;
const tundlgDonutANDGonzagoButton% := 14;
const tundlgFixptJumpANDBerlinerButton% := 15;
const tundlgBoxODonutsButton% := 16;
const tundlgXPosButton% := 17;
const tundlgDotsButton% := 18;
const tundlgDisparityAndBakersDozenButton% := 19;
const tundlgCRGButton% := 20;
const tundlgSelectSEQFileButton% := 21;
const tundlgBlankButton% := 22;
const tundlgGratingOnlyButton% := 23;
const tundlgCRG2Button% := 24;  'This is for CRG on SECOND screen
const tundlgDanishButton% := 25;
const tundlgDSSButton% := 26;
const tundlgNullTestANDLagButton% := 27;
const tundlgSelectTuningFileButton% := 28;
const tundlgLagButton% := 29;
const tundlgOptogeneticsButton% := 30;
const tundlgFixptColorButton% := 31;
const tundlgPolkaDotButton% := 32;
const tundlgSelectTuningFileButton2% := 33;  'Needed for bakers dozen opto/condition file

' A note about "steps". 
' The dialogs ask for a number of "steps". A step is a transition from one stimulus
' to another. Thus, if there are N steps, there are N+1 different stimuli.

' These are specific to the individual tuning curve types - orientation first
var tunOriNSteps%;		' # steps in orientation tuning curve
var tunOriNRepeats%;		' # repeats in ori tuning curve
var tunOriMinOrientation;	' min orientation
var tunOriMaxOrientation;	' max orientation
var tunOriProgression%;
var tunOriUseFile%;
var tunOriTuningFile$;

' Contrast next
var tunContrastNSteps%;			' # steps in contrast tuning curve
var tunContrastNRepeats%;		' # repeats in contrast tuning curve
var tunContrastMinContrast;		' min contrast
var tunContrastMaxContrast;		' max contrast
var tunContrastProgression%;
var tunContrastUseFile%;
var tunContrastTuningFile$;
var tunContrastDualScreenCombo%;
var tunContrastDualScreenComboRegistry%;  'we are saving a slightly different value in the registry - we need to disable this if not allowed, but we'd like to save the allowed value

var tempDualValue%;  'This is the value of tunDualTuningType, but gathered from the dialog BEFORE the dialog is closed, used for setting DlgAllow only for the Contrast dialog (for now)

' Spatial next
var tunSpatialNSteps%;			' # steps in spatial freq tuning curve
var tunSpatialNRepeats%;		' # repeats in spatial freq tuning curve
var tunSpatialMinSF;			' min SF
var tunSpatialMaxSF;			' max SF
var tunSpatialProgression%;
var tunSpatialUseFile%;
var tunSpatialTuningFile$;

' Temporal next
var tunTemporalNSteps%;			' # steps in temporal tuning curve
var tunTemporalNRepeats%;		' # repeats in temporal tuning curve
var tunTemporalMinTF;		' min TF
var tunTemporalMaxTF;		' max TF
var tunTemporalProgression%;
var tunTemporalUseFile%;
var tunTemporalTuningFile$;

' Area next
var tunAreaNSteps%;			' # steps in area tuning curve
var tunAreaNRepeats%;		' # repeats in area tuning curve
var tunAreaMinDiam;		' min diameter
var tunAreaMaxDiam;		' max diameter
var tunAreaProgression%;
var tunAreaUseFile%;
var tunAreaTuningFile$;
var tunAreaDualScreenCombo%;
var tunAreaDualScreenComboRegistry%;  'we are saving a slightly different value in the registry - we need to disable this if not allowed, but we'd like to save the allowed value


' X/XY Position next
var tunXPosNSteps%;			' # steps in X position tuning curve
var tunXPosNRepeats%;		' # repeats in X position tuning curve
var tunXPosMinXPos;		' min position
var tunXPosMaxXPos;		' max position
var tunXPosProgression%;
var tunXYPosNXSteps%;			' # steps in X position tuning curve
var tunXYPosNRepeats%;		' # repeats in X position tuning curve
var tunXYPosMinXPos;		' min position
var tunXYPosMaxXPos;		' max position
var tunXYPosProgression%;
var tunXYPosNYSteps%;			' # steps in Y position tuning curve
var tunXYPosMinYPos;		' min position
var tunXYPosMaxYPos;		' max position


' Donuts - use same vars as area. There is one additional var - the optimal value index.
var tunDonutOptimalIndex%:=0;		' step index where area stim stops growing and donut stim starts
var tunDonutOptimalDiam;
var tunDonutProgression%;
var tunDonutCoreOnSlave% := 0;

' Berliners - also use same variables as Area.  Use optimal value index from Donuts.  Add maximal value index
var tunDonutOptimalDiamPlusOne;
var tunBerlinerMaximalIndex%:=0;    ' index for "maximal" size
var tunBerlinerMaximalDiam;
var tunBerlinerNSteps%;
var tunBerlinerNRepeats% := 3;  'just putting in 3 repeats for now
var tunBerlinerProgression%;
var tunBerlinerCoreOnSlave% := 0;

' Box O' Donuts
'var tunUseHoleKluge%;               'will be set by tuning dialogs if we are putting a hole in the stimulus
var tunBoxODonutsCurrentCurve%:=0;  'note, will be 0 unless BoxODonuts is selected on the dialog
var tunCurve1Text$;                 'For the nifty boxes telling us what's been done!
var tunCurve2Text$;
var updateCurve1Text%;              'These is just a pointer that allows us to change the tunCurve1Text$ value on the fly
var updateCurve2Text%;
var tunCurve1SelectedType$;         'This prevents us from doubling up
var tunBoxODonutsProgression%;
var tunBoxODonutsNRepeats%;
var tunBoxODonutsNumGratingOption%;
var tunMasterFollowsCurve1%;


' Dots - this is a bit different - it's an orientation tuning curve, 
' but the other parameters aren't quite general grating parameters, so do them here, too
var tunDotsNSteps%;		' # steps in orientation tuning curve
var tunDotsNRepeats%;		' # repeats in ori tuning curve
var tunDotsMinOrientation;	' min orientation
var tunDotsMaxOrientation;	' max orientation
var tunDotsProgression%;
var tunDotsX;               ' X position, deg
var tunDotsY;               ' Y position, deg
var tunDotsDiameter;        ' deg
var tunDotsSpeed;           ' deg/sec
var tunDotsDensity;         ' dots/deg^2
var tunDotsSize%;           ' pixels
var tunDotsBGR%;            ' Background color, red level
var tunDotsBGG%;            ' Background color, green level
var tunDotsBGB%;            ' Background color, blue level
var tunDotsFGR%;            ' Dot color, red level
var tunDotsFGG%;            ' Dot color, green level
var tunDotsFGB%;            ' Dot color, blue level


' Disparity - this runs a Disparity tuning curve on either the slave or master screen
var tunDisparityOnMaster%;      ' if 1, Disparity is on master, if 0, Disparity is on slave.
var tunDisparityProgression%;   ' if 1, progression is random
var tunDisparityLinear%;        ' if 1, tuning curve is linear, 0 log
var tunDisparityNSteps%;
var tunDisparityNRepeats%;
var tunDisparityCenterXPos;
var tunDisparityMaxXPos;
var tunDisparityMinXPos;


' Contrast Reversing Gratings
var tunCRGCurrentCurve%:=0;     ' note, will be 0 unless CRG is selected on the dialog
var tunCRGNRepeats%;            ' number of repeats of the CRG sequence, note there will be one repeat for each level in the non-CRG tuning curve
                                    ' thus if this is 3 and the tuning curve has 5 values and there are 10 sequences this is 150 stimuli
var tunCRGFramesPerFlip%;       ' number of frames for each contrast reverse in the sequence
var tunCRGProgression%;         ' if 1, progression is random
var tunCRGOnSlave%;             ' if 1, CRG is on slave screen, using slave here so "master" is at top of list box with this variable as an index
var tunCRGSeqFile$;             ' full path of sequence file
var tunCRGSeqFile2$;            ' full path of secondary sequence file, if used
var tunCRGNSeq1%;               ' will hold the number of sequences in the sequence file, not saved to registry
var tunCRGNSeq2%;               ' will hold the number of sequences in the sequence file, not saved to registry
var tunCRGNFlips1%;             ' number of flips per sequence in file 1 (note that nFlips is a bit of a misnomer...it's really the number of frame-blocks)
var tunCRGNFlips2%;             ' number of flips per sequence in file 2
var tunCRGSecsPerSeq:=0;        ' length of a sequence in seconds, to be compared to stim duration in tuning curve, not saved to registry


' Danishes
var tunDanishNSteps%;           ' # steps in outer diameter tuning curve
var tunDanishNRepeats%;         ' # repeats in outer diameter tuning curve
var tunDanishMinOuterDiameter;  ' min outer diameter
var tunDanishMaxOuterDiameter;  ' max outer diameter
var tunDanishProgression%;      ' if 1, progression is random
var tunDanishIncludeBlank%;     ' if 1, include "blank" (that is, zero-size donut) in tuning curve



' Gonzagos
var tunGonzagoCoreContrastNSteps%;  ' # steps in core contrast tuning curve
var tunGonzagoDonutAreaNSteps%;     ' # steps in outer diameter tuning curve
var tunGonzagoNRepeats%;            ' # repeats of tuning curve
var tunGonzagoMinOuterDiameter;     ' min outer diameter of donut
var tunGonzagoMaxOuterDiameter;     ' max outer diameter of donut
var tunGonzagoMinContrast;		    ' min contrast of core
var tunGonzagoMaxContrast;		    ' max contrast of core
var tunGonzagoProgression%;         ' if 1, progression is random
'var tunGonzagoIncludeBlank%;        ' if 1, include "blank" (that is, zero-size donut) in tuning curve  (Gonzagos always include blanks in BOTH conditions)



'Dynamic Surround Suppression
var tunDSSNTrials%;             ' # of trials (one trial is made of N periods)
var tunDSSNPeriods%;            ' # of flash + blank periods
var tunDSSNBlanks%;             ' # of blank periods, the remainder are flashes
var tunDSSNFlashesPerReward%;   ' # of flashes per each reward
var tunDSSCurrPeriod%;          ' counts current period
var tunDSSFlashesUntilReward%;  ' how many flashes until we get a reward?
var tunDSSFlashOrBlank%[tunMaxTrials%];  'is current "flash" a flash or a blank?
var tunDSSDuration;             'how long is each flash, will take from "fixation duration"
var tunDSSIsOn%;                'keep track of current state
var tunNextDSSTime;             'when is the next flip?



'Null Test - now Phase tuning, but with the same name, now that counterphase is a true grating parameter
var tunNullTestNSteps%;         ' # steps in null test tuning curve
var tunNullTestNRepeats%;       ' # repeats in null test tuning curve
var tunNullTestMinPhase;        ' minimum phase
var tunNullTestMaxPhase;        ' maximum phase
'var tunNullTestTF;              ' temporal frequency of the contrast reversal
var tunNullTestProgression%;    ' if 1, progression is random
'var tunNullTestStepFunc%;
var tunNullTestUseFile%;
var tunNullTestTuningFile$;


'Lag
var tunLagNSteps%;			' # steps in temporal tuning curve
var tunLagNRepeats%;		' # repeats in temporal tuning curve
var tunLagMinLagFrames%;    ' min Lag, frames
var tunLagMaxLagFrames%;	' max Lag, frames
var tunLagMinLagFrames;     ' min Lag, frames, float for using GRPP
var tunLagMaxLagFrames;	    ' max Lag, frames, float for using GRPP
var tunLagMinLagMS;         ' min Lag, ms, for display
var tunLagMaxLagMS;         ' max lag, ms, for display
var tunLagProgression%;
var tunLagUseFile%;
var tunLagTuningFile$;
var tunLagFrames1$;
var tunLagFrames2$;
var tunLagMasterIsLagged%;


'Baker's Dozen variables
var tunBDTuningFile$;
var tunBakersDozenFileLoc$;
var tunBDUseOCFile%;  'Use Opto/condition file?
var tunBDOCFile$;
var tunBakersDozenOCFileLoc$;
'Baker's Dozen tuning file read variables
var tunNumBDCurvesAllowed% := 17;  'include paired curves as two curves
'Index order of BD curves:
'0 = ORIentation; 1 = Temporal Freq; 2 = Spatial Freq; 3 = CONtrast
'4 = FIXpoint COLor; 5 = AREA; 6 = PHASE; 7,8 = XYPOSition (paired)
'9 = XPOSition; 10,11 = Width/Height (paired); 12 = DonutHole
'13,14 = FIXXY position (paired); 15 = stimDELay; 16 = stimDURation
var tunBDTunCurveLabel$[tunNumBDCurvesAllowed%];
tunBDTunCurveLabel$[0]  := "ORI";
tunBDTunCurveLabel$[1]  := "TF";
tunBDTunCurveLabel$[2]  := "SF";
tunBDTunCurveLabel$[3]  := "CON";
tunBDTunCurveLabel$[4]  := "FIXCOL";
tunBDTunCurveLabel$[5]  := "AREA";
tunBDTunCurveLabel$[6]  := "PHASE";
tunBDTunCurveLabel$[7]  := "XYPOS";  'This is X position
tunBDTunCurveLabel$[8]  := "";  'Reserved for Y position
tunBDTunCurveLabel$[9]  := "XPOS";
tunBDTunCurveLabel$[10] := "WH";  'This is width
tunBDTunCurveLabel$[11] := "";  'Reserved for height
tunBDTunCurveLabel$[12] := "DH";
tunBDTunCurveLabel$[13] := "FIXXY";  'This is fixation X
tunBDTunCurveLabel$[14] := "";  'Reserved for fixation Y
tunBDTunCurveLabel$[15] := "DEL";
tunBDTunCurveLabel$[16] := "DUR";
var tunBDWhichTunCurve[tunNumBDCurvesAllowed%];    'Will be 1 for each tuning curve that is specified in the BD file and 0 if not
var tunBDTuningValues$[tunMaxTrials%][tunNumBDCurvesAllowed%];  'Will fill up to 5000 values, as STRINGS, column index is as above
var tunPauseOnConditionChange% := 0;  'Currently only implemented for Baker's Dozen, will be used openly in idle loop
var tunBDConditionLabel$[tunMaxTrials%];
var tunTBTOpto%[tunMaxTrials%];  'this is only available in Baker's Dozen for now


'Fixpt Color
var tunFPCNSteps%;
var tunFPCNRepeats%;
var tunFPCRedValue%;
var tunFPCGreenValue%;
var tunFPCBlueValue%;
var tunFPCGunIndex%;
var tunFPCMinValue;
var tunFPCMaxValue;
var tunFPCProgression%;
var tunFPCUseFile%;
var tunFPCTuningFile$;


'Fixpt Jump
var tunFPJNAdvances%;           'How many trials (advances), number of actual "trials" will vary based on probability of saccade
var tunFPJXOffset;              'X offset of fixation point, degrees
var tunFPJYOffset;              'Y offset of fixation point, degrees
var tunFPJProbSaccade;          'Probability of a saccade each trial (evidently no minimum number of presentations between saccades)
var tunFPJtFixptMove;           'Time of fixation point jump, if any
var tunFPJFileLoc$ := GetWorkPath$() + "\\FixptJumpFile.txt";             'Location of FPJ file
var tunFPJFixptStr$;
var tunFPJGratingStr$;
var tunFPJFixptX[tunMaxTrials%];
var tunFPJFixptY[tunMaxTrials%];
var tunFPJGratingX[tunMaxTrials%];
var tunFPJGratingY[tunMaxTrials%];
var tunFPJIsJump%;


'Polka Dots
    'Color
var tunPDNColorSteps%;
var tunPDRedValue%;
var tunPDGreenValue%;
var tunPDBlueValue%;
var tunPDGunIndex%;
var tunPDMinGunValue;
var tunPDMaxGunValue;
    'XY Position
var tunPDNXSteps%;	    ' # steps in X position tuning curve
var tunPDMinXPos;		' min position
var tunPDMaxXPos;		' max position
var tunPDNYSteps%;		' # steps in Y position tuning curve
var tunPDMinYPos;		' min position
var tunPDMaxYPos;		' max position
    'Common variables
var tunPDDiameter;
var tunPDNRepeats%;
var tunPDProgression%;  'For now, do not consider randomizing position without also randomizing color, or vice versa
var tunPDUseFile%;
var tunPDTuningFile$;
var tunPDShowGrating%;  
var tunPDLagSec;
var tunPDLagFrames%;
var tunNColorValues%;



' Optogenetics variables
var tunPreStimOptoTime;
var tunPostStimOptoTime;
var tunOptoStaysOn%;
var tunOptoVoltageOut;
var tunOptoStartState%;  'essentially an index, 0 = off first, 1 = on first (those are logical), 2 = random
var tunOptoState% := 0;  'current opto state, will toggle, can set here in dialog box
var dontToggleOpto% := 0;  'by default, toggle opto on every block
'var tunRecOptoBox% := 0;      'record the output from the opto box?
var tunOptoNPulses%;
var tunPulsedOptoOnset;
var tunPulsedOptoWidth;
var tunPulsedOptoIPI;
var tunPulsedOptoOnsetClockSteps%;
var tunPulsedOptoOffsetClockSteps%;
var tunPulsedOptoWidthClockSteps%;
var tunPulsedOptoIPIClockSteps%;
var tunDoOpto%;                     '1 if doing optogenetics
var doTBTopto%;                     '1 if opto is to be specified trial-by-trial, currently only available via Baker's Dozen and "OC" specfile
'var tunRecStimulator% := 0;   'record the stimulator?
var tunOptoUsePulse% := 0;  'Are we using a "pulsing stimulation"?
var tunLaserDiode% := 0;  'Are we recording the output of the laser using a photodiode?
var tunInterBlockTime := 0;        ' New, time between blocks, important for opto




' Strings that hold grating parameters
var tunGratingParams$;
var tunGratingParamsSlave$;

' Crosshair display variables
var tunUseXHairs%;                'Do we use crosshairs?
var tunXHairInnerRadiusOffset;    'Inner diameter of inner grid ring
var tunXHairMiddleRadiusOffset;   'Outer diameter of inner grid ring/Inner diameter of outer grid ring
var tunXHairOuterRadiusOffset;    'Outer diameter of outer grid ring
var tunXHairNumGridDivisions%;    'Number of divisions in the grid rings
var tunXHairTicInnerOffset;       'Inner extent of 0/90/180/270 ticks
var tunXHairTicOuterOffset;       'Outer extent of 0/90/180/270 ticks
var tunMaximalDiam;
var tunSlaveMaximalDiam;

var tunAlwaysLooking% := 1; ' If set eye signals ignored - subject presumed to be looking always. TESTING ONLY.
var tunSendINTANPulse%;     'Used to send pulses to INTAN machine

var tunFixationDuration := 2.0;	' Time required to hold fixation for reward (stim ON) - this is the stimulus duration
var tunUseMaintainMode% := 1;  ' If 1, maintain fixation point on screen through stimuli, if zero, force "restart" on each stimulus
var tunMaintainFixation := 2.0;	' Time required to hold fixation for reward (stim OFF)
var tunAcquisitionTime := 1.0;		' Time allowed to acquire fixation
var tunStimulusOnsetDelay := 0;     ' Time of stimulus onset delay following acquisition 
var tunBackgroundColor$ := "gray";	' background color for stim
var tunAcqFailTime := 2.0;			' Wait time after acquisition failure
var tunHoldFailTime := 2.0;			' Wait time after failure to hold fixation (not on the first time after acquisition)
var tunMaintainFailTime := 2.0;	' Wait time after breaking fixation during maintain phase
'var tunTimeOutTime := 2.0;			' Wait time after failure to hold fixation (first time after acquisition)
var tunStdInterTrialTime := 2.0;    'Standard intertrial time
var tunDoRivalry% := 0;          ' If checked, run for the rivalry rig
var tunDoF12% := 1;                 ' compute f1 and f2. 
var tunDoTuningHist% := 1;          'do tuning histograms?
var tunSetStationary% := 0;         'do stationary?
var tunXHairText$;                  'holds whether crosshairs are on or off
var updateXHairText%;             'Gets the item number of a DlgText object for update
var TunCurveMArg$:="";            'holds type of tuning curve on Master
var TunCurveM2Arg$:="";           'holds type of tuning curve on second Master grating, only for two-grating box'o'donuts right now
var TunCurveSArg$:="";            'holds type of tuning curve on slave
var TunCurveS2Arg$:="";           'holds second type of tuning curve on slave, for Box O' Donuts, rivalry version
var TunCurveDArg$:="";            'holds second type of tuning curve on distractor, for Box O' Donuts two-grating version
var tunButtonCollect%;            'Collect button data for rivalry?
var tunUseLagDialog%;             'will be 1 if we are using the lag dialog, 0 for null test
var tunUseDonutDialog%;           'will be 1 if we are using the donut dialog, 0 for Gonzagos
var tunUseCRGDialog%;             'will be 1 if we are using the CRG dialog, 0 for FixPtColor
var tunUseConstantLag%;           '0 = no constant lag, 1 = constant lag on master, 2 = constant lag on slave
var tunUseDisparityDialog%;
var tunUseBerlinerDialog%;
var tunConstantLagFrames%;
var tunConstantLagMS$;

' These will be set by the tuning curve choice
var tunNAdvances%;		' Number of times stim will advance during one repeat
var tunNRepeats%;		' Number of repeats
var tunRepeatForever%;  ' Allow looping through the stimuli over and over forever

' This vector will hold the actual values to step through. Some are log steps, some are not. 
' The Indices array is the order to step through the values with: tunValues[tunValuesIndices%[0]], tunValues[tunValuesIndices%[1]], ...
' djs Make a constant tunMaxTrials to set the max number of trials. Arrays etc should be declared with this const. See below and
' tunF1Sum, tunF2Sum. 

var tunValues[tunMaxTrials%];
var tunValues$[tunMaxTrials%];  'for reading the combo tuning file, there will be a '-' separator
var tun1Values[tunMaxTrials%];
var tun2Values[tunMaxTrials%];
var tunValuesIndices%[tunMaxTrials%]; 
var tun1ValuesIndices%[tunMaxTrials%]; 
var tun2ValuesIndices%[tunMaxTrials%]; 
var tunNValues%;
var tun1NValues%;
var tun2NValues%;
var tunValuesStringified$;
var tun1ValuesStringified$;     'For Box O' Donuts
var tun2ValuesStringified$;
var tunPDDotSpecsPerTrial$[tunMaxTrials%];
var tunPDXValues[tunMaxTrials%];
var tunPDYValues[tunMaxTrials%]; 
var tunPDXValuesIndices%[tunMaxTrials%]; 
var tunPDYValuesIndices%[tunMaxTrials%];
var tunPDXNValues%;
var tunPDYNValues%;
var tunPDXValuesStringified$;
var tunPDYValuesStringified$;

' Wavemarks and continuous ports
const tunMaxPorts% := 64;  'there can be more channels, but that's all the ports we can collect
var tunNWavemarks% := 0;
var tunWavemarkPorts%[tunMaxPorts%];
var tunNContinuous% := 0;
var tunContinuousPorts%[tunMaxPorts%];

' Hold sum of F1 values. Each channel (up to tunMaxPorts%) has values saved according to the index of the tuning value
' Rely on the fact that arrays are initialized with 0s in Spike2. 
var tunF1Sum[tunMaxPorts%][tunMaxTrials%];  'see, this isn't really a sum, it's a matrix that holds all the values
var tunF2Sum[tunMaxPorts%][tunMaxTrials%];
var tunF0ActualSum[tunMaxPorts%][tunMaxTrials%];  'these are really sums
var tunF1ActualSum[tunMaxPorts%][tunMaxTrials%];  
var tunF2ActualSum[tunMaxPorts%][tunMaxTrials%];
var tunF0Count%[tunMaxPorts%][tunMaxTrials%];  'use these to allow us to calculate averages instead of putting every single value on the plot
var tunF1Count%[tunMaxPorts%][tunMaxTrials%]; 
var tunF2Count%[tunMaxPorts%][tunMaxTrials%];
var tunTF;              ' Will need to use this during FFT analysis. Use at your own risk....


'------------ Read/write tuning curve parameters to the registry ------------

proc GetTuningCurveOrientationParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    tunOriNSteps% := GetIntRegistryValue%(key$, "NSteps", tunOriNSteps%);
    tunOriNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunOriNRepeats%);
    tunOriMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    tunOriMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    tunOriProgression% := GetIntRegistryValue%(key$, "Progression", tunOriProgression%);
    tunOriUseFile% := GetIntRegistryValue%(key$, "UseFile", tunOriUseFile%);
    tunOriTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunOriTuningFile$);
end;

proc SaveTuningCurveOrientationParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    SetIntRegistryValue(key$, "NSteps", tunOriNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunOriNRepeats%);
    SetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    SetIntRegistryValue(key$, "Progression", tunOriProgression%);
    SetIntRegistryValue(key$, "UseFile", tunOriUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunOriTuningFile$);
end;

proc GetTuningCurveContrastParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    
    tunContrastNSteps% := GetIntRegistryValue%(key$, "NSteps", tunContrastNSteps%);
    tunContrastNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunContrastNRepeats%);
    tunContrastMinContrast := GetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    tunContrastMaxContrast := GetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    tunContrastProgression% := GetIntRegistryValue%(key$, "Progression", tunContrastProgression%);
    tunContrastUseFile% := GetIntRegistryValue%(key$, "UseFile", tunContrastUseFile%);
    tunContrastTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunContrastTuningFile$);
    tunContrastDualScreenComboRegistry% := GetIntRegistryValue%(key$, "DualScreenCombo", tunContrastDualScreenComboRegistry%);
end;

proc SaveTuningCurveContrastParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    SetIntRegistryValue(key$, "NSteps", tunContrastNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunContrastNRepeats%);
    SetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    SetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    SetIntRegistryValue(key$, "Progression", tunContrastProgression%);
    SetIntRegistryValue(key$, "UseFile", tunContrastUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunContrastTuningFile$);
    SetIntRegistryValue(key$, "DualScreenCombo", tunContrastDualScreenComboRegistry%);
end;

proc GetTuningCurveSpatialParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    tunSpatialNSteps% := GetIntRegistryValue%(key$, "NSteps", tunSpatialNSteps%);
    tunSpatialNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunSpatialNRepeats%);
    tunSpatialMinSF := GetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    tunSpatialMaxSF := GetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    tunSpatialProgression% := GetIntRegistryValue%(key$, "Progression", tunSpatialProgression%);
    tunSpatialUseFile% := GetIntRegistryValue%(key$, "UseFile", tunSpatialUseFile%);
    tunSpatialTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunSpatialTuningFile$);
end;

proc SaveTuningCurveSpatialParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    SetIntRegistryValue(key$, "NSteps", tunSpatialNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunSpatialNRepeats%);
    SetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    SetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    SetIntRegistryValue(key$, "Progression", tunSpatialProgression%);
    SetIntRegistryValue(key$, "UseFile", tunSpatialUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunSpatialTuningFile$);
end;

proc GetTuningCurveTemporalParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";
    
    tunTemporalNSteps% := GetIntRegistryValue%(key$, "NSteps", tunTemporalNSteps%);
    tunTemporalNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunTemporalNRepeats%);
    tunTemporalMinTF := GetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    tunTemporalMaxTF := GetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    tunTemporalProgression% := GetIntRegistryValue%(key$, "Progression", tunTemporalProgression%);
    tunTemporalUseFile% := GetIntRegistryValue%(key$, "UseFile", tunTemporalUseFile%);
    tunTemporalTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunTemporalTuningFile$);
end;

proc SaveTuningCurveTemporalParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";

    SetIntRegistryValue(key$, "NSteps", tunTemporalNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunTemporalNRepeats%);
    SetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    SetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    SetIntRegistryValue(key$, "Progression", tunTemporalProgression%);
    SetIntRegistryValue(key$, "UseFile", tunTemporalUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunTemporalTuningFile$);
end;


proc GetTuningCurveXPosParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XPos";
    
    tunXPosNSteps% := GetIntRegistryValue%(key$, "NSteps", tunXPosNSteps%);
    tunXPosNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunXPosNRepeats%);
    tunXPosMinXPos := GetFloatRegistryValue(key$, "MinXPos", tunXPosMinXPos);
    tunXPosMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunXPosMaxXPos);
    tunXPosProgression% := GetIntRegistryValue%(key$, "Progression", tunXPosProgression%);
end;

proc SaveTuningCurveXPosParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XPos";

    SetIntRegistryValue(key$, "NSteps", tunXPosNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunXPosNRepeats%);
    SetFloatRegistryValue(key$, "MinXPos", tunXPosMinXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunXPosMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunXPosProgression%);
end;


proc GetTuningCurveXYPosParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XYPos";
    
    tunXYPosNXSteps% := GetIntRegistryValue%(key$, "NXSteps", tunXYPosNXSteps%);
    tunXYPosNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunXYPosNRepeats%);
    tunXYPosMinXPos := GetFloatRegistryValue(key$, "MinXPos", tunXYPosMinXPos);
    tunXYPosMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunXYPosMaxXPos);
    tunXYPosProgression% := GetIntRegistryValue%(key$, "Progression", tunXYPosProgression%);
    tunXYPosNYSteps% := GetIntRegistryValue%(key$, "NYSteps", tunXYPosNYSteps%);
    tunXYPosMinYPos := GetFloatRegistryValue(key$, "MinYPos", tunXYPosMinYPos);
    tunXYPosMaxYPos := GetFloatRegistryValue(key$, "MaxYPos", tunXYPosMaxYPos);
end;

proc SaveTuningCurveXYPosParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XYPos";

    SetIntRegistryValue(key$, "NXSteps", tunXYPosNXSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunXYPosNRepeats%);
    SetFloatRegistryValue(key$, "MinXPos", tunXYPosMinXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunXYPosMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunXYPosProgression%);
    SetIntRegistryValue(key$, "NYSteps", tunXYPosNYSteps%);
    SetFloatRegistryValue(key$, "MinYPos", tunXYPosMinYPos);
    SetFloatRegistryValue(key$, "MaxYPos", tunXYPosMaxYPos);
end;


proc GetTuningCurveDisparityParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Disparity";
    
    tunDisparityNSteps% := GetIntRegistryValue%(key$, "NSteps", tunDisparityNSteps%);
    tunDisparityNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunDisparityNRepeats%);
    tunDisparityCenterXPos := GetFloatRegistryValue(key$, "CenterXPos", tunDisparityCenterXPos);
    tunDisparityMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunDisparityMaxXPos);
    tunDisparityProgression% := GetIntRegistryValue%(key$, "Progression", tunDisparityProgression%);
    tunDisparityLinear% := GetIntRegistryValue%(key$, "Linear", tunDisparityLinear%);
    tunDisparityOnMaster% := GetIntRegistryValue%(key$, "Master", tunDisparityOnMaster%);
    
end;

proc SaveTuningCurveDisparityParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Disparity";
    
    SetIntRegistryValue(key$, "NSteps", tunDisparityNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunDisparityNRepeats%);
    SetFloatRegistryValue(key$, "CenterXPos", tunDisparityCenterXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunDisparityMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunDisparityProgression%);
    SetIntRegistryValue(key$, "Linear", tunDisparityLinear%);
    SetIntRegistryValue(key$, "Master", tunDisparityOnMaster%);
    
end;


proc GetTuningCurveAreaParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    tunAreaNSteps% := GetIntRegistryValue%(key$, "NSteps", tunAreaNSteps%);
    tunAreaNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunAreaNRepeats%);
    tunAreaMinDiam := GetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    tunAreaMaxDiam := GetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    tunAreaProgression% := GetIntRegistryValue%(key$, "Progression", tunAreaProgression%);
    tunAreaUseFile% := GetIntRegistryValue%(key$, "UseFile", tunAreaUseFile%);
    tunAreaTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunAreaTuningFile$);
    tunAreaDualScreenComboRegistry% := GetIntRegistryValue%(key$, "DualScreenCombo", tunAreaDualScreenComboRegistry%);
    tunDonutOptimalIndex% := GetIntRegistryValue%(key$, "OptimalIndex", tunDonutOptimalIndex%);
    tunDonutProgression% := GetIntRegistryValue%(key$, "DonutProgression", tunDonutProgression%);
    tunDonutCoreOnSlave% := GetIntRegistryValue%(key$, "DonutCoreOnSlave", tunDonutCoreOnSlave%);
    tunBerlinerMaximalIndex% := GetIntRegistryValue%(key$, "MaximalIndexBerliner", tunBerlinerMaximalIndex%);
    tunBerlinerMaximalDiam := GetFloatRegistryValue(key$, "MaximalDiamBerliner", tunBerlinerMaximalDiam);
    tunBerlinerNSteps% := GetIntRegistryValue%(key$, "NStepsBerliner", tunBerlinerNSteps%);
    tunBerlinerNRepeats% := GetIntRegistryValue%(key$, "NRepeatsDiamBerliner", tunBerlinerNRepeats%);
    tunBerlinerProgression% := GetIntRegistryValue%(key$, "BerlinerProgression", tunBerlinerProgression%);
    tunBerlinerCoreOnSlave% := GetIntRegistryValue%(key$, "BerlinerCoreOnSlave", tunBerlinerCoreOnSlave%);
    tunMasterFollowsCurve1% := GetIntRegistryValue%(key$, "MasterFollowsCurve1", tunMasterFollowsCurve1%); 
    tunBoxODonutsProgression% := GetIntRegistryValue%(key$, "BoxODonutsProgression", tunBoxODonutsProgression%);
    tunBoxODonutsNRepeats% := GetIntRegistryValue%(key$, "BoxODonutsNRepeats", tunBoxODonutsNRepeats%);
    tunBoxODonutsNumGratingOption% := GetIntRegistryValue%(key$, "BoxODonutsOneOrTwoGratings", tunBoxODonutsNumGratingOption%);  'variable renamed, keep key the same
end;

proc SaveTuningCurveAreaParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    SetIntRegistryValue(key$, "NSteps", tunAreaNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunAreaNRepeats%);
    SetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    SetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    SetIntRegistryValue(key$, "Progression", tunAreaProgression%);
    SetIntRegistryValue(key$, "UseFile", tunAreaUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunAreaTuningFile$);
    SetIntRegistryValue(key$, "DualScreenCombo", tunAreaDualScreenComboRegistry%);
    SetIntRegistryValue(key$, "OptimalIndex", tunDonutOptimalIndex%);
    SetIntRegistryValue(key$, "DonutProgression", tunDonutProgression%);
    SetIntRegistryValue(key$, "DonutCoreOnSlave", tunDonutCoreOnSlave%);
    SetIntRegistryValue(key$, "MaximalIndexBerliner", tunBerlinerMaximalIndex%);
    SetFloatRegistryValue(key$, "MaximalDiamBerliner", tunBerlinerMaximalDiam);
    SetIntRegistryValue(key$, "NStepsBerliner", tunBerlinerNSteps%);
    SetIntRegistryValue(key$, "NRepeatsDiamBerliner", tunBerlinerNRepeats%);
    SetIntRegistryValue(key$, "BerlinerProgression", tunBerlinerProgression%);
    SetIntRegistryValue(key$, "MasterFollowsCurve1", tunMasterFollowsCurve1%);
    SetIntRegistryValue(key$, "BoxODonutsProgression", tunBoxODonutsProgression%);
    SetIntRegistryValue(key$, "BerlinerCoreOnSlave", tunBerlinerCoreOnSlave%);
    SetIntRegistryValue(key$, "BoxODonutsNRepeats", tunBoxODonutsNRepeats%);
    SetIntRegistryValue(key$, "BoxODonutsOneOrTwoGratings", tunBoxODonutsNumGratingOption%);  'variable renamed, keep key the same
end;

proc GetTuningCurveDotsParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Dots";
    tunDotsNSteps% := GetIntRegistryValue%(key$, "NSteps", tunDotsNSteps%);
    tunDotsNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunDotsNRepeats%);
    tunDotsMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunDotsMinOrientation);
    tunDotsMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunDotsMaxOrientation);
    tunDotsX := GetFloatRegistryValue(key$, "X", tunDotsX);
    tunDotsY := GetFloatRegistryValue(key$, "Y", tunDotsY);
    tunDotsDiameter := GetFloatRegistryValue(key$, "Diameter", tunDotsDiameter);
    tunDotsSpeed := GetFloatRegistryValue(key$, "Speed", tunDotsSpeed);
    tunDotsDensity := GetFloatRegistryValue(key$, "Density", tunDotsDensity);
    tunDotsSize% := GetIntRegistryValue%(key$, "Size", tunDotsSize%);
    tunDotsProgression% := GetIntRegistryValue%(key$, "Progression", tunDotsProgression%);
    tunDotsBGR% := GetIntRegistryValue%(key$, "BGR", tunDotsBGR%);
    tunDotsBGG% := GetIntRegistryValue%(key$, "BGG", tunDotsBGG%);
    tunDotsBGB% := GetIntRegistryValue%(key$, "BGB", tunDotsBGB%);
    tunDotsFGR% := GetIntRegistryValue%(key$, "FGR", tunDotsFGR%);
    tunDotsFGG% := GetIntRegistryValue%(key$, "FGG", tunDotsFGG%);
    tunDotsFGB% := GetIntRegistryValue%(key$, "FGB", tunDotsFGB%);
end;

proc SaveTuningCurveDotsParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Dots";
    SetIntRegistryValue(key$, "NSteps", tunDotsNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunDotsNRepeats%);
    SetFloatRegistryValue(key$, "MinOrientation", tunDotsMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunDotsMaxOrientation);
    SetFloatRegistryValue(key$, "X", tunDotsX);
    SetFloatRegistryValue(key$, "Y", tunDotsY);
    SetFloatRegistryValue(key$, "Diameter", tunDotsDiameter);
    SetFloatRegistryValue(key$, "Speed", tunDotsSpeed);
    SetFloatRegistryValue(key$, "Density", tunDotsDensity);
    SetIntRegistryValue(key$, "Size", tunDotsSize%);
    SetIntRegistryValue(key$, "Progression", tunDotsProgression%);
    SetIntRegistryValue(key$, "BGR", tunDotsBGR%);
    SetIntRegistryValue(key$, "BGG", tunDotsBGG%);
    SetIntRegistryValue(key$, "BGB", tunDotsBGB%);
    SetIntRegistryValue(key$, "FGR", tunDotsFGR%);
    SetIntRegistryValue(key$, "FGG", tunDotsFGG%);
    SetIntRegistryValue(key$, "FGB", tunDotsFGB%);
end;


proc GetTuningCurveCRGParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRG";
    tunCRGNRepeats% := GetIntRegistryValue%(key$, "CRGNRepeats", tunCRGNRepeats%);
    tunCRGFramesPerFlip% := GetIntRegistryValue%(key$, "CRGFramesPerTurn", tunCRGFramesPerFlip%);
    tunCRGProgression% := GetIntRegistryValue%(key$, "CRGProgression", tunCRGProgression%);
    tunCRGOnSlave% := GetIntRegistryValue%(key$, "CRGOnSlave", tunCRGOnSlave%);
    tunCRGSeqFile$ := GetStringRegistryValue$(key$, "CRGSeqFile", tunCRGSeqFile$);
end;


proc SaveTuningCurveCRGParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRG";
    SetIntRegistryValue(key$, "CRGNRepeats", tunCRGNRepeats%);
    SetIntRegistryValue(key$, "CRGFramesPerTurn", tunCRGFramesPerFlip%);
    SetIntRegistryValue(key$, "CRGProgression", tunCRGProgression%);
    SetIntRegistryValue(key$, "CRGOnSlave", tunCRGOnSlave%);
    SetStringRegistryValue(key$, "CRGSeqFile", tunCRGSeqFile$);
end;



proc GetTuningCurveDanishParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Danish";
    tunDanishNSteps% := GetIntRegistryValue%(key$, "DanishNSteps", tunDanishNSteps%);
    tunDanishNRepeats% := GetIntRegistryValue%(key$, "DanishNRepeats", tunDanishNRepeats%);
    tunDanishMinOuterDiameter := GetFloatRegistryValue(key$, "DanishMinOuterDiameter", tunDanishMinOuterDiameter);
    tunDanishMaxOuterDiameter := GetFloatRegistryValue(key$, "DanishMaxOuterDiameter", tunDanishMaxOuterDiameter);
    tunDanishProgression% := GetIntRegistryValue%(key$, "DanishProgression", tunDanishProgression%);
    tunDanishIncludeBlank% := GetIntRegistryValue%(key$, "DanishIncludeBlank", tunDanishIncludeBlank%);
end;


proc SaveTuningCurveDanishParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Danish";
    SetIntRegistryValue(key$, "DanishNSteps", tunDanishNSteps%);
    SetIntRegistryValue(key$, "DanishNRepeats", tunDanishNRepeats%);
    SetFloatRegistryValue(key$, "DanishMinOuterDiameter", tunDanishMinOuterDiameter);
    SetFloatRegistryValue(key$, "DanishMaxOuterDiameter", tunDanishMaxOuterDiameter);
    SetIntRegistryValue(key$, "DanishProgression", tunDanishProgression%);
    SetIntRegistryValue(key$, "DanishIncludeBlank", tunDanishIncludeBlank%);
end;


proc GetTuningCurveGonzagoParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Gonzago";
    'tunGonzagoNSteps% := GetIntRegistryValue%(key$, "GonzagoNSteps", tunGonzagoNSteps%);
    tunGonzagoCoreContrastNSteps% := GetIntRegistryValue%(key$, "GonzagoCoreContrastNSteps", tunGonzagoCoreContrastNSteps% );
    tunGonzagoDonutAreaNSteps% := GetIntRegistryValue%(key$, "GonzagoDonutAreaNSteps", tunGonzagoDonutAreaNSteps%);
    tunGonzagoNRepeats% := GetIntRegistryValue%(key$, "GonzagoNRepeats", tunGonzagoNRepeats%);
    tunGonzagoMinOuterDiameter := GetFloatRegistryValue(key$, "GonzagoMinOuterDiameter", tunGonzagoMinOuterDiameter);
    tunGonzagoMaxOuterDiameter := GetFloatRegistryValue(key$, "GonzagoMaxOuterDiameter", tunGonzagoMaxOuterDiameter);
    tunGonzagoMinContrast := GetFloatRegistryValue(key$, "GonzagoMinContrast", tunGonzagoMinContrast);
    tunGonzagoMaxContrast := GetFloatRegistryValue(key$, "GonzagoMaxContrast", tunGonzagoMaxContrast);
    tunGonzagoProgression% := GetIntRegistryValue%(key$, "GonzagoProgression", tunGonzagoProgression%);
    'tunGonzagoIncludeBlank% := GetIntRegistryValue%(key$, "GonzagoIncludeBlank", tunGonzagoIncludeBlank%);

    
end;


proc SaveTuningCurveGonzagoParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Gonzago";
    'SetIntRegistryValue(key$, "GonzagoNSteps", tunGonzagoNSteps%);
    SetIntRegistryValue(key$, "GonzagoCoreContrastNSteps", tunGonzagoCoreContrastNSteps% );
    SetIntRegistryValue(key$, "GonzagoDonutAreaNSteps", tunGonzagoDonutAreaNSteps%);
    SetIntRegistryValue(key$, "GonzagoNRepeats", tunGonzagoNRepeats%);
    SetFloatRegistryValue(key$, "GonzagoMinOuterDiameter", tunGonzagoMinOuterDiameter);
    SetFloatRegistryValue(key$, "GonzagoMaxOuterDiameter", tunGonzagoMaxOuterDiameter);
    SetFloatRegistryValue(key$, "GonzagoMinContrast", tunGonzagoMinContrast);
    SetFloatRegistryValue(key$, "GonzagoMaxContrast", tunGonzagoMaxContrast);
    SetIntRegistryValue(key$, "GonzagoProgression", tunGonzagoProgression%);
    'SetIntRegistryValue(key$, "GonzagoIncludeBlank", tunGonzagoIncludeBlank%);
end;




proc GetTuningCurveDSSParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DSS";
    tunDSSNPeriods% := GetIntRegistryValue%(key$, "DSSNPeriods", tunDSSNPeriods%);
    tunDSSNBlanks% := GetIntRegistryValue%(key$, "DSSNBlanks", tunDSSNBlanks%);
    tunDSSNFlashesPerReward% := GetIntRegistryValue%(key$, "DSSNFlashesPerReward", tunDSSNFlashesPerReward%);
    tunDSSNTrials% := GetIntRegistryValue%(key$, "DSSNTrials", tunDSSNTrials%);
end;


proc SaveTuningCurveDSSParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DSS";
    SetIntRegistryValue(key$, "DSSNPeriods", tunDSSNPeriods%);
    SetIntRegistryValue(key$, "DSSNBlanks", tunDSSNBlanks%);
    SetIntRegistryValue(key$, "DSSNFlashesPerReward", tunDSSNFlashesPerReward%);
    SetIntRegistryValue(key$, "DSSNTrials", tunDSSNTrials%);
end;


proc GetTuningCurveNullTestParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\NullTest";
    
    tunNullTestNSteps% := GetIntRegistryValue%(key$, "NSteps", tunNullTestNSteps%);
    tunNullTestNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunNullTestNRepeats%);
    tunNullTestProgression% := GetIntRegistryValue%(key$, "Progression", tunNullTestProgression%);
    'tunNullTestStepFunc% := GetIntRegistryValue%(key$, "StepFunc", tunNullTestStepFunc%);
    tunNullTestMinPhase := GetFloatRegistryValue(key$, "MinPhase", tunNullTestMinPhase);
    tunNullTestMaxPhase := GetFloatRegistryValue(key$, "MaxPhase", tunNullTestMaxPhase);
    'tunNullTestTF := GetFloatRegistryValue(key$, "TransitionFreq", tunNullTestTF);
    tunNullTestUseFile% := GetIntRegistryValue%(key$, "UseFile", tunNullTestUseFile%);
    tunNullTestTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunNullTestTuningFile$);
end;

proc SaveTuningCurveNullTestParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\NullTest";

    SetIntRegistryValue(key$, "NSteps", tunNullTestNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunNullTestNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunNullTestProgression%);
    'SetIntRegistryValue(key$, "StepFunc", tunNullTestStepFunc%);
    SetFloatRegistryValue(key$, "MinPhase", tunNullTestMinPhase);
    SetFloatRegistryValue(key$, "MaxPhase", tunNullTestMaxPhase);
    'SetFloatRegistryValue(key$, "TransitionFreq", tunNullTestTF);
    SetIntRegistryValue(key$, "UseFile", tunNullTestUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunNullTestTuningFile$);
end;

proc GetTuningCurveLagParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Lag";
    
    tunLagNSteps% := GetIntRegistryValue%(key$, "NSteps", tunLagNSteps%);
    tunLagNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunLagNRepeats%);
    tunLagMinLagFrames% := GetIntRegistryValue%(key$, "MinLag", tunLagMinLagFrames%);
    tunLagMaxLagFrames% := GetIntRegistryValue%(key$, "MaxLag", tunLagMaxLagFrames%);
    tunLagProgression% := GetIntRegistryValue%(key$, "Progression", tunLagProgression%);
    tunLagUseFile% := GetIntRegistryValue%(key$, "UseFile", tunLagUseFile%);
    tunLagTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunLagTuningFile$);
    tunLagMasterIsLagged% := GetIntRegistryValue%(key$, "MasterIsLagged", tunLagMasterIsLagged%);
end;

proc SaveTuningCurveLagParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Lag";
    SetIntRegistryValue(key$, "NSteps", tunLagNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunLagNRepeats%);
    SetIntRegistryValue(key$, "MinLag", tunLagMinLagFrames%);
    SetIntRegistryValue(key$, "MaxLag", tunLagMaxLagFrames%);
    SetIntRegistryValue(key$, "Progression", tunLagProgression%);
    SetIntRegistryValue(key$, "UseFile", tunLagUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunLagTuningFile$);
    SetIntRegistryValue(key$, "MasterIsLagged", tunLagMasterIsLagged%);
end;


proc GetTunOptoParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Opto";
    
    tunPreStimOptoTime := GetFloatRegistryValue(key$, "PreStimOptoTime", tunPreStimOptoTime);
    tunPostStimOptoTime := GetFloatRegistryValue(key$, "PostStimOptoTime", tunPostStimOptoTime);
    tunOptoStaysOn% := GetIntRegistryValue%(key$, "OptoStaysOn", tunOptoStaysOn%);
    tunOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", tunOptoVoltageOut);
    tunOptoStartState% := GetIntRegistryValue%(key$, "OptoStartState", tunOptoStartState%);
    tunOptoUsePulse% := GetIntRegistryValue%(key$, "OptoUsePulse", tunOptoUsePulse%);
    tunLaserDiode% := GetIntRegistryValue%(key$, "LaserDiode", tunLaserDiode%);
    tunOptoNPulses% := GetIntRegistryValue%(key$, "OptoNPulses", tunOptoNPulses%);
    tunPulsedOptoOnset := GetFloatRegistryValue(key$, "PulsedOptoOnset", tunPulsedOptoOnset);
    tunPulsedOptoWidth := GetFloatRegistryValue(key$, "PulsedOptoWidth", tunPulsedOptoWidth);
    tunPulsedOptoIPI := GetFloatRegistryValue(key$, "PulsedOptoIPI", tunPulsedOptoIPI);
    tunInterBlockTime := GetFloatRegistryValue(key$, "InterBlockTime", tunInterBlockTime);
    
    
    'tunRecOptoBox% := GetIntRegistryValue%(key$, "RecOptoBox", tunRecOptoBox%);
    'tunRecStimulator% := GetIntRegistryValue%(key$, "RecStimulator", tunRecStimulator%);

end;

proc SaveTunOptoParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Opto";
    SetFloatRegistryValue(key$, "PreStimOptoTime", tunPreStimOptoTime);
    SetFloatRegistryValue(key$, "PostStimOptoTime", tunPostStimOptoTime);
    SetIntRegistryValue(key$, "OptoStaysOn", tunOptoStaysOn%);
    SetFloatRegistryValue(key$, "OptoVoltageOut", tunOptoVoltageOut);
    SetIntRegistryValue(key$, "OptoStartState", tunOptoStartState%);
    SetIntRegistryValue(key$, "OptoUsePulse", tunOptoUsePulse%);
    SetIntRegistryValue(key$, "LaserDiode", tunLaserDiode%);
    SetIntRegistryValue(key$, "OptoNPulses", tunOptoNPulses%);
    SetFloatRegistryValue(key$, "PulsedOptoOnset", tunPulsedOptoOnset);
    SetFloatRegistryValue(key$, "PulsedOptoWidth", tunPulsedOptoWidth);
    SetFloatRegistryValue(key$, "PulsedOptoIPI", tunPulsedOptoIPI);
    SetFloatRegistryValue(key$, "InterBlockTime", tunInterBlockTime);
    
    'SetIntRegistryValue(key$, "RecOptoBox", tunRecOptoBox%);
    'SetIntRegistryValue(key$, "RecStimulator", tunRecStimulator%);
end;


proc GetTuningCurveBakersDozenParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\BakersDozen";
    tunBDTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunBDTuningFile$);
    tunBDUseOCFile% := GetIntRegistryValue%(key$, "BDUseOCFile", tunBDUseOCFile%);
    tunBDOCFile$ := GetStringRegistryValue$(key$, "OCFile", tunBDOCFile$);
    tunPauseOnConditionChange% := GetIntRegistryValue%(key$, "PauseOnConditionChange", tunPauseOnConditionChange%);
    tunRepeatForever% := GetIntRegistryValue%(key$, "RepeatForever", tunRepeatForever%);
end;

proc SaveTuningCurveBakersDozenParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\BakersDozen";
    SetStringRegistryValue(key$, "TuningFile", tunBDTuningFile$);
    SetIntRegistryValue(key$, "BDUseOCFile", tunBDUseOCFile%);
    SetStringRegistryValue(key$, "OCFile", tunBDOCFile$);
    SetIntRegistryValue(key$, "PauseOnConditionChange", tunPauseOnConditionChange%);
    SetIntRegistryValue(key$, "RepeatForever", tunRepeatForever%);
end;



proc GetTuningCurveFixptColorParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\FixptColor";
    tunFPCNSteps% := GetIntRegistryValue%(key$, "NSteps", tunFPCNSteps%);
    tunFPCNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunFPCNRepeats%);
    tunFPCRedValue% := GetIntRegistryValue%(key$, "RedValue", tunFPCRedValue%);
    tunFPCGreenValue% := GetIntRegistryValue%(key$, "GreenValue", tunFPCGreenValue%);
    tunFPCBlueValue% := GetIntRegistryValue%(key$, "BlueValue", tunFPCBlueValue%);
    tunFPCGunIndex% := GetIntRegistryValue%(key$, "GunIndex", tunFPCGunIndex%);
    tunFPCMinValue := GetFloatRegistryValue(key$, "MinValue", tunFPCMinValue);
    tunFPCMaxValue := GetFloatRegistryValue(key$, "MaxValue", tunFPCMaxValue);
    tunFPCProgression% := GetIntRegistryValue%(key$, "Progression", tunFPCProgression%);
    tunFPCUseFile% := GetIntRegistryValue%(key$, "UseFile", tunFPCUseFile%);
    tunFPCTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunFPCTuningFile$);
end;

proc SaveTuningCurveFixptColorParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\FixptColor";
    SetIntRegistryValue(key$, "NSteps", tunFPCNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunFPCNRepeats%);
    SetIntRegistryValue(key$, "RedValue", tunFPCRedValue%);
    SetIntRegistryValue(key$, "GreenValue", tunFPCGreenValue%);
    SetIntRegistryValue(key$, "BlueValue", tunFPCBlueValue%);
    SetIntRegistryValue(key$, "GunIndex", tunFPCGunIndex%);
    SetFloatRegistryValue(key$, "MinValue", tunFPCMinValue);
    SetFloatRegistryValue(key$, "MaxValue", tunFPCMaxValue);
    SetIntRegistryValue(key$, "Progression", tunFPCProgression%);
    SetIntRegistryValue(key$, "UseFile", tunFPCUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunFPCTuningFile$);
end;


proc GetTuningCurveFixptJumpParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\FixptJump";
    tunFPJNAdvances% := GetIntRegistryValue%(key$, "FPJNAdvances", tunFPJNAdvances%);
    tunFPJXOffset := GetFloatRegistryValue(key$, "FPJXOffset", tunFPJXOffset);
    tunFPJYOffset := GetFloatRegistryValue(key$, "FPJYOffset", tunFPJYOffset);
    tunFPJProbSaccade := GetFloatRegistryValue(key$, "FPJProbSaccade", tunFPJProbSaccade);
    tunFPJtFixptMove := GetFloatRegistryValue(key$, "FPJtFixptMove", tunFPJtFixptMove);
end;


proc SaveTuningCurveFixptJumpParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\FixptJump";
    SetIntRegistryValue(key$, "FPJNAdvances", tunFPJNAdvances%);
    SetFloatRegistryValue(key$, "FPJXOffset", tunFPJXOffset);
    SetFloatRegistryValue(key$, "FPJYOffset", tunFPJYOffset);
    SetFloatRegistryValue(key$, "FPJProbSaccade", tunFPJProbSaccade);
    SetFloatRegistryValue(key$, "FPJtFixptMove", tunFPJtFixptMove);
end;


proc GetTuningCurvePolkaDotParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\PolkaDots";
    tunPDNColorSteps% := GetIntRegistryValue%(key$, "NColorSteps", tunPDNColorSteps%);
    tunPDNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunPDNRepeats%);
    tunPDRedValue% := GetIntRegistryValue%(key$, "RedValue", tunPDRedValue%);
    tunPDGreenValue% := GetIntRegistryValue%(key$, "GreenValue", tunPDGreenValue%);
    tunPDBlueValue% := GetIntRegistryValue%(key$, "BlueValue", tunPDBlueValue%);
    tunPDGunIndex% := GetIntRegistryValue%(key$, "GunIndex", tunPDGunIndex%);
    tunPDMinGunValue := GetFloatRegistryValue(key$, "MinGunValue", tunPDMinGunValue);
    tunPDMaxGunValue := GetFloatRegistryValue(key$, "MaxGunValue", tunPDMaxGunValue);
    tunPDNXSteps% := GetIntRegistryValue%(key$, "NXSteps", tunPDNXSteps%);
    tunPDMinXPos := GetFloatRegistryValue(key$, "MinXPos", tunPDMinXPos);
    tunPDMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunPDMaxXPos);
    tunPDNYSteps% := GetIntRegistryValue%(key$, "NYSteps", tunPDNYSteps%);
    tunPDMinYPos := GetFloatRegistryValue(key$, "MinYPos", tunPDMinYPos);
    tunPDMaxYPos := GetFloatRegistryValue(key$, "MaxYPos", tunPDMaxYPos);
    tunPDProgression% := GetIntRegistryValue%(key$, "Progression", tunPDProgression%);
    tunPDUseFile% := GetIntRegistryValue%(key$, "UseFile", tunPDUseFile%);
    tunPDTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunPDTuningFile$);
    tunPDDiameter := GetFloatRegistryValue(key$, "Diameter", tunPDDiameter);
    tunPDShowGrating% := GetIntRegistryValue%(key$, "ShowGrating", tunPDShowGrating%);
    tunPDLagSec := GetFloatRegistryValue(key$, "LagSec", tunPDLagSec);
end;

proc SaveTuningCurvePolkaDotParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\PolkaDots";
    SetIntRegistryValue(key$, "NColorSteps", tunPDNColorSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunPDNRepeats%);
    SetIntRegistryValue(key$, "RedValue", tunPDRedValue%);
    SetIntRegistryValue(key$, "GreenValue", tunPDGreenValue%);
    SetIntRegistryValue(key$, "BlueValue", tunPDBlueValue%);
    SetIntRegistryValue(key$, "GunIndex", tunPDGunIndex%);
    SetFloatRegistryValue(key$, "MinGunValue", tunPDMinGunValue);
    SetFloatRegistryValue(key$, "MaxGunValue", tunPDMaxGunValue);
    SetIntRegistryValue(key$, "NXSteps", tunPDNXSteps%);
    SetFloatRegistryValue(key$, "MinXPos", tunPDMinXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunPDMaxXPos);
    SetIntRegistryValue(key$, "NYSteps", tunPDNYSteps%);
    SetFloatRegistryValue(key$, "MinYPos", tunPDMinYPos);
    SetFloatRegistryValue(key$, "MaxYPos", tunPDMaxYPos);
    SetIntRegistryValue(key$, "Progression", tunPDProgression%);
    SetIntRegistryValue(key$, "UseFile", tunPDUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunPDTuningFile$);
    SetFloatRegistryValue(key$, "Diameter", tunPDDiameter);
    SetIntRegistryValue(key$, "ShowGrating", tunPDShowGrating%);
    SetFloatRegistryValue(key$, "LagSec", tunPDLagSec);
end;



'------------ END Read/write tuning curve parameters to the registry ------------


func TuningCurveOrientationDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveOrientationParameters();
	DlgCreate("Run Orientation Tuning Curve");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Orientation (deg)", 0, 360);
	DlgReal(4, "Max Orientation (deg)", 0, 360);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunOriNSteps%, tunOriNRepeats%, tunOriMinOrientation, tunOriMaxOrientation, tunOriProgression%, tunOriUseFile%, tunOriTuningFile$);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
	if i% = 1 then
		SaveTuningCurveOrientationParameters();
		PrintLog("TuningCurveOrientationDialog - user hit OK\n");
		tunType$ := tunTypeOrientation$;
        tunUseFile% := tunOriUseFile%;
        tunTuningFile$ := tunOriTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeOrientation$;
            tunUseFile1% := tunOriUseFile%;
            tunTuningFile1$ := tunOriTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is ORIENTATION";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgOrientationButton%);  'So we don't pick orientation again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeOrientation$;
            tunUseFile2% := tunOriUseFile%;
            tunTuningFile2$ := tunOriTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is ORIENTATION";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgOrientationButton%);  'So we don't pick orientation again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeOrientation$;
            if DlgValue(5) = 0 then 'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is ORIENTATION";
            else
                tunCurve1Text$ := "Tuning Curve on Master is ORIENTATION";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;

        iReturn% := 1;
        
	endif;
	if i% = 0 then
		PrintLog("TuningCurveOrientationDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;



func TuningCurveContrastDialog%()
	var iReturn% := 0;
	var i%;
    var hmm1%;
    var hmm2%;
    
    GetTuningCurveContrastParameters();    
    
    'This determines whether the dual screen combo tuning controls are allowed 
    hmm1% := DlgValue(11);
    hmm2% := DlgValue(12);
    if hmm1% = 1 and hmm2% = 0 then
        tempDualValue% := 1;
        tunContrastDualScreenCombo% := tunContrastDualScreenComboRegistry%;  'if it's allowed, set it to the registry value
    else
        tempDualValue% := 0;
        tunContrastDualScreenCombo% := 0;  'Also, if it's not allowed, set it to 0
    endif;
    
	
	DlgCreate("Contrast Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Contrast (%)", 0.1, 100);
	DlgReal(4, "Max Contrast (%)", 0.1, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgCheck(8, "Do Dual-Screen Combo Tuning",2,9);
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveContrastDialogChanged%);

	i% := DlgShow(tunContrastNSteps%, tunContrastNRepeats%, tunContrastMinContrast, tunContrastMaxContrast, tunContrastProgression%, tunContrastUseFile%, tunContrastTuningFile$, tunContrastDualScreenCombo%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't. 
	if i% = 1 then
        if tempDualValue% = 1 then 'save value in registry if we are allowed to change it
            tunContrastDualScreenComboRegistry% := tunContrastDualScreenCombo%;
        endif;
        
		SaveTuningCurveContrastParameters();
'		PrintLog("TuningCurveContrastDialog - user hit OK\n");
		tunType$ := tunTypeContrast$;
        tunUseFile% := tunContrastUseFile%;
        tunTuningFile$ := tunContrastTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeContrast$;
            tunUseFile1% := tunContrastUseFile%;
            tunTuningFile1$ := tunContrastTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is CONTRAST";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgContrastButton%);  'So we don't pick contrast again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeContrast$;
            tunUseFile2% := tunContrastUseFile%;
            tunTuningFile2$ := tunContrastTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is CONTRAST";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgContrastButton%);  'So we don't pick contrast again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeContrast$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is CONTRAST";
            else
                tunCurve1Text$ := "Tuning Curve on Master is CONTRAST";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        iReturn% := 1;
        
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveContrastDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;


func TuningCurveContrastDialogChanged%(item%)
    'There is an update to ONLY the contrast dialog that requires a special dialog changed function 
    
    
    DlgEnable(tempDualValue%,8);  'enable/disable dual screen combo based on if it should be allowed

    
    if DlgValue(6) = 0 then  'If we are not using a tuning file
        DlgEnable(0,7);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(6) = 1 then
        DlgEnable(1,7);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


func TuningCurveSpatialDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveSpatialParameters();
	DlgCreate("Spatial Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min SF", .01, 100);
	DlgReal(4, "Max SF", .01, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);

	i% := DlgShow(tunSpatialNSteps%, tunSpatialNRepeats%, tunSpatialMinSF, tunSpatialMaxSF, tunSpatialProgression%, tunSpatialUseFile%, tunSpatialTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
	if i% = 1 then
		SaveTuningCurveSpatialParameters();
'		PrintLog("TuningCurveSpatialDialog - user hit OK\n");
		tunType$ := tunTypeSpatial$;
        tunUseFile% := tunSpatialUseFile%;
        tunTuningFile$ := tunSpatialTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeSpatial$;
            tunUseFile1% := tunSpatialUseFile%;
            tunTuningFile1$ := tunSpatialTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is SPATIAL FREQ";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgSpatialButton%);  'So we don't pick spatial frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeSpatial$;
            tunUseFile2% := tunSpatialUseFile%;
            tunTuningFile2$ := tunSpatialTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is SPATIAL FREQ";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgSpatialButton%);  'So we don't pick spatial frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeSpatial$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is SPATIAL FREQ";
            else
                tunCurve1Text$ := "Tuning Curve on Master is SPATIAL FREQ";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;

        iReturn% := 1;
        
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveSpatialDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveTemporalDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveTemporalParameters();
	DlgCreate("Temporal Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min TF", 0, 100);
	DlgReal(4, "Max TF", 0, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);

	i% := DlgShow(tunTemporalNSteps%, tunTemporalNRepeats%, tunTemporalMinTF, tunTemporalMaxTF, tunTemporalProgression%, tunTemporalUseFile%, tunTemporalTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
	if i% = 1 then
		SaveTuningCurveTemporalParameters();
'		PrintLog("TuningCurveTemporalDialog - user hit OK\n");
		tunType$ := tunTypeTemporal$;
        tunUseFile% := tunTemporalUseFile%;
        tunTuningFile$ := tunTemporalTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeTemporal$;
            tunUseFile1% := tunTemporalUseFile%;
            tunTuningFile1$ := tunTemporalTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is TEMPORAL FREQ";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgTemporalButton%);  'So we don't pick temporal frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeTemporal$;
            tunUseFile2% := tunTemporalUseFile%;
            tunTuningFile2$ := tunTemporalTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is TEMPORAL FREQ";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgTemporalButton%);  'So we don't pick temporal frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeTemporal$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is TEMPORAL FREQ";
            else
                tunCurve1Text$ := "Tuning Curve on Master is TEMPORAL FREQ";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;

        iReturn% := 1;
        
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveTemporalDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveAreaDialog%()
	var iReturn% := 0;
	var i%;
    var hmm1%;
    var hmm2%;
    
	GetTuningCurveAreaParameters();
    
    'This determines whether the dual screen combo tuning controls are allowed 
    hmm1% := DlgValue(11);
    hmm2% := DlgValue(12);
    if hmm1% = 1 and hmm2% = 0 then
        tempDualValue% := 1;
        tunAreaDualScreenCombo% := tunAreaDualScreenComboRegistry%;  'if it's allowed, set it to the registry value
    else
        tempDualValue% := 0;
        tunAreaDualScreenCombo% := 0;  'Also, if it's not allowed, set it to 0
    endif;
    
    
	DlgCreate("Area Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgCheck(8, "Do Dual-Screen Combo Tuning",2,9);
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveContrastDialogChanged%);  'Yes, that says CONTRAST.  I wrote the Contrast one special because
                                                             'of the dual-screen combo tuning, and now area does the same.  The
                                                             'dialog-changed functions are generic, so...
    
    
	i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunAreaUseFile%, tunAreaTuningFile$, tunAreaDualScreenCombo%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
        if tempDualValue% = 1 then 'save value in registry if we are allowed to change it
            tunAreaDualScreenComboRegistry% := tunAreaDualScreenCombo%;
        endif;
        
		SaveTuningCurveAreaParameters();
'		PrintLog("TuningCurveAreaDialog - user hit OK\n");
		tunType$ := tunTypeArea$;
        tunUseFile% := tunAreaUseFile%;
        tunTuningFile$ := tunAreaTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeArea$;
            tunUseFile1% := tunAreaUseFile%;
            tunTuningFile1$ := tunAreaTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is AREA";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgAreaButton%);  'So we don't pick area again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeArea$;
            tunUseFile2% := tunAreaUseFile%;
            tunTuningFile2$ := tunAreaTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is AREA";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgAreaButton%);  'So we don't pick area again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeArea$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is AREA";
            else
                tunCurve1Text$ := "Tuning Curve on Master is AREA";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;

        iReturn% := 1;
        
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;




func TuningCurveXPosDialog%()
	var iReturn% := 0;
	var i%;
    
    'This function is now complicated because fixstim has XY tuning while dualstim only has X tuning
    'Because XY tuning is a superset of X tuning there does not seem to be much reason to have a separate
    'button, so that means this button needs to change between XY tuning and X tuning depending on the
    'context.  But that's doable.
    if DlgValue(11) = 1 or tunCRGCurrentCurve% = 1 or tunBoxODonutsCurrentCurve% > 0 then  'if it's a dualstim/Box scenario, use X position
        
        GetTuningCurveXPosParameters();
        DlgCreate("XPos Tuning Curve Parameters");
        DlgInteger(1, "Number of Steps", 1, 100);
        'DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgReal(3, "Min X Position", -14, 14);
        DlgReal(4, "Max X Position", -14, 14);
        'DlgCheck(5, "Random Progression");
        if tunBoxODonutsCurrentCurve% = 0 then
            DlgInteger(2, "Number of Repeats", 1, 3000);
            DlgCheck(5, "Random Progression");
        else
            DlgInteger(2, "----------------", 1, 1);
            DlgCheck(5, "----------------");
        endif;

        
        i% := DlgShow(tunXPosNSteps%, tunXPosNRepeats%, tunXPosMinXPos, tunXPosMaxXPos, tunXPosProgression%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        
        if i% = 1 then
            SaveTuningCurveXPosParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeXPos$;
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            'Oh, and update tuning types we are going to use.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypeXPos$;
                tunCurve1Text$ := "Tuning Curve 1 is X POSITION";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick X position again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypeXPos$;
                tunCurve2Text$ := "Tuning Curve 2 is X POSITION";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick X position again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            case tunCRGCurrentCurve% = 1 then
                tunCRGCurrentCurve% := 2;
                tunType1$ := tunTypeXPos$;
                if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                    tunCurve1Text$ := "Tuning Curve on Slave is X POSITION";
                else
                    tunCurve1Text$ := "Tuning Curve on Master is X POSITION";
                endif;
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            endcase;
            
            iReturn% := 1;
            
        endif;
    else 'if it's a fixstim scenario, use XY position
        'Note that XYPosition is now superficially set up for Box'o'Donuts use, but as this is a
        'basically zero-priority change, and there are complications in the implementation at later
        'stages, I am putting it off.  Adjust this ELSE's IF to remove tunBoxODonutsCurrentCurve% > 0
        'to get in here if this is ever implemented. -jj
        
        GetTuningCurveXYPosParameters();
        DlgCreate("XYPos Tuning Curve Parameters");
        'DlgInteger(1, "Number of Repeats", 1, 3000);
        DlgInteger(2, "Number of X Steps", 0, 100);
        DlgReal(3, "Min X Position", -14, 14);
        DlgReal(4, "Max X Position", -14, 14);
        DlgInteger(5, "Number of Y Steps", 0, 100);
        DlgReal(6, "Min Y Position", -14, 14);
        DlgReal(7, "Max Y Position", -14, 14);
        'DlgCheck(8, "Random Progression");
        if tunBoxODonutsCurrentCurve% = 0 then
            DlgInteger(1, "Number of Repeats", 1, 3000);
            DlgCheck(8, "Random Progression");
        else
            DlgInteger(1, "----------------", 1, 1);
            DlgCheck(8, "----------------");
        endif;
        
        DlgAllow(0xffff, 0, TuningCurveXYPosDialogChanged%);
        
        i% := DlgShow(tunXYPosNRepeats%, tunXYPosNXSteps%, tunXYPosMinXPos, tunXYPosMaxXPos, tunXYPosNYSteps%, tunXYPosMinYPos, tunXYPosMaxYPos, tunXYPosProgression%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        
        if i% = 1 then
            SaveTuningCurveXYPosParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeXYPos$;
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            'Oh, and update tuning types we are going to use.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypeXYPos$;
                tunCurve1Text$ := "Tuning Curve 1 is XY POSITION";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick XY position again, don't rename variable
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypeXYPos$;
                tunCurve2Text$ := "Tuning Curve 2 is XY POSITION";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick XY position again, don't rename variable
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            'Not allowing XYPos fir CRG at this point, only updating for Box'o'Donuts
            endcase;
               
            iReturn% := 1;
            
        endif;
    endif;    
        
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;



func TuningCurveXYPosDialogChanged%(item%) 
    if DlgValue(2) = 0 then  'If no X variation
        DlgEnable(0,4); 'disable X Max
    else
        DlgEnable(1,4); 'enable X Max
    endif
    if DlgValue(5) = 0 then  'If no Y variation
        DlgEnable(0,7); 'disable Y Max
    else
        DlgEnable(1,7); 'enable Y Max
    endif
    return 1;
end





func TuningCurveDisparityAndBakersDozenDialog%()
    'This is closely related to XPos
	var iReturn% := 0;
	var i%;
    
    if tunUseDisparityDialog% = 1 then   'run disparity dialog    
        
        var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
        var contrast%;
        var param$, cv$, pattern$, aperture$;
        var label$;
        
        'get parameters for Disparity tuning curve
        GetTuningCurveDisparityParameters();
        
        'get current x position, will allow update without going to grating parameters
        param$ := GetGratingParameters$("Stimulus");  'for XPos, get grating parameters from master stimulus, will reset master/slave accordingly 
        ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
        tunDisparityCenterXPos := x;
        
        DlgCreate("Disparity Tuning Curve Parameters");
        DlgInteger(1, "Number of Steps (one way)", 1, 100);
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgReal(3, "Center X Position", -14, 14);
        DlgReal(4, "Max X Position (will mirror)", -14, 14);
        DlgCheck(5, "Slave Screen Is Stationary");
        DlgCheck(6, "No function - only linear for now");
        'DlgCheck(6, "Linear progression (unchecked is log)");
        DlgCheck(7, "Random Progression");
        
        
        i% := DlgShow(tunDisparityNSteps%, tunDisparityNRepeats%, tunDisparityCenterXPos, tunDisparityMaxXPos, tunDisparityOnMaster%, tunDisparityLinear%, tunDisparityProgression%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't. 
        'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
        if i% = 1 then
            SaveTuningCurveDisparityParameters();
            'and reset the x position for master AND slave gratings
            x := tunDisparityCenterXPos;
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
            SaveGratingParameters("Stimulus", param$);  'this saves master
            TunMasterValsToSlave%();  'this copies master values over to slave
            
            tunType$ := tunTypeDisparity$;

            iReturn% := 1;
            
        endif;
        if i% = 0 then
            '		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
    else  'Run Baker's Dozen dialog
        GetTuningCurveBakersDozenParameters();
        DlgCreate("Run Baker's Dozen Tuning Curve");
        DlgString(1,40,255,"",3,1);  'for visual confirmation of selected trials file
        DlgButton(tundlgSelectTuningFileButton%, " Select Baker's Dozen File ", SelectBakersDozenFile%, 2, 2);
        DlgCheck(2,"Use Opto/Condition File?",2,4);
        DlgString(3,40,255,"",3,5);  'for visual confirmation of selected opto/condition file
        DlgButton(tundlgSelectTuningFileButton2%, " Select Opto/Condition File ", SelectBakersDozenOCFile%, 2, 6);
        DlgCheck(4,"Pause on Condition Change",2,7);
        DlgCheck(5,"Repeat Forever?",2,9);
        
        DlgAllow(0xffff, 0, TuningCurveBDDialogChanged%);
        
        i% := DlgShow(tunBDTuningFile$,tunBDUseOCFile%,tunBDOCFile$,tunPauseOnConditionChange%,tunRepeatForever%);
        
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
        if i% = 1 then
            SaveTuningCurveBakersDozenParameters();
            PrintLog("TuningCurveBakersDozenDialog - user hit OK\n");
            tunType$ := tunTypeBakersDozen$;
            tunUseFile% := 1;
            tunBakersDozenFileLoc$ := tunBDTuningFile$;
            
            if tunBDUseOCFile% = 1 then
                tunBakersDozenOCFileLoc$ := tunBDOCFile$;
                dontToggleOpto% := 1;  'Do not allow automatic toggling of opto at end-of-block, we will be controlling it on a trial-by-trial basis
                doTBTopto% := 1;  'Turn on trial-by-trial opto specification
            else
                tunPauseOnConditionChange% := 0;  'Force pause on condition change to 0 if no conditions are being read (could be 1 from dialog registry chaced value)
            endif;
            
            iReturn% := 1;
            
        endif;
        if i% = 0 then
            PrintLog("TuningCurveOrientationDialog - user hit Cancel\n");
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
    endif;
    
    
	return iReturn%;
end;






' This function is initially called with a "0" input, which forces the 1-5 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
func TuningCurveDonutDialogChanged%(item%)
    if item% = 0 then
        DlgEnable(0, 1, 2, 3, 4);
    endif    
    return 1;
end

func TuningCurveDonutANDGonzagoDialog%()
    
    var iReturn% := 0;
    var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    var mylist$[2];
    
    if tunUseDonutDialog% = 0 then

        GetTuningCurveGonzagoParameters();
        
        
        DlgCreate("Gonzago Tuning Curve Parameters");
        DlgInteger(1, "Number of Core Contrast Steps", 1, 100);
        DlgInteger(2, "Number of Donut Area Steps", 1, 100);
        DlgInteger(3, "Number of Repeats", 1, 3000);
        DlgReal(4, "Min Core Contrast", 0.1, 100);
        DlgReal(5, "Max Core Contrast", 0.1, 100);
        DlgReal(6, "Min Donut Outer Diameter", 0.1, 100);
        DlgReal(7, "Max Donut Outer Diameter", 0.1, 100);
        DlgCheck(8, "Random Progression");
        
        DlgButton(151, "Core Grating", TunDlgGratingCore%);
        DlgButton(152, "Donut Grating", TunDlgGratingDonut%);
        DlgButton(153, "Core Vals -> Donut", TunCoreValsToDonut%);
        DlgButton(154, "Donut Vals -> Core", TunDonutValsToCore%);
        'DlgAllow(0xffff, 0, TuningCurveGonzagoDialogChanged%);
        
        i% := DlgShow(tunGonzagoCoreContrastNSteps%, tunGonzagoDonutAreaNSteps%, tunGonzagoNRepeats%, tunGonzagoMinContrast, tunGonzagoMaxContrast, tunGonzagoMinOuterDiameter, tunGonzagoMaxOuterDiameter, tunGonzagoProgression%);
        
        'for now, no dummy-proofing
        
        
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        if i% = 1 then
            SaveTuningCurveGonzagoParameters();
            tunType$ := tunTypeGonzago$;
            tunType1$ := tunTypeContrast$;
            tunType2$ := tunTypeArea$;

            iReturn% := 1;
            
        endif;
        if i% = 0 then
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
        return iReturn%;
        
    else
    
        mylist$[0] := "Master";
        mylist$[1] := "Slave";
        
        
        GetTuningCurveAreaParameters();
        
        ' Before we proceed, we must generate a list of choices for the optimal diameter. 
        ' Note that there are nsteps+1 values. 
        
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
        sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
        
        DlgCreate("Donut Tuning Curve Parameters");
        DlgInteger(1, "Number of Steps", 1, 100);
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgReal(3, "Min Diameter", 0.1, 100);
        DlgReal(4, "Max Diameter", 0.1, 100);
        DlgCheck(5, "Random Progression");
        DlgList(6, "Optimal diameter", sValues$);
        DlgList(7, "Core is on:", mylist$[]);
        DlgButton(151, "Master Grating", TunDlgGratingMaster%);
        DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
        DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
        DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
        DlgAllow(0xffff, 0, TuningCurveDonutDialogChanged%);
        i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunDonutProgression%, tunDonutOptimalIndex%, tunDonutCoreOnSlave%);
        tunDonutOptimalDiam := result[tunDonutOptimalIndex%];
        
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't. 
        tunMaximalDiam := result[tunDonutOptimalIndex%];
        tunSlaveMaximalDiam := tunAreaMaxDiam;
        if i% = 1 then
            SaveTuningCurveAreaParameters();
            tunType$ := tunTypeDonut$;

            iReturn% := 1;
            
        endif;
        if i% = 0 then
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
        return iReturn%;
        
    endif;
    
end;

' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
func TuningCurveBerlinerDialogChanged%(item%)    
    if item% = 0 then
        DlgEnable(0, 1, 3, 4);
    endif   
    return 1;
end

func TuningCurveFixptJumpANDBerlinerDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    var mylist$[2];
    var x,y,w,h;
    var count%;
    var r1%, r2%;
    var r1, r2;  'for float math
    var safety%;
    
    if tunUseBerlinerDialog% = 0 then
        
        GetTuningCurveFixptJumpParameters(); 
        
        
        
        DlgCreate("Fixation Point Jump Parameters");
        DlgInteger(1, "Number of Total Jumps", 1, 1000);
        DlgReal(2, "Fixation Point X Offset (deg)", 0, 30);  'Will be used for both +/- location of fixpt
        DlgReal(3, "Fixation Point Y Offset (deg)", 0, 30);
        DlgReal(4, "Probability of Fixpt Jump (0-1)", 0.01, 1);  'don't allow 0 or the program will never end; could in principle do no jumps by setting offsets to 0
        DlgReal(5, "Time of Fixpt Jump (s)", 0.1, 10);  'needs to be short enough that the acquisition time will fit within standard maintain fixation period
        
        i% := DlgShow(tunFPJNAdvances%, tunFPJXOffset, tunFPJYOffset, tunFPJProbSaccade, tunFPJtFixptMove);
        
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        if i% = 1 then
            SaveTuningCurveFixptJumpParameters(); 
            
            tunType$ := tunTypeFixptJump$;
            
            'Make sure that tunMaintainFixation, tunAcquisitionTime and tunFPJtFixptMove all work out
            'We are including 100 ms "slop" for possible OS time slice delay in moving the fixpt
            'OK, currently using tunMaintainFixation as during-maintain acquisition time, so this isn't necessary, also it can't be done here (easily)
            'if tunMaintainFixation-tunFPJtFixptMove < tunAcquisitionTime+0.1 then
            '    message("Acquisition time must be at least 100 ms less than the time from fixpt move to time of next stim!  Quitting!");
            '    halt;
            'endif
            
            'Generate Fixation Point/Grating locations
            'Get x/y of grating
            ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"), x, y, w, h);
            'Loop through X/Y variables until full, do not allow two in a row to be the same
            while count% < tunFPJNAdvances%+1 and safety% < 10000 do
                'Calculate two values that are either 1 or -1
                r1% := rand(2,0);  'This doesn't seem like a two-liner, but I can't seem to pull it off.  Offsetting Rand() by -1 does not work right, and doing the math directly doesn't work!
                r1% := (r1%*2)-1; 
                r2% := rand(2,0);  
                r2% := (r2%*2)-1;
                r1 := r1%;
                r2 := r2%;
                tunFPJFixptX[count%] := tunFPJXOffset*r1;  'Use +/- fixpt offset
                tunFPJFixptY[count%] := tunFPJYOffset*r2;
                tunFPJGratingX[count%] := x + (tunFPJXOffset*r1);  'adjust position of grating accordingly
                tunFPJGratingY[count%] := y + (tunFPJYOffset*r2);
                if count% > 0 then
                    if (tunFPJFixptX[count%] <> tunFPJFixptX[count%-1]) or (tunFPJFixptY[count%] <> tunFPJFixptY[count%-1]) then
                        count% += 1;  'Only increment count% if the new position is different than the old position, otherwise try again
                    endif
                else
                    count% += 1; 'DO increment count% if it is 0
                endif
                safety% += 1;
            wend
            'Just keeping the safety around, it saved my butt during testing at least
            if safety% >= 10000 then
                printlog("Safety is %d\n",safety%);
                message("While loop in Fixpt Jump dialog has failed!  Quitting!");
                halt;
            endif;
            'Stringify the values
            tunFPJFixptStr$ := " -y ";
            tunFPJGratingStr$ := " -Z ";
            count% := 0;
            for count% := 0 to tunFPJNAdvances% do
                tunFPJFixptStr$ := tunFPJFixptStr$ + str$(tunFPJFixptX[count%]) + "," + str$(tunFPJFixptY[count%]);
                tunFPJGratingStr$ := tunFPJGratingStr$ + str$(tunFPJGratingX[count%]) + "," + str$(tunFPJGratingY[count%]);
                'Add closing comma before next line for all lines but the final one
                if count% < tunFPJNAdvances% then
                    tunFPJFixptStr$ := tunFPJFixptStr$ + ",";
                    tunFPJGratingStr$ := tunFPJGratingStr$ + ",";
                endif;
            next
            printlog("Fixpt string is %s\n",tunFPJFixptStr$);
            printlog("Grating string is %s\n",tunFPJGratingStr$);
            
            
            
            iReturn% := 1;
            
        endif;
        if i% = 0 then
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
        return iReturn%;
        
    else
        
        mylist$[0] := "Master";
        mylist$[1] := "Slave";
        
        
        GetTuningCurveAreaParameters();
        
        ' Before we proceed, we must generate a list of choices for the optimal diameter. These are based on the most recent run of Area tuning
        ' Note that there are nsteps+1 values. 
        
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
        sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
        
        'We want the default maximal value to be the largest value available when we open the dialog
        'so set tunBerlinerMaximalIndex% appropriately
        tunBerlinerMaximalIndex% := tunAreaNSteps%;
        
        'Define tunBerlinerNSteps%, because we are no longer doing a tuning curve.
        tunBerlinerNSteps% := 6;
        
        DlgCreate("Berliner Tuning Curve Parameters");
        'DlgInteger(1, "Number of Steps", 2, 100);
        DlgInteger(1, "Number of Stimuli", 1, 100);
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgReal(3, "Min Diameter", 0.1, 100);
        DlgReal(4, "Max Diameter", 0.1, 100);
        DlgCheck(5, "Random Progression");
        DlgList(6, "Optimal diameter", sValues$);
        DlgList(7, "Maximal diameter", sValues$);
        DlgList(8, "Core is on:", mylist$[]);
        DlgButton(151, "Master Grating", TunDlgGratingMaster%);
        DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
        DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
        DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
        DlgAllow(0xffff, 0, TuningCurveBerlinerDialogChanged%);
        'i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%);
        i% := DlgShow(tunBerlinerNSteps%, tunBerlinerNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunBerlinerProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%, tunBerlinerCoreOnSlave%);
        
        tunMaximalDiam := tunAreaMaxDiam;
        tunSlaveMaximalDiam := result[tunBerlinerMaximalIndex%];
        ' Don't let the user screw this up by selecting incompatible values
        if tunBerlinerMaximalIndex% > tunDonutOptimalIndex%+1 then
            tunDonutOptimalDiam := result[tunDonutOptimalIndex%];
            tunDonutOptimalDiamPlusOne := result[tunDonutOptimalIndex%+1];
            tunBerlinerMaximalDiam := result[tunBerlinerMaximalIndex%];
        else
            i% := 0;  'Treat this as a "cancel"
            if tunBerlinerMaximalIndex% > tunDonutOptimalIndex% then
                message("Oops!|The maximal index was only one value greater than the optimal index!\nThis would result in 'near facilitation' and 'far suppression'\nstimuli being identical!\n\nI know you didn't want that, so try again!");
            else
                message("Oops!|The maximal index was not greater than the optimal index!\n\nI know you didn't want that, so try again!");
            endif;
        endif;
        
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        if i% = 1 then
            SaveTuningCurveAreaParameters();
            tunType$ := tunTypeBerliner$;
            
            iReturn% := 1;
            
        endif;
        if i% = 0 then
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
        return iReturn%;
        
    endif; 
	
end;




' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
' There are now TWO different callback for BoxODonuts depending on whether there is a second screen or not - this is the second screen version
func TuningCurveBoxODonutsDialogChanged%(item%)    
    'This re-enables any disabled buttons if the Box O' Donuts dialog is cancelled
    if item% = 0 then
        DlgEnable(1,-tundlgOrientationButton%);
        DlgEnable(1,-tundlgContrastButton%);
        DlgEnable(1,-tundlgSpatialButton%);
        DlgEnable(1,-tundlgTemporalButton%);
        DlgEnable(1,-tundlgAreaButton%);
        DlgEnable(1,-tundlgXPosButton%);
        DlgEnable(1,-tundlgLagButton%);
        'DlgEnable(1,-tundlgFixptColorButton%);
        'DlgEnable(1,-tundlgPolkaDotButton%);  'only enable polka dots for second button
        
    endif;  
    if tunBoxODonutsCurrentCurve% = 1 then
        DlgEnable(0,-tundlgPolkaDotButton%);
    else
        DlgEnable(1,-tundlgPolkaDotButton%);
    endif;
    if tunBoxODonutsCurrentCurve% = 3 then
        DlgEnable(1,-1);  'enable "OK" if both curves have been selected
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    'disable dialog list allowing one or two gratings - if doing dual VSG we will ignore this value
    DlgEnable(0,4);
    
    return 1;
end


' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
' There are now TWO different callback for BoxODonuts depending on whether there is a second screen or not - this is the one screen version
func TuningCurveBoxODonutsDialogChanged2%(item%)    
    'This re-enables any disabled buttons if the Box O' Donuts dialog is cancelled
    if item% = 0 then
        DlgEnable(1,-tundlgOrientationButton%);
        DlgEnable(1,-tundlgContrastButton%);
        DlgEnable(1,-tundlgSpatialButton%);
        DlgEnable(1,-tundlgTemporalButton%);
        DlgEnable(1,-tundlgAreaButton%);
        DlgEnable(1,-tundlgXPosButton%);
        DlgEnable(1,-tundlgLagButton%);
        'DlgEnable(1,-tundlgFixptColorButton%);
        'DlgEnable(1,-tundlgPolkaDotButton%);  only enable polka dots for second button
        DlgEnable(0,3);  'Disable master follows curve 1 checkbox
        DlgEnable(0,-151);  'Disable all two-screen buttons
        DlgEnable(0,-152);
        DlgEnable(0,-153);
        DlgEnable(0,-154);
        
    endif;  
    if tunBoxODonutsCurrentCurve% = 1 then
        DlgEnable(0,-tundlgPolkaDotButton%);
    else
        DlgEnable(1,-tundlgPolkaDotButton%);
    endif;
    if tunBoxODonutsCurrentCurve% = 3 then
        DlgEnable(1,-1);  'enable "OK" if both curves have been selected
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    'enable dialog list allowing one or two gratings - if doing single VSG we will use this value
    DlgEnable(1,4);    
    
    return 1;
end



func TuningCurveBoxODonutsDialog%()
    var sValues$;
    var i%;
    var iReturn%;
    var gratingOptions$[2];
    
    gratingOptions$[0] := "Both tuning curves on main grating";
    gratingOptions$[1] := "Tuning curve 1 on main grating, tuning curve 2 on distractor1";
    
    GetTuningCurveAreaParameters();   'parameters are still carried in "area", may not be ideal but ought to work 
    
    tunBoxODonutsCurrentCurve% := 1;  'this will be 0 unless we select this tuning curve
    
    tunCurve1Text$ := "Tuning Curve 1 is unselected";
    tunCurve2Text$ := "Tuning Curve 2 is unselected";
    
    
    DlgCreate("Box O' Donuts Parameters");
    
    DlgInteger(1,"Number of repeats",1,1000,20);
    DlgCheck(2, "Random Progression", 2, 2);
    DlgCheck(3, "Master Follows Curve 1", 2, 3);
    DlgList(4, 55, gratingOptions$[], 2, 35, 1);
    
    if tunUseLagDialog% = 0 then  'do not show lag tuning for single-vsg  UPDATE: now show Lag or Null/Phase
        DlgGroup("Select Two Tuning Curve Types", 1, 4, 63, 6);   'phase needs to be a bit wider to accomodate a button with a longer label
    else
        DlgGroup("Select Two Tuning Curve Types", 1, 4, 59, 6); 
    endif;
    
    updateCurve1Text% := DlgText(tunCurve1Text$, 14, 5, 30);  'this is to keep track of selected tuning curve 1
    updateCurve2Text% := DlgText(tunCurve2Text$, 14, 6, 30);  'this is to keep track of selected tuning curve 2
    DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 8); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 8);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 9);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 9);
	DlgButton(tundlgAreaButton%, "Area", TuningCurveAreaDialog%, 36, 8);
    DlgButton(tundlgXPosButton%, "X Position", TuningCurveXPosDialog%, 36, 9);
    if tunUseLagDialog% = 1 then  'only show lag tuning for dual-vsg  UPDATE: now show Lag or Null/Phase
        DlgButton(tundlgLagButton%, "Lag", TuningCurveNullTestANDLagDialog%, 50, 8);
    else
        DlgButton(tundlgLagButton%, "Phase/Null", TuningCurveNullTestANDLagDialog%, 50, 8);
    endif;
    'DlgButton(tundlgFixptColorButton%, "Fixpt Color", TuningCurveFixptColorANDCRGDialog%, 50 , 9);
    DlgButton(tundlgPolkaDotButton%, "Polka Dots", TuningCurvePolkaDotANDCRGDialog%, 50 , 9);
    
    
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    if DlgValue(11) = 1 then
        DlgAllow(0xffff, 0, TuningCurveBoxODonutsDialogChanged%);
    else
        DlgAllow(0xffff, 0, TuningCurveBoxODonutsDialogChanged2%);
    endif;
    
    
    i% := DlgShow(tunBoxODonutsNRepeats%,tunBoxODonutsProgression%,tunMasterFollowsCurve1%,tunBoxODonutsNumGratingOption%);
    
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.	
    tunBoxODonutsCurrentCurve% := 0;  'reset this, we don't need it once this dialog box is closed and it messes up stuff if we want to pick a different tuning curve    
    if i% = 1 then
		SaveTuningCurveAreaParameters();
		tunType$ := tunTypeBoxODonuts$;

        iReturn% := 1;
        
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;   
    
end



func TuningCurveDotsDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveDotsParameters();
	DlgCreate("Run Dots Tuning Curve");
    
    DlgGroup("Tuning Curve Parameters", 1, 1, 47, 6);
	DlgInteger(1, "Number of Steps", 1, 100, 0, 2);
	DlgInteger(2, "Number of Repeats", 1, 1000, 0, 3);
	DlgReal(3, "Min Orientation (deg)", 0, 360, 0, 4);
	DlgReal(4, "Max Orientation (deg)", 0, 360, 0, 5);
	DlgCheck(5, "Random Progression", 0, 6);
    
    DlgGroup("Dot Parameters", 1, 7, 47, 7);
    DlgReal(6, "X Position (deg):",  -40, 40, 0, 8);
    DlgReal(7, "Y Position (deg):", -40, 40, 0, 9);
    DlgReal(8, "Diameter (deg):", .1, 30, 0, 10);
    DlgReal(9, "Speed (deg/sec):", 0, 100, 0, 11);
    DlgReal(10, "Density (dots/deg^2):", 0, 200, 0 ,12);
    DlgInteger(11, "Dot Size (pixels):", 0, 50, 0, 13);
    
    DlgGroup("Color", 1, 14, 47, 7);
    DlgInteger(12, "BG Color Red Value:", 0, 255, 0, 15);
    DlgInteger(13, "BG Color Green Value:", 0, 255, 0, 16);
    DlgInteger(14, "BG Color Blue Value:", 0, 255, 0, 17);
    DlgInteger(15, "Dot Color Red Value:", 0, 255, 0, 18);
    DlgInteger(16, "Dot Color Green Value:", 0, 255, 0, 19);
    DlgInteger(17, "Dot Color Blue Value:", 0, 255, 0, 20);

    
    
    'DlgList(12, "Color:", ColorVectorList$[]);  Color, BG color?  
    
    
	i% := DlgShow(tunDotsNSteps%, tunDotsNRepeats%, tunDotsMinOrientation, tunDotsMaxOrientation, tunDotsProgression%, tunDotsX, tunDotsY,
    tunDotsDiameter, tunDotsSpeed, tunDotsDensity, tunDotsSize%, tunDotsBGR%, tunDotsBGG%, tunDotsBGB%, tunDotsFGR%, tunDotsFGG%, tunDotsFGB%);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
	if i% = 1 then
		SaveTuningCurveDotsParameters();
		PrintLog("TuningCurveDotsDialog - user hit OK\n");
		tunType$ := tunTypeDots$;
                
        iReturn% := 1;
        
	endif;
	if i% = 0 then
		PrintLog("TuningCurveDotsDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;




' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
func TuningCurveCRGDialogChanged%(item%)    
    'This re-enables the master/slave listbox if CRG dialog is cancelled (actually not needed)
    'if item% = 0 then
        'DlgEnable(1,5); 
    'endif;  
    if item% = 5 then
        if DlgValue(5) = 0 then
            DlgValue$(updateCurve2Text%,"Contrast Reversing Grating on MASTER");
        else
            DlgValue$(updateCurve2Text%,"Contrast Reversing Grating on SLAVE");
        endif;
    endif;
    if tunCRGCurrentCurve% = 2 then
        DlgEnable(1,-1);  'enable "OK" if curve has been selected
        DlgEnable(0,5);   'and disable the master/slave listbox - can't change this once you've picked a curve
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    return 1;
end


'func TuningCurveFixptColorANDCRGDialog%()
func TuningCurvePolkaDotANDCRGDialog%()
    var iReturn%;
    var i%;
    
    if tunUseCRGDialog% = 0 then
        
        var GunLabels$[4];
        GunLabels$[0] := "R";
        GunLabels$[1] := "G";
        GunLabels$[2] := "B";
        GunLabels$[3] := "Luminance";
        
        GetTuningCurvePolkaDotParameters();
        DlgCreate("Run Polka Dot Tuning Curve");
        DlgGroup("Common Parameters", 1, 1, 52, 9);
        'DlgInteger(1, "Number of Total Repeats", 1, 10, 2, 2);  'these options will not be used in Box'o'Donuts
        'DlgCheck(3, "Random Progression",2,5);
        if tunBoxODonutsCurrentCurve% = 0 then
            DlgInteger(1, "Number of Total Repeats", 1, 200, 36, 2);
            DlgCheck(3, "Random Progression",2,6);
        else
            DlgInteger(1, "----------------", 1, 1, 36, 2);
            DlgCheck(3, "----------------", 2, 6);
        endif;
        DlgReal(2, "Polka Dot Diameter (degrees)", 0.01, 30, 36, 3);
        DlgCheck(19, "Show Main Grating",2,4);
        DlgReal(20, "Stimulus Delay (s)", 0.001, 10, 36, 5);
        DlgCheck(4, "Use File For Tuning Values",2,7);
        DlgString(5,40,255,"",3,8);  'for visual confirmation of selected seq file
        DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 9);
        
        DlgGroup("Color Parameters", 1, 10, 52, 8);
        DlgInteger(6, "Number of Steps (0 = no color change)", 0, 100, 36, 11);
        DlgInteger(7, "Red Gun Value (0-255)",0,255, 36, 12);
        DlgInteger(8, "Green Gun Value (0-255)",0,255, 36, 13);
        DlgInteger(9, "Blue Gun Value (0-255)",0,255, 36, 14);
        DlgList(10,"Color to Vary",GunLabels$,4, 30, 15);
        DlgReal(11, "Min Value (0-255)", 0, 255, 36, 16);
        DlgReal(12, "Max Value (0-255)", 0, 255, 36, 17);
        
        DlgGroup("XY Position Parameters", 1, 18, 52, 7);
        DlgInteger(13, "Number of X Steps (0 = no X step)", 0, 100, 36, 19);
        DlgReal(14, "Min X Position", -14, 14, 36, 20);
        DlgReal(15, "Max X Position", -14, 14, 36, 21);
        DlgInteger(16, "Number of Y Steps (0 = no Y step)", 0, 100, 36, 22);
        DlgReal(17, "Min Y Position", -14, 14, 36, 23);
        DlgReal(18, "Max Y Position", -14, 14, 36, 24);
        
        DlgAllow(0xffff, 0, TuningCurvePolkaDotDialogChanged%);
        
        i% := DlgShow(tunPDNRepeats%, tunPDDiameter, tunPDProgression%, tunPDUseFile%, tunPDTuningFile$, tunPDNColorSteps%,  
        tunPDRedValue%, tunPDGreenValue%, tunPDBlueValue%, tunPDGunIndex%, tunPDMinGunValue, tunPDMaxGunValue, tunPDNXSteps%, 
        tunPDMinXPos, tunPDMaxXPos, tunPDNYSteps%, tunPDMinYPos, tunPDMaxYPos, tunPDShowGrating%, tunPDLagSec);
               
        
        
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
        if i% = 1 then
            SaveTuningCurvePolkaDotParameters();
            PrintLog("TuningCurvePolkaDotDialog - user hit OK\n");
            tunType$ := tunTypePolkaDot$;
            tunUseFile% := tunPDUseFile%;
            tunTuningFile$ := tunPDTuningFile$;
        
            tunPDLagFrames% := 1000*tunPDLagSec/dataScreenMSPerFrame;
            'printlog("tunPDLagFrames% is %d\n",tunPDLagFrames%);
            


            ''''''''TESTING SECTION - THIS CODE WILL GO INTO START
            
            
            
            
            'This is just for testing the output of the new StringifyColorProgression$ (and inherently 
            'GetFixptColorThisTrial$) and they work FAAAAAAABULOUSLY
            
            
            
            
'            ''Here is the XY position, which is basically identical to XYPos
'            'for tun1, use X
'            if tunPDNXSteps% = 0 then  'this allows for no x movement
'                tun1Values[0] := tunPDMinXPos;
'                tun1ValuesIndices%[0] := 1;
'            else
'                GetRepeatedParameterProgression%(tunPDNXSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunPDMinXPos, tunPDMaxXPos, 0, 0);
'            endif;
'            tun1NValues% := (tunPDNXSteps%+1);
'            
'            'for tun2, use Y
'            if tunPDNYSteps% = 0 then  'this allows for no y movement
'                tun2Values[0] := tunPDMinYPos;
'                tun2ValuesIndices%[0] := 1;
'            else
'                GetRepeatedParameterProgression%(tunPDNYSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunPDMinYPos, tunPDMaxYPos, 0, 0);
'            endif;
'            tun2NValues% := (tunPDNYSteps%+1);       
'              
'            tunXYNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
'            tunXYNValues% := tun1NValues%*tun2NValues%*1;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
'            
'            'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
'            GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],0,1);         
'            
'            'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
'            tun1ValuesStringified$ := StringifyProgression$(tunXYNValues%, tun1Values[], tun1ValuesIndices%[]);
'            tun2ValuesStringified$ := StringifyProgression$(tunXYNValues%, tun2Values[], tun2ValuesIndices%[]);
'            
'            printlog("X values are %s\n",tun1ValuesStringified$);
'            printlog("Y values are %s\n",tun2ValuesStringified$);
'
'                       
'            
'            'This is the Color, have already renamed PolkaDot, but will have to do more work...let's put this later, actually
'            
'            
'            docase
'            'This seems a bit silly, but it has to look like this to work with the subsequent functions we call
'            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 0 then  'this allows for no color change, red gun selected
'                tunValues[0] := tunPDRedValue%;
'                tunValuesIndices%[0] := 0;
'            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 1 then  'this allows for no color change, green gun selected
'                tunValues[0] := tunPDGreenValue%;
'                tunValuesIndices%[0] := 0;
'            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 2 then  'this allows for no color change, blue gun selected
'                tunValues[0] := tunPDBlueValue%;
'                tunValuesIndices%[0] := 0;
'            case tunPDNColorSteps% = 0 and tunPDGunIndex% = 3 then  'this allows for no color change, luminance
'                tunValues[0] := tunPDMinGunValue;
'                tunValuesIndices%[0] := 0;
'            else 'the color is changing
'                GetRepeatedParameterProgression%(tunPDNColorSteps%+1, 1, tunValues[], tunValuesIndices%[], tunPDMinGunValue, tunPDMaxGunValue, 0, tunPDProgression%);
'            endcase  
'            tunNAdvances% := tunPDNColorSteps%;            
'            tunNValues% := (tunNAdvances%+1)*1;  
'            
'            tunValuesStringified$ := StringifyPolkaDotProgression$(tunNValues%, tunValues[], tunValuesIndices%[]);
'            printlog("Color String is %s\n",tunValuesStringified$);
'            
'            
'            'Now we need to Interleave the X string, the Y string, the Diameter, and the color string.  Diameter is a constant.
'            
'            tunNRepeats% := tunPDNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
'            tunValuesStringified$ := InterleavePDStrings$(tun1ValuesStringified$,tun2ValuesStringified$,Str$(tunPDDiameter),tunValuesStringified$,tunNRepeats%);
'            printlog("Polka Dot string is %s\n",tunValuesStringified$);
'            
'            
'            tunNValues% := tunXYNValues%*tunNValues%*tunNRepeats%;
'            printlog("Total number of values is %d\n",tunNValues%);
'            
'            'Randomization of the above would be very complicated.  The easiest thing to do here will be to write a function
'            'to randomize the VSG string.  This would require parsing the VSG string down using the semicolon as a token.
'            'Easy enough.  But, since we also need to tag each trial with the dot specs, rather than break down the VSG string
'            'every trial, we should just break it down once at the beginning and store the result.
'            
'            if tunPDProgression% = 1 then
'                'Fill tunValuesIndices with shuffled value
'                Shuffle%(tunNValues%,tunValuesIndices%[]);
'            else
'                'Fill tunValuesIndices with unshuffled index
'                var jjj%;
'                for jjj% := 0 to tunNvalues%-1 do
'                    tunValuesIndices%[jjj%] := jjj%;
'                next
'            endif
'            
'            'We run this even if we are not scrambling, because we are filling tunPDDotSpecsPerTrial$[]
'            tunvaluesStringified$ := ShufflePDTuningString$(tunNValues%,tunValuesIndices%[],tunvaluesStringified$,tunPDDotSpecsPerTrial$[]);
'            
'            'printlog("Randomized string is %s\n",tunValuesStringified$);
'            'printlog("Order is %d\n",tunValuesIndices%[0:tunNValues%]);
'            'printlog("Individual dot specs are %s\n",tunPDDotSpecsPerTrial$[0:tunNValues%]);
            
            '''''''''END TESTING
            
            
            
            
            
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypePolkaDot$;
                tunUseFile1% := tunPDUseFile%;
                tunTuningFile1$ := tunPDTuningFile$;
                tunCurve1Text$ := "Tuning Curve 1 is POLKA-DOT";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgPolkaDotButton%);  'So we don't pick polka dots again
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypePolkaDot$;
                tunUseFile2% := tunPDUseFile%;
                tunTuningFile2$ := tunPDTuningFile$;
                tunCurve2Text$ := "Tuning Curve 2 is POLKA-DOT";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgPolkaDotButton%);  'So we don't pick polka dots again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            endcase;
            
            iReturn% := 1;
            
        endif;
        if i% = 0 then
            PrintLog("TuningCurvePolkaDotDialog - user hit Cancel\n");
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        'PrintLog("Return value is %d\n", iReturn%);
        return iReturn%;  
        
        
        
        
        ''''This is the old "FixptColor" dialog, now inactive
'        var GunLabels$[4];
'        GunLabels$[0] := "R";
'        GunLabels$[1] := "G";
'        GunLabels$[2] := "B";
'        GunLabels$[3] := "Luminance";
'        
'        GetTuningCurveFixptColorParameters();
'        DlgCreate("Run Fixpt Color Tuning Curve");
'        DlgInteger(1, "Number of Steps", 1, 100);
'        'DlgInteger(2, "Number of Repeats", 1, 10);
'        DlgInteger(3, "Red Gun Value (0-255)",0,255);
'        DlgInteger(4, "Green Gun Value (0-255)",0,255);
'        DlgInteger(5, "Blue Gun Value (0-255)",0,255);
'        DlgList(6,"Color to Vary",GunLabels$,4);
'        DlgReal(7, "Min Value (0-255)", 0, 255);
'        DlgReal(8, "Max Value (0-255)", 0, 255);
'        'DlgCheck(9, "Random Progression");
'        DlgCheck(10, "Use File For Tuning Values");
'        DlgString(11,40,255,"",3);  'for visual confirmation of selected seq file
'        DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 12);
'        if tunBoxODonutsCurrentCurve% = 0 then
'            DlgInteger(2, "Number of Repeats", 1, 3000);
'            DlgCheck(9, "Random Progression");
'        else
'            DlgInteger(2, "----------------", 1, 1);
'            DlgCheck(9, "----------------");
'        endif;
'        DlgAllow(0xffff, 0, TuningCurveFixptColorDialogChanged%);
'        
'        i% := DlgShow(tunFPCNSteps%, tunFPCNRepeats%, tunFPCRedValue%, tunFPCGreenValue%, tunFPCBlueValue%, tunFPCGunIndex%, 
'        tunFPCMinValue, tunFPCMaxValue, tunFPCProgression%, tunFPCUseFile%, tunFPCTuningFile$);
'        
'        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
'        ' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
'        if i% = 1 then
'            SaveTuningCurveFixptColorParameters();
'            PrintLog("TuningCurveFixptColorDialog - user hit OK\n");
'            tunType$ := tunTypeFixptColor$;
'            tunUseFile% := tunFPCUseFile%;
'            tunTuningFile$ := tunFPCTuningFile$;
'            
'            
'            'This is just for testing the output of the new StringifyColorProgression$ (and inherently 
'            'GetFixptColorThisTrial$) and they work FAAAAAAABULOUSLY
'            'tunNRepeats% := tunFPCNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
'            'tunNAdvances% := tunFPCNSteps%;
'            'GetRepeatedParameterProgression%(tunFPCNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunFPCMinValue, tunFPCMaxValue, 0, tunFPCProgression%);
'            'tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
'            'tunValuesStringified$ := StringifyColorProgression$(tunNValues%, tunValues, tunValuesIndices%);
'            'printlog("Tuning String is %s\n",tunValuesStringified$);
'            
'            
'            
'            
'            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
'            docase
'            case tunBoxODonutsCurrentCurve% = 1 then
'                tunType1$ := tunTypeFixptColor$;
'                tunUseFile1% := tunFPCUseFile%;
'                tunTuningFile1$ := tunFPCTuningFile$;
'                tunCurve1Text$ := "Tuning Curve 1 is FIXPT-COLOR";
'                DlgValue$(updateCurve1Text%, tunCurve1Text$);
'                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
'                DlgEnable(0,-tundlgFixptColorButton%);  'So we don't pick fixpt color again
'            case tunBoxODonutsCurrentCurve% = 2 then
'                tunType2$ := tunTypeFixptColor$;
'                tunUseFile2% := tunFPCUseFile%;
'                tunTuningFile2$ := tunFPCTuningFile$;
'                tunCurve2Text$ := "Tuning Curve 2 is FIXPT-COLOR";
'                DlgValue$(updateCurve2Text%, tunCurve2Text$);
'                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
'                DlgEnable(0,-tundlgFixptColorButton%);  'So we don't pick fixpt color again
'                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
'            endcase;
'
'            iReturn% := 1;
'            
'        endif;
'        if i% = 0 then
'            PrintLog("TuningCurveFixptColorDialog - user hit Cancel\n");
'            tunType$ := tunTypeNone$;
'            if tunContext$ = tunContextDAQ$ then
'                iReturn% := 1;
'            else
'                iReturn% := 2;
'            endif;
'        endif;
'        PrintLog("Return value is %d\n", iReturn%);
'        return iReturn%;

        
    else
        
        
        
        'Just copied over Box O Donuts for now
        var sValues$;
        var tunCurveText$;
        var tunCurveCRGText$;
        
        var mylist$[2];
        mylist$[0] := "Master";
        mylist$[1] := "Slave";
        
        GetTuningCurveCRGParameters();    
        
        tunCRGCurrentCurve% := 1;  'this will be 0 unless we select this tuning curve
        
        tunCurveText$ := "Tuning Curve is unselected";
        if tunCRGOnSlave% = 0 then
            tunCurveCRGText$ := "Contrast Reversing Grating on MASTER";
        else
            tunCurveCRGText$ := "Contrast Reversing Grating on SLAVE";
        endif;
        
        
        DlgCreate("Contrast Reversing Grating Parameters");
        
        DlgInteger(1,"# of repeats per CRG sequence",1,1000,30,1);
        DlgInteger(2,"# of frames per turn",1,1000,30,2);
        DlgCheck(3, "Random Progression", 2, 3);
        DlgButton(tundlgSelectSEQFileButton%,   "Select Sequence File", SelectSEQFile%,49,3);
        DlgString(4,40,255,"",50,2);  'for visual confirmation of selected seq file
        
        
        
        DlgGroup("CRG Screen and Tuning Curve Type", 1, 4, 64, 7); 
        DlgList(5, "CRG is on:", mylist$[], 2, 3);
        updateCurve2Text% := DlgText(tunCurveCRGText$, 9, 6, 50);  'this keeps track of which screen holds CRG, 1/2 label got swapped, just rolling with it
        updateCurve1Text% := DlgText(tunCurveText$, 9, 7, 50);  'this is to keep track of selected tuning curve 
        DlgButton(tundlgBlankButton%, "     Blank     ", TuningCurveCRGBlank%, 2, 8);  'for blank screen
        DlgButton(tundlgGratingOnlyButton%, "  Grating Only  ", TuningCurveCRGGratingOnly%, 18, 8);  'for single grating
        DlgButton(tundlgCRG2Button%, "Secondary CRG", TuningCurveCRG2%, 36, 8);  'for secondary CRG
        
        DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 9); 'Note that labels for Orientation-Area are superceded 
        DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 9);  'by TuningCurveScriptDialogChanged% even upon opening 
        DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 10);           'the dialog (i.e. whatever label is here is unused)
        DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 10);
        DlgButton(tundlgAreaButton%, "         Area         ", TuningCurveAreaDialog%, 36, 9);
        DlgButton(tundlgXPosButton%, "     X Position     ", TuningCurveXPosDialog%, 36, 10);
        DlgButton(tundlgLagButton%, "   Lag   ", TuningCurveNullTestANDLagDialog%, 55, 8);
        
        DlgButton(151, "Master Grating", TunDlgGratingMaster%);
        DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
        DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
        DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
        DlgAllow(0xffff, 0, TuningCurveCRGDialogChanged%);
        
        i% := DlgShow(tunCRGNRepeats%,tunCRGFramesPerFlip%,tunCRGProgression%,tunCRGSeqFile$,tunCRGOnSlave%);
        
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.        
        tunCRGCurrentCurve% := 0;  'reset this, we don't need it once this dialog box is closed and it messes up stuff if we want to pick a different tuning curve    
        if i% = 1 then
            SaveTuningCurveCRGParameters();
            tunType$ := tunTypeCRG$;

            iReturn% := 1;
            
        endif;
        if i% = 0 then
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
        return iReturn%;  
        
    endif;
    
    
end





func TuningCurveCRGBlank%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    tunCRGCurrentCurve% := 2;
    tunType1$ := tunTypeBlank$;
    if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
        tunCurve1Text$ := "Slave will be BLANK";
    else
        tunCurve1Text$ := "Master will be BLANK";
    endif;
    DlgValue$(updateCurve1Text%, tunCurve1Text$);
    TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    return 1;
end





func TuningCurveCRGGratingOnly%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    tunCRGCurrentCurve% := 2;
    tunType1$ := tunTypeGratingOnly$;
    if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
        tunCurve1Text$ := "Slave will have STATIC GRATING";
    else
        tunCurve1Text$ := "Master will have STATIC GRATING";
    endif;
    DlgValue$(updateCurve1Text%, tunCurve1Text$);
    TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    'set some contrast values...I think we can get away without committing these to the registry
    'Actually, I'm just going to hard code this in Tuning's CreateSampleConfiguration, should work fine
    'tunContrastNSteps% := 1;
    'tunContrastMinContrast := 0;
    'tunContrastMaxContrast := 100;
    return 1;
end




func TuningCurveCRG2%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a secondary CRG sequence file");  'Find a sequence file
    tunCRGSeqFile2$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it 
    
    
    if fh0% > 0  then 'success in opening file 
        tunCRGCurrentCurve% := 2;
        tunType1$ := tunTypeCRG$;
    
        if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
            tunCurve1Text$ := "Slave will have SECONDARY CRG";
        else
            tunCurve1Text$ := "Master will have SECONDARY CRG";
        endif;
        DlgValue$(updateCurve1Text%, tunCurve1Text$);
        TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    endif
    
    return 1;
end





' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
'func TuningCurveDanishDialogChanged%(item%)    
    'if item% = 0 then
    '    DlgEnable(0, 1, 3, 4);
    'endif   
    'return 1;
'end

func TuningCurveDanishDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    
	GetTuningCurveDanishParameters();
    
    
	DlgCreate("Danish Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
    'DlgInteger(1, "Number of Stimuli", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 3000);
	DlgReal(3, "Min Outer Diameter", 0.1, 100);
	DlgReal(4, "Max Outer Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Include Blank");
    DlgButton(151, "Core Grating", TunDlgGratingCore%);
    DlgButton(152, "Donut Grating", TunDlgGratingDonut%);
    DlgButton(153, "Core Vals -> Donut", TunCoreValsToDonut%);
    DlgButton(154, "Donut Vals -> Core", TunDonutValsToCore%);
    'DlgAllow(0xffff, 0, TuningCurveDanishDialogChanged%);
	
    i% := DlgShow(tunDanishNSteps%, tunDanishNRepeats%, tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, tunDanishProgression%, tunDanishIncludeBlank%);
    
    'for now, no dummy-proofing


	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't. 
	if i% = 1 then
		SaveTuningCurveDanishParameters();
		tunType$ := tunTypeDanish$;

        iReturn% := 1;
        
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;




' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
'func TuningCurveDSSDialogChanged%(item%)    
'    if item% = 0 then
'        DlgEnable(0, 1, 3, 4);
'    endif   
'    return 1;
'end

func TuningCurveDSSDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[10000];
    var indices%[10000];
    
	GetTuningCurveDSSParameters();
    
    ' Before we proceed, we must generate a list of choices for the optimal diameter. These are based on the most recent run of Area tuning
    ' Note that there are nsteps+1 values. 
    
    'GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
    'sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
    
    'We want the default maximal value to be the largest value available when we open the dialog
    'so set tunBerlinerMaximalIndex% appropriately
    'tunBerlinerMaximalIndex% := tunAreaNSteps%;
    
    'Define tunBerlinerNSteps%, because we are no longer doing a tuning curve.
    'tunBerlinerNSteps% := 6;
    
	DlgCreate("DSS Parameters");
    DlgInteger(1, "Number of Trials", 1, 10000);
	DlgInteger(2, "Number of Surround Flashes/Blanks", 1, 10000);
	DlgInteger(3, "Number of 'Blank' Flashes", 0, 5000);
	DlgInteger(4, "Number of Flashes per Reward",  1, 1000);
    DlgButton(151, "Core Grating", TunDlgGratingMaster%);
    DlgButton(152, "Donut Grating", TunDlgGratingDonut%);
    DlgButton(153, "Core Vals -> Donut", TunCoreValsToDonut%);
    DlgButton(154, "Donut Vals -> Core", TunDonutValsToCore%);
    'DlgAllow(0xffff, 0, TuningCurveDSSDialogChanged%);
	'i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%);
    i% := DlgShow(tunDSSNTrials%,tunDSSNPeriods%, tunDSSNBlanks%, tunDSSNFlashesPerReward%);
    
  
    ' Can't allow too many blanks
    if tunDSSNBlanks%*10 > tunDSSNPeriods% then
        i% := 0;  'Treat this as a "cancel"
        message("Oops!|A maximum of 1/10 of stimuli can be flashes\nTry again!");
    endif;
    
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't. 
	if i% = 1 then
		SaveTuningCurveDSSParameters();
		tunType$ := tunTypeDSS$;

        iReturn% := 1;
        
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;



func TuningCurveNullTestANDLagDialog%()
    var iReturn% := 0;
    var i%;
    
    if tunUseLagDialog% = 0 then   'DlgValue(11) = 0 then  'run null test dialog
        
        GetTuningCurveNullTestParameters();
        DlgCreate("Null Test/Phase Tuning Curve Parameters");
        DlgInteger(1, "Number of Steps", 1, 99);
        DlgInteger(2, "Number of Repeats", 1, 3000);
        DlgReal(3, "Start Phase", 0, 360);
        DlgReal(4, "End Phase", 0, 360);
        'DlgReal(5, "Transition Frequency (Hz)", 0.1,100);  'tunNullTestTF, removed
        DlgCheck(5, "Random Progression");
        'DlgCheck(6, "Step Function in Time");   'tunNullTestStepFunc%, removed
        DlgCheck(6, "Use File For Tuning Values");
        DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
        DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFileNullTest%, 2, 8);
        DlgAllow(0xffff, 0, TuningCurveNullTestDialogChanged%);
        
        i% := DlgShow(tunNullTestNSteps%, tunNullTestNRepeats%, tunNullTestMinPhase, tunNullTestMaxPhase,  tunNullTestProgression%, tunNullTestUseFile%, tunNullTestTuningFile$);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't. 
        'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
        if i% = 1 then
            SaveTuningCurveNullTestParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeNullTest$;
            tunUseFile% := tunNullTestUseFile%;
            tunTuningFile$ := tunNullTestTuningFile$;
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypeNullTest$;
                tunUseFile1% := tunNullTestUseFile%;
                tunTuningFile1$ := tunNullTestTuningFile$;
                tunCurve1Text$ := "Tuning Curve 1 is PHASE/NULL";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgLagButton%);  'So we don't pick phase/null again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypeNullTest$;
                tunUseFile2% := tunNullTestUseFile%;
                tunTuningFile2$ := tunNullTestTuningFile$;
                tunCurve2Text$ := "Tuning Curve 2 is PHASE/NULL";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgLagButton%);  'So we don't pick phase/null again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            'case tunCRGCurrentCurve% = 1 then    'This has not been implemented, I don't think CRGs are currently used?  revisit if it becomes necessary
            '    tunCRGCurrentCurve% := 2;
            '    tunType1$ := tunTypeNullTest$;
            '    if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
            '        tunCurve1Text$ := "Tuning Curve on Slave is PHASE/NULL";
            '    else
            '        tunCurve1Text$ := "Tuning Curve on Master is PHASE/NULL";
            '    endif;
            '    DlgValue$(updateCurve1Text%, tunCurve1Text$);
            '    TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            endcase;
            
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            'DlgValue$(-1,"Run Null Test");
            'TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
            'TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            
            iReturn% := 1;
            
        endif;
        if i% = 0 then
            '		PrintLog("TuningCurveNullTestDialog - user hit Cancel\n");
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
            'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
            'DlgValue$(-1,"Select Expt.");
            'TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
            'TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
        endif;
        
        return iReturn%;
        
    else 'run Lag tuning dialog
        
        var checkint;  'checking to make sure the number of frames will work
        
        GetTuningCurveLagParameters();
        DlgCreate("Lag Tuning Curve Parameters",0,0,62);
        DlgInteger(1, "Number of Steps", 1, 100,30,1);
        'DlgInteger(2, "Number of Repeats", 1, 10);
        DlgInteger(3, "Min Lag (frames)", 0, 1000,30,3);
        DlgInteger(4, "Max Lag (frames)", 0, 1000,30,4);
        'DlgCheck(5, "Random Progression");
        DlgCheck(6, "Use File For Tuning Values");
        DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
        DlgString(8,11,255,"",50,3);  DlgText("(ms)",45,3);
        DlgString(9,11,255,"",50,4);  DlgText("(ms)",45,4);
        DlgCheck(10,"Master Screen is Lagged",29,5);
        DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
        if tunBoxODonutsCurrentCurve% = 0 then
            DlgInteger(2, "Number of Repeats", 1, 3000,30,2);
            DlgCheck(5, "Random Progression");
        else
            DlgInteger(2, "----------------", 1, 1,30,2);
            DlgCheck(5, "----------------");
        endif;
        DlgAllow(0xffff, 0, TuningCurveLagDialogChanged%);
        
        i% := DlgShow(tunLagNSteps%, tunLagNRepeats%, tunLagMinLagFrames%, tunLagMaxLagFrames%, tunLagProgression%, tunLagUseFile%, tunLagTuningFile$, tunLagFrames1$, tunLagFrames2$,tunLagMasterIsLagged%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.

        'First things first, check the lag to make sure it will work
        if i% = 1 then
            tunLagMinLagFrames := tunLagMinLagFrames%;  'prepare for non-integer math
            tunLagMaxLagFrames := tunLagMaxLagFrames%;
            checkint := frac((tunLagMaxLagFrames-tunLagMinLagFrames)/tunLagNSteps%);
            'if lag will not work, note this and return as if canceled
            if checkint <> 0 then     
                message("The given number of steps will not create integer frame counts!  Try again!");
                i% := 0;
            endif;
        endif;
        
        if i% = 1 then
            SaveTuningCurveLagParameters();
            '		PrintLog("TuningCurveLagDialog - user hit OK\n");
            tunType$ := tunTypeLag$;
            tunUseFile% := tunLagUseFile%;
            tunTuningFile$ := tunLagTuningFile$;
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypeLag$;
                tunUseFile1% := tunLagUseFile%;
                tunTuningFile1$ := tunLagTuningFile$;
                tunCurve1Text$ := "Tuning Curve 1 is LAG";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgLagButton%);  'So we don't pick lag again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "Polka Dots" button, -1 is sham input
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypeLag$;
                tunUseFile2% := tunLagUseFile%;
                tunTuningFile2$ := tunLagTuningFile$;
                tunCurve2Text$ := "Tuning Curve 2 is LAG";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgLagButton%);  'So we don't pick lag again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            case tunCRGCurrentCurve% = 1 then
                tunCRGCurrentCurve% := 2;
                tunType1$ := tunTypeLag$;
                if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                    tunCurve1Text$ := "Tuning Curve on Slave is LAG";
                else
                    tunCurve1Text$ := "Tuning Curve on Master is LAG";
                endif;
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            endcase;

            iReturn% := 1;
            
        endif;
        if i% = 0 then
            '		PrintLog("TuningCurveLagDialog - user hit Cancel\n");
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
        return iReturn%;
    endif;
    
        
end;


func TuningCurveLagDialogChanged%(item%)
    'This single dialog changed function can be used for ALL the tuning dialogs that allow file-based tuning curves
    '(at least currently) because they all have the same structure and therefore the same dialog positions to allow/disallow
    DlgValue$(8,Str$(DlgValue(3)*1000/dataScreenHz));  'just set the text values of the frame to millisecond conversion every time
    DlgValue$(9,Str$(DlgValue(4)*1000/dataScreenHz));
    DlgEnable(0,8);  'Always disable millisecond conversion, we can't type here to get frame values
    DlgEnable(0,9); 
    if DlgValue(6) = 0 then  'If we are not using a tuning file
        DlgEnable(0,7);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(6) = 1 then
        DlgEnable(1,7);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


func TuningCurveNullTestDialogChanged%(item%)
    'The Null Test dialog has extra entries below, moving the tested checkbox to position 8 and the DlgString to 9
    if DlgValue(8) = 0 then  'If we are not using a tuning file
        DlgEnable(0,9);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(8) = 1 then
        DlgEnable(1,9);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


func SelectTuningFileNullTest%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file
    'This is the same as the regular file, but the string dialog entry is in a different location for the null test.
    'It would have been really cool to have this function take an argument, but I tried that and it automatically ran
    'the function without the button being pressed as soon as the parent dialog was open, so that's a no-go.

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(9,direc$);  'Place filename into dialog item 9 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;


func TunDlgGratingMaster%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Stimulus");
    i% := GratingParametersDialogMaster%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    if i% = 1 then
        SaveGratingParameters("Stimulus", tunGratingParams$);
        SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end



func TunDlgGratingSlave%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("SlaveStimulus");
    i% := GratingParametersDialogSlave%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    if i% = 1 then
        SaveGratingParameters("SlaveStimulus", tunGratingParams$);
        SaveGratingParameters("StatSlaveStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func TunDlgGratingCore%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Stimulus");
    i% := GratingParametersDialogCore%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    if i% = 1 then
        SaveGratingParameters("Stimulus", tunGratingParams$);
        SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func TunDlgGratingDonut%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase, ctf;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Distractor1");
    i% := GratingParametersDialogDonut%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    if i% = 1 then
        SaveGratingParameters("Distractor1", tunGratingParams$);
        'SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func GratingParametersDialogMaster%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$, &ctf)
    
	var i% := 16;  'That's right, 16, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
    ColorVectorList$[1]:="Blue/Yellow";	cvl$[1]:="[0/0/1]-[1/1/0]";
    ColorVectorList$[2]:="Red/Cyan";	cvl$[2]:="[1/0/0]-[0/1/1]";
    ColorVectorList$[3]:="Green/Magenta";	cvl$[3]:="[0/1/0]-[1/0/1]";
	'ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	'ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	'ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[4];
	var pl$[4];
	var ipl% := 0;
	PatternList$[0]:="Gr Sine; Cp Sine";	pl$[0]:="ss";
	PatternList$[1]:="Gr Square; Cp Sine";	pl$[1]:="qs";
    PatternList$[2]:="Gr Sine; Cp Square";	pl$[2]:="sq";
	PatternList$[3]:="Gr Square; Cp Square";	pl$[3]:="qq";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 16 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 5, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 4, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 2, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 100);
        DlgReal(9, "Temporal Freq:", 0, 100);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern (Grating/Counterphase):", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgReal(15, "Counterphase Transition Freq:", 0, 10);
        DlgButton(16, "Copy from Slave", TunCopySlaveVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%, ctf);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$, ctf);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif
    return i%;
end;

func GratingParametersDialogSlave%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$, &ctf)
    
	var i% := 16;  'That's right, 16, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
    ColorVectorList$[1]:="Blue/Yellow";	cvl$[1]:="[0/0/1]-[1/1/0]";
    ColorVectorList$[2]:="Red/Cyan";	cvl$[2]:="[1/0/0]-[0/1/1]";
    ColorVectorList$[3]:="Green/Magenta";	cvl$[3]:="[0/1/0]-[1/0/1]";
	'ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	'ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	'ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[4];
	var pl$[4];
	var ipl% := 0;
	PatternList$[0]:="Gr Sine; Cp Sine";	pl$[0]:="ss";
	PatternList$[1]:="Gr Square; Cp Sine";	pl$[1]:="qs";
    PatternList$[2]:="Gr Sine; Cp Square";	pl$[2]:="sq";
	PatternList$[3]:="Gr Square; Cp Square";	pl$[3]:="qq";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 16 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 5, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 4, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 2, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 100);
        DlgReal(9, "Temporal Freq:", 0, 100);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern (Grating/Counterphase):", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgReal(15, "Counterphase Transition Freq:", 0, 10);
        DlgButton(16, "Copy From Master", TunCopyMasterVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%, ctf);
        Convert180(phase);
        
    wend;
    
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$, ctf);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif;
    return i%;
end;


func GratingParametersDialogCore%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$, &ctf)
    
	var i% := 16;  'That's right, 16, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
    ColorVectorList$[1]:="Blue/Yellow";	cvl$[1]:="[0/0/1]-[1/1/0]";
    ColorVectorList$[2]:="Red/Cyan";	cvl$[2]:="[1/0/0]-[0/1/1]";
    ColorVectorList$[3]:="Green/Magenta";	cvl$[3]:="[0/1/0]-[1/0/1]";
	'ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	'ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	'ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[4];
	var pl$[4];
	var ipl% := 0;
	PatternList$[0]:="Gr Sine; Cp Sine";	pl$[0]:="ss";
	PatternList$[1]:="Gr Square; Cp Sine";	pl$[1]:="qs";
    PatternList$[2]:="Gr Sine; Cp Square";	pl$[2]:="sq";
	PatternList$[3]:="Gr Square; Cp Square";	pl$[3]:="qq";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 16 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 5, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 4, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 100);
        DlgReal(9, "Temporal Freq:", 0, 100);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern (Grating/Counterphase):", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgReal(15, "Counterphase Transition Freq:", 0, 10);
        DlgButton(16, "Copy from Donut!", TunCopyDonutVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%, ctf);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters, not using static but easier to just leave it in
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$, ctf);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif
    return i%;
end;



func GratingParametersDialogDonut%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$, &ctf)
    
	var i% := 16;  'That's right, 16, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
    ColorVectorList$[1]:="Blue/Yellow";	cvl$[1]:="[0/0/1]-[1/1/0]";
    ColorVectorList$[2]:="Red/Cyan";	cvl$[2]:="[1/0/0]-[0/1/1]";
    ColorVectorList$[3]:="Green/Magenta";	cvl$[3]:="[0/1/0]-[1/0/1]";
	'ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	'ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	'ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[4];
	var pl$[4];
	var ipl% := 0;
	PatternList$[0]:="Gr Sine; Cp Sine";	pl$[0]:="ss";
	PatternList$[1]:="Gr Square; Cp Sine";	pl$[1]:="qs";
    PatternList$[2]:="Gr Sine; Cp Square";	pl$[2]:="sq";
	PatternList$[3]:="Gr Square; Cp Square";	pl$[3]:="qq";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 16 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 5, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 4, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 2, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 100);
        DlgReal(9, "Temporal Freq:", 0, 100);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern (Grating/Counterphase):", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgReal(15, "Counterphase Transition Freq:", 0, 10);
        DlgButton(16, "Copy From Core", TunCopyCoreVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%, ctf);
        Convert180(phase);
        
    wend;
    
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters, not using static but easier to just leave it in
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$, ctf);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif;
    return i%;
end;



func TunCopySlaveVals%(&param$)

    param$ := GetGratingParameters$("SlaveStimulus");

    return 1;
end



func TunCopyMasterVals%(&param$)

    param$ := GetGratingParameters$("Stimulus");

    return 1;
end


func TunCopyDonutVals%(&param$)
    var x, y, w, h, iw, ih, ctf;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    'Simply using "Distractor1" rather than making a separate "Donut" grating, can change if it's a problem
    param$ := GetGratingParameters$("Distractor1");
    ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    w := iw;  'set grating width to make a core that fits inside the donut, of zero inner diameter
    h := ih;
    iw := 0;
    ih := 0;
    param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);


    return 1;
end

func TunCopyCoreVals%(&param$)
    
    var x, y, w, h, iw, ih, ctf;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;    
    
    param$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    iw := w;  'set grating width to make a donut that surrounds the core, of arbitrary width
    ih := h;
    w := iw+1;
    h := ih+1;
    param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);

    return 1;
end


func TunMasterValsToSlave%()
    
    var x, y, w, h, iw, ih, ctf;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Stimulus");
    SaveGratingParameters("SlaveStimulus", tempParams$);
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$, ctf);  'hardcoded zero TF
    SaveGratingParameters("StatSlaveStimulus", tempParams$);
    
    return 1;
end


func TunSlaveValsToMaster%()
    
    var x, y, w, h, iw, ih, ctf;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("SlaveStimulus");
    SaveGratingParameters("Stimulus", tempParams$);
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$, ctf);  'hardcoded zero TF
    SaveGratingParameters("StatStimulus", tempParams$);
    
    return 1;
end


func TunCoreValsToDonut%()
    
    var x, y, w, h, iw, ih, ctf;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    iw := w;  'set grating width to make a donut that surrounds the core, of arbitrary width
    ih := h;
    w := iw+1;
    h := ih+1;
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    SaveGratingParameters("Distractor1", tempParams$);
    
    return 1;
end


func TunDonutValsToCore%()
    
    var x, y, w, h, iw, ih, ctf;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Distractor1");
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    w := iw;  'set grating width to make a core that fits inside the donut, of zero inner diameter
    h := ih;
    iw := 0;
    ih := 0;
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    SaveGratingParameters("Stimulus", tempParams$);
    
    return 1;
end


func TuningXHairDialog%()
    DlgCreate("Crosshair/Grid");
    DlgCheck(1, "Use crosshair grid");
    DlgReal(2, "Grid inner radius offset", 0, 100);
    DlgReal(3, "Grid mid radius offset", 0, 100);
    DlgReal(4, "Grid outer radius offset", 0, 100);
    DlgInteger(5, "Number of divisions in grid", 2, 128);
    DlgReal(6, "XHair inner offset", -1, 100);
    DlgReal(7, "XHair outer offset", -1, 100);
    DlgAllow(0xffff, 0, TuningXHairDialogChanged%);
    DlgShow(tunUseXHairs%, tunXHairInnerRadiusOffset, tunXHairMiddleRadiusOffset, tunXHairOuterRadiusOffset, tunXHairNumGridDivisions%, tunXHairTicInnerOffset, tunXHairTicOuterOffset);
    return 1;
end


func TuningXHairDialogChanged%(item%)
    docase 
    case item% = 0 then
        DlgEnable(tunUseXHairs%, 2, 3, 4, 5, 6, 7);
    case item% = 1 then
        DlgEnable(DlgValue(1), 2, 3, 4, 5, 6, 7);
    endcase
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve main dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




proc GetTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	tunFixationDuration := GetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
    tunUseMaintainMode% := GetIntRegistryValue%(key$, "UseMaintainMode", tunUseMaintainMode%);
	tunMaintainFixation := GetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    tunAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    tunStimulusOnsetDelay := GetFloatRegistryValue(key$, "StimulusOnsetDelay", tunStimulusOnsetDelay);
    tunAcqFailTime := GetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    tunHoldFailTime := GetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    tunMaintainFailTime := GetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    tunStdInterTrialTime := GetFloatRegistryValue(key$, "StdInterTrialTime", tunStdInterTrialTime);
    tunBackgroundColor$ := GetStringRegistryValue$(key$, "BackgroundColor", tunBackgroundColor$);
    tunDoRivalry% := GetIntRegistryValue%(key$, "DoRivalry", tunDoRivalry%);
    tunDualTuningType% := GetIntRegistryValue%(key$, "DualTuningType", tunDualTuningType%);
    tunUseXHairs% := GetIntRegistryValue%(key$, "UseXHairs", tunUseXHairs%);
    tunXHairInnerRadiusOffset := GetFloatRegistryValue(key$, "XHairInnerRadiusOffset", tunXHairInnerRadiusOffset);
    tunXHairMiddleRadiusOffset := GetFloatRegistryValue(key$, "XHairMiddleRadiusOffset", tunXHairMiddleRadiusOffset);
    tunXHairOuterRadiusOffset := GetFloatRegistryValue(key$, "XHairOuterRadiusOffset", tunXHairOuterRadiusOffset);
    tunXHairTicInnerOffset := GetFloatRegistryValue(key$, "XHairTicInnerOffset", tunXHairTicInnerOffset);
    tunXHairTicOuterOffset := GetFloatRegistryValue(key$, "XHairTicOuterOffset", tunXHairTicOuterOffset);
    tunXHairNumGridDivisions% := GetIntRegistryValue%(key$, "XHairNumGridDivisions", tunXHairNumGridDivisions%);
    tunButtonCollect% := GetIntRegistryValue%(key$, "ButtonCollect", tunButtonCollect%);
    tunDoTuningHist% := GetIntRegistryValue%(key$, "DoTuningHist", tunDoTuningHist%);
    tunUseConstantLag% := GetIntRegistryValue%(key$, "UseConstantLag", tunUseConstantLag%);
    tunConstantLagFrames% := GetIntRegistryValue%(key$, "ConstantLagFrames", tunConstantLagFrames%);
    tunDoOpto% := GetIntRegistryValue%(key$, "DoOpto", tunDoOpto%);
    tunSetStationary% := GetIntRegistryValue%(key$, "SetStationary", tunSetStationary%);
    tunSendINTANPulse% := GetIntRegistryValue%(key$, "SendINTANPulse", tunSendINTANPulse%);
    
    
end;

proc SaveTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	SetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
    SetIntRegistryValue(key$, "UseMaintainMode", tunUseMaintainMode%);
	SetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    SetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    SetFloatRegistryValue(key$, "StimulusOnsetDelay", tunStimulusOnsetDelay);
    SetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    SetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    SetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    SetFloatRegistryValue(key$, "StdInterTrialTime", tunStdInterTrialTime);
    SetStringRegistryValue(key$, "BackgroundColor", tunBackgroundColor$);
    SetIntRegistryValue(key$, "DoRivalry", tunDoRivalry%);
    SetIntRegistryValue(key$, "DualTuningType", tunDualTuningType%);
    SetIntRegistryValue(key$, "UseXHairs", tunUseXHairs%);
    SetFloatRegistryValue(key$, "XHairInnerRadiusOffset", tunXHairInnerRadiusOffset);
    SetFloatRegistryValue(key$, "XHairMiddleRadiusOffset", tunXHairMiddleRadiusOffset);
    SetFloatRegistryValue(key$, "XHairOuterRadiusOffset", tunXHairOuterRadiusOffset);
    SetFloatRegistryValue(key$, "XHairTicInnerOffset", tunXHairTicInnerOffset);
    SetFloatRegistryValue(key$, "XHairTicOuterOffset", tunXHairTicOuterOffset);
    SetIntRegistryValue(key$, "XHairNumGridDivisions", tunXHairNumGridDivisions%);
    SetIntRegistryValue(key$, "ButtonCollect", tunButtonCollect%);
    SetIntRegistryValue(key$, "DoTuningHist", tunDoTuningHist%);
    SetIntRegistryValue(key$, "DoOpto", tunDoOpto%);
    SetIntRegistryValue(key$, "SetStationary", tunSetStationary%);
    SetIntRegistryValue(key$, "SendINTANPulse", tunSendINTANPulse%);
    

    PrintLog("Saved DoRivalry=%d\n", tunDoRivalry%);
end;


' TuningCurveScriptDialog
' This dialog uses two global variables, tunContext$ and tunType$. 
' Set tunContext$ = tunContextConfig$ to run in the config scripts. The dialog 
' and its children (TuningCurveOrientationDialog, etc) will behave as expected, 
' allowing the user to set parameters and saving them in the registry. Set 
' tunContext$ = tunContextDAQ$ to run in a DAQ script. In this context you 
' must check the return value of the dialog and (possibly) the value of 
' tunType$. If the user hits Cancel in the main dialog, the return value is 0. 
' If the user selects a subdialog and hits OK, the return value will be 1 and 
' the value of tunType$ will be one of (tunTypeOrientation$, tunTypeContrast$, 
' tunTypeSpatial$, tunTypeTemporal$). Here, proceed directly to DAQ. If the 
' user Hits Cancel from the subdialog, then they return to the main dialog. If 
' they hit OK from the main dialog, then the return value is 1, but 
' tunType$ = tunTypeNone$. 


func TuningCurveScriptDialog%()
	var i%;
	var iReturn%;
    var tempParam$;
    var tempPhase;
    var boxOK% := 1;  'do the stimulus/crosshairs boxes overlap?
    var twoInts%[2];
    
	GetTuningCurveScriptParameters();
    GetTunOptoParameters();  'We must get these or the user has to open the opto dialog every time.
    
    'Pack twoInts%[]
    twoInts%[0] := tunDoOpto%;
    twoInts%[1] := tunSendINTANPulse%;
    
    docase 'And recalculate tunOptoState, in case the user doesn't click on opto parameters button
    case tunOptoStartState% = 3 then
        dontToggleOpto% := 1;
        tunOptoState% := 1;
    case tunOptoStartState% = 2 then
        tunOptoState% := round(Rand());
        dontToggleOpto% := 0;
    else
        tunOptoState% := tunOptoStartState%;
        dontToggleOpto% := 0;
    endcase;
	var bcl$[3];
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    var ibcl%:=0;
    var constantLag$[3];
    constantLag$[0] := "No Constant Lag";
    constantLag$[1] := "Lag On Master";
    constantLag$[2] := "Lag On Slave";
    var dualType$[3];
    dualType$[0] := "Dual Tuning";
    dualType$[1] := "Master only";
    dualType$[2] := "Slave only";
    var maintainList$[5];
    maintainList$[0] := "Nothing";
    maintainList$[1] := "FixOnly";  
    maintainList$[2] := "Fix+Rwd";
    maintainList$[3] := "Core+Fix";
    maintainList$[4] := "C+F+Rwd";
    'these are for the addition of the stationary function to the standard tuning curves
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase, ctf;
    var cv$, pattern$, aperture$;
    var tempParams$;
        
    
	for i%:=0 to 2 do
		if tunBackgroundColor$ = bcl$[i%] then
			ibcl% := i%;
		endif
	next;
    
    docase 
    case tunUseXHairs% = 0 then
        tunXHairText$ := "Crosshairs are OFF";
    case tunUseXHairs% = 1 then
        tunXHairText$ := "Crosshairs are ON";
    endcase
    
    'Updated dialog box - more efficient use of space, neater
    'DlgCreate("Tuning Curve Parameters", 0, 0, 0, 0, -1, 1, 1);  'center dialog relative to screen and not to application window to eliminate cutting off the bottom of the dialog!
    DlgCreate("Tuning Curve Parameters", 0, 0, 0, 0, -1);  'center dialog relative to screen and not to application window to eliminate cutting off the bottom of the dialog!
	DlgGroup("Common Parameters", 1, 1, 52, 10);
	DlgReal(1, "Acquire Fixation time(s):", 1, 1000, 40, 2);
    DlgReal(2, "Acquire Fixation penalty(s):", .1, 100, 40, 3);
    DlgReal(3, "Stimulus onset delay(s):", 0, 100, 40, 4);
	DlgReal(4, "Stimulus duration(s):", .01, 100, 40, 5);
    DlgReal(5, "During-Stim fixation break penalty(s):", .1, 100, 40, 6);
    DlgReal(6, "Intertrial interval(s):", .01, 100, 40, 7);
	DlgReal(7, "Maintain fixation after stim(s):", .01, 100, 40, 8);
	DlgReal(8, "Maintain fixation after stim penalty(s):", .1, 100, 40, 9);
	DlgList(9, "Background color:", bcl$, 3, 34, 10);
    if JuicerType% = 1 then
        DlgInteger(10, "Juicer open dur. (ms):", 1, 2000, 40, 11);
    else  'JuicerResult should only be 2, other values should not allow access to dialog box
        DlgInteger(10, "Num. juicer pulses:", 1, 200, 40, 11);
    endif;   
    'juicer duration / n repeats dialog here?  Have to write values to DAQ parameters if changed, disable if not correct for juicer? 
    DlgGroup("Dual VSG Options", 1, 12, 52, 4);
    DlgCheck(11, "Use Dual VSG", 2, 13);
    'DlgCheck(12, "Select to turn off card sync", 25, 13);
    DlgInteger(18, 2, 0, 100, 20, 13); DlgText("<-(Frames) Constant Lag (ms)->",22,13); DlgString(19,5,255,"",48,13);
    DlgList(17, "Use Constant Lag?", constantLag$, 3, 25, 14); 
    DlgList(12, "Dual Tuning Configuration:", dualType$, 3, 25, 15);
    
    'DlgCheck(13, "Maintain Fixpt between trials", 2, 14);  'change this to a list
    DlgList(13, 11, maintainList$, 5, 3, 16); DlgText("Maintain what btwn trls", 15, 16);
    DlgCheck(14, "Stationary",2,17);
    DlgCheck(15, "Make Histograms", 35,16);
    DlgCheck(16, "Use Rivalry Button", 35,17);
    DlgButton(tundlgXHairButton%, " Crosshairs  ", UpdateTuningXHairDialog%, 1, 18);
    updateXHairText% := DlgText(tunXHairText$, 15, 18);
    
    DlgCheck(20,"Opto On",2,19);
    DlgButton(tundlgOptogeneticsButton%, "Optogenetics Parameters", TunOptoDialog%, 18, 19);    
    
    
	DlgGroup("Individual Tuning Curve Types", 1, 20, 52, 6);
	DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 21); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 21);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 22);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 22);
	DlgButton(tundlgAreaButton%, "         Area         ", TuningCurveAreaDialog%, 36, 21);
    DlgButton(tundlgXPosButton%, "     X Position     ", TuningCurveXPosDialog%, 36, 22);
	DlgButton(tundlgDonutANDGonzagoButton%, "   Donuts!   ", TuningCurveDonutANDGonzagoDialog%, 2, 23);
    DlgButton(tundlgFixptJumpANDBerlinerButton%, "    Berliners!    ", TuningCurveFixptJumpANDBerlinerDialog%, 18, 23);
    DlgButton(tundlgBoxODonutsButton%, " Box O' Donuts ", TuningCurveBoxODonutsDialog%, 36, 23);
    DlgButton(tundlgDotsButton%, "     Dots!     ", TuningCurveDotsDialog%, 2, 24);
    'DlgButton(tundlgCRGButton%,"      CRaGs      ",TuningCurveFixptColorANDCRGDialog%, 18, 24);
    DlgButton(tundlgCRGButton%,"      CRaGs      ",TuningCurvePolkaDotANDCRGDialog%, 18, 24);
    DlgButton(tundlgDisparityAndBakersDozenButton%, "      Disparity      ", TuningCurveDisparityAndBakersDozenDialog%, 36, 24);
    DlgButton(tundlgDanishButton%, "  Danishes!  ", TuningCurveDanishDialog%, 2, 25);
    DlgButton(tundlgDSSButton%,"        DSS        ",TuningCurveDSSDialog%, 18, 25);
    DlgButton(tundlgNullTestANDLagButton%,"      Null Test     ",TuningCurveNullTestANDLagDialog%, 36, 25);
    
    DlgCheck(21,"Send INTAN pulses?",2,26);
    
    DlgAllow(0xffff, 0, TuningCurveScriptDialogChanged%);
	
    if JuicerType% = 1 then
        i%:=DlgShow(tunAcquisitionTime, tunAcqFailTime, tunStimulusOnsetDelay, tunFixationDuration, tunHoldFailTime, 
        tunStdInterTrialTime, tunMaintainFixation, tunMaintainFailTime,
        ibcl%, JuiceRewardMS%, tunDoRivalry%,  
        tunDualTuningType%, tunUseMaintainMode%, tunSetStationary%, tunDoTuningHist%, tunButtonCollect%,
        tunUseConstantLag%,tunConstantLagFrames%,tunConstantLagMS$,twoInts%[]);
    else
        i%:=DlgShow(tunAcquisitionTime, tunAcqFailTime, tunStimulusOnsetDelay, tunFixationDuration, tunHoldFailTime, 
        tunStdInterTrialTime, tunMaintainFixation, tunMaintainFailTime, 
        ibcl%, JuicePerReward%, tunDoRivalry%,  
        tunDualTuningType%, tunUseMaintainMode%, tunSetStationary%, tunDoTuningHist%, tunButtonCollect%,
        tunUseConstantLag%,tunConstantLagFrames%,tunConstantLagMS$,twoInts%[]);
    endif;
    
    
    ' djs 4-1-09
    ' Spike2 v6 change. DlgShow will return the button number when a button on the dialog is hit and the corresponding
    ' function returns 0. In this case those buttons open the various tuning type sub dialogs (orientation, area, etc). 
    ' In the last version, DlgShow would return the same value that the subdialog's function returned, and the code here
    ' was set up to behave accordingly. When the user hits the Cancel button in the subdialog everything still remains
    ' the same. 
    
    ' djs 2-4-2011
    ' Spike2v6 bug (see TuningDialogs.s2s) workaround requires that the tuning type dialogs return something > 0. 
    ' That will mean that closing any of those dialogs will not cause the main dialog (this one) to close automatically. 
    ' When it did close automatically the return value from DlgShow above was the same as the button that caused
    ' the close. Now, that button is NOT causing the close, so the return value is going to be 1 (not the button number). 
    ' In addition, the return value from this function needs to change because we now assume that the user will have
    ' to hit OK on this dialog to start the experiment. Thus, make sure that the return value from this function is 1
    ' when user hits OK and 0 when user hits Cancel. Also, do not save script parameters when user hits Cancel.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    ' A note on this "workaround" by jj, 10/13/21:
    ' The short explanation of the above is: over a decade ago, when "OK" was selected from a tuning curve
    ' subdialog (e.g. the Contrast Tuning dialog), the subdialog would close, the main dialog would ALSO
    ' close, and the experiment would start immediately.  This caused issues when dialogs were called in
    ' particular contexts, so this was changed such that closing a subdialog did not close the main dialog
    ' nor does it start the experiment.  In the end, the current design is probably preferable, because it
    ' allows for more flexible coding of subdialogs and does not require the user to complete dialog sections
    ' in a strict order.  This "workaround" has been in place for over 10 years.  At this point, it's not
    ' exactly a "workaround" anymore, it's standard code.  All futile IF/ELSE statements that assigned
    ' an iReturn% of 1 in either case have been removed and replaced with a simple assignment.
    ' The above note is retained here, but is now removed from all dialog box code.
    
    'PrintLog("Tuning Curve Parameters Dialog - return from DlgShow is %d\n", i%);
    '	if i%=tundlgOrientationButton% or i%=tundlgContrastButton% or i%=tundlgSpatialButton% or i%=tundlgTemporalButton% or i%=tundlgAreaButton% then
    if i% = 1 then
        'unpack twoInts%[]
        tunDoOpto% := twoInts%[0];
        tunSendINTANPulse% := twoInts%[1];
        
		tunBackgroundColor$ := bcl$[ibcl%];
		SaveTuningCurveScriptParameters();
        SaveDAQParameters();  'Now saving DAQ parameters because juicer variables can change
        tunDSSDuration := tunFixationDuration;  'just setting this no matter what, not much reason to put in an IF
		if tunContext$ = tunContextDAQ$ then 
            iReturn% := 1;
		else iReturn% := 1;
		endif;
        
        'do not allow incorrect maintain mode - 2&3 are only legal for danishes
        if tunUseMaintainMode% > 2 and tunType$ <> tunTypeDanish$ and tunType$ <> tunTypeDSS$ then
            tunUseMaintainMode% := tunUseMaintainMode%-2;
            message("You cannot maintain core unless this is a Danish/DSS scenario, only maintaining fixation point!");
        endif;
        'furthermore...
        if tunUseMaintainMode% > 2 and tunType$ = tunTypeDanish$ then
            message("Maintain core is currently BROKEN for Danishes.  Sorry, not maintaining core.");
            tunUseMaintainMode% := tunUseMaintainMode%-2;
        endif;
        
        'check to make sure that the box for the crosshairs and stimuli do not overlap
        'this would work if it only got the maximum value of the size of the stimuli
        if tunUseXHairs% = 1 and (tunType$ = tunTypeBerliner$ or tunType$ = tunTypeDonut$) then
            tempParam$ := GetGratingParameters$("Stimulus");
            boxOK% := CheckXHairStimulusBox(tempParam$,tunXHairOuterRadiusOffset,tunMaximalDiam);
            if boxOK% = 0 then
                boxOK% := Query("The stimulus will overlap the crosshairs!","Continue","Quit");
            endif;           
            if boxOK% = 1 then
                tempParam$ := GetGratingParameters$("SlaveStimulus");
                boxOK% := CheckXHairStimulusBox(tempParam$,tunXHairOuterRadiusOffset,tunSlaveMaximalDiam);
                if boxOK% = 0 then
                    boxOK% := Query("The slave stimulus will overlap the crosshairs!","Continue","Quit");
                endif;
            endif;
            if boxOK% = 0 then
                iReturn% := 0;  'quit if user requested quit
            endif;
        endif;  
        
        'check to see if tunSetStationary is set for the "standard" tuning curves
        if tunSetStationary% = 1 then
            'Check for one of the five "standard" tuning curves that are not temporal - obviously stationary does not work with temporal tuning curves
            if (tunType$ = tunTypeOrientation$ or tunType$ = tunTypeContrast$ or tunType$ = tunTypeSpatial$ or tunType$ = tunTypeArea$ or tunType$ = tunTypeXYPos$ or tunType$ = tunTypeBoxODonuts$) and tunDoRivalry% = 0 then
                tempParams$ := GetGratingParameters$("Stimulus");
                ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
                tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$, ctf);  'hardcoded zero TF
                SaveGratingParameters("StatStimulus", tempParams$);
            else
                if tunDoRivalry% = 1 then
                    message("The Stationary option is not defined for Dual VSG.  If you wish to change this, \nsee your local programmer.  Quitting.");
                else
                    message("The Stationary option is not defined for tuning type '" + tunType$ + "'.  If you wish to change this, \nsee your local programmer.  Quitting.");
                endif;
                'if Stationary is set but cannot be used, undo the change in the registry
                tunSetStationary% := 0;
                SaveTuningCurveScriptParameters();
                iReturn% := 0;
            endif;
        endif
        
        'just make sure we don't have trouble with constant lag if there is no dual tuning - may not be needed but still...
        if tunDoRivalry% = 0 then
            tunUseConstantLag% := 0;
        endif;
        
        
        'Force tunUseMaintainMode to be 1 if any other value is chosen for tunTypeFixptJump$
        if tunUseMaintainMode% <> 1 and tunType$ = tunTypeFixptJump$ then 'let's not get too clever, force this to 1, the "late" reward will mess things up 
            tunUseMaintainMode% := 1;
            message("Maintain Mode was changed to '1' (maintain fixation, no maintain reward) for Fixpt Jump experiment!  Carry on.");
        endif
        
        
	endif;
	if i% = 0 then
		'PrintLog("Tuning Curve Parameters dialog - user hit Cancel, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then 
			if tunType$ <> tunTypeNone$ then 
				iReturn% := 0;
				'SaveTuningCurveScriptParameters();
			else iReturn% := 0;
		 	endif;
		else
			iReturn% := 2;		' The calling/main dialog would close if we returned 0
		endif;
    endif;
	return iReturn%;
end;



func TuningCurveScriptDialogChanged%(item%) 
    DlgValue$(19,Str$(DlgValue(18)*1000/dataScreenHz));  'just set the text values of the frame to millisecond conversion every time
    DlgEnable(0,19);  'Always disable millisecond conversion, we can't type here to get frame values
    if DlgValue(11) = 0 then  'If single VSG, do not allow Donuts or Berliners or disparity or CRG
        'DlgEnable(0,-tundlgDonutANDGonzagoButton%,-tundlgFixptJumpANDBerlinerButton%,-tundlgBoxODonutsButton%,-tundlgCRGButton%,-tundlgDisparityAndBakersDozenButton%); 'old version
        'DlgEnable(0,-tundlgFixptJumpANDBerlinerButton%);  'allow boxOdonuts for single screen now, CRG now turns to FixptColor
        'Also disable card synch functions, dual tuning listbox
        DlgEnable(0,12); 'dual tuning listbox
        DlgEnable(0,17); 'constant lag listbox
        DlgEnable(0,18); 'constant lag frames box
        'But do allow Dots, Danish, DSS, Null Test
        DlgEnable(1,-tundlgDotsButton%);
        DlgEnable(1,-tundlgDanishButton%);
        DlgEnable(1,-tundlgDSSButton%);
        'DlgEnable(1,-tundlgNullTestANDLagButton%);  'this is now NullTest/Lag, don't enable/disable
        'Also, change labels on buttons to reflect the monocular aspect of not using dual VSG
        DlgValue$(-tundlgOrientationButton%, " Orientation  ");
        DlgValue$(-tundlgContrastButton%, "     Contrast     ");
        DlgValue$(-tundlgSpatialButton%, "Spatial Freq");
        DlgValue$(-tundlgTemporalButton%, "Temporal Freq");
        DlgValue$(-tundlgAreaButton%, "Area");
        DlgValue$(-tundlgXPosButton%, "XY Position");
        DlgValue$(-tundlgNullTestANDLagButton%, "      Null Test     ");
        DlgValue$(-tundlgDonutANDGonzagoButton%, "      Gonzagos!     ");
        DlgValue$(-tundlgDisparityAndBakersDozenButton%, "   Baker's Dozen   ");
        DlgValue$(-tundlgFixptJumpANDBerlinerButton%, "   Fixpt Jump   ");
        DlgValue$(-tundlgCRGButton%, "Polka Dots");
        tunUseLagDialog% := 0;
        tunUseDonutDialog% := 0;
        tunUseDisparityDialog% := 0;
        tunUseCRGDialog% := 0;
        tunUseBerlinerDialog% := 0;
    endif;
    if DlgValue(11) = 1 then  'If dual VSG, allow donuts and Berliners and disparity and CRG
        'DlgEnable(1,-tundlgDonutANDGonzagoButton%,-tundlgFixptJumpANDBerlinerButton%,-tundlgBoxODonutsButton%,-tundlgCRGButton%,-tundlgDisparityAndBakersDozenButton%);  'old version
        DlgEnable(1,-tundlgDonutANDGonzagoButton%,-tundlgFixptJumpANDBerlinerButton%);  'allow boxOdonuts for single screen now
        'Also allow turning off card synch, dual tuning listbox
        DlgEnable(1,12);  'dual tuning listbox
        DlgEnable(1,17); 'constant lag listbox
        DlgEnable(1,18); 'constant lag frames box
        'But don't allow Dots, Danish, DSS, Null test
        DlgEnable(0,-tundlgDotsButton%);
        DlgEnable(0,-tundlgDanishButton%);
        DlgEnable(0,-tundlgDSSButton%);
        'DlgEnable(0,-tundlgNullTestANDLagButton%);  'this is now NullTest/Lag, don't enable/disable
        'Also, change labels on buttons to reflect the binocular aspect of using dual VSG
        DlgValue$(-tundlgDisparityAndBakersDozenButton%, "   Disparity   ");  'Except disparity
        docase 
        case DlgValue(12) = 0 then
            DlgValue$(-tundlgOrientationButton%, " D Orientation ");
            DlgValue$(-tundlgContrastButton%, "    D Contrast    ");
            DlgValue$(-tundlgSpatialButton%, "D Spatial Freq");
            DlgValue$(-tundlgTemporalButton%, "D Temporal Freq");
            DlgValue$(-tundlgAreaButton%, "D Area");
            DlgValue$(-tundlgXPosButton%, "D X Position");
            DlgValue$(-tundlgNullTestANDLagButton%, "        Lag        ");
            DlgValue$(-tundlgDonutANDGonzagoButton%, "       Donuts!      ");
            DlgValue$(-tundlgCRGButton%, "      CRGs      ");
            DlgValue$(-tundlgFixptJumpANDBerlinerButton%, "    Berliners!    ");
        case DlgValue(12) = 1 then
            DlgValue$(-tundlgOrientationButton%, " M Orientation ");
            DlgValue$(-tundlgContrastButton%, "    M Contrast    ");
            DlgValue$(-tundlgSpatialButton%, "M Spatial Freq");
            DlgValue$(-tundlgTemporalButton%, "M Temporal Freq");
            DlgValue$(-tundlgAreaButton%, "M Area");
            DlgValue$(-tundlgXPosButton%, "M X Position");
            DlgValue$(-tundlgNullTestANDLagButton%, "        Lag        ");
            DlgValue$(-tundlgDonutANDGonzagoButton%, "       Donuts!      ");
            DlgValue$(-tundlgCRGButton%, "      CRGs      ");
            DlgValue$(-tundlgFixptJumpANDBerlinerButton%, "    Berliners!    ");
        case DlgValue(12) = 2 then
            DlgValue$(-tundlgOrientationButton%, " S Orientation ");
            DlgValue$(-tundlgContrastButton%, "    S Contrast    ");
            DlgValue$(-tundlgSpatialButton%, "S Spatial Freq");
            DlgValue$(-tundlgTemporalButton%, "S Temporal Freq");
            DlgValue$(-tundlgAreaButton%, "S Area");
            DlgValue$(-tundlgXPosButton%, "S X Position");
            DlgValue$(-tundlgNullTestANDLagButton%, "        Lag        ");
            DlgValue$(-tundlgDonutANDGonzagoButton%, "       Donuts!      ");
            DlgValue$(-tundlgCRGButton%, "      CRGs      ");
            DlgValue$(-tundlgFixptJumpANDBerlinerButton%, "    Berliners!    ");
        endcase;
        tunUseLagDialog% := 1;
        tunUseDonutDialog% := 1;
        tunUseDisparityDialog% := 1;
        tunUseCRGDialog% := 1;
        tunUseBerlinerDialog% := 1;
    endif;
    if DlgValue(13) = 0 then 'disable maintain mode timing if not using maintain mode
        DlgEnable(0,7);
        DlgEnable(0,8);
    endif;
    if DlgValue(13) > 0 then 'enable maintain mode timing if using maintain mode
        DlgEnable(1,7);
        DlgEnable(1,8);
    endif;
    return 1;
end




func TunOptoDialog%()
	var iReturn% := 1;
	var i%;
    var labels$[4];
    var stimdur;
    var tempNPulses%;
    var tempCount%;
    stimdur := dlgvalue(4);  'get stimulus duration value from calling (main) dialog, limit opto period based on this
    
    labels$[0] := "Opto Off First";
    labels$[1] := "Opto On First";
    labels$[2] := "Random First";
    labels$[3] := "Opto On All Blocks";
	GetTunOptoParameters();
	DlgCreate("Optogenetics Parameters");
    DlgGroup("Common Parameters", 1, 1, 38, 5);
    DlgReal(1, "Opto Voltage Out (V)",0.0002,5,20,2); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    DlgList(2, "Order of blocks",labels$,4,20,3);
    DlgReal(3, "InterBlock Time(s):", 0, 100, 20, 4);  'new, allow really long stimuli
    DlgCheck(4, "Use pulsing opto",2,5);
    DlgCheck(5, "Record Laser Diode",2,6);
    DlgGroup("Wrap-Around Opto", 1, 7, 38, 4);
    DlgReal(6, "PreStimulus Opto On (s)",0,100,20,8);
    DlgReal(7, "PostStimulus Opto On (s)",0,100,20,9);
    DlgCheck(8, "Keep Opto on between stims",2,10);
    DlgGroup("Pulsing Opto", 1, 11, 38, 5);
    DlgInteger(9, "Opto # Pulses ",1,1000,20,12);
    DlgReal(10, "Opto Period Onset (s)",0,stimdur,20,13);
    DlgReal(11, "Opto Pulse Width (s)",0,stimdur,20,14);
    DlgReal(12, "Opto Interpulse Interval (s)",0,1000,20,15);
    
    'DlgCheck(6, "Record control box voltage");
    'DlgCheck(7, "Record stimulator");
    
    DlgAllow(0xffff, 0, TunOptoDialogChanged%);    
    
	'i% := DlgShow(tunPreStimOptoTime,tunPostStimOptoTime,tunOptoStaysOn%,tunOptoVoltageOut,tunOptoStartState%);',tunRecOptoBox%,tunRecStimulator%);
	'changing order with bigger dialog - note that with addition of the dialogChanged function the above will not be terribly relevant ever again
    i% := DlgShow(tunOptoVoltageOut,tunOptoStartState%,tunInterBlockTime,tunOptoUsePulse%,tunLaserDiode%,tunPreStimOptoTime,tunPostStimOptoTime,tunOptoStaysOn%,tunOptoNPulses%,tunPulsedOptoOnset,tunPulsedOptoWidth,tunPulsedOptoIPI);
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTunOptoParameters();
        docase
        case tunOptoStartState% = 3 then
            dontToggleOpto% := 1;
            tunOptoState% := 1;
        case tunOptoStartState% = 2 then
            tunOptoState% := round(Rand());
            dontToggleOpto% := 0;  'Explicitly set this! If registry value of tunOptoStartState% was 3, dontToggleOpto% was set to 1 when main dialog was opened!
        else
            tunOptoState% := tunOptoStartState%;
            dontToggleOpto% := 0;  'Explicitly set this! If registry value of tunOptoStartState% was 3, dontToggleOpto% was set to 1 when main dialog was opened!
        endcase;
        'printlog("Opto start state is %d\n",tunOptoState%);  'yep, works
        
        'do temporary calculation to make sure all pulses will occur during the stimulus
        'unfortunately we will have to do this AGAIN once the script starts because the user could change the stimulus duration after the opto parameters
        'fortunately, the calculation is the same and it all worked on the first try
        if tunOptoUsePulse% = 1 then
            stimdur := stimdur - tunPulsedOptoOnset;  'duration of stimulus after onset delay
            stimdur := stimdur - tunPulsedOptoWidth;  'duration of stimulus after first opto pulse
            if stimdur < 0 then  'if first pulse will extend beyond stimulus duration
                'tunOptoNPulses% := 0;  'turn off opto by using no pulses, eek, no.
                tunDoOpto% := 0;  'this is how you turn off opto
                'tell user to try again
                Message("The first opto pulse will extend beyond the stimulus!  There will be no pulses!  Please try again!");
            else
                tempNPulses% := tunOptoNPulses% - 1;  'how many more pulses are left?
                tempCount% := 1;  'temporary successful pulse count
                while tempNPulses% > 0 do
                    stimdur := stimdur - tunPulsedOptoWidth - tunPulsedOptoIPI;  'subtract duration of one more pulse+IPI
                    if stimdur < 0 then  'if this pulse will extend beyond stimulus duration
                        Message("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed!  You may try again!");
                        tunOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                        tempNPulses% := 0;  'break while
                    else  'if this pulse is OK
                        tempCount% += 1;  'increment temporary successful pulse count
                    endif;
                    tempNPulses% -= 1;  'decrement temporary pulse count remaining
                wend
                
            endif;
            
        endif;
        
        
        
	endif;
    
	return iReturn%;
end;



' This function is initially called with a "0" input
func TunOptoDialogChanged%(item%) 
    DlgEnable(0,5);  'Just straight up disable the laser diode recording
    if DlgValue(4) = 1 then
        DlgEnable(1,9);  'enable pulsing dialog values 
        DlgEnable(1,10);
        DlgEnable(1,11);
        DlgEnable(1,12);
        DlgEnable(0,6);  'disable wrap-around dialog values 
        DlgEnable(0,7);
        DlgEnable(0,8);
    else
        DlgEnable(0,9);  'disable pulsing dialog values 
        DlgEnable(0,10);
        DlgEnable(0,11);
        DlgEnable(0,12);
        DlgEnable(1,6);  'enable wrap-around dialog values 
        DlgEnable(1,7);
        DlgEnable(1,8);
    endif;
    
    return 1;
end






func UpdateTuningXHairDialog%()
    
    'Run the tuning crosshairs dialog  
    TuningXHairDialog%();  
    
    'When done with the tuning crosshairs dialog, update tunXHairText$ and update the main dialog
    docase 
    case tunUseXHairs% = 0 then
        tunXHairText$ := "Crosshairs are OFF";
    case tunUseXHairs% = 1 then
        tunXHairText$ := "Crosshairs are ON";
    endcase
    
    DlgValue$(updateXHairText%, tunXHairText$);
    
    return 1;
end


'----- Check to make sure the stimulus and crosshair rectangles do not overlap
Func CheckXHairStimulusBox(gr$,maxRadius,maxDiam);
    var x;
    var y;
    var w;
    var h;
    var iw;
    var ih;
    var contrast%;
    var sf;
    var tf;
    var ori;
    var phase;
    var cv$;
    var pattern$;
    var aperture$;
    var ctf;
    var xencroach;
    var yencroach;
    
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$, ctf);
    xencroach := Abs(x) - w/2;
    yencroach := Abs(y) - h/2;
    if maxDiam > 0 then
        xencroach := Abs(x) - maxDiam/2;
        yencroach := Abs(y) - maxDiam/2;
    endif;
    if xencroach < maxRadius and yencroach < maxRadius then
        return 0;  'rectangles will overlap
    else
        return 1;  'rectangles will not overlap
    endif;
       
end



func SelectSEQFile%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a CRG sequence file");  'Find a sequence file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(4,direc$);  'Place filename into dialog item 4 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;



func SelectTuningFile%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(7,direc$);  'Place filename into dialog item 7 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;


func SelectBakersDozenFile%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(1,direc$);  'Place filename into dialog item 1 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;


func SelectBakersDozenOCFile%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select an opto/condition file");  'Find an opto/condition file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(3,direc$);  'Place filename into dialog item 3 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;


func TuningCurveGenericDialogChanged%(item%)
    'This single dialog changed function can be used for ALL the tuning dialogs that allow file-based tuning curves
    '(at least currently) because they all have the same structure and therefore the same dialog positions to allow/disallow
    if DlgValue(6) = 0 then  'If we are not using a tuning file
        DlgEnable(0,7);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(6) = 1 then
        DlgEnable(1,7);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


func TuningCurveBDDialogChanged%(item%)
    if DlgValue(2) = 0 then  'If we are not using a tuning file
        DlgEnable(0,3);  'disable the string box with the text file name
        DlgEnable(0,-tundlgSelectTuningFileButton2%);  'disable the corresponding button
        DlgEnable(0,4);  'disable the pause on condition change checkbox
    endif;
    if DlgValue(2) = 1 then
        DlgEnable(1,3);  'enable the string box with the text file name
        DlgEnable(1,-tundlgSelectTuningFileButton2%);  'enable the corresponding button
        DlgEnable(1,4);  'enable the pause on condition change checkbox
    endif;
    return 1;
end


'Disabled in favor of PolkaDots, which can do this
'func TuningCurveFixptColorDialogChanged%(item%)
'    if DlgValue(10) = 0 then  'If we are not using a tuning file
'        DlgEnable(0,11);  'disable the string box with the text file name (button still works)
'        DlgEnable(1,1);  'enable nSteps, gun select, min, and max
'        DlgEnable(1,6); 
'        DlgEnable(1,7);
'        DlgEnable(1,8);
'    endif;
'    if DlgValue(10) = 1 then
'        DlgEnable(1,11);  'enable the string box with the text file name
'        DlgEnable(0,1);  'disable nSteps, gun select, min, and max
'        DlgEnable(0,6);
'        DlgEnable(0,7);
'        DlgEnable(0,8);
'    endif;
'    docase
'    case DlgValue(6) = 0 then  'If we are tuning the red gun
'        DlgEnable(0,3);  'disable red gun
'        DlgEnable(1,4);  'enable green gun
'        DlgEnable(1,5);  'enable blue gun
'    case DlgValue(6) = 1 then  'If we are tuning the green gun
'        DlgEnable(1,3);  'enable red gun
'        DlgEnable(0,4);  'disable green gun
'        DlgEnable(1,5);  'enable blue gun
'    case DlgValue(6) = 2 then  'If we are tuning the blue gun
'        DlgEnable(1,3);  'enable red gun
'        DlgEnable(1,4);  'enable green gun
'        DlgEnable(0,5);  'disable blue gun
'    case DlgValue(6) = 3 then  'If we are tuning luminance, it will be gray
'        DlgEnable(0,3);  'disable red gun
'        DlgEnable(0,4);  'disable green gun
'        DlgEnable(0,5);  'disable blue gun
'    endcase
'    return 1;
'end



func TuningCurvePolkaDotDialogChanged%(item%)
    
    'First, check if we are using a tuing file, if so, disable everything, otherwise enable everything
    if DlgValue(4) = 0 then  'If we are not using a tuning file
        DlgEnable(0,5);  'disable the string box with the text file name (button still works)
        DlgEnable(1,6);  'enable nSteps, gun select, min, and max, guns will be enabled as desired below  
        DlgEnable(1,10); 
        DlgEnable(1,11);
        DlgEnable(1,12);
        DlgEnable(1,13); 'enable XY position entries 
        DlgEnable(1,14);
        DlgEnable(1,15);
        DlgEnable(1,16);
        DlgEnable(1,17);
        DlgEnable(1,18);
    endif;
    if DlgValue(4) = 1 then
        DlgEnable(1,5);  'enable the string box with the text file name
        DlgEnable(0,6);  'disable nSteps, guns, gun select, min, and max
        DlgEnable(0,7);  
        DlgEnable(0,8);  
        DlgEnable(0,9); 
        DlgEnable(0,10);
        DlgEnable(0,11);
        DlgEnable(0,12);
        DlgEnable(0,13); 'disable XY position entries 
        DlgEnable(0,14);
        DlgEnable(0,15);
        DlgEnable(0,16);
        DlgEnable(0,17);
        DlgEnable(0,18);
    endif;
    
    'Second, determine which gun entries to enable (gun select, min/max are enabled above when DlgValue(3) = 0 and need not be enabled here)
    docase
    case DlgValue(6) = 0 and DlgValue(4) = 0 and DlgValue(10) = 3 then  'If we are not tuning, and selected luminance, enable min to select luminance, disable all three guns and gun select, max
        DlgEnable(0,7);  'enable red gun
        DlgEnable(0,8);  'enable green gun
        DlgEnable(0,9);  'enable blue gun
        DlgEnable(0,10);
        DlgEnable(1,11);
        DlgEnable(0,12);
    case DlgValue(6) = 0 and DlgValue(4) = 0 then  'If we are not tuning, enable all three guns and disable gun select, max, min
        DlgEnable(1,7);  'enable red gun
        DlgEnable(1,8);  'enable green gun
        DlgEnable(1,9);  'enable blue gun
        DlgEnable(0,10);
        DlgEnable(0,11);
        DlgEnable(0,12);
    case DlgValue(10) = 0 and DlgValue(4) = 0 then  'If we are tuning the red gun (and not using a tuning file)
        DlgEnable(0,7);  'disable red gun
        DlgEnable(1,8);  'enable green gun
        DlgEnable(1,9);  'enable blue gun
    case DlgValue(10) = 1 and DlgValue(4) = 0 then  'If we are tuning the green gun
        DlgEnable(1,7);  'enable red gun
        DlgEnable(0,8);  'disable green gun
        DlgEnable(1,9);  'enable blue gun
    case DlgValue(10) = 2 and DlgValue(4) = 0 then  'If we are tuning the blue gun
        DlgEnable(1,7);  'enable red gun
        DlgEnable(1,8);  'enable green gun
        DlgEnable(0,9);  'disable blue gun
    case DlgValue(10) = 3 and DlgValue(4) = 0 then  'If we are tuning luminance, it will be gray
        DlgEnable(0,7);  'disable red gun
        DlgEnable(0,8);  'disable green gun
        DlgEnable(0,9);  'disable blue gun
    endcase
    
    'Third, determine if X/Y positions are not being varied, and disable MAX entry if so
    docase
    case DlgValue(13) = 0 and DlgValue(4) = 0 then
        DlgEnable(0,15);  'disable Max X
    case DlgValue(4) = 0 then
        DlgEnable(1,15);  'enable Max X
    endcase
    docase
    case DlgValue(16) = 0 and DlgValue(4) = 0 then
        DlgEnable(0,18);  'disable Max Y
    case DlgValue(4) = 0 then
        DlgEnable(1,18);  'enable Max Y
    endcase
    
    
    return 1;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve main dialog END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
